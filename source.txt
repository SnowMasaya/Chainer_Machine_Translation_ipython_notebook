この文書について... 
Python チュートリアル 
索引 
の著作権は、Copyright 1993, 1994, 1995, 1996, 1997, NikosDrakos, Computer Based Learning Unit, University ofLeeds, and Copyright 1997, 1998, RossMoore, Mathematics Department, Macquarie University,Sydney.となっています。 
Python ドキュメントの 
への対応は、Fred L. Drake, Jr. の多大な努力で実現しました。 
オリジナルのナビゲーションアイコンは、Christopher Petrilli によるものです。 
マークアップのことを気にする必要はありません; ドキュメンテーションチームが喜んで手配します。 
Python でのプログラミングに関する疑問など、このドキュメントに書かれている情報の使い方についての質問は、日本 Python ユーザ会メーリングリストで行うとよいでしょう。 
Python ドキュメントインデクス 
序 
リリース 2.4 
平成18年6月27日 日本語訳: Python ドキュメント翻訳プロジェクト 
目次 
1. Python への意欲を高める 
1.1 ここからどこへ 
2. Python インタプリタを使う 
2.1 インタプリタを起動する 
2.1.1 引数の受け渡し 
2.1.2 対話モード 
2.2 インタプリタとその環境 
2.2.1 エラー処理 
2.2.2 実行可能な Python スクリプト 
2.2.3 ソースコードの文字コード方式 (encoding) 
2.2.4 対話モード用の起動時実行ファイル 
3. 形式ばらない Python の紹介 
3.1 Python を電卓として使う 
3.1.1 数 
3.1.2 文字列 
3.1.3 Unicode 文字列 
3.1.4 リスト 
3.2 プログラミングへの第一歩 
4. その他の制御フローツール 
4.1 if 文 
4.2 for 文 
4.3 range() 関数 
4.4 break 文と continue 文とループの else 節 
4.5 pass 文 
4.6 関数を定義する 
4.7 関数定義についてもう少し 
4.7.1 デフォルトの引数値 
4.7.2 キーワード引数 
4.7.3 任意引数リスト 
4.7.4 引数リストのアンパック 
4.7.5 ラムダ形式 
4.7.6 ドキュメンテーション文字列 
5. データ構造 
5.1 リスト型についてもう少し 
5.1.1 リストをスタックとして使う 
5.1.2 リストをキューとして使う 
5.1.3 実用的なプログラミングツール 
5.1.4 リストの内包表記 
5.2 del 文 
5.3 タプルとシーケンス 
5.4 集合型 
5.5 辞書 
5.6 ループのテクニック 
5.7 条件についてもう少し 
5.8 シーケンスとその他の型の比較 
6. モジュール 
6.1 モジュールについてもうすこし 
6.1.1 モジュール検索パス 
6.1.2 ``コンパイル'' された Python ファイル 
6.2 標準モジュール 
6.3 dir() 関数 
6.4 パッケージ 
6.4.1 パッケージから * を import する 
6.4.2 パッケージ内での参照 
6.4.3 複数ディレクトリ中のパッケージ 
7. 入力と出力 
7.1 ファンシーな出力の書式化 
7.2 ファイルを読み書きする 
7.2.1 ファイルオブジェクトのメソッド 
7.2.2 pickle モジュール 
8. エラーと例外 
8.1 構文エラー 
8.2 例外 
8.3 例外を処理する 
8.4 例外を送出する 
8.5 ユーザ定義の例外 
8.6 後片付け動作を定義する 
9. クラス 
9.1 用語について一言 
9.2 Python のスコープと名前空間 
9.3 クラス初見 
9.3.1 クラス定義の構文 
9.3.2 クラスオブジェクト 
9.3.3 インスタンスオブジェクト 
9.3.4 メソッドオブジェクト 
9.4 いろいろな注意点 
9.5 継承 
9.5.1 多重継承 
9.6 プライベート変数 
9.7 残りのはしばし 
9.7.1 例外はクラスであってもよい 
9.8 イテレータ (iterator) 
9.9 ジェネレータ (generator) 
9.10 ジェネレータ式 
10. 標準ライブラリミニツアー 
10.1 オペレーティングシステムへのインタフェース 
10.2 ファイルのワイルドカード表記 
10.3 コマンドライン引数 
10.4 エラー出力のリダイレクトとプログラムの終了 
10.5 文字列のパターンマッチング 
10.6 数学 
10.7 インターネットへのアクセス 
10.8 日付と時刻 
10.9 データ圧縮 
10.10 パフォーマンスの計測 
10.11 品質管理 
10.12 バッテリー同梱 
11. 標準ライブラリミニツアー - その 2 
11.1 出力のフォーマット 
11.2 文字列テンプレート 
11.3 バイナリデータレコードの操作 
11.4 マルチスレッド処理 
11.5 ログ記録 
11.6 弱参照 
11.7 リスト操作のためのツール 
11.8 10 進浮動小数演算 
12. さあ何を? 
A. 対話入力編集とヒストリ置換 
A.1 行編集 
A.2 ヒストリ置換 
A.3 キー割り当て 
A.4 解説 
B. 浮動小数点演算、その問題と制限 
B.1 表現エラー 
C. 歴史とライセンス 
C.1 Python の歴史 
E. 用語集 
リリース 2.4 ,平成18年6月27日 更新 
ご意見やご指摘をお寄せになりたい方は、 
このドキュメントについて... 
をご覧ください。 
Python/C API リファレンスマニュアル 
5.9 比較 (comparison) 
Python リファレンスマニュアル 
5.8 ビット単位演算の二項演算 (binary bit-wise 
5. 式 (expression) 
5.10 ブール演算 (boolean operation) 
C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。 
また、a b c が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います: 
のような書き方は、現在では古い書き方とみなされています。 演算子 , , ==, =, =, および!= は、二つのオブジェクト間の値を比較します。 
オブジェクトは同じ型である必要はありません。 双方のオブジェクトが数値であれば、共通型への変換が行われます。 
それ以外の場合、異なる型のオブジェクトは常に 不等であるとみなされ、一貫してはいるが規定されていない方法で並べられます。 (このような比較演算の変則的な定義は、ソートのような操作や、in およびnot in といった演算子の定義を単純化するためのものです。 
将来、異なる型のオブジェクト間における比較規則は変更されるかもしれません。 )同じ型のオブジェクト間における比較は、型によって異なります: 
数値間の比較では、算術的な比較が行われます。 
文字列間の比較では、各文字に対する等価な数値型 (組み込み関数 ord() の結果) を使って辞書的な (lexicographically) 比較が行われます。 
Unicode および 8 ビット文字列は、この動作に関しては完全に互換です。 
タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な比較が行われます。 
このため、二つのシーケンスを等価にするためには、各要素が完全に等価でなくてはならず、シーケンスは同じ型で同じ長さをもっていなければなりません。 二つのシーケンスが等価でない場合、異なる値を持つ最初の要素間での比較に従った順序関係になります。 
例えば、cmp([1,2,x], [1,2,y]) はcmp(x,y) と等しい結果を返します。 
片方の要素に対応する要素が他方にない場合、より短いシーケンスが前に並びます (例えば、[1,2] [1,2,3] となります)。 
マップ (辞書) 間の比較では、(key, value) からなるリストをソートしたものが等しい場合に等価になります。 
等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないかのいずれかです。 
その他のほとんどの型の比較では、同じオブジェクトでないかぎり等価にはなりません。 あるオブジェクトの他のオブジェクトに対する大小関係は任意に決定され、一つのプログラムの実行中は一貫したものとなります。 
演算子 in および not in は、集合内の要素であるかどうか (メンバシップ、membership) を調べます。 
は、x が集合 s のメンバである場合には真となり、それ以外の場合には偽となります。 
の否定(negation) を返します。 
集合メンバシップテストは、伝統的にはシーケンス型に限定されてきました; すなわち、あるオブジェクトがある集合のメンバとなるのは、集合がシーケンス型であり、シーケンスがオブジェクトと等価な要素を含む場合でした。 
しかしながら、現在ではオブジェクトがシーケンスでなくてもメンバシップテストをサポートしています。 
特に、辞書型では、 
と書くことで、うまい具合にメンバシップテストをサポートしています; 他のマップ型もこれに倣っているかもしれません。 リストやタプル型については、 
x in y は 
x == y[i] となるようなインデクスi が存在するとき、かつそのときに限り真になります。 
Unicode 文字列または文字列型については、 
は x が y の部分文字列であるとき、かつそのときに限り真になります。 
この演算と等価なテストは y.find(x) != -1 です。 
__contains__() メソッドの定義されたユーザ定義クラスでは、 
が真となるのは 
y.__contains__(x) が真となるとき、かつそのときに限ります。 __contains__() は定義していないが __getitem__()は定義しているようなユーザ定義クラスでは、 
x == y[i] となるような非負の整数インデクスi が存在するとき、かつそのときにかぎり真となります。 
インデクス i が負である場合に IndexError 例外が送出されることはありません。 
(別の何らかの例外が送出された場合、例外は in から送出されたかのようになります)。 演算子 not in は、in の真値に対する逆転として定義されています。 
演算子 is および is not は、オブジェクトのアイデンティティに対するテストを行います: 
は、 x と y が同じオブジェクトを指すとき、かつそのときに限り真になります。 
は、is の真値を逆転したものになります。 
...したものが等しい場合に等価になります。 
実装では、この演算をリストを構築したりソートしたりすることなく効率的に行います。 
...のいずれかです。 
Python の初期のバージョンでは、ソートされた(key, value) のリストに対して辞書的な比較を行っていましたが、これは等価性の計算のようなよくある操作を実現するには非常にコストの高い操作でした。 
もっと以前のバージョンの Python では、辞書はアイデンティティだけで比較されていました。 しかしこの仕様は、{} との比較によって辞書が空であるか確かめられると期待していた人々を混乱させていました。 
Python ドキュメントの作成 
1 初めに 
2 ディレクトリ構造 
3 スタイルガイド 
4 LaTeX 入門 
4.1 構文法 
4.2 階層構造 
4.3 よく使われる環境 
5 ドキュメントクラス 
6 特殊マークアップ構文 
6.1 プリアンブル用のマークアップ 
6.2 メタ情報マークアップ 
6.3 情報単位 
6.4 コードの例示 
6.5 インラインマークアップ 
6.6 雑多なテキストマークアップ 
6.7 モジュール特有のマークアップ 
6.8 ライブラリレベルのマークアップ 
6.9 表のマークアップ 
6.10 参考文献リストのマークアップ 
6.11 索引生成のためのマークアップ 
6.12 文法における導出の表示 
6.13 グラフィカルインタフェースの構成要素 
7 処理ツール 
7.1 外部ツール 
7.2 内部用ツール 
7.3 Cygwin での作業 
8 画像の取り込み 
9 将来の方向性 
9.1 構造化ドキュメント 
9.2 議論の場 
ご意見やご指摘をお寄せになりたい方は、 このドキュメントについて... 
11.22.3 DateTime オブジェクト 
Python ライブラリリファレンス 
11.22.2 Boolean オブジェクト 
11.22.4 Binary オブジェクト 
このクラスは、エポックからの秒数、タプルで表現された時刻、ISO 8061形式の時間/日付文字列の何れかで初期化することができます。 
文字列をインスタンスの新しい時間を示す値として指定します。 
出力ストリームオブジェクト out に、XML-RPCエンコーディングのDateTime値を出力します。 
また、__cmp__と__repr__で定義される演算子を使用することができます。 
5. 他のアプリケーションへの Python の埋め込み 
Python インタプリタの拡張と埋め込み 
4.3 DLL 使用の実際 
Python インタプリタの拡張と埋め込み 
5.1 高水準の埋め込み 
5. 他のアプリケーションへの Python の埋め込み 
前章では、 Python を拡張する方法、すなわち C 関数のライブラリをPython に結びつけて機能を拡張する方法について述べました。 
同じようなことを別の方法でも実行できます: それは、自分の C/C++アプリケーションに Python を埋め込んで機能を強化する、というものです。 
Python の埋め込みは Python の拡張と似ていますが、全く同じというわけではありません。 
その違いは、Python を拡張した場合にはアプリケーションのメインプログラムは依然として Python インタプリタである一方、 Python を組み込みんだ場合には、メインプログラムにはPython が関係しない -- その代わりに、アプリケーションのある一部分が時折 Python インタプリタを呼び出して何らかの Python コードを実行させる -- かもしれない、ということです。 従って、 Python の埋め込みを行う場合、自作のメインプログラムを提供しなければなりません。 
メインプログラムがやらなければならないことの一つに、 Python インタプリタの初期化があります。 
とにかく少なくとも関数 Py_Initialize() (Mac OS ならPyMac_Initialize()) を呼び出さねばなりません。 
オプションとして、Python 側にコマンドライン引数を渡すために関数呼び出しを行います。 
その後、アプリケーションのどこでもインタプリタを呼び出せるようになります。 インタプリタを呼び出すには、異なるいくつかの方法があります:Python 文が入った文字列をPyRun_SimpleString() に渡す、stdio ファイルポインタとファイル名 (これはエラーメッセージ内でコードを識別するためだけのものです) をPyRun_SimpleFile() に渡す、といった具合です。 
これまでの各章で説明した低水準の操作を呼び出して、Python オブジェクトを構築したり使用したりもできます。 Python の埋め込みを行っている簡単なデモは、ソース配布物のDemo/embed/ ディレクトリにあります。 
参考: 
5.1 高水準の埋め込み 
5.2 超高水準の埋め込みから踏み出す: 概要 
5.3 純粋な埋め込み 
5.4 埋め込まれた Python の拡張 
5.5 C++による Python の埋め込み 
5.6 リンクに関する要件 
5.1 高水準の埋め込み 
4.2 例外 
4.1.1 動的な機能とのやりとり 
4. 実行モデル 
例外とは、コードブロックの通常の制御フローを中断して、エラーやその他の例外的な状況を処理できるようにするための手段です。 
例外はエラーが検出された時点で送出 (raise) 
されます;例外は、エラーが発生部の周辺のコードブロックか、エラーが発生したコードブロック直接または間接的に呼び出しているコードブロックで 処理 (handle) することができます。 
Python インタプリタは、ランタイムエラー (ゼロによる除算など) が検出されると例外を送出します。 
Python プログラムから、raise文を使って明示的に例外を送出することもできます。 例外ハンドラ (exception handler) は、 try ... except文で指定することができます。 
ある例外にどの except 節が一致するかの選択は、オブジェクトのアイデンティティに基づいて行われます。 
except 節は、同じクラスの例外か、基底クラスの例外しか参照しません。 例外が発行されると、オブジェクト (None になることもあります)が例外の 値 (value) として渡されます; このオブジェクトが例外ハンドラの選択自体に影響することはありませんが、選択された例外ハンドラに付帯情報として渡されます。 
例外がクラスの場合、オブジェクトは送出された例外クラスのインスタンスでなければなりません。 
警告:例外に対するメッセージは、Python API 仕様には含まれていません。 
メッセージの内容は、ある Python のバージョンから次のバージョンになるときに、警告なしに変更される可能性があります。 したがって、複数バージョンのインタプリタで動作するようなコードにおいては、例外メッセージの内容に依存した記述をすべきではありません。 
try 文については、7.4 節、raise 文については6.9 節も参照してください。 
Copyright 2001-2004 Python Software Foundation.All rights reserved.Copyright 2000 BeOpen.com.All rights reserved.Copyright 1995-2000 Corporation for National Research Initiatives.All rights reserved.Copyright 1991-1995 Stichting Mathematisch Centrum.All rights reserved. Translation Copyright 2003, 2004Python Document Japanese Translation Project. All rights reserved.ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を参照してください。 
概要: 
Python はインタプリタ形式の、オブジェクト指向のプログラミング言語です。 
このドキュメントでは、Python インタプリタを拡張するために C やC++ でモジュールを書く方法について述べます。 
拡張モジュールでは、新たな関数を定義できるだけでなく、新たなオブジェクト型とそのメソッドも定義できます。 
このドキュメントではまた、Python インタプリタを別のアプリケーションに埋め込み (embedding)、拡張言語として使う方法についても述べます。 
このドキュメントの最後には、オペレーティングシステム上で (実行時に)動的に拡張モジュールをロードする機能がサポートされている場合に、動的ロード可能な拡張モジュールをコンパイルしてリンクする方法を示します。 このドキュメントでは、読者は Python について基礎的な知識を持ち合わせているものと仮定しています。 
形式ばらない Python 言語の入門には、 
を読んでください。 
を読めば、Python 言語についてより形式的な定義を得られます。 
また、 
では、Python に広い適用範囲をもたらしている既存のオブジェクト型、関数、および (組み込み、および Python で書かれたものの両方の) モジュールについて解説しています。 Python/C API 全体の詳しい説明は、別のドキュメントである、 
を参照してください。 
Python モジュールの配布 
11 日本語訳について 
エ 
CCompiler (distutils.ccompiler 、ホ・ッ・鬣ケ) 
Command (distutils.cmd 、ホ・ッ・鬣ケ) 
FancyGetopt (distutils.fancy_getopt 、ホ・ッ・鬣ケ) 
TextFile (distutils.text_file 、ホ・ッ・鬣ケ) 
add_include_dir() (CCompiler 、ホ・皈ス・テ・ノ) 
add_library() (CCompiler 、ホ・皈ス・テ・ノ) 
add_library_dir() (CCompiler 、ホ・皈ス・テ・ノ) 
add_link_object() (CCompiler 、ホ・皈ス・テ・ノ) 
add_runtime_library_dir() (CCompiler 、ホ・皈ス・テ・ノ) 
announce() (CCompiler 、ホ・皈ス・テ・ノ) 
byte_compile() (distutils.util ・筵ク・蝪シ・ 
change_root() (distutils.util モジュール) 
check_environ() (distutils.util モジュール) 
close() (TextFile のメソッド) 
Command (distutils.core のクラス) 
compile() (CCompiler のメソッド) 
convert_path() (distutils.util モジュール) 
copy_file() (distutils.file_util モジュール) 
copy_tree() (distutils.dir_util モジュール) 
create_static_lib() (CCompiler のメソッド) 
create_tree() (distutils.dir_util モジュール) 
customize_compiler() (distutils.sysconfig モジュール) 
debug_print() (CCompiler のメソッド) 
define_macro() (CCompiler のメソッド) 
detect_language() (CCompiler のメソッド) 
Distribution (distutils.core のクラス) 
distutils.archive_util (standard モジュール) 
distutils.bcppcompiler (standard モジュール) 
distutils.ccompiler (standard モジュール) 
distutils.cmd (standard モジュール) 
distutils.command (standard モジュール) 
distutils.command.bdist (standard モジュール) 
distutils.command.bdist_dumb (standard モジュール) 
distutils.command.bdist_packager (standard モジュール) 
distutils.command.bdist_rpm (standard モジュール) 
distutils.command.bdist_wininst (standard モジュール) 
distutils.command.build (standard モジュール) 
distutils.command.build_clib (standard モジュール) 
distutils.command.build_ext (standard モジュール) 
distutils.command.build_py (standard モジュール) 
distutils.command.build_scripts (standard モジュール) 
distutils.command.clean (standard モジュール) 
distutils.command.config (standard モジュール) 
distutils.command.install (standard モジュール) 
distutils.command.install_data (standard モジュール) 
distutils.command.install_headers (standard モジュール) 
distutils.command.install_lib (standard モジュール) 
distutils.command.install_scripts (standard モジュール) 
distutils.command.register (standard モジュール) 
distutils.command.sdist (standard モジュール) 
distutils.core (standard モジュール) 
distutils.cygwinccompiler (standard モジュール) 
distutils.debug (standard モジュール) 
distutils.dep_util (standard モジュール) 
distutils.dir_util (standard モジュール) 
distutils.dist (standard モジュール) 
distutils.emxccompiler (standard モジュール) 
distutils.errors (standard モジュール) 
distutils.extension (standard モジュール) 
distutils.fancy_getopt (standard モジュール) 
distutils.file_util (standard モジュール) 
distutils.filelist (standard モジュール) 
distutils.log (standard モジュール) 
distutils.msvccompiler (standard モジュール) 
distutils.mwerkscompiler (standard モジュール) 
distutils.spawn (standard モジュール) 
distutils.sysconfig (standard モジュール) 
distutils.text_file (standard モジュール) 
distutils.unixccompiler (standard モジュール) 
distutils.util (standard モジュール) 
distutils.version (standard モジュール) 
EXEC_PREFIX (distutils.sysconfig モジュール) 
executable_filename() (CCompiler のメソッド) 
execute() (CCompiler のメソッド) 
execute() (distutils.util モジュール) 
Extension (distutils.core のクラス) 
fancy_getopt() (distutils.fancy_getopt モジュール) 
finalize_options() (Command のメソッド) 
find_library_file() (CCompiler のメソッド) 
gen_lib_options() (distutils.ccompiler モジュール) 
gen_preprocess_options() (distutils.ccompiler モジュール) 
generate_help() (FancyGetopt のメソッド) 
get_config_h_filename() (distutils.sysconfig モジュール) 
get_config_var() (distutils.sysconfig モジュール) 
get_config_vars() (distutils.sysconfig モジュール) 
get_default_compiler() (distutils.ccompiler モジュール) 
get_makefile_filename() (distutils.sysconfig モジュール) 
get_option_order() (FancyGetopt のメソッド) 
get_platform() (distutils.util モジュール) 
get_python_inc() (distutils.sysconfig モジュール) 
get_python_lib() (distutils.sysconfig モジュール) 
getopt() (FancyGetopt のメソッド) 
grok_environment_error() (distutils.util モジュール) 
has_function() (CCompiler のメソッド) 
HOME (環境変数) 
initialize_options()() (Command のメソッド) 
library_dir_option() (CCompiler のメソッド) 
library_filename() (CCompiler のメソッド) 
library_option() (CCompiler のメソッド) 
link() (CCompiler のメソッド) 
link_executable() (CCompiler のメソッド) 
link_shared_lib() (CCompiler のメソッド) 
link_shared_object() (CCompiler のメソッド) 
make_archive() (distutils.archive_util モジュール) 
make_tarball() (distutils.archive_util モジュール) 
make_zipfile() (distutils.archive_util モジュール) 
mkpath() (CCompiler のメソッド) 
mkpath() (distutils.dir_util モジュール) 
move_file() (CCompiler のメソッド) 
move_file() (distutils.file_util モジュール) 
new_compiler() (distutils.ccompiler モジュール) 
newer() (distutils.dep_util モジュール) 
newer_group() (distutils.dep_util モジュール) 
newer_pairwise() (distutils.dep_util モジュール) 
object_filenames() (CCompiler のメソッド) 
open() (TextFile のメソッド) 
PLAT (環境変数) 
PREFIX (distutils.sysconfig モジュール) 
preprocess() (CCompiler のメソッド) 
readline() (TextFile のメソッド) 
readlines() (TextFile のメソッド) 
remove_tree() (distutils.dir_util モジュール) 
rfc822_escape() (distutils.util モジュール) 
run() (Command のメソッド) 
run_setup() (distutils.core モジュール) 
runtime_library_dir_option() (CCompiler のメソッド) 
set_executables() (CCompiler のメソッド) 
set_include_dirs() (CCompiler のメソッド) 
set_libraries() (CCompiler のメソッド) 
set_library_dirs() (CCompiler のメソッド) 
set_link_objects() (CCompiler のメソッド) 
set_python_build() (distutils.sysconfig モジュール) 
set_runtime_library_dirs() (CCompiler のメソッド) 
setup() (distutils.core モジュール) 
shared_object_filename() (CCompiler のメソッド) 
show_compilers() (distutils.ccompiler モジュール) 
spawn() (CCompiler のメソッド) 
split_quoted() (distutils.util モジュール) 
strtobool() (distutils.util モジュール) 
subst_vars() (distutils.util モジュール) 
undefine_macro() (CCompiler のメソッド) 
unreadline() (TextFile のメソッド) 
warn() (CCompiler のメソッド) 
warn() (TextFile のメソッド) 
wrap_text() (distutils.fancy_getopt モジュール) 
PLAT Python モジュールの配布 
1 Distutilsの紹介 
このドキュメントでは、 Python モジュール配布ユーティリティ(Python Distribution Utilities, ``Distutils'') について、 モジュール開発者の視点に立ち、多くの人々がビルド/リリース/インストールの負荷をほとんどかけずに Python モジュールや拡張モジュールを入手できるようにする方法について述べます。 
1 Distutilsの紹介 
1 概念と用語 
2 簡単な例 
3 Python 一般の用語 
4 Distutils 固有の用語 
2 setup スクリプトを書く 
1 パッケージを全て列挙する 
2 個々のモジュールを列挙する 
3 拡張モジュールについて記述する 
3.1 拡張モジュールの名前とパッケージ 
3.2 拡張モジュールのソースファイル 
3.3 プリプロセッサオプション 
3.4 ライブラリオプション 
3.5 その他の操作 
4 スクリプトをインストールする 
5 パッケージデータをインストールする 
6 追加のファイルをインストールする 
7 追加のメタデータ 
8 setup スクリプトをデバッグする 
3 setup 設定ファイル (setup configuration file) を書く 
4 ソースコード配布物を作成する 
1 配布するファイルを指定する 
2 マニフェスト (manifest) 関連のオプション 
5 ビルド済み配布物を作成する 
1 ダム形式のビルド済み配布物を作成する 
2 RPM パッケージを作成する 
3 Windows インストーラを作成する 
3.1 インストール後実行スクリプト (postinstallation script) 
6 パッケージインデクスに登録する 
7 例 
1 pure Python 配布物 (モジュール形式) 
2 pure Python 配布物 (パッケージ形式) 
3 単体の拡張モジュール 
8 Distutilsの拡張 
1 新しいコマンドの統合 
9 リファレンスマニュアル 
1 モジュールをインストールする: install コマンド群 
2 ソースコード配布物を作成する: sdist command 
10 API リファレンス 
1 distutils.core -- Distutils のコア機能 
2 distutils.ccompiler -- CCompiler ベースクラス 
3 distutils.unixccompiler -- Unix C コンパイラ 
4 distutils.msvccompiler -- Microsoft コンパイラ 
5 distutils.bcppcompiler -- Borland コンパイラ 
6 distutils.cygwincompiler -- Cygwin コンパイラ 
7 distutils.emxccompiler -- OS/2 EMX コンパイラ 
8 distutils.mwerkscompiler -- Metrowerks CodeWarriorサポート 
9 distutils.archive_util -- アーカイブユーティリティ 
10 distutils.dep_util -- 依存関係のチェック 
11 distutils.dir_util -- ディレクトリツリーの操作 
12 distutils.file_util -- 1ファイルの操作 
13 distutils.util -- その他のユーティリティ関数 
14 distutils.dist -- Distribution クラス 
15 distutils.extension -- Extension クラス 
16 distutils.debug -- Distutils デバッグモード 
17 distutils.errors -- Distutils 例外 
18 distutils.fancy_getopt-- 標準 getopt モジュールのラッパ 
19 distutils.filelist -- FileList クラス 
20 distutils.log -- シンプルな PEP 282 スタイルのロギング 
21 distutils.spawn -- サブプロセスの生成 
22 distutils.sysconfig --システム設定情報 
23 distutils.text_file -- TextFile クラス 
24 distutils.version -- バージョン番号クラス 
25 distutils.cmd -- Distutils コマンドの抽象クラス 
26 distutils.command -- Distutils 各コマンド 
27 distutils.command.bdist -- バイナリインストーラの構築 
28 distutils.command.bdist_packager -- パッケージの抽象ベースクラス 
29 distutils.command.bdist_dumb -- ``ダム''インストーラを構築 
30 distutils.command.bdist_rpm -- Redhat RPMとSRPM形式のバイナリディストリビューションを構築 
31 distutils.command.bdist_wininst -- Windowsインストーラの構築 
32 distutils.command.sdist -- ソース配布物の構築 
33 distutils.command.build -- パッケージ中の全ファイルを構築 
34 distutils.command.build_clib -- パッケージ中のCライブラリを構築 
35 distutils.command.build_ext -- パッケージ中の拡張を構築 
36 distutils.command.build_py -- パッケージ中の.py/.pyc ファイルを構築 
37 distutils.command.build_scripts -- パッケージ中のスクリプトを構築 
38 distutils.command.clean -- パッケージのビルドエリアを消去 
39 distutils.command.config -- パッケージの設定 
40 distutils.command.install -- パッケージのインストール 
41 distutils.command.install_data-- パッケージ中のデータファイルをインストール 
42 distutils.command.install_headers-- パッケージから C/C++ ヘッダファイルをインストール 
43 distutils.command.install_lib-- パッケージから ライブラリファイルをインストール 
44 distutils.command.install_scripts-- パッケージから スクリプトファイルをインストール 
45 distutils.command.register-- モジュールをPython Package Indexに登録する 
46 新しいDistutilsコマンドの作成 
このドキュメントで扱っている内容は、 Distutils を使った Python モジュールの配布で、とりわけ開発者/配布者の役割に重点を置いています:Python モジュールのインストールに関する情報を探しているのなら、 
マニュアルを参照してください。 
1 概念と用語 
D.3 2.4 差分翻訳者一覧 (敬称略) 
3.1 オブジェクト、値、および型 
3. データモデル 
3.2 標準型の階層 
Python における オブジェクト (object) とは、データを抽象的に表したものです。 
オブジェクトが一度生成されると、そのオブジェクトのアイデンティティ値 は決して変化することがありません; アイデンティティ値をオブジェクトのメモリ上のアドレスと考えてもかまいません。 
演算子 `is' は、二つのオブジェクト間のアイデンティティ値を比較します; 関数 id() 
は、オブジェクトのアイデンティティ値を表す整数 (現在の実装ではオブジェクトのメモリ上のアドレス)を返します。 オブジェクトの 型 もまた変わることがありません。 
オブジェクトの型は、そのオブジェクトのサポートする操作(``長さを持っているか?'' など) を決定し、その型のオブジェクトが取りうる値について定義しています。 
関数は、オブジェクトの型(型自体も一つのオブジェクトです) を返します。 
オブジェクトによっては、値 (value) を変えることができます。 
値を変えることができるオブジェクトは 変更可能 (mutable) であるといいます; 値を一度設定すると、その後は変えることができないオブジェクトは変更不能 (immutable) であると呼びます。 (変更不能なコンテナオブジェクトが変更可能なオブジェクトへの参照を含んでいる場合、その値は後者のオブジェクトの変更によって変わる場合があります; その場合でも、コンテナの含んでいるオブジェクトの集まりは変わらないため、コンテナは変更不能と考えます。 
実装では、ごみ収集を遅らせたり、全く行わないようにすることができます -- 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。 
(実装上の注意: 現在の実装では参照カウント (reference-counting) 手順を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。 この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。 
循環参照を持つごみオブジェクト収集の制御については、 
これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトでは外部リソースを明示的に解放する方法、大抵は close() メソッドを提供しています。 こうしたオブジェクトは明示的に close するよう強く奨めます。 
操作をする際には、`try...finally' 文を使うと便利です。 他のオブジェクトに対する参照をもつオブジェクトもあります; これらはコンテナ (container) と呼ばれます。 
コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。 
オブジェクトへの参照自体がコンテナの値の一部です。 
ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。 
したがって、(タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。 型はオブジェクトの動作のほとんど全てに影響します。 
オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます:変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。 
("c = d = []" とすると、 c と d の両方に同じオブジェクトを代入します) 
... もまた変わることがありません。 
Python 2.2 以降、型とクラスの段階的な統合が始まっているため、このドキュメントで主張されている内容が 100% 正確で完全というわけではなくなりました: 例えば、場合によっては、ある管理された条件下でなら、オブジェクトの型を変更することができます。 
このマニュアルに大幅な改訂が施されるまでは、このドキュメントでの記述は、``旧クラス型 (classic class)'' に関してのみ信頼できる内容と考えねばなりません。 Python 2.2 および 2.3 では、互換性のためにクラシックなクラスがまだデフォルトとなっています。 
1.10 参照カウント法 
1.9 任意の値を構築する 
1. C や C++ 
1.10.1 Python における参照カウント法 
C や C++のような言語では、プログラマはヒープ上のメモリを動的に確保したり解放したりする責任があります。 
こうした作業は C では関数malloc() やfree() で行います。 
そこで、適切な時にfree() を呼び出すことが重要になります。 
あるメモリブロックに対して、free() を呼ばなかったにもかかわらずそのアドレスを忘却してしまうと、ブロックが占有しているメモリはプログラムが終了するまで再利用できなくなります。 
これはメモリリーク(memory leak) と呼ばれています。 
逆に、プログラムがあるメモリブロックに対してfree() を呼んでおきながら、そのブロックを使い続けようとすると、別の malloc() 呼び出しによって行われるブロックの再利用と衝突を起こします。 
例えば、ある関数があるメモリブロックを確保し、何らかの計算を行って、再度ブロックを解放するとします。 
さて、関数の要求仕様を変更して、計算に対するテストを追加すると、エラー条件を検出し、関数の途中で処理を戻すようになるかもしれません。 
この途中での終了が起きるとき、確保されたメモリブロックは解放し忘れやすいのです。 コードが後で追加された場合には特にそうです。 
このようなメモリリークが一旦紛れ込んでしまうと、長い間検出されないままになることがよくあります: エラーによる関数の終了は、全ての関数呼び出しのに対してほんのわずかな割合しか起きず、その一方でほとんどの近代的な計算機は相当量の仮想記憶を持っているため、メモリリークが明らかになるのは、長い間動作していたプロセスがリークを起こす関数を何度も使った場合に限られるからです。 
従って、この種のエラーを最小限にとどめるようなコーディング規約や戦略を設けて、不慮のメモリリークを避けることが重要なのです。 Python はmalloc() やfree() を非常によく利用するため、メモリリークの防止に加え、解放されたメモリの使用を防止する戦略が必要です。 
このために選ばれたのが参照カウント法 (reference counting) と呼ばれる手法です。 
参照カウント法の原理は簡単です: 全てのオブジェクトにはカウンタがあり、オブジェクトに対する参照がどこかに保存されたらカウンタをインクリメントし、オブジェクトに対する参照が削除されたらデクリメントします。 
)自動ガベージコレクションの大きな利点は、ユーザがfree() を明示的によばなくてよいことにあります。 
(速度やメモリの有効利用性も利点として主張されています -- が、これは確たる事実ではありません。 
循環参照検出機構のおかげで、直接、間接にかかわらず循環参照の生成を気にせずにアプリケーションを構築できます;というのも、参照カウント法だけを使ったガベージコレクション実装にとって循環参照は弱点だからです。 
循環参照は、(間接参照の場合も含めて) 相互への参照が入ったオブジェクトから形成されるため、循環内のオブジェクトは各々非ゼロの参照カウントを持ちます。 
典型的な参照カウント法の実装では、たとえ循環参照を形成するオブジェクトに対して他に全く参照がないとしても、循環参照内のどのオブジェクトに属するメモリも再利用できません。 循環参照検出機構は、ごみとなった循環参照を検出し、Python で実装された後始末関数 (finalizer、__del__() メソッド) が定義されていないかぎり、それらのメモリを再利用できます。 
後始末関数がある場合、検出機構は検出した循環参照を 
gcモジュール に (具体的にはこのモジュールのgarbage 変数内) に公開します。 
gc モジュールではまた、検出機構 (collect() 関数) を実行する方法や設定用のインタフェース、実行時に検出機構を無効化する機能も公開しています。 
循環参照検出機構はオプションの機構とみなされています;デフォルトで入ってはいますが、Unix プラットフォーム(Mac OS X も含みます) ではビルド時にconfigure スクリプトの--without-cycle-gc オプションを使って、他のプラットフォームではpyconfig.h ヘッダのWITH_CYCLE_GC定義をはずして無効にできます。 
こうして循環参照検出機構を無効化すると、gc モジュールは利用できなくなります。 
1.10.1 Python における参照カウント法 
1.10.2 所有権にまつわる規則 
1.10.3 薄氷 
1.10.4 NULL ポインタ 
A. バグ報告 
B. 歴史とライセンス 
1.2.5.2 モジュール検索パスにモジュールを追加する 
Macintoshモジュールリファレンス 
1.2.5 設定を行なう 
1.2.5.3 デフォルトの起動オプション 
import 文を実行すると、Python はそのモジュールをsys.path で定義された場所に探しに行きます。 
Mac 上で sys.path を編集するには、EditPythonPrefs を起動して、一番上にある大きめのフィールドにパスを入力します (1 行 に 1 つづつ書きます)。 MacPython ではメインの Python ディレクトリを定義しているので、フォルダをメイン Python ディレクトリに追加するのが最も簡単な方法です。 
「My Folder」という名前のフォルダを作って自作のスクリプトを入れ、メインの Python ディレクトリに追加したければ、"$(PYTHON):My Folder" を新たな行に入力します。 OS 9 かそれ以前の OS でデスクトップを追加したければ、 "StartupDriveName:Desktop Folder" を新たな行として入力します。 
2.4.1 文字列リテラル 
2.4 リテラル (literal) 
2.4.2 文字列リテラルの結合 (concatenation) 
文字列リテラルは以下の字句定義で記述されます: 
上記の生成規則で示されていない文法的な制限が一つあります。 それは文字列リテラルの stringprefix と残りの部分の間に空白を入れてはならないということです。 
ソースコード文字セット(source character set) はエンコード宣言で決まります.エンコード宣言がない場合には ASCII になります.2.1.4 節を参照してください.より平易な説明: 文字列リテラルは、対応する一重引用符 (') または二重引用符 (") で囲われます。 
また、対応する三連の一重引用符や二重引用符で囲うこともできます (通常、三重クオート文字列: triple-quoted string として参照されます)。 
バックスラッシュ () 文字を使って、ある文字を例えば改行文字やバックスラッシュ自体、クオート文字といった別の意味を持つようにエスケープすることができます。 
文字列リテラルの前には、オプションとして "r" または "R"一文字を接頭してもかまいません; このような文字列は raw 文字列(raw string) と呼ばれ、バックスラッシュによるエスケープシーケンスの解釈規則が異なります。 
"u" や "U" を接頭すると、文字列は Unicode 文字列 (Unicode string) になります。 
Unicode 文字列はUnicode コンソーシアムおよび ISO10646 で定義されている Unicode 文字セットを使います。 
"r" または "R" 接頭文字がつかないかぎり、文字列中のエスケープシーケンスは標準 C で使われているのと同様の法則にしたがって解釈されます。 以下に Python で認識されるエスケープシーケンスを示します: 
エスケープシーケンス 
意味 
備考 
無視 
バックスラッシュ () 
一重引用符 (') 
二重引用符 (") 
ASCII 端末ベル (BEL) 
ASCII バックスペース (BS) 
ASCII フォームフィード (FF) 
ASCII 行送り (LF) 
Unicode データベース中で名前 name を持つ文字 (Unicode のみ) 
ASCII 復帰 (CR) 
ASCII 水平タブ (TAB) 
16-bit の 16 進数値 xxxx を持つ文字 (Unicode のみ) 
32-bit の 16 進数値 xxxxxxxx を持つ文字 (Unicode のみ) 
ASCII 水平タブ (VT) 
8 進数値 ooo を持つ文字 
16 進数値 hh を持つ文字 
備考: 
サロゲートペアの断片を形成する個々のコード単位は、このエスケープシーケンスでエンコードすることができます。 
Unicode 文字はすべてこの方法でエンコードできますが、Python が 16-bit コード単位を扱うようにコンパイルされている(デフォルトの設定です) 場合、基本多言語面 (Basic Multilingual Plane, BMP) 外の文字はサロゲートペア (surrogate pair) を使ってエンコードすることになります。 
サロゲートペアの断片を形成する個々のコード単位はこのエスケープシーケンスを使ってエンコードすることができます。 
標準 C と同じく、最大で 3 桁の 8 進数まで受理します。 
標準 C とは違い、最大で 2 桁の 16 進数しか受理されません。 
文字列リテラル中では, 16 進および 8 進エスケープはエスケープの示すバイト文字になります.そのバイト文字がソース文字セットでエンコードされている保証はありません.Unicode リテラル中では,エスケープ文字はエスケープ文字の表現する値を持つ Unicode 文字になります. 
バックスラッシュも文字列中に残ります。 
(この挙動はデバッグの際に便利です: エスケープシーケンスを誤入力した場合、その結果として出力に失敗しているのが用意にわかります) テーブル中で ``(Unicode のみ)'' と書かれたエスケープシーケンスは、非 Unicode文字列リテラル中では認識されないエスケープシーケンスのカテゴリに分類されるので注意してください。 
接頭文字 "r" または "R" がある場合、バックスラッシュの後にくる文字はそのまま文字列中に入り、バックスラッシュは全て文字列中に残されます。 
例えば、文字列リテラル r"n" は二つの文字:バックスラッシュと小文字の "n" からなる文字列を表すことになります。 
引用符はバックスラッシュでエスケープすることができますが、バックスラッシュ自体も残ってしまいます; 例えば、r""" は不正でない文字列リテラルで、バックスラッシュと二重引用符からなる文字列を表します; r"" は正しくない文字列リテラルです (raw 文字列を奇数個連なったバックスラッシュで終わらせることはできません)。 
厳密にいえば、(バックスラッシュが直後のクオート文字をエスケープしてしまうため) raw 文字列を単一のバックスラッシュで終わらせることはできないということになります。 
また、バックスラッシュの直後に改行がきても、行継続を意味するのではなく 、それら二つの文字として解釈されるので注意してください。 "r" および "R" 接頭文字を "u" や"U" と合わせて使った場合、uXXXX エスケープシーケンスは処理されますが、その他のバックスラッシュはすべて文字列中に残されます 。 
例えば、文字列リテラルur"u0062n" は、3つの Unicode 文字: `LATIN SMALL LETTER B' (ラテン小文字 B)、`REVERSE SOLIDUS' (逆向き斜線)、および `LATIN SMALL LETTER N' (ラテン小文字 N) を表します。 バックスラッシュの前にバックスラッシュをつけてエスケープすることはできます; しかし、バックスラッシュは両方とも文字列中に残されます。 
その結果、uXXXX エスケープシーケンスは、バックスラッシュが奇数個連なっている場合にのみ認識されます。 
2.3 組み込み型 
2.2 非必須組み込み関数 (Non-essential Built-in 
2. 組み込みオブジェクト 
2.3.1 真値テスト 
以下のセクションでは、インタプリタに組み込まれている標準の型について記述します。 
これまでの Python の歴史では、組み込み型はオブジェクト指向における継承を行う際に雛型にできないという点で、ユーザ定義型とは異なっていました。 
リリース 2.2 からは状況が変わり始めましたが、目標とするユーザ定義型と組み込み方の一元化はまだまだ完成の域には達していません。 主要な組み込み型は数値型、シーケンス型、マッピング型、ファイルクラス、インスタンス型、および例外です。 
演算によっては、複数の型でサポートされているものがあります;特に、ほぼ全てのオブジェクトについて、比較、真値テスト、(repr() 関数と同等、またstr() 関数とはわずかに異なる` ...` 形式での) 文字列への変換を行うことができます。 
オブジェクトがprint 
によって書かれていると、後の方の文字列への変換が暗黙に行われます(Information on 
print 文やその他の文に関する情報は 
および 
で見つけることができます。 
2.3.2 ブール演算 
2.3.3 比較 
2.3.4 数値型 
2.3.4.1 整数型におけるビット文字列演算 
2.3.5 イテレータ型 
2.3.6 シーケンス型 
2.3.6.1 文字列メソッド 
2.3.6.2 文字列フォーマット操作 
2.3.6.3 XRange 型 
2.3.6.4 変更可能なシーケンス型 
2.3.7 set(集合) 型 
2.3.8 マップ型 
2.3.9 ファイルオブジェクト 
2.3.10 他の組み込み型 
2.3.10.1 モジュール 
2.3.10.2 クラスおよびクラスインスタンス 
2.3.10.3 関数 
2.3.10.4 メソッド 
2.3.10.5 コードオブジェクト 
2.3.10.6 型オブジェクト 
2.3.10.7 ヌルオブジェクト 
2.3.10.8 省略表記オブジェクト 
2.3.10.9 ブール値 
2.3.10.10 内部オブジェクト 
2.3.11 特殊な属性 
3.3.1 弱参照オブジェクト 
3.3.2 例 
弱参照オブジェクトは属性あるいはメソッドを持ちません。 
しかし、リファレントがまだ存在するならば、呼び出すことでそのリファレントを取得できるようにします: import weakref class Object:... pass... o = Object() r = weakref.ref(o) o2 = r() o is o2True 
リファレントがもはや存在しないならば、参照オブジェクトの呼び出しはNoneを返します: 
弱参照オブジェクトがまだ生きているかどうかのテストは、式 
ref() is not Noneを用いて行われます。 
通常、参照オブジェクトを使う必要があるアプリケーションコードはこのパターンに従います: 
# rは弱参照オブジェクトo = r()if o is None:# リファレントがガーベジコレクトされたprint "Object has been allocated; can't frobnicate."else:print "Object is still live!"o.do_something_useful() 
これはWeakValueDictionary の実装で使われており、マップ内の各エントリによるメモリのオーバヘッドを減らしています。 
こうした実装は、ある参照に追加情報を関連付けたい場合に便利ですし、リファレントを取り出すための呼び出し時に何らかの追加処理を行いたい場合にも使えます。 以下の例では、ref のサブクラスを使って、あるオブジェクトに追加情報を保存し、リファレントがアクセスされたときにその値に作用をできるようにするための方法を示しています: 
11 日本語訳について 
1.1 簡単な例 
1.2 幕間小話: エラーと例外 
1.3 例に戻る 
1.4 モジュールのメソッドテーブルと初期化関数 
1.5 コンパイルとリンク 
1.6 C から Python 関数を呼び出す 
1.7 拡張モジュール関数でのパラメタ展開 
1.8 拡張モジュール関数のキーワードパラメタ 
1.11 C++での拡張モジュール作成 
1.12 拡張モジュールに C API を提供する 
2. 新しい型を定義する 
2.1 基本的なこと 
2.1.1 基本のサンプルにデータとメソッドを追加する 
2.1.2 データ属性をこまかく制御する 
2.1.3 循環ガベージコレクションをサポートする 
2.2 タイプメソッド 
2.2.1 最終化 (finalization) と解放 
2.2.3 属性を管理する 
2.2.4 オブジェクトの比較 
2.2.5 抽象的なプロトコルのサポート 
2.2.6 その他いろいろ 
3. distutils による C および C++ 拡張モジュールのビルド 
3.1 拡張モジュールの配布 
4. Windows 上での C および C++ 拡張モジュールのビルド 
4.1 型どおりのアプローチ 
4.2 Unix と Windows の相違点 
4.3 DLL 使用の実際 
5.6 リンクに関する要件 
A. バグ報告 
B. 歴史とライセンス 
B.1 Python の歴史 
1. C や C++ 
リリース 2.4 ,平成18年6月27日 更新 ご意見やご指摘をお寄せになりたい方は、 
このドキュメントについて... 
Pythonは拡張性のあるインタプリタ形式のオブジェクト指向言語です。 
簡単なテキスト処理スクリプトから対話型のWWWブラウザまで、幅広い用途に対応しています。 
Pythonリファレンスマニュアル 
では、プログラミング言語 Python の厳密な構文とセマンティクスについて説明していますが、Python とともに配付され,Python をすぐに活用する上で大いに役立つ標準ライブラリについては説明していません。 
このライブラリには、例えばファイルI/O のように, Python プログラマが直接アクセスできないシステム機能へのアクセス機能を提供する (Cで書かれた) 組み込みモジュールや、日々のプログラミングで生じる多くの問題に標準的な解決策を提供するpure Python で書かれたモジュールが入っています。 
これら数多くのモジュールには、Pythonプログラムに移植性を持たせ、それを高めるという明確な意図があります。 このライブラリリファレンスマニュアルでは、Pythonの標準ライブラリだけでなく、多くのオプションのライブラリモジュールについて説明しています(ライブラリモジュールの中には,プラットフォームでのサポートやコンパイル時の設定によって、使えたり使えなかったりするものがあります).また、言語の標準の型、組み込みの関数と例外、Python リファレンスマニュアルで説明していなかったり,説明不足であるような多くの点についても説明しています。 
このマニュアルでは、読者が Python 言語について基礎的な知識を持っていると仮定しています。 
形式ばらずに Python を学んでみたければ、 
Pythonチュートリアル 
を参照してください。 
は、高度な文法とセマンティクスについて疑問があるときに参照してください。 
最後に、 
Pythonインタプリタの拡張と組み込み 
と題されたマニュアルには、Pythonに新しい機能を追加する方法と、他のアプリケーションに Python を組み込む方法が書かれています。 
UnexpectedException (doctest 、ホホ羌ー) == operator 
__bases__ (class の属性) 
__builtin__ (組み込み モジュール) 
__call__() (Generator のメソッド) 
__class__ (instance の属性) 
__concat__() (operator モジュール) 
__delslice__() (operator モジュール) 
__dict__ (object の属性) 
__displayhook__ (sys モジュール) 
__div__() (operator モジュール) 
__eq__() (Charset のメソッド) 
__eq__() (Header のメソッド) 
__eq__() (operator モジュール) 
__excepthook__ (sys モジュール) 
__floordiv__() (operator モジュール) 
__future__ (standard モジュール) 
__ge__() (operator モジュール) 
__getslice__() (operator モジュール) 
__gt__() (operator モジュール) 
__iadd__() (AddressList のメソッド) 
__init__() (difflib モジュール) 
__init__() (NullTranslations のメソッド) 
__init__() (Textbox のメソッド) 
__inv__() (operator モジュール) 
__invert__() (operator モジュール) 
__isub__() (AddressList のメソッド) 
__iter__() (container のメソッド) 
__iter__() (iterator のメソッド) 
__le__() (operator モジュール) 
__len__() (AddressList のメソッド) 
__len__() (Message のメソッド) 
__lshift__() (operator モジュール) 
__lt__() (operator モジュール) 
__main__ (組み込み モジュール) 
__members__ (object の属性) 
__methods__ (object の属性) 
__mod__() (operator モジュール) 
__mul__() (operator モジュール) 
__ne__() (Header のメソッド),[Link] 
__ne__() (operator モジュール) 
__neg__() (operator モジュール) 
__not__() (operator モジュール) 
__or__() (operator モジュール) 
__pos__() (operator モジュール) 
__pow__() (operator モジュール) 
__repeat__() (operator モジュール) 
__repr__() (netrc のメソッド) 
__rshift__() (operator モジュール) 
__setslice__() (operator モジュール) 
__stderr__ (sys モジュール) 
__stdin__ (sys モジュール) 
__stdout__ (sys モジュール) 
__str__() (AddressList のメソッド) 
__str__() (Charset のメソッド) 
__str__() (date のメソッド) 
__str__() (datetime のメソッド) 
__str__() (Header のメソッド) 
__str__() (Message のメソッド) 
__str__() (time のメソッド) 
__sub__() (AddressList のメソッド) 
__sub__() (operator モジュール) 
__truediv__() (operator モジュール) 
__unicode__() (Header のメソッド) 
__xor__() (operator モジュール) 
_exit() (os モジュール) 
_getframe() (sys モジュール) 
_locale (組み込み モジュール) 
_parse() (NullTranslations のメソッド) 
_structure() (email.Iterators モジュール) 
_urlopener (urllib モジュール) 
_winreg (extension モジュール) 
a2b_base64() (binascii モジュール) 
a2b_hex() (binascii モジュール) 
a2b_hqx() (binascii モジュール) 
a2b_qp() (binascii モジュール) 
a2b_uu() (binascii モジュール) 
ABMON_1 ... ABMON_12 (locale モジュール) 
abort() (FTP のメソッド) 
abort() (os モジュール) 
above() (Textbox のメソッド) 
abs() (Context のメソッド) 
abs() (operator モジュール) 
abspath() (os.path モジュール) 
ac_out_buffer_size (asyncore モジュール) 
accept() (dispatcher のメソッド) 
accept() (socket のメソッド) 
accept2dyear (time モジュール) 
access() (os モジュール) 
acos() (cmath モジュール) 
acos() (math モジュール) 
acosh() (cmath モジュール) 
acquire() (Condition のメソッド) 
acquire() (lock のメソッド) 
acquire() (Semaphore のメソッド) 
acquire() (Textbox のメソッド) 
acquire() (Timer のメソッド),[Link] 
acquire_lock() (imp モジュール) 
activate_form() (form のメソッド) 
activeCount() (threading モジュール) 
add() (operator モジュール) 
add() (Stats のメソッド) 
add() (TarFile のメソッド) 
add_alias() (email.Charset モジュール) 
add_box() (form のメソッド) 
add_browser() (form のメソッド) 
add_button() (form のメソッド) 
add_charset() (email.Charset モジュール) 
add_choice() (form のメソッド) 
add_clock() (form のメソッド) 
add_codec() (email.Charset モジュール) 
add_cookie_header() (CookieJar のメソッド) 
add_counter() (form のメソッド) 
add_data() (Request のメソッド) 
add_dial() (form のメソッド) 
add_fallback() (NullTranslations のメソッド) 
add_flowing_data() (formatter のメソッド) 
add_handler() (OpenerDirector のメソッド) 
add_header() (Message のメソッド) 
add_header() (Request のメソッド) 
add_history() (readline モジュール) 
add_hor_rule() (formatter のメソッド) 
add_input() (form のメソッド) 
add_label_data() (formatter のメソッド) 
add_lightbutton() (form のメソッド) 
add_line_break() (formatter のメソッド) 
add_literal_data() (formatter のメソッド) 
add_menu() (form のメソッド) 
add_parent() (BaseHandler のメソッド) 
add_password() (HTTPPasswordMgr のメソッド) 
add_positioner() (form のメソッド) 
add_roundbutton() (form のメソッド) 
add_section() (SafeConfigParser のメソッド) 
add_slider() (form のメソッド) 
add_text() (form のメソッド) 
add_timer() (form のメソッド) 
add_type() (mimetypes モジュール) 
add_unredirected_header() (Request のメソッド) 
add_valslider() (form のメソッド) 
addcallback() (CD parser のメソッド) 
addch() (window のメソッド) 
addError() (TestResult のメソッド) 
addFailure() (TestResult のメソッド) 
addfile() (TarFile のメソッド) 
addFilter() (Textbox のメソッド),[Link] 
addHandler() (Textbox のメソッド) 
addheader() (MimeWriter のメソッド) 
addinfo() (Profile のメソッド) 
addLevelName() (logging モジュール) 
addnstr() (window のメソッド) 
address_string() (BaseHTTPRequestHandler のメソッド) 
addresslist (AddressList の属性) 
addstr() (window のメソッド) 
addSuccess() (TestResult のメソッド) 
addTest() (TestSuite のメソッド) 
addTests() (TestSuite のメソッド) 
adjusted() (Decimal のメソッド) 
adler32() (zlib モジュール) 
adpcm2lin() (audioop モジュール) 
adpcm32lin() (audioop モジュール) 
AF_INET (socket モジュール) 
AF_INET6 (socket モジュール) 
AF_UNIX (socket モジュール) 
AI_* (socket モジュール) 
aifc() (aifc のメソッド) 
aifc (standard モジュール) 
aiff() (aifc のメソッド) 
AIFF-C,[Link] AL (standard モジュール) 
al (組み込み モジュール) 
AL (標準 モジュール) 
alarm() (signal モジュール) 
all_errors (ftplib モジュール) 
all_features (xml.sax.handler モジュール) 
all_properties (xml.sax.handler モジュール) 
allocate_lock() (thread モジュール) 
allowed_domains() (DefaultCookiePolicy のメソッド) 
allowremoval() (CD player のメソッド) 
alt() (curses.ascii モジュール) 
ALT_DIGITS (locale モジュール) 
altsep (os モジュール) 
altzone (time モジュール) 
anchor_bgn() (HTMLParser のメソッド) 
anchor_end() (HTMLParser のメソッド) 
and_() (operator モジュール) 
annotate() (dircache モジュール) 
anydbm (standard モジュール) 
api_version (sys モジュール) 
apop() (POP3_SSL のメソッド) 
append() (array のメソッド) 
append() (Header のメソッド) 
append() (IMAP4_stream のメソッド) 
append() (SystemRandom のメソッド) 
append() (Template のメソッド) 
appendChild() (Node のメソッド) 
appendleft() (SystemRandom のメソッド) 
architecture() (platform モジュール) 
aRepr (repr モジュール) 
argv (sys モジュール) 
array() (array モジュール) 
array (組み込み モジュール) 
ArrayType (array モジュール) 
article() (NNTPDataError のメソッド) 
AS_IS (formatter モジュール) 
as_string() (Message のメソッド) 
as_tuple() (Decimal のメソッド) 
ascii() (curses.ascii モジュール) 
ascii_letters (string モジュール) 
ascii_lowercase (string モジュール) 
ascii_uppercase (string モジュール) 
asctime() (time モジュール) 
asin() (cmath モジュール) 
asin() (math モジュール) 
asinh() (cmath モジュール) 
assert_() (TestCase のメソッド) 
assert_line_data() (formatter のメソッド) 
assertAlmostEqual() (TestCase のメソッド) 
assertEqual() (TestCase のメソッド) 
assertNotAlmostEqual() (TestCase のメソッド) 
assertNotEqual() (TestCase のメソッド) 
assertRaises() (TestCase のメソッド) 
ast2list() (parser モジュール) 
ast2tuple() (parser モジュール) 
astimezone() (datetime のメソッド) 
ASTType (parser モジュール) 
asyncore (組み込み モジュール) 
atan() (cmath モジュール) 
atan() (math モジュール) 
atan2() (math モジュール) 
atanh() (cmath モジュール) 
atexit (standard モジュール) 
atime (cd モジュール) 
atof() (locale モジュール) 
atof() (string モジュール) 
atoi() (locale モジュール) 
atoi() (string モジュール) 
atol() (string モジュール) 
attach() (Message のメソッド) 
AttlistDeclHandler() (xmlparser のメソッド) 
attrgetter() (operator モジュール) 
attributes (Node の属性) 
attributes (XMLParser の属性) 
attron() (window のメソッド) 
attrset() (window のメソッド) 
audio (cd モジュール) 
AUDIO_FILE_ENCODING_ADPCM_G721 (sunau モジュール) 
AUDIO_FILE_ENCODING_ADPCM_G722 (sunau モジュール) 
AUDIO_FILE_ENCODING_ADPCM_G723_3 (sunau モジュール) 
AUDIO_FILE_ENCODING_ADPCM_G723_5 (sunau モジュール) 
AUDIO_FILE_ENCODING_ALAW_8 (sunau モジュール) 
AUDIO_FILE_ENCODING_DOUBLE (sunau モジュール) 
AUDIO_FILE_ENCODING_FLOAT (sunau モジュール) 
AUDIO_FILE_ENCODING_LINEAR_16 (sunau モジュール) 
AUDIO_FILE_ENCODING_LINEAR_24 (sunau モジュール) 
AUDIO_FILE_ENCODING_LINEAR_32 (sunau モジュール) 
AUDIO_FILE_ENCODING_LINEAR_8 (sunau モジュール) 
AUDIO_FILE_ENCODING_MULAW_8 (sunau モジュール) 
AUDIO_FILE_MAGIC (sunau モジュール) 
AUDIODEV (環境変数),[Link] 
audioop (組み込み モジュール) 
authenticate() (IMAP4_stream のメソッド) 
authenticators() (netrc のメソッド) 
avg() (audioop モジュール) 
avgpp() (audioop モジュール) 
b16decode() (base64 モジュール) 
b16encode() (base64 モジュール) 
b2a_base64() (binascii モジュール) 
b2a_hex() (binascii モジュール) 
b2a_hqx() (binascii モジュール) 
b2a_qp() (binascii モジュール) 
b2a_uu() (binascii モジュール) 
b32decode() (base64 モジュール) 
b32encode() (base64 モジュール) 
b64decode() (base64 モジュール) 
b64encode() (base64 モジュール) 
backslashreplace_errors_errors() (codecs モジュール) 
backward() (turtle モジュール) 
backward_compatible (imageop モジュール) 
BaseHTTPServer (standard モジュール) 
basename() (os.path モジュール) 
basicConfig() (logging モジュール) 
BasicContext (decimal のクラス) 
Bastion() (Bastion モジュール) 
Bastion (standard モジュール) 
baudrate() (curses モジュール) 
bdb (標準 モジュール) 
beep() (curses モジュール) 
Beep() (winsound モジュール) 
below() (Textbox のメソッド) 
bestreadsize() (CD player のメソッド) 
betavariate() (random モジュール) 
bgn_group() (form のメソッド) 
bias() (audioop モジュール) 
bidirectional() (unicodedata モジュール) 
binary() (xmlrpclib モジュール) 
binascii (組み込み モジュール) 
bind() (dispatcher のメソッド) 
bind() (socket のメソッド) 
bind_textdomain_codeset() (gettext モジュール) 
bindtextdomain() (gettext モジュール) 
binhex() (binhex モジュール) 
binhex (standard モジュール) 
binhex (標準 モジュール) bisect() (bisect モジュール) 
bisect (standard モジュール) 
bisect_left() (bisect モジュール) 
bisect_right() (bisect モジュール) 
bkgd() (window のメソッド) 
bkgdset() (window のメソッド) 
blocked_domains() (DefaultCookiePolicy のメソッド) 
BLOCKSIZE (cd モジュール) 
blocksize (sha モジュール) 
body() (NNTPDataError のメソッド) 
body_encode() (Charset のメソッド) 
body_encoding (email.Charset モジュール) 
body_line_iterator() (email.Iterators モジュール) 
BOM (codecs モジュール) 
BOM_BE (codecs モジュール) 
BOM_LE (codecs モジュール) 
BOM_UTF16 (codecs モジュール) 
BOM_UTF16_BE (codecs モジュール) 
BOM_UTF16_LE (codecs モジュール) 
BOM_UTF32 (codecs モジュール) 
BOM_UTF32_BE (codecs モジュール) 
BOM_UTF32_LE (codecs モジュール) 
BOM_UTF8 (codecs モジュール) 
boolean() (xmlrpclib モジュール) 
BooleanType (types モジュール) 
border() (window のメソッド) 
bottom() (Textbox のメソッド) 
BoundedSemaphore() (threading モジュール) 
box() (window のメソッド) 
break_long_words (TextWrapper の属性) 
BROWSER (環境変数),[Link] 
bsddb (extension モジュール) 
bsddb (組み込み モジュール),[Link],[Link] 
btopen() (bsddb モジュール) 
buffer() (組み込み関数),[Link] 
buffer_info() (array のメソッド) 
buffer_size (xmlparser の属性) 
buffer_text (xmlparser の属性) 
buffer_used (xmlparser の属性) 
BufferType (types モジュール) 
bufsize() (audio device のメソッド) 
build_opener() (urllib2 モジュール) 
builtin_module_names (sys モジュール) 
BuiltinFunctionType (types モジュール) 
BuiltinMethodType (types モジュール) 
byteorder (sys モジュール) 
byteswap() (array のメソッド) 
bz2 (組み込み モジュール) 
C_BUILTIN (imp モジュール) 
C_EXTENSION (imp モジュール) 
calcsize() (struct モジュール) 
calendar() (calendar モジュール) 
calendar (standard モジュール) 
call() (subprocess モジュール) 
call() (TarInfo のメソッド) 
CallableProxyType (weakref モジュール) 
can_change_color() (curses モジュール) 
can_fetch() (RobotFileParser のメソッド) 
cancel() (scheduler のメソッド) 
cancel() (Timer のメソッド) 
capitalize() (string のメソッド) 
capitalize() (string モジュール) 
capwords() (string モジュール) 
cat() (nis モジュール) 
catalog (cd モジュール) 
category() (unicodedata モジュール) 
cbreak() (curses モジュール) 
cd (組み込み モジュール) 
CDROM (cd モジュール) 
ceil() (math モジュール) center() (string のメソッド) 
center() (string モジュール) 
cgi (standard モジュール) 
cgi_directories (CGIHTTPRequestHandler の属性) 
CGIHTTPServer (standard モジュール) 
CGIHTTPServer (標準 モジュール) 
cgitb (standard モジュール) 
chain() (itertools モジュール) 
channels() (audio device のメソッド) 
CHAR_MAX (locale モジュール) 
CharacterDataHandler() (xmlparser のメソッド) 
characters() (ContentHandler のメソッド) 
CHARSET (mimify モジュール) 
charset() (NullTranslations のメソッド) 
chdir() (os モジュール) 
check() (IMAP4_stream のメソッド) 
check() (tabnanny モジュール) 
check_forms() (fl モジュール) 
check_output() (OutputChecker のメソッド) 
checkcache() (linecache モジュール) 
childerr (Popen4 の属性) 
childNodes (Node の属性) 
chmod() (os モジュール) 
choice() (random モジュール) 
choice() (whrandom モジュール) 
choose_boundary() (mimetools モジュール) 
chown() (os モジュール) 
chroot() (os モジュール) 
chunk (standard モジュール) 
circle() (turtle モジュール) 
Clamped (decimal のクラス) 
classobj() (new モジュール) 
ClassType (types モジュール) 
clear() (CookieJar のメソッド) 
clear() (Event のメソッド) 
clear() (window のメソッド) 
clear_flags() (Context のメソッド) 
clear_history() (readline モジュール) 
clear_memo() (Pickler のメソッド) 
clear_session_cookies() (CookieJar のメソッド) 
clearcache() (linecache モジュール) 
clearok() (window のメソッド) 
client_address (BaseHTTPRequestHandler の属性) 
clock() (time モジュール) 
clone() (Generator のメソッド) 
clone() (Template のメソッド) 
cloneNode() (Node のメソッド),[Link] 
close() (aifc のメソッド),[Link] 
Close() (ASTVisitor のメソッド) 
close() (AU_read のメソッド) 
close() (AU_write のメソッド) 
close() (audio device のメソッド),[Link] 
close() (BaseHandler のメソッド) 
close() (BZ2File のメソッド) 
close() (CD player のメソッド) 
close() (Chunk のメソッド) 
close() (dispatcher のメソッド) 
close() (FeedParser のメソッド) 
close() (file のメソッド) 
close() (FileHandler のメソッド) close() (fileinput モジュール) 
close() (FTP のメソッド) 
close() (HTMLParser のメソッド) 
close() (HTTPSConnection のメソッド) 
close() (IncrementalParser のメソッド) 
close() (MemoryHandler のメソッド) 
close() (mixer device のメソッド) 
close() (NTEventLogHandler のメソッド) close() (os モジュール) 
close() (Profile のメソッド) 
close() (Queue のメソッド),[Link] 
close() (SGMLParser のメソッド) 
close() (socket のメソッド) 
close() (SocketHandler のメソッド) 
close() (StringIO のメソッド) 
close() (SysLogHandler のメソッド) 
close() (TarFile のメソッド) 
close() (TarInfo のメソッド) 
close() (Telnet のメソッド) 
close() (Textbox のメソッド) 
close() (Wave_read のメソッド) 
close() (Wave_write のメソッド) 
close() (XMLParser のメソッド) 
close() (ZipFile のメソッド) 
close_when_done() (async_chat のメソッド) 
closed (file の属性) 
CloseKey() (_winreg モジュール) 
closelog() (syslog モジュール) 
closeport() (audio port のメソッド) 
clrtobot() (window のメソッド) 
clrtoeol() (window のメソッド) 
cmath (組み込み モジュール) 
cmd (standard モジュール) 
cmd (標準 モジュール) 
cmdloop() (Cmd のメソッド) 
cmp() (filecmp モジュール) 
cmp() (組み込み関数) cmp_op (dis モジュール) 
cmpfiles() (filecmp モジュール) 
code (ExpatError の属性) 
code() (new モジュール) 
code (standard モジュール) 
codecs (standard モジュール) 
coded_value (Morsel の属性) 
codeop (standard モジュール) 
codepoint2name (htmlentitydefs モジュール) 
CODESET (locale モジュール) 
CodeType (types モジュール) 
collapse_rfc2231_value() (email.Utils モジュール) 
collect() (gc モジュール) 
collect_incoming_data() (async_chat のメソッド) 
collections (standard モジュール) 
color() (fl モジュール) 
color() (turtle モジュール) 
color_content() (curses モジュール) 
color_pair() (curses モジュール) 
colorsys (standard モジュール) 
COLUMNS (環境変数),[Link] 
combine() (datetime のメソッド) 
combining() (unicodedata モジュール) 
command (BaseHTTPRequestHandler の属性) 
commands (standard モジュール) 
comment (Cookie の属性) 
COMMENT (tokenize モジュール) 
comment (ZipInfo の属性) 
comment_url (Cookie の属性) 
commenters (shlex の属性) 
CommentHandler() (xmlparser のメソッド) 
common (dircmp の属性) 
common_dirs (dircmp の属性) 
common_files (dircmp の属性) 
common_funny (dircmp の属性) 
common_types (mimetypes モジュール),[Link] 
commonprefix() (os.path モジュール) 
communicate() (Popen のメソッド) 
compare() (Context のメソッド) 
compare() (Decimal のメソッド) 
compare() (Differ のメソッド) 
COMPARISON_FLAGS (doctest モジュール) 
compile() (AST のメソッド) 
compile() (compiler モジュール) 
compile() (py_compile モジュール) 
compile() (re モジュール) 
compile() (組み込み関数),[Link],[Link],[Link] compile_command() (code モジュール) 
compile_command() (codeop モジュール) 
compile_dir() (compileall モジュール) 
compile_path() (compileall モジュール) 
compileall (standard モジュール) 
compileast() (parser モジュール) 
compileFile() (compiler モジュール) 
compiler ( モジュール) 
compiler.ast ( モジュール) 
compiler.visitor ( モジュール) 
complete() (Completer のメソッド) 
completedefault() (Cmd のメソッド) 
complex() (built-in function) complex() (組み込み関数) 
ComplexType (types モジュール) 
compress() (bz2 モジュール) 
compress() (BZ2Compressor のメソッド) 
compress() (Compress のメソッド) 
compress() (jpeg モジュール) 
compress() (zlib モジュール) 
compress_size (ZipInfo の属性) 
compress_type (ZipInfo の属性) 
compressobj() (zlib モジュール) 
COMSPEC (環境変数) 
concat() (operator モジュール) 
ConfigParser (standard モジュール) 
confstr() (os モジュール) 
confstr_names (os モジュール) 
connect() (dispatcher のメソッド) 
connect() (FTP のメソッド) 
connect() (HTTPSConnection のメソッド) 
connect() (SMTP のメソッド) 
connect() (socket のメソッド) 
connect_ex() (socket のメソッド) 
ConnectRegistry() (_winreg モジュール) 
constructor() (copy_reg モジュール) 
contains() (operator モジュール) 
ContentHandler (xml.sax.handler のクラス) 
control (cd モジュール) 
controlnames (curses.ascii モジュール) 
controls() (mixer device のメソッド) 
convert() (Charset のメソッド) 
Cookie (standard モジュール) 
cookiejar (UnknownHandler の属性) 
cookielib (standard モジュール) 
copy() (Context のメソッド) 
copy() (hmac のメソッド) 
copy() (IMAP4_stream のメソッド) 
copy() (md5 のメソッド) 
copy() (sha のメソッド) 
copy() (shutil モジュール) 
copy (standard モジュール) 
copy() (Template のメソッド) 
copy (標準 モジュール) copy2() (shutil モジュール) 
copy_reg (standard モジュール) 
copybinary() (mimetools モジュール) 
copyfile() (shutil モジュール) 
copyfileobj() (shutil モジュール) 
copyliteral() (mimetools モジュール) 
copymessage() (Folder のメソッド) 
copymode() (shutil モジュール) 
copyright (sys モジュール) 
copystat() (shutil モジュール) 
copytree() (shutil モジュール) 
cos() (cmath モジュール) 
cos() (math モジュール) 
cosh() (cmath モジュール) 
cosh() (math モジュール) 
count() (array のメソッド) 
count() (itertools モジュール) 
count() (string のメソッド) 
count() (string モジュール) 
countOf() (operator モジュール) 
countTestCases() (TestCase のメソッド) 
cPickle (組み込み モジュール),[Link] 
CRC (ZipInfo の属性) 
crc32() (binascii モジュール) 
crc32() (zlib モジュール) 
crc_hqx() (binascii モジュール) 
create() (IMAP4_stream のメソッド) 
create_decimal() (Context のメソッド) 
create_socket() (dispatcher のメソッド) 
create_system (ZipInfo の属性) 
create_version (ZipInfo の属性) 
createAttribute() (Document のメソッド) 
createAttributeNS() (Document のメソッド) 
createComment() (Document のメソッド) 
createElement() (Document のメソッド) 
createElementNS() (Document のメソッド) 
CreateKey() (_winreg モジュール) 
createLock() (Textbox のメソッド) 
createparser() (cd モジュール) 
createProcessingInstruction() (Document のメソッド) 
createTextNode() (Document のメソッド) 
critical() (logging モジュール) 
critical() (Textbox のメソッド) 
CRNCYSTR (locale モジュール) 
crop() (imageop モジュール) 
cross() (audioop モジュール) 
crypt() (crypt モジュール) 
crypt (組み込み モジュール),[Link] 
cStringIO (組み込み モジュール) 
csv (standard モジュール) 
ctermid() (os モジュール) 
ctime() (date のメソッド) 
ctime() (datetime のメソッド) 
ctime() (time モジュール) 
ctrl() (curses.ascii モジュール) 
curdir (os モジュール) 
CurrentByteIndex (xmlparser の属性) 
CurrentColumnNumber (xmlparser の属性) 
currentframe() (inspect モジュール) 
CurrentLineNumber (xmlparser の属性) 
currentThread() (threading モジュール) 
curs_set() (curses モジュール) 
curses (standard モジュール) 
curses.ascii (standard モジュール) 
curses.panel (standard モジュール) 
curses.textpad (standard モジュール) 
curses.wrapper (standard モジュール) 
cursyncup() (window のメソッド) 
cwd() (FTP のメソッド) 
cycle() (itertools モジュール) 
D_FMT (locale モジュール) 
D_T_FMT (locale モジュール) 
data (Binary の属性) 
data (Comment の属性) 
data (MutableString の属性) 
data (ProcessingInstruction の属性) 
data (Text の属性) 
data (UserDict の属性) 
data (UserList の属性) 
DATASIZE (cd モジュール) 
date (datetime のクラス) 
date() (datetime のメソッド) 
date() (NNTPDataError のメソッド) 
date_time (ZipInfo の属性) 
date_time_string() (BaseHTTPRequestHandler のメソッド) 
datetime (datetime のクラス) 
datetime (組み込み モジュール) 
day (date の属性) 
day (datetime の属性) 
DAY_1 ... DAY_7 (locale モジュール) 
daylight (time モジュール) 
dbhash (standard モジュール) 
dbhash (標準 モジュール) dbm (組み込み モジュール),[Link],[Link],[Link] 
deactivate_form() (form のメソッド) 
debug() (doctest モジュール),[Link] 
debug (IMAP4_stream の属性) 
debug() (logging モジュール) 
debug (shlex の属性) 
debug() (Template のメソッド) 
debug() (TestCase のメソッド) 
debug() (Textbox のメソッド) 
debug (ZipFile の属性) 
debug=0 (TarFile の属性) 
DEBUG_COLLECTABLE (gc モジュール) 
DEBUG_INSTANCES (gc モジュール) 
DEBUG_LEAK (gc モジュール) 
DEBUG_OBJECTS (gc モジュール) 
DEBUG_SAVEALL (gc モジュール) 
debug_src() (doctest モジュール) 
DEBUG_STATS (gc モジュール) 
DEBUG_UNCOLLECTABLE (gc モジュール) 
decimal() (unicodedata モジュール) 
DecimalException (decimal のクラス) 
decode() (base64 モジュール) 
decode() (Binary のメソッド) 
decode() (mimetools モジュール) 
decode() (quopri モジュール) 
decode() (ServerProxy のメソッド) 
decode() (string のメソッド) 
decode() (TextWrapper のメソッド) 
decode() (uu モジュール) 
decode_header() (email.Header モジュール) 
decode_params() (email.Utils モジュール) 
decode_rfc2231() (email.Utils モジュール) 
decodestring() (base64 モジュール) 
decodestring() (quopri モジュール) 
decomposition() (unicodedata モジュール) 
decompress() (bz2 モジュール) 
decompress() (BZ2Decompressor のメソッド) 
decompress() (Decompress のメソッド) 
decompress() (jpeg モジュール) 
decompress() (zlib モジュール) 
decompressobj() (zlib モジュール) 
dedent() (textwrap モジュール) 
def_prog_mode() (curses モジュール) 
def_shell_mode() (curses モジュール) 
default() (ASTVisitor のメソッド) 
default() (Cmd のメソッド) 
default_bufsize (xml.dom.pulldom モジュール) 
default_open() (BaseHandler のメソッド) 
DefaultContext (decimal のクラス) 
DefaultHandler() (xmlparser のメソッド) 
DefaultHandlerExpand() (xmlparser のメソッド) 
defaults() (SafeConfigParser のメソッド) 
defaultTestLoader (unittest モジュール) 
defaultTestResult() (TestCase のメソッド) 
defects (email.Message モジュール) 
defpath (os モジュール) 
degrees() (math モジュール) 
del_param() (Message のメソッド) 
delay_output() (curses モジュール) 
delayload (Cookie の属性) 
delch() (window のメソッド) 
dele() (POP3_SSL のメソッド) 
delete() (FTP のメソッド) 
delete() (IMAP4_stream のメソッド) 
delete_object() (FORMS object のメソッド) 
deleteacl() (IMAP4_stream のメソッド) 
deletefolder() (MH のメソッド) 
DeleteKey() (_winreg モジュール) 
deleteln() (window のメソッド) 
deleteparser() (CD parser のメソッド) 
DeleteValue() (_winreg モジュール) 
delimiter (Dialect の属性) 
delitem() (operator モジュール) 
delslice() (operator モジュール) 
demo() (turtle モジュール) 
deque() (collections モジュール) 
dereference (TarFile の属性) 
derwin() (window のメソッド) 
description() (NNTPDataError のメソッド) 
descriptions() (NNTPDataError のメソッド) 
Detach() (ASTVisitor のメソッド) 
DEVICE (standard モジュール) 
devnull (os モジュール) 
dgettext() (gettext モジュール) 
Dialect (csv のクラス) 
DictionaryType (types モジュール) 
diff_files (dircmp の属性) 
Differ (difflib のクラス) 
difflib (standard モジュール) 
digest() (hmac のメソッド) 
digest() (md5 のメソッド) 
digest() (sha のメソッド) 
digest_size (md5 モジュール) 
digest_size (sha モジュール) 
digit() (unicodedata モジュール) 
digits (string モジュール) 
dir() (FTP のメソッド) 
dircache (standard モジュール) 
dis (standard モジュール) 
disable() (gc モジュール) 
disable() (logging モジュール) 
disassemble() (dis モジュール) 
discard (Cookie の属性) 
discard_buffers() (async_chat のメソッド) 
disco() (dis モジュール) 
dispatch() (ASTVisitor のメソッド) 
displayhook() (sys モジュール) 
dist() (platform モジュール) 
distb() (dis モジュール) 
distutils (standard モジュール) 
dither2grey2() (imageop モジュール) 
dither2mono() (imageop モジュール) 
div() (operator モジュール) 
divide() (Context のメソッド) 
DivisionByZero (decimal のクラス) 
divmod() (Context のメソッド) 
dl (extension モジュール) 
dllhandle (sys モジュール) 
dngettext() (gettext モジュール) 
do_command() (Textbox のメソッド) 
do_forms() (fl モジュール) 
do_GET() (SimpleHTTPRequestHandler のメソッド) 
do_HEAD() (SimpleHTTPRequestHandler のメソッド) 
do_POST() (CGIHTTPRequestHandler のメソッド) 
doc_header (Cmd の属性) 
DocFileSuite() (doctest モジュール) 
docmd() (SMTP のメソッド) 
docstring (DocTest の属性) 
doctest (standard モジュール) 
documentElement (Document の属性) 
domain_initial_dot (Cookie の属性) 
domain_return_ok() (CookiePolicy のメソッド) 
domain_specified (Cookie の属性) 
DomainLiberal (LWPCookieJar の属性) 
DomainRFC2965Match (LWPCookieJar の属性) 
DomainStrict (LWPCookieJar の属性) 
DomainStrictNoDots (LWPCookieJar の属性) 
DomainStrictNonDomain (LWPCookieJar の属性) 
done() (Unpacker のメソッド) 
DONT_ACCEPT_BLANKLINE (doctest モジュール) 
DONT_ACCEPT_TRUE_FOR_1 (doctest モジュール) 
doRollover() (RotatingFileHandler のメソッド) 
doRollover() (TimedRotatingFileHandler のメソッド) 
DOTALL (re モジュール) 
doublequote (Dialect の属性) 
doupdate() (curses モジュール) 
down() (turtle モジュール) 
drain() (audio device のメソッド) 
dropwhile() (itertools モジュール) 
dst() (datetime のメソッド) 
dst() (time のメソッド),[Link] 
DTDHandler (xml.sax.handler のクラス) 
dumbdbm (standard モジュール) 
dumbdbm (標準 モジュール) 
dummy_thread (standard モジュール) 
dummy_threading (standard モジュール) 
dump() (marshal モジュール) 
dump() (pickle モジュール) 
dump() (Pickler のメソッド) 
dump_address_pair() (rfc822 モジュール) 
dump_stats() (Stats のメソッド) 
dumps() (marshal モジュール) 
dumps() (pickle モジュール) 
dumps() (xmlrpclib モジュール) 
dup() (os モジュール) 
dup2() (os モジュール) 
e (cmath モジュール) 
e (math モジュール) 
E2BIG (errno モジュール) 
EACCES (errno モジュール) 
EADDRINUSE (errno モジュール) 
EADDRNOTAVAIL (errno モジュール) 
EADV (errno モジュール) 
EAFNOSUPPORT (errno モジュール) 
EAGAIN (errno モジュール) 
EAI_* (socket モジュール) 
EALREADY (errno モジュール) 
east_asian_width() (unicodedata モジュール) 
EBADE (errno モジュール) 
EBADF (errno モジュール) 
EBADFD (errno モジュール) 
EBADMSG (errno モジュール) 
EBADR (errno モジュール) 
EBADRQC (errno モジュール) 
EBADSLT (errno モジュール) 
EBFONT (errno モジュール) 
EBUSY (errno モジュール) 
ECHILD (errno モジュール) 
echo() (curses モジュール) 
echochar() (window のメソッド) 
ECHRNG (errno モジュール) 
ECOMM (errno モジュール) 
ECONNABORTED (errno モジュール) 
ECONNREFUSED (errno モジュール) 
ECONNRESET (errno モジュール) 
EDEADLK (errno モジュール) 
EDEADLOCK (errno モジュール) 
EDESTADDRREQ (errno モジュール) 
edit() (Textbox のメソッド) 
EDOM (errno モジュール) 
EDOTDOT (errno モジュール) 
EDQUOT (errno モジュール) 
EEXIST (errno モジュール) 
EFAULT (errno モジュール) 
EFBIG (errno モジュール) 
ehlo() (SMTP のメソッド) 
EHOSTDOWN (errno モジュール) 
EHOSTUNREACH (errno モジュール) 
EIDRM (errno モジュール) 
EILSEQ (errno モジュール) 
EINPROGRESS (errno モジュール) 
EINTR (errno モジュール) 
EINVAL (errno モジュール) 
EIO (errno モジュール) 
EISCONN (errno モジュール) 
EISDIR (errno モジュール) 
EISNAM (errno モジュール) 
eject() (CD player のメソッド) 
EL2HLT (errno モジュール) 
EL2NSYNC (errno モジュール) 
EL3HLT (errno モジュール) 
EL3RST (errno モジュール) 
ElementDeclHandler() (xmlparser のメソッド) 
elements (XMLParser の属性) 
ELIBACC (errno モジュール) 
ELIBBAD (errno モジュール) 
ELIBEXEC (errno モジュール) 
ELIBMAX (errno モジュール) 
ELIBSCN (errno モジュール) 
ELLIPSIS (doctest モジュール) 
EllipsisType (types モジュール) 
ELNRNG (errno モジュール) 
ELOOP (errno モジュール) 
email (standard モジュール) 
email.Charset (standard モジュール) 
email.Encoders (standard モジュール) 
email.Errors (standard モジュール) 
email.Generator (standard モジュール) 
email.Header (standard モジュール) 
email.Iterators (standard モジュール) 
email.Message (standard モジュール) 
email.Parser (standard モジュール) 
email.Utils (standard モジュール) 
EMFILE (errno モジュール) 
emit() (BufferingHandler のメソッド) 
emit() (DatagramHandler のメソッド) 
emit() (FileHandler のメソッド) 
emit() (HTTPHandler のメソッド) 
emit() (NTEventLogHandler のメソッド) 
emit() (RotatingFileHandler のメソッド) 
emit() (SMTPHandler のメソッド) 
emit() (SocketHandler のメソッド) 
emit() (StreamHandler のメソッド) 
emit() (SysLogHandler のメソッド) 
emit() (Textbox のメソッド) 
emit() (TimedRotatingFileHandler のメソッド) 
EMLINK (errno モジュール) 
empty() (Queue のメソッド) 
empty() (scheduler のメソッド) 
EMPTY_NAMESPACE (xml.dom モジュール) 
emptyline() (Cmd のメソッド) 
EMSGSIZE (errno モジュール) 
EMULTIHOP (errno モジュール) 
enable() (cgitb モジュール) 
enable() (gc モジュール) 
ENAMETOOLONG (errno モジュール) 
ENAVAIL (errno モジュール) 
enclose() (window のメソッド) 
encode() (base64 モジュール) encode() (Binary のメソッド) 
encode() (Header のメソッド) 
encode() (mimetools モジュール) 
encode() (quopri モジュール) 
encode() (ServerProxy のメソッド),[Link] 
encode() (string のメソッド) 
encode() (TextWrapper のメソッド) 
encode() (uu モジュール) 
encode_7or8bit() (email.Encoders モジュール) encode_base64() (email.Encoders モジュール) 
encode_noop() (email.Encoders モジュール) 
encode_quopri() (email.Encoders モジュール) 
encode_rfc2231() (email.Utils モジュール) 
encoded_header_len() (Charset のメソッド) 
EncodedFile() (codecs モジュール) 
encodePriority() (SysLogHandler のメソッド) 
encodestring() (base64 モジュール) 
encodestring() (quopri モジュール) 
encoding (file の属性) 
encodings.idna (standard モジュール) 
encodings_map (mimetypes モジュール),[Link] 
end() (Template のメソッド) 
end_group() (form のメソッド) 
end_headers() (BaseHTTPRequestHandler のメソッド) 
end_marker() (MultiFile のメソッド) 
end_paragraph() (formatter のメソッド) 
EndCdataSectionHandler() (xmlparser のメソッド) 
EndDoctypeDeclHandler() (xmlparser のメソッド) 
endDocument() (ContentHandler のメソッド) 
endElement() (ContentHandler のメソッド) 
EndElementHandler() (xmlparser のメソッド) 
endElementNS() (ContentHandler のメソッド) 
endheaders() (HTTPSConnection のメソッド) 
EndNamespaceDeclHandler() (xmlparser のメソッド) 
endpick() (gl モジュール) 
endpos (MatchObject の属性) 
endPrefixMapping() (ContentHandler のメソッド) 
endselect() (gl モジュール) 
endswith() (string のメソッド) 
endwin() (curses モジュール) 
ENETDOWN (errno モジュール) 
ENETRESET (errno モジュール) 
ENETUNREACH (errno モジュール) 
ENFILE (errno モジュール) 
ENOANO (errno モジュール) 
ENOBUFS (errno モジュール) 
ENOCSI (errno モジュール) 
ENODATA (errno モジュール) 
ENODEV (errno モジュール) 
ENOENT (errno モジュール) 
ENOEXEC (errno モジュール) 
ENOLCK (errno モジュール) 
ENOLINK (errno モジュール) 
ENOMEM (errno モジュール) 
ENOMSG (errno モジュール) 
ENONET (errno モジュール) 
ENOPKG (errno モジュール) 
ENOPROTOOPT (errno モジュール) 
ENOSPC (errno モジュール) 
ENOSR (errno モジュール) 
ENOSTR (errno モジュール) 
ENOSYS (errno モジュール) 
ENOTBLK (errno モジュール) 
ENOTCONN (errno モジュール) 
ENOTDIR (errno モジュール) 
ENOTEMPTY (errno モジュール) 
ENOTNAM (errno モジュール) 
ENOTSOCK (errno モジュール) 
ENOTTY (errno モジュール) 
ENOTUNIQ (errno モジュール) 
enter() (scheduler のメソッド) 
enterabs() (scheduler のメソッド) 
entities (DocumentType の属性) 
EntityDeclHandler() (xmlparser のメソッド) 
entitydefs (htmlentitydefs モジュール) 
entitydefs (XMLParser の属性) 
EntityResolver (xml.sax.handler のクラス) 
eof (shlex の属性) 
EOPNOTSUPP (errno モジュール) 
EOVERFLOW (errno モジュール) 
EPERM (errno モジュール) 
EPFNOSUPPORT (errno モジュール) 
epilogue (email.Message モジュール) 
EPIPE (errno モジュール) 
EPROTO (errno モジュール) 
EPROTONOSUPPORT (errno モジュール) 
EPROTOTYPE (errno モジュール) 
eq() (operator モジュール) 
ERA (locale モジュール) 
ERA_D_FMT (locale モジュール) 
ERA_D_T_FMT (locale モジュール) 
ERA_YEAR (locale モジュール) 
ERANGE (errno モジュール) 
erase() (window のメソッド) 
erasechar() (curses モジュール) 
EREMCHG (errno モジュール) 
EREMOTE (errno モジュール) 
EREMOTEIO (errno モジュール) 
ERESTART (errno モジュール) 
EROFS (errno モジュール) 
ERR (curses モジュール) 
errcode (ServerProxy の属性) 
errmsg (ServerProxy の属性) 
errno (standard モジュール) 
errno (組み込み モジュール),[Link] 
error,[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link] ERROR (cd モジュール) 
error() (ErrorHandler のメソッド) 
error() (logging モジュール) 
error() (MH のメソッド) 
error() (OpenerDirector のメソッド) 
error() (Textbox のメソッド) 
error_leader() (shlex のメソッド) 
error_message_format (BaseHTTPRequestHandler の属性) 
ErrorByteIndex (xmlparser の属性) 
errorcode (errno モジュール) 
ErrorCode (xmlparser の属性) 
ErrorColumnNumber (xmlparser の属性) 
ErrorHandler (xml.sax.handler のクラス) 
errorlevel=0 (TarFile の属性) 
ErrorLineNumber (xmlparser の属性) 
errors (TestResult の属性) 
ErrorString() (xml.parsers.expat モジュール) 
escape() (cgi モジュール) 
escape() (re モジュール) 
escape (shlex の属性) 
escape() (xml.sax.saxutils モジュール) 
escapechar (Dialect の属性) 
escapedquotes (shlex の属性) 
ESHUTDOWN (errno モジュール) 
ESOCKTNOSUPPORT (errno モジュール) 
ESPIPE (errno モジュール) 
ESRCH (errno モジュール) 
ESRMNT (errno モジュール) 
ESTALE (errno モジュール) 
ESTRPIPE (errno モジュール) 
ETIME (errno モジュール) 
ETIMEDOUT (errno モジュール) 
Etiny() (Context のメソッド) 
ETOOMANYREFS (errno モジュール) 
Etop() (Context のメソッド) 
ETXTBSY (errno モジュール) 
EUCLEAN (errno モジュール) 
EUNATCH (errno モジュール) 
EUSERS (errno モジュール) 
eval() (組み込み関数),[Link],[Link],[Link],[Link] 
Event() (threading モジュール) 
EWOULDBLOCK (errno モジュール) 
EX_CANTCREAT (os モジュール) 
EX_CONFIG (os モジュール) 
EX_DATAERR (os モジュール) 
EX_IOERR (os モジュール) 
EX_NOHOST (os モジュール) 
EX_NOINPUT (os モジュール) 
EX_NOPERM (os モジュール) 
EX_NOTFOUND (os モジュール) 
EX_NOUSER (os モジュール) 
EX_OK (os モジュール) 
EX_OSERR (os モジュール) 
EX_OSFILE (os モジュール) 
EX_PROTOCOL (os モジュール) 
EX_SOFTWARE (os モジュール) 
EX_TEMPFAIL (os モジュール) 
EX_UNAVAILABLE (os モジュール) 
EX_USAGE (os モジュール) 
example (DocTestFailure の属性) 
example (UnexpectedException の属性) 
examples (DocTest の属性) 
exc_clear() (sys モジュール) 
exc_info() (sys モジュール) 
exc_info (UnexpectedException の属性) 
exc_msg (Example の属性) 
exc_traceback (sys モジュール) 
exc_type (sys モジュール) 
exc_value (sys モジュール) 
excepthook() (in module sys) excepthook() (sys モジュール) 
exception() (logging モジュール) 
exception() (Textbox のメソッド) 
exceptions (standard モジュール) 
EXDEV (errno モジュール) 
exec_prefix (sys モジュール) 
execfile() (built-in function) execfile() (組み込み関数) 
execl() (os モジュール) 
execle() (os モジュール) 
execlp() (os モジュール) 
execlpe() (os モジュール) 
executable (sys モジュール) 
execv() (os モジュール) 
execve() (os モジュール) 
execvp() (os モジュール) 
execvpe() (os モジュール) 
EXFULL (errno モジュール) 
exists() (os.path モジュール) 
exit() (sys モジュール) 
exit() (thread モジュール) 
exitfunc (sys モジュール) 
exp() (cmath モジュール) 
exp() (math モジュール) 
expand() (MatchObject のメソッド) 
expand_tabs (TextWrapper の属性) 
expandNode() (DOMEventStream のメソッド) 
expandtabs() (string のメソッド) 
expandtabs() (string モジュール) 
expanduser() (os.path モジュール) 
expandvars() (os.path モジュール) 
expect() (Telnet のメソッド) 
expires (Cookie の属性) 
expovariate() (random モジュール) 
expr() (parser モジュール) 
expunge() (IMAP4_stream のメソッド) 
extend() (array のメソッド) 
extend() (SystemRandom のメソッド) 
extend_path() (pkgutil モジュール) 
ExtendedContext (decimal のクラス) 
extendleft() (SystemRandom のメソッド) 
extensions_map (SimpleHTTPRequestHandler の属性) 
external_attr (ZipInfo の属性) 
ExternalEntityParserCreate() (xmlparser のメソッド) 
ExternalEntityRefHandler() (xmlparser のメソッド) 
extra (ZipInfo の属性) 
extract() (TarFile のメソッド) 
extract_cookies() (CookieJar のメソッド) 
extract_stack() (traceback モジュール) 
extract_tb() (traceback モジュール) 
extract_version (ZipInfo の属性) 
extractfile() (TarFile のメソッド) 
extsep (os モジュール) 
F_BAVAIL (statvfs モジュール) 
F_BFREE (statvfs モジュール) 
F_BLOCKS (statvfs モジュール) 
F_BSIZE (statvfs モジュール) 
F_FAVAIL (statvfs モジュール) 
F_FFREE (statvfs モジュール) 
F_FILES (statvfs モジュール) 
F_FLAG (statvfs モジュール) 
F_FRSIZE (statvfs モジュール) 
F_NAMEMAX (statvfs モジュール) 
F_OK (os モジュール) 
fabs() (math モジュール) 
fail() (TestCase のメソッド) 
failIf() (TestCase のメソッド) 
failIfAlmostEqual() (TextTestRunner のメソッド) 
failIfEqual() (TextTestRunner のメソッド) 
failUnless() (TextTestRunner のメソッド) 
failUnlessAlmostEqual() (TextTestRunner のメソッド) 
failUnlessEqual() (TextTestRunner のメソッド) 
failUnlessRaises() (TextTestRunner のメソッド) 
failureException (TestCase の属性) 
failures (TestResult の属性) 
fatalError() (ErrorHandler のメソッド) 
faultCode (ServerProxy の属性) 
faultString (ServerProxy の属性) 
fcntl() (fcntl モジュール) 
fcntl (組み込み モジュール),[Link] 
fdatasync() (os モジュール) 
fdopen() (os モジュール) 
feature_external_ges (xml.sax.handler モジュール) 
feature_external_pes (xml.sax.handler モジュール) 
feature_namespace_prefixes (xml.sax.handler モジュール) 
feature_namespaces (xml.sax.handler モジュール) 
feature_string_interning (xml.sax.handler モジュール) 
feature_validation (xml.sax.handler モジュール) 
feed() (FeedParser のメソッド) 
feed() (HTMLParser のメソッド) 
feed() (IncrementalParser のメソッド) 
feed() (SGMLParser のメソッド) 
feed() (XMLParser のメソッド) 
file (class descriptor の属性) 
file (function descriptor の属性) 
file() (posixfile method) file() (組み込み関数) 
file_offset (ZipInfo の属性) 
file_open() (FileHandler のメソッド) 
file_size (ZipInfo の属性) 
filecmp (standard モジュール) 
fileinput (standard モジュール) 
filelineno() (fileinput モジュール) 
filename (Cookie の属性) 
filename (DocTest の属性) 
filename() (fileinput モジュール) 
filename (ZipInfo の属性) 
filename_only (tabnanny モジュール) 
fileno() (audio device のメソッド),[Link] 
fileno() (file のメソッド) 
fileno() (mixer device のメソッド) 
fileno() (Profile のメソッド) 
fileno() (socket のメソッド) 
fileno() (Telnet のメソッド) 
fileopen() (posixfile モジュール) 
FileType (types モジュール) 
fill() (textwrap モジュール) 
filter() (curses モジュール) 
filter() (Filter のメソッド) 
filter() (fnmatch モジュール) 
filter() (Textbox のメソッド),[Link] 
filterwarnings() (warnings モジュール) 
find() (DocTestFinder のメソッド) 
find() (gettext モジュール) 
find() (Queue のメソッド) 
find() (string のメソッド) 
find() (string モジュール) 
find_first() (form のメソッド) 
find_last() (form のメソッド) 
find_longest_match() (SequenceMatcher のメソッド) 
find_module() (imp モジュール) 
find_prefix_at_end() (asynchat モジュール) 
find_user_password() (HTTPPasswordMgr のメソッド) 
findall() (re モジュール) 
findall() (RegexObject のメソッド) 
findCaller() (Textbox のメソッド) 
findfactor() (audioop モジュール) 
findfile() (test.test_support モジュール) 
findfit() (audioop モジュール) 
findfont() (fm モジュール) 
finditer() (re モジュール) 
finditer() (RegexObject のメソッド) 
findmatch() (mailcap モジュール) 
findmax() (audioop モジュール) 
first() (dbhash のメソッド) 
first() (fifo のメソッド) 
first() (Queue のメソッド) 
firstChild (Node の属性) 
firstkey() (gdbm モジュール) 
firstweekday() (calendar モジュール) 
fix() (fpformat モジュール) 
fix_sentence_endings (TextWrapper の属性) 
FL (standard モジュール) 
fl (組み込み モジュール) 
flag_bits (ZipInfo の属性) 
flags (RegexObject の属性) 
flash() (curses モジュール) 
flatten() (Generator のメソッド) 
float() (built-in function) float() (組み込み関数),[Link] 
FloatType (types モジュール) 
flock() (fcntl モジュール) 
floor() (in module math) floor() (math モジュール) 
floordiv() (operator モジュール) 
flp (standard モジュール) 
flush() (audio device のメソッド) 
flush() (BufferingHandler のメソッド) 
flush() (BZ2Compressor のメソッド) 
flush() (Compress のメソッド) 
flush() (Decompress のメソッド) 
flush() (file のメソッド) 
flush() (MemoryHandler のメソッド) 
flush() (Queue のメソッド) 
flush() (StreamHandler のメソッド) 
flush() (Textbox のメソッド) 
flush() (writer のメソッド) 
flush_softspace() (formatter のメソッド) 
flushheaders() (MimeWriter のメソッド) 
flushinp() (curses モジュール) 
FlushKey() (_winreg モジュール) 
fm (組み込み モジュール) 
fmod() (math モジュール) 
fnmatch() (fnmatch モジュール) 
fnmatch (standard モジュール) 
fnmatchcase() (fnmatch モジュール) 
fontpath() (fm モジュール) 
forget() (statcache モジュール) 
forget() (test.test_support モジュール) 
forget_dir() (statcache モジュール) 
forget_except_prefix() (statcache モジュール) 
forget_prefix() (statcache モジュール) 
fork() (os モジュール) 
fork() (pty モジュール) 
forkpty() (os モジュール) 
format() (Formatter のメソッド) 
format() (locale モジュール) 
format() (PrettyPrinter のメソッド) 
format() (Textbox のメソッド) 
format_exc() (traceback モジュール) 
format_exception() (traceback モジュール) 
format_exception_only() (traceback モジュール) 
format_list() (traceback モジュール) 
format_stack() (traceback モジュール) 
format_tb() (traceback モジュール) 
formataddr() (email.Utils モジュール) 
formatargspec() (inspect モジュール) 
formatargvalues() (inspect モジュール) 
formatdate() (email.Utils モジュール) 
formatException() (Formatter のメソッド) 
formatter (HTMLParser の属性) 
formatter (standard モジュール) formatter (標準 モジュール) 
formatTime() (Formatter のメソッド) 
formatwarning() (warnings モジュール) FORMS Library 
forward() (turtle モジュール) 
found_terminator() (async_chat のメソッド) 
fp (AddressList の属性) 
fpathconf() (os モジュール) 
fpectl (extension モジュール) 
fpformat (standard モジュール) 
frame (ScrolledText の属性) frame object 
FrameType (types モジュール) 
freeze_form() (form のメソッド) 
freeze_object() (FORMS object のメソッド) 
frexp() (math モジュール) 
from_splittable() (Charset のメソッド) 
frombuf() (TarInfo のメソッド) 
fromchild (Popen4 の属性) 
fromfd() (socket モジュール) 
fromfile() (array のメソッド) 
fromlist() (array のメソッド) 
fromordinal() (date のメソッド) 
fromordinal() (datetime のメソッド) 
fromstring() (array のメソッド) 
fromtimestamp() (date のメソッド) 
fromtimestamp() (datetime のメソッド) 
fromunicode() (array のメソッド) 
fromutc() (time のメソッド) 
fstat() (os モジュール) 
fstatvfs() (os モジュール) 
fsync() (os モジュール) 
ftp_open() (FTPHandler のメソッド) 
ftp_proxy (環境変数) 
ftplib (standard モジュール) 
ftruncate() (os モジュール) 
full() (Queue のメソッド) 
function() (new モジュール) 
FunctionType (types モジュール) 
funny_files (dircmp の属性) 
gammavariate() (random モジュール) 
garbage (gc モジュール) 
gather() (Textbox のメソッド) 
gauss() (random モジュール) 
gc (extension モジュール) 
gdbm (組み込み モジュール),[Link],[Link] 
ge() (operator モジュール) 
generate_tokens() (tokenize モジュール) 
GeneratorType (types モジュール) 
get() (AddressList のメソッド) 
get() (Message のメソッド) 
get() (mixer device のメソッド) 
get() (Queue のメソッド) 
get() (SafeConfigParser のメソッド),[Link] 
get() (webbrowser モジュール) get_all() (Message のメソッド) 
get_begidx() (readline モジュール) 
get_body_encoding() (Charset のメソッド) 
get_boundary() (Message のメソッド) 
get_buffer() (Packer のメソッド) 
get_buffer() (Unpacker のメソッド) 
get_charset() (Message のメソッド) 
get_charsets() (Message のメソッド) 
get_close_matches() (difflib モジュール) 
get_completer() (readline モジュール) 
get_completer_delims() (readline モジュール) 
get_content_charset() (Message のメソッド) 
get_content_maintype() (Message のメソッド) 
get_content_subtype() (Message のメソッド) 
get_content_type() (Message のメソッド) 
get_current_history_length() (readline モジュール) 
get_data() (Request のメソッド) 
get_debug() (gc モジュール) 
get_default_type() (Message のメソッド) 
get_dialect() (csv モジュール) 
get_directory() (fl モジュール) 
get_doctest() (DocTestParser のメソッド) 
get_endidx() (readline モジュール) 
get_examples() (DocTestParser のメソッド) 
get_filename() (fl モジュール) 
get_filename() (Message のメソッド) 
get_full_url() (Request のメソッド) 
get_grouped_opcodes() (SequenceMatcher のメソッド) 
get_history_item() (readline モジュール) 
get_history_length() (readline モジュール) 
get_host() (Request のメソッド) 
get_ident() (thread モジュール) 
get_line_buffer() (readline モジュール) 
get_magic() (imp モジュール) 
get_main_type() (Message のメソッド) 
get_matching_blocks() (SequenceMatcher のメソッド) 
get_method() (Request のメソッド) 
get_mouse() (fl モジュール) 
get_nonstandard_attr() (Cookie のメソッド) 
get_nowait() (Queue のメソッド) 
get_objects() (gc モジュール) 
get_opcodes() (SequenceMatcher のメソッド) 
get_origin_req_host() (Request のメソッド) 
get_osfhandle() (msvcrt モジュール) 
get_output_charset() (Charset のメソッド) 
get_param() (Message のメソッド) 
get_params() (Message のメソッド) 
get_pattern() (fl モジュール) 
get_payload() (Message のメソッド) 
get_position() (Unpacker のメソッド) 
get_recsrc() (mixer device のメソッド) 
get_referents() (gc モジュール) 
get_referrers() (gc モジュール) 
get_rgbmode() (fl モジュール) 
get_selector() (Request のメソッド) 
get_socket() (Telnet のメソッド) 
get_starttag_text() (HTMLParser のメソッド) 
get_starttag_text() (SGMLParser のメソッド) 
get_subtype() (Message のメソッド) 
get_suffixes() (imp モジュール) 
get_terminator() (async_chat のメソッド) 
get_threshold() (gc モジュール) 
get_token() (shlex のメソッド) 
get_type() (Message のメソッド) 
get_type() (Request のメソッド) 
get_unixfrom() (Message のメソッド) 
getacl() (IMAP4_stream のメソッド) 
getaddr() (AddressList のメソッド) 
getaddresses() (email.Utils モジュール) 
getaddrinfo() (socket モジュール) 
getaddrlist() (AddressList のメソッド) 
getallmatchingheaders() (AddressList のメソッド) 
getargspec() (inspect モジュール) 
getargvalues() (inspect モジュール) 
getatime() (os.path モジュール) 
getAttribute() (Element のメソッド) 
getAttributeNode() (Element のメソッド) 
getAttributeNodeNS() (Element のメソッド) 
getAttributeNS() (Element のメソッド) 
GetBase() (xmlparser のメソッド) 
getbegyx() (window のメソッド) 
getboolean() (SafeConfigParser のメソッド) 
getByteStream() (InputSource のメソッド) 
getcaps() (mailcap モジュール) 
getch() (msvcrt モジュール) 
getch() (window のメソッド) 
getchannels() (audio configuration のメソッド) 
getCharacterStream() (InputSource のメソッド) 
getche() (msvcrt モジュール) 
getcheckinterval() (sys モジュール) 
getChildNodes() (Node のメソッド) 
getChildren() (Node のメソッド) 
getclasstree() (inspect モジュール) 
getColumnNumber() (Locator のメソッド) 
getcomments() (inspect モジュール) 
getcompname() (aifc のメソッド) 
getcompname() (AU_read のメソッド) 
getcompname() (Wave_read のメソッド) 
getcomptype() (aifc のメソッド) 
getcomptype() (AU_read のメソッド) 
getcomptype() (Wave_read のメソッド) 
getconfig() (audio port のメソッド) 
getContentHandler() (XMLReader のメソッド) 
getcontext() (decimal モジュール) 
getcontext() (MH のメソッド) 
getctime() (os.path モジュール) 
getcurrent() (Folder のメソッド) 
getcwd() (os モジュール) 
getdate() (AddressList のメソッド) 
getdate_tz() (AddressList のメソッド) 
getdecoder() (codecs モジュール) 
getdefaultencoding() (sys モジュール) 
getdefaultlocale() (locale モジュール) 
getdefaulttimeout() (socket モジュール) 
getdlopenflags() (sys モジュール) 
getdoc() (inspect モジュール) 
getDOMImplementation() (xml.dom モジュール) 
getDTDHandler() (XMLReader のメソッド) 
getEffectiveLevel() (Textbox のメソッド) 
getegid() (os モジュール) 
getElementsByTagName() (Document のメソッド) 
getElementsByTagName() (Element のメソッド) 
getElementsByTagNameNS() (Document のメソッド) 
getElementsByTagNameNS() (Element のメソッド) 
getencoder() (codecs モジュール) 
getEncoding() (InputSource のメソッド) 
getencoding() (Message のメソッド) 
getEntityResolver() (XMLReader のメソッド) 
getenv() (os モジュール) 
getErrorHandler() (XMLReader のメソッド) 
geteuid() (os モジュール) 
getEvent() (DOMEventStream のメソッド) 
getEventCategory() (NTEventLogHandler のメソッド) 
getEventType() (NTEventLogHandler のメソッド) 
getException() (SAXException のメソッド) 
getfd() (audio port のメソッド) 
getFeature() (XMLReader のメソッド) 
getfile() (inspect モジュール) 
getfilesystemencoding() (sys モジュール) 
getfillable() (audio port のメソッド) 
getfilled() (audio port のメソッド) 
getfillpoint() (audio port のメソッド) 
getfirst() (FieldStorage のメソッド) 
getfirstmatchingheader() (AddressList のメソッド) 
getfloat() (SafeConfigParser のメソッド) 
getfloatmax() (audio configuration のメソッド) 
getfqdn() (socket モジュール) 
getframeinfo() (inspect モジュール) 
getframerate() (aifc のメソッド) 
getframerate() (AU_read のメソッド) 
getframerate() (Wave_read のメソッド) 
getfullname() (Folder のメソッド) 
getgid() (os モジュール) 
getgrall() (grp モジュール) 
getgrgid() (grp モジュール) 
getgrnam() (grp モジュール) 
getgroups() (os モジュール) 
getheader() (AddressList のメソッド) 
getheader() (HTTPSConnection のメソッド) 
getheaders() (HTTPSConnection のメソッド) gethostbyaddr() (in module socket) 
gethostbyaddr() (socket モジュール) 
gethostbyname() (socket モジュール) 
gethostbyname_ex() (socket モジュール) gethostname() (in module socket) 
gethostname() (socket モジュール) 
getinfo() (audio device のメソッド) 
getinfo() (ZipFile のメソッド) 
getinnerframes() (inspect モジュール) 
GetInputContext() (xmlparser のメソッド) 
getint() (SafeConfigParser のメソッド) 
getitem() (operator モジュール) 
getkey() (window のメソッド) 
getlast() (Folder のメソッド) 
getLength() (Attributes のメソッド) 
getLevelName() (logging モジュール) 
getline() (linecache モジュール) 
getLineNumber() (Locator のメソッド) 
getlist() (FieldStorage のメソッド) 
getloadavg() (os モジュール) 
getlocale() (locale モジュール) 
getLogger() (logging モジュール) 
getLoggerClass() (logging モジュール) 
getlogin() (os モジュール) 
getmaintype() (Message のメソッド) 
getmark() (aifc のメソッド) 
getmark() (AU_read のメソッド) 
getmark() (Wave_read のメソッド) 
getmarkers() (aifc のメソッド) 
getmarkers() (AU_read のメソッド) 
getmarkers() (Wave_read のメソッド) 
getmaxyx() (window のメソッド) 
getmcolor() (fl モジュール) 
getmember() (TarFile のメソッド) 
getmembers() (inspect モジュール) 
getmembers() (TarFile のメソッド) 
getMessage() (SAXException のメソッド) 
getmessagefilename() (Folder のメソッド) 
getMessageID() (NTEventLogHandler のメソッド) 
getmodule() (inspect モジュール) 
getmoduleinfo() (inspect モジュール) 
getmodulename() (inspect モジュール) 
getmouse() (curses モジュール) 
getmro() (inspect モジュール) 
getmtime() (os.path モジュール) 
getname() (Chunk のメソッド) 
getName() (Thread のメソッド) 
getNameByQName() (AttributesNS のメソッド) 
getnameinfo() (socket モジュール) 
getNames() (Attributes のメソッド) 
getnames() (TarFile のメソッド) 
getnamespace() (XMLParser のメソッド) 
getnchannels() (aifc のメソッド) 
getnchannels() (AU_read のメソッド) 
getnchannels() (Wave_read のメソッド) 
getnframes() (aifc のメソッド) 
getnframes() (AU_read のメソッド) 
getnframes() (Wave_read のメソッド) 
getopt() (getopt モジュール) 
getopt (standard モジュール) 
getouterframes() (inspect モジュール) 
getoutput() (commands モジュール) 
getpagesize() (resource モジュール) 
getparam() (Message のメソッド) 
getparams() (aifc のメソッド) 
getparams() (al モジュール) 
getparams() (AU_read のメソッド) 
getparams() (Wave_read のメソッド) 
getparyx() (window のメソッド) 
getpass() (getpass モジュール) 
getpass (standard モジュール) 
getpath() (MH のメソッド) 
getpeername() (socket のメソッド) 
getpgrp() (os モジュール) 
getpid() (os モジュール) 
getplist() (Message のメソッド) 
getpos() (HTMLParser のメソッド) 
getppid() (os モジュール) 
getpreferredencoding() (locale モジュール) 
getprofile() (MH のメソッド) 
getProperty() (XMLReader のメソッド) 
getprotobyname() (socket モジュール) 
getPublicId() (InputSource のメソッド) 
getPublicId() (Locator のメソッド) 
getpwall() (pwd モジュール) 
getpwnam() (pwd モジュール) 
getpwuid() (pwd モジュール) 
getQNameByName() (AttributesNS のメソッド) 
getQNames() (AttributesNS のメソッド) 
getqueuesize() (audio configuration のメソッド) 
getquota() (IMAP4_stream のメソッド) 
getquotaroot() (IMAP4_stream のメソッド) 
getrandbits() (random モジュール) 
getrawheader() (AddressList のメソッド) 
getreader() (codecs モジュール) 
getrecursionlimit() (sys モジュール) 
getrefcount() (sys モジュール) 
getresponse() (HTTPSConnection のメソッド) 
getrlimit() (resource モジュール) 
getrusage() (resource モジュール) 
getsampfmt() (audio configuration のメソッド) 
getsample() (audioop モジュール) 
getsampwidth() (aifc のメソッド) 
getsampwidth() (AU_read のメソッド) 
getsampwidth() (Wave_read のメソッド) 
getsequences() (Folder のメソッド) 
getsequencesfilename() (Folder のメソッド) 
getservbyname() (socket モジュール) 
getservbyport() (socket モジュール) 
getsid() (os モジュール) 
getsignal() (signal モジュール) 
getsize() (Chunk のメソッド) 
getsize() (os.path モジュール) 
getsizes() (imgfile モジュール) 
getslice() (operator モジュール) 
getsockname() (socket のメソッド) 
getsockopt() (socket のメソッド) 
getsource() (inspect モジュール) 
getsourcefile() (inspect モジュール) 
getsourcelines() (inspect モジュール) 
getstate() (random モジュール) 
getstatus() (audio port のメソッド) 
getstatus() (CD player のメソッド) 
getstatus() (commands モジュール) 
getstatusoutput() (commands モジュール) 
getstr() (window のメソッド) 
getSubject() (SMTPHandler のメソッド) 
getsubtype() (Message のメソッド) 
getSystemId() (InputSource のメソッド) 
getSystemId() (Locator のメソッド) 
getsyx() (curses モジュール) 
gettarinfo() (TarFile のメソッド) 
gettempdir() (tempfile モジュール) 
gettempprefix() (tempfile モジュール) 
getTestCaseNames() (TestLoader のメソッド) 
gettext() (gettext モジュール) 
gettext() (GNUTranslations のメソッド) 
gettext() (NullTranslations のメソッド) 
gettext (standard モジュール) 
gettimeout() (socket のメソッド) 
gettrackinfo() (CD player のメソッド) 
getType() (Attributes のメソッド) 
gettype() (Message のメソッド) 
getuid() (os モジュール) 
getuser() (getpass モジュール) 
getValue() (Attributes のメソッド) 
getvalue() (StringIO のメソッド) 
getValueByQName() (AttributesNS のメソッド) 
getweakrefcount() (weakref モジュール) 
getweakrefs() (weakref モジュール) 
getwelcome() (FTP のメソッド) 
getwelcome() (NNTPDataError のメソッド) 
getwelcome() (POP3_SSL のメソッド) 
getwidth() (audio configuration のメソッド) 
getwin() (curses モジュール) 
getwindowsversion() (sys モジュール) 
getwriter() (codecs モジュール) 
getyx() (window のメソッド) 
gid (TarInfo の属性) 
GL (standard モジュール) 
gl (組み込み モジュール) 
glob() (glob モジュール) 
glob (standard モジュール) 
glob (標準 モジュール) globals() (built-in function) 
globs (DocTest の属性) 
gmtime() (time モジュール) 
gname (TarInfo の属性) 
gnu_getopt() (getopt モジュール) 
gopher_open() (GopherHandler のメソッド) 
gopher_proxy (環境変数) 
gopherlib (standard モジュール) 
got (DocTestFailure の属性) 
goto() (turtle モジュール) 
grey22grey() (imageop モジュール) 
grey2grey2() (imageop モジュール) 
grey2grey4() (imageop モジュール) 
grey2mono() (imageop モジュール) 
grey42grey() (imageop モジュール) 
group() (MatchObject のメソッド) 
group() (NNTPDataError のメソッド) 
groupby() (itertools モジュール) 
groupdict() (MatchObject のメソッド) 
groupindex (RegexObject の属性) 
groups() (MatchObject のメソッド) 
grp (組み込み モジュール) 
gt() (operator モジュール) 
guess_all_extensions() (mimetypes モジュール) guess_extension() (MimeTypes のメソッド) 
guess_extension() (mimetypes モジュール) 
guess_type() (MimeTypes のメソッド) 
guess_type() (mimetypes モジュール) 
gzip (standard モジュール) 
halfdelay() (curses モジュール) 
handle() (BaseHTTPRequestHandler のメソッド) 
handle() (Textbox のメソッド),[Link] 
handle_accept() (dispatcher のメソッド) 
handle_authentication_request() (AbstractBasicAuthHandler のメソッド) 
handle_authentication_request() (AbstractDigestAuthHandler のメソッド) 
handle_cdata() (XMLParser のメソッド) 
handle_charref() (HTMLParser のメソッド) 
handle_charref() (SGMLParser のメソッド) 
handle_charref() (XMLParser のメソッド) 
handle_close() (async_chat のメソッド) 
handle_close() (dispatcher のメソッド) 
handle_comment() (HTMLParser のメソッド) 
handle_comment() (SGMLParser のメソッド) 
handle_comment() (XMLParser のメソッド) 
handle_connect() (dispatcher のメソッド) 
handle_data() (HTMLParser のメソッド) 
handle_data() (SGMLParser のメソッド) 
handle_data() (XMLParser のメソッド) 
handle_decl() (HTMLParser のメソッド) 
handle_decl() (SGMLParser のメソッド) 
handle_doctype() (XMLParser のメソッド) 
handle_endtag() (HTMLParser のメソッド) 
handle_endtag() (SGMLParser のメソッド) 
handle_endtag() (XMLParser のメソッド) 
handle_entityref() (HTMLParser のメソッド) 
handle_entityref() (SGMLParser のメソッド) 
handle_error() (dispatcher のメソッド) 
handle_expt() (dispatcher のメソッド) 
handle_image() (HTMLParser のメソッド) 
handle_one_request() (BaseHTTPRequestHandler のメソッド) 
handle_pi() (HTMLParser のメソッド) 
handle_proc() (XMLParser のメソッド) 
handle_read() (async_chat のメソッド) 
handle_read() (dispatcher のメソッド) 
handle_request() (SimpleXMLRPCRequestHandler のメソッド) 
handle_special() (XMLParser のメソッド) 
handle_startendtag() (HTMLParser のメソッド) 
handle_starttag() (HTMLParser のメソッド) 
handle_starttag() (SGMLParser のメソッド) 
handle_starttag() (XMLParser のメソッド) 
handle_write() (async_chat のメソッド) 
handle_write() (dispatcher のメソッド) 
handle_xml() (XMLParser のメソッド) 
handleError() (SocketHandler のメソッド),[Link] 
handleError() (Textbox のメソッド) 
handler() (cgitb モジュール) 
has_colors() (curses モジュール) 
has_data() (Request のメソッド) 
has_extn() (SMTP のメソッド) 
has_header() (Request のメソッド) 
has_header() (Sniffer のメソッド) 
has_ic() (curses モジュール) 
has_il() (curses モジュール) 
has_ipv6 (socket モジュール) 
has_key() (Message のメソッド) 
has_key() (Queue のメソッド) 
has_nonstandard_attr() (Cookie のメソッド) 
has_option() (SafeConfigParser のメソッド) 
has_section() (SafeConfigParser のメソッド) 
hasAttributes() (Node のメソッド) 
hasChildNodes() (Node のメソッド) 
hascompare (dis モジュール) 
hasconst (dis モジュール) 
hasFeature() (DOMImplementation のメソッド) 
hasfree (dis モジュール) 
hashopen() (bsddb モジュール) 
hasjabs (dis モジュール) 
hasjrel (dis モジュール) 
haslocal (dis モジュール) 
hasname (dis モジュール) 
have_unicode (test.test_support モジュール) 
head() (NNTPDataError のメソッド) 
header_encode() (Charset のメソッド) 
header_encoding (email.Charset モジュール) 
header_offset (ZipInfo の属性) 
headers (AddressList の属性) 
headers (BaseHTTPRequestHandler の属性) 
headers (ServerProxy の属性) 
heapify() (heapq モジュール) 
heapmin() (msvcrt モジュール) 
heappop() (heapq モジュール) 
heappush() (heapq モジュール) 
heapq (standard モジュール) 
heapreplace() (heapq モジュール) 
helo() (SMTP のメソッド) 
help() (NNTPDataError のメソッド) 
hexbin() (binhex モジュール) 
hexdigest() (hmac のメソッド) 
hexdigest() (md5 のメソッド) 
hexdigest() (sha のメソッド) 
hexdigits (string モジュール) 
hexlify() (binascii モジュール) 
hexversion (sys モジュール) 
hidden() (Textbox のメソッド) 
hide() (Textbox のメソッド) 
hide_cookie2 (LWPCookieJar の属性) 
hide_form() (form のメソッド) 
hide_object() (FORMS object のメソッド) 
HIGHEST_PROTOCOL (pickle モジュール) 
hline() (window のメソッド) 
hls_to_rgb() (colorsys モジュール) 
hmac (standard モジュール) 
HOME (環境変数),[Link] 
hosts (netrc の属性) 
hotshot (standard モジュール) 
hotshot.stats (standard モジュール) 
hour (datetime の属性) 
hour (time の属性) 
hsv_to_rgb() (colorsys モジュール) 
HtmlDiff (difflib のクラス) 
htmlentitydefs (standard モジュール) 
htmllib (standard モジュール) 
HTMLParser (standard モジュール) 
htonl() (socket モジュール) 
htons() (socket モジュール) 
http_error_301() (HTTPRedirectHandler のメソッド) 
http_error_302() (HTTPRedirectHandler のメソッド) 
http_error_303() (HTTPRedirectHandler のメソッド) 
http_error_307() (HTTPRedirectHandler のメソッド) 
http_error_401() (HTTPBasicAuthHandler のメソッド) 
http_error_401() (HTTPDigestAuthHandler のメソッド) 
http_error_407() (ProxyBasicAuthHandler のメソッド) 
http_error_407() (ProxyDigestAuthHandler のメソッド) 
http_error_\varnnn() (BaseHandler のメソッド) 
http_error_default() (BaseHandler のメソッド) 
http_open() (HTTPHandler のメソッド) 
HTTP_PORT (httplib モジュール) 
hypot() (math モジュール) 
I (re モジュール) 
ibufcount() (audio device のメソッド) 
id() (TestCase のメソッド) 
idcok() (window のメソッド) 
ident (cd モジュール) 
identchars (Cmd の属性) 
idlok() (window のメソッド) 
ifilter() (itertools モジュール) 
ifilterfalse() (itertools モジュール) 
ignorableWhitespace() (ContentHandler のメソッド) 
ignore() (Stats のメソッド) 
ignore_errors() (codecs モジュール) 
IGNORE_EXCEPTION_DETAIL (doctest モジュール) 
ignore_zeros (TarFile の属性) 
IGNORECASE (re モジュール) 
ihave() (NNTPDataError のメソッド) 
ihooks (標準 モジュール) IllegalKeywordArgument 
imageop (組み込み モジュール) 
imap() (itertools モジュール) 
imaplib (standard モジュール) 
imgfile (組み込み モジュール) 
imghdr (standard モジュール) 
immedok() (window のメソッド) 
imp (組み込み モジュール),[Link] 
in_table_a1() (stringprep モジュール) 
in_table_b1() (stringprep モジュール) 
in_table_c11() (stringprep モジュール) 
in_table_c11_c12() (stringprep モジュール) 
in_table_c12() (stringprep モジュール) 
in_table_c21() (stringprep モジュール) 
in_table_c21_c22() (stringprep モジュール) 
in_table_c22() (stringprep モジュール) 
in_table_c3() (stringprep モジュール) 
in_table_c4() (stringprep モジュール) 
in_table_c5() (stringprep モジュール) 
in_table_c6() (stringprep モジュール) 
in_table_c7() (stringprep モジュール) 
in_table_c8() (stringprep モジュール) 
in_table_c9() (stringprep モジュール) 
in_table_d1() (stringprep モジュール) 
in_table_d2() (stringprep モジュール) 
INADDR_* (socket モジュール) 
inch() (window のメソッド) 
indent (Example の属性) 
index() (array のメソッド) 
index (cd モジュール) 
index() (string のメソッド) 
index() (string モジュール) 
indexOf() (operator モジュール) 
inet_aton() (socket モジュール) 
inet_ntoa() (socket モジュール) 
inet_ntop() (socket モジュール) 
inet_pton() (socket モジュール) 
Inexact (decimal のクラス) 
infile (shlex の属性) 
info() (logging モジュール) 
info() (NullTranslations のメソッド) 
info() (Textbox のメソッド) 
infolist() (ZipFile のメソッド) 
init() (fm モジュール) 
init() (mimetypes モジュール) 
init_builtin() (imp モジュール) 
init_color() (curses モジュール) 
init_frozen() (imp モジュール) 
init_pair() (curses モジュール) 
inited (mimetypes モジュール) 
initial_indent (TextWrapper の属性) 
initscr() (curses モジュール) 
input() (fileinput モジュール) 
input() (組み込み関数) input_charset (email.Charset モジュール) 
InputType (cStringIO モジュール) 
insch() (window のメソッド) 
insdelln() (window のメソッド) 
insert() (array のメソッド) 
insert_text() (readline モジュール) 
insertBefore() (Node のメソッド) 
insertln() (window のメソッド) 
insnstr() (window のメソッド) 
insort() (bisect モジュール) 
insort_left() (bisect モジュール) 
insort_right() (bisect モジュール) 
inspect (standard モジュール) 
insstr() (window のメソッド) 
install() (gettext モジュール) 
install() (NullTranslations のメソッド) 
install_opener() (urllib2 モジュール) 
instance() (new モジュール) 
instancemethod() (new モジュール) 
InstanceType (types モジュール) 
instr() (window のメソッド) 
instream (shlex の属性) 
int() (built-in function) int() (組み込み関数) 
Int2AP() (imaplib モジュール) 
interact() (code モジュール) 
interact() (InteractiveConsole のメソッド) 
interact() (Telnet のメソッド) 
internal_attr (ZipInfo の属性) 
Internaldate2tuple() (imaplib モジュール) 
internalSubset (DocumentType の属性) 
interrupt_main() (thread モジュール) 
intro (Cmd の属性) 
IntType (types モジュール) 
inv() (operator モジュール) 
InvalidOperation (decimal のクラス) 
invert() (operator モジュール) 
ioctl() (fcntl モジュール) 
IP_* (socket モジュール) 
IPPORT_* (socket モジュール) 
IPPROTO_* (socket モジュール) 
IPV6_* (socket モジュール) 
is_() (operator モジュール) 
is_blocked() (DefaultCookiePolicy のメソッド) 
is_builtin() (imp モジュール) 
IS_CHARACTER_JUNK() (difflib モジュール) 
is_data() (MultiFile のメソッド) 
is_empty() (fifo のメソッド) 
is_expired() (Cookie のメソッド) 
is_frozen() (imp モジュール) 
is_jython (test.test_support モジュール) 
IS_LINE_JUNK() (difflib モジュール) 
is_linetouched() (window のメソッド) 
is_multipart() (Message のメソッド) 
is_not() (operator モジュール) 
is_not_allowed() (DefaultCookiePolicy のメソッド) 
is_resource_enabled() (test.test_support モジュール) 
is_tarfile() (tarfile モジュール) 
is_unverifiable() (Request のメソッド) 
is_wintouched() (window のメソッド) 
is_zipfile() (zipfile モジュール) 
isabs() (os.path モジュール) 
isAlive() (Thread のメソッド) 
isalnum() (curses.ascii モジュール) 
isalnum() (string のメソッド) 
isalpha() (curses.ascii モジュール) 
isalpha() (string のメソッド) 
isascii() (curses.ascii モジュール) 
isatty() (Chunk のメソッド) 
isatty() (file のメソッド) 
isatty() (os モジュール) 
isblank() (curses.ascii モジュール) 
isblk() (TarInfo のメソッド) 
isbuiltin() (inspect モジュール) 
isCallable() (operator モジュール) 
ischr() (TarInfo のメソッド) 
isclass() (inspect モジュール) 
iscntrl() (curses.ascii モジュール) 
iscode() (inspect モジュール) 
iscomment() (AddressList のメソッド) 
isctrl() (curses.ascii モジュール) 
isDaemon() (Thread のメソッド) 
isdatadescriptor() (inspect モジュール) 
isdev() (TarInfo のメソッド) 
isdigit() (curses.ascii モジュール) 
isdigit() (string のメソッド) 
isdir() (os.path モジュール) 
isdir() (TarInfo のメソッド) 
isenabled() (gc モジュール) 
isEnabledFor() (Textbox のメソッド) 
isendwin() (curses モジュール) 
ISEOF() (token モジュール) 
isexpr() (AST のメソッド) 
isexpr() (parser モジュール) 
isfifo() (TarInfo のメソッド) 
isfile() (os.path モジュール) 
isfile() (TarInfo のメソッド) 
isfirstline() (fileinput モジュール) 
isframe() (inspect モジュール) 
isfunction() (inspect モジュール) 
isgraph() (curses.ascii モジュール) 
isheader() (AddressList のメソッド) 
iskeyword() (keyword モジュール) 
islast() (AddressList のメソッド) 
isleap() (calendar モジュール) 
islice() (itertools モジュール) 
islink() (os.path モジュール) 
islnk() (TarInfo のメソッド) 
islower() (curses.ascii モジュール) 
islower() (string のメソッド) 
isMappingType() (operator モジュール) 
ismeta() (curses.ascii モジュール) 
ismethod() (inspect モジュール) 
ismethoddescriptor() (inspect モジュール) 
ismodule() (inspect モジュール) 
ismount() (os.path モジュール) 
ISNONTERMINAL() (token モジュール) 
isNumberType() (operator モジュール) 
isocalendar() (date のメソッド) 
isocalendar() (datetime のメソッド) 
isoformat() (date のメソッド) 
isoformat() (datetime のメソッド) 
isoformat() (time のメソッド) 
isoweekday() (date のメソッド) 
isoweekday() (datetime のメソッド) 
isprint() (curses.ascii モジュール) 
ispunct() (curses.ascii モジュール) 
isqueued() (fl モジュール) 
isreadable() (pprint モジュール) 
isreadable() (PrettyPrinter のメソッド) 
isrecursive() (pprint モジュール) 
isrecursive() (PrettyPrinter のメソッド) 
isreg() (TarInfo のメソッド) 
isReservedKey() (Morsel のメソッド) 
isroutine() (inspect モジュール) 
isSameNode() (Node のメソッド) 
isSequenceType() (operator モジュール) 
isSet() (Event のメソッド) 
isspace() (curses.ascii モジュール) 
isspace() (string のメソッド) 
isstdin() (fileinput モジュール) 
issuite() (AST のメソッド) 
issuite() (parser モジュール) 
issym() (TarInfo のメソッド) 
ISTERMINAL() (token モジュール) 
istitle() (string のメソッド) 
istraceback() (inspect モジュール) 
isupper() (curses.ascii モジュール) 
isupper() (string のメソッド) 
isxdigit() (curses.ascii モジュール) 
item() (NamedNodeMap のメソッド) 
item() (NodeList のメソッド) 
itemgetter() (operator モジュール) 
items() (Message のメソッド) 
items() (SafeConfigParser のメソッド),[Link] 
itemsize (array の属性) 
itertools (standard モジュール) 
izip() (itertools モジュール) 
java_ver() (platform モジュール) 
join() (os.path モジュール) 
join() (string のメソッド) 
join() (string モジュール) 
join() (Thread のメソッド) 
joinfields() (string モジュール) 
jpeg (組み込み モジュール) 
js_output() (BaseCookie のメソッド) 
js_output() (Morsel のメソッド) 
jumpahead() (random モジュール) 
kbhit() (msvcrt モジュール) 
KDEDIR (環境変数) 
key (Morsel の属性) 
keyname() (curses モジュール) 
keypad() (window のメソッド) 
keys() (Message のメソッド) 
keys() (Queue のメソッド) 
keyword (standard モジュール) 
kill() (os モジュール) 
killchar() (curses モジュール) 
killpg() (os モジュール) 
knee ( モジュール) 
knownfiles (mimetypes モジュール) 
kwlist (keyword モジュール) 
LambdaType (types モジュール) 
LANG (環境変数),[Link],[Link],[Link],[Link] 
LANGUAGE (環境変数),[Link] 
last() (dbhash のメソッド) 
last (MultiFile の属性) 
last() (NNTPDataError のメソッド) 
last() (Queue のメソッド) 
last_traceback (sys モジュール) 
last_type (sys モジュール) 
last_value (sys モジュール) 
lastChild (Node の属性) 
lastcmd (Cmd の属性) 
lastgroup (MatchObject の属性) 
lastindex (MatchObject の属性) 
lastpart() (MimeWriter のメソッド) 
LC_ALL (locale モジュール) LC_ALL (環境変数),[Link] 
LC_COLLATE (locale モジュール) 
LC_CTYPE (locale モジュール) 
LC_MESSAGES (locale モジュール) 
LC_MESSAGES (環境変数),[Link] 
LC_MONETARY (locale モジュール) 
LC_NUMERIC (locale モジュール) 
ldexp() (math モジュール) 
ldgettext() (gettext モジュール) 
ldngettext() (gettext モジュール) 
le() (operator モジュール) 
leapdays() (calendar モジュール) 
leaveok() (window のメソッド) 
left() (turtle モジュール) 
left_list (dircmp の属性) 
left_only (dircmp の属性) 
len() (built-in function) len() (組み込み関数),[Link] 
length (NamedNodeMap の属性) 
length (NodeList の属性) 
letters (string モジュール) 
level (MultiFile の属性) 
lgettext() (gettext モジュール) 
lgettext() (NullTranslations のメソッド) 
libc_ver() (platform モジュール) 
library (dbm モジュール) 
lin2adpcm() (audioop モジュール) 
lin2adpcm3() (audioop モジュール) 
lin2lin() (audioop モジュール) 
lin2ulaw() (audioop モジュール) 
linecache (standard モジュール) 
lineno (class descriptor の属性) 
lineno (DocTest の属性) 
lineno (Example の属性) 
lineno (ExpatError の属性) 
lineno (shlex の属性) 
LINES (環境変数),[Link] 
linesep (os モジュール) 
lineterminator (Dialect の属性) 
link() (os モジュール) 
linkname (TarInfo の属性) 
list() (IMAP4_stream のメソッド) 
list() (NNTPDataError のメソッド) 
list() (POP3_SSL のメソッド) 
list() (TarFile のメソッド) 
list_dialects() (csv モジュール) 
listallfolders() (MH のメソッド) 
listallsubfolders() (MH のメソッド) 
listdir() (dircache モジュール) 
listdir() (os モジュール) 
listen() (dispatcher のメソッド) 
listen() (logging モジュール) 
listen() (socket のメソッド) 
listfolders() (MH のメソッド) 
listmessages() (Folder のメソッド) 
listsubfolders() (MH のメソッド) 
ListType (types モジュール) 
ljust() (string のメソッド) 
ljust() (string モジュール) 
LK_LOCK (msvcrt モジュール) 
LK_NBLCK (msvcrt モジュール) 
LK_NBRLCK (msvcrt モジュール) 
LK_RLCK (msvcrt モジュール) 
LK_UNLCK (msvcrt モジュール) 
LNAME (環境変数) 
lngettext() (gettext モジュール) 
lngettext() (NullTranslations のメソッド) 
load() (BaseCookie のメソッド) 
load() (FileCookieJar のメソッド) 
load() (hotshot.stats モジュール) 
load() (marshal モジュール) 
load() (pickle モジュール) 
load() (Unpickler のメソッド) 
load_compiled() (imp モジュール) 
load_dynamic() (imp モジュール) 
load_module() (imp モジュール) 
load_source() (imp モジュール) 
loads() (marshal モジュール) 
loads() (pickle モジュール) 
loads() (xmlrpclib モジュール) 
loadTestsFromModule() (TestLoader のメソッド) 
loadTestsFromName() (TestLoader のメソッド) 
loadTestsFromNames() (TestLoader のメソッド) 
loadTestsFromTestCase() (TestLoader のメソッド) 
local (threading のクラス) 
LOCALE (re モジュール) 
locale (standard モジュール) 
localeconv() (locale モジュール) 
localName (Attr の属性) 
localName (Node の属性) 
lock() (mutex のメソッド) 
Lock() (threading モジュール) lock_held() (imp モジュール) 
locked() (lock のメソッド) 
lockf() (fcntl モジュール) lockf() (in module fcntl) 
locking() (msvcrt モジュール) 
LockType (thread モジュール) 
log() (logging モジュール) 
log() (math モジュール) 
log() (Textbox のメソッド) 
log10() (cmath モジュール) 
log10() (math モジュール) 
log\optional, base() (cmath モジュール) log_data_time_string() (BaseHTTPRequestHandler のメソッド) 
log_error() (BaseHTTPRequestHandler のメソッド) 
log_message() (BaseHTTPRequestHandler のメソッド) 
log_request() (BaseHTTPRequestHandler のメソッド) 
logging (standard モジュール) 
login() (FTP のメソッド) 
login() (IMAP4_stream のメソッド) 
login() (SMTP のメソッド) 
login_cram_md5() (IMAP4_stream のメソッド) 
LOGNAME (環境変数),[Link] 
lognormvariate() (random モジュール) 
logout() (IMAP4_stream のメソッド) 
long() (built-in function) long() (組み込み関数),[Link] 
longimagedata() (rgbimg モジュール) 
longname() (curses モジュール) 
longstoimage() (rgbimg モジュール) 
LongType (types モジュール) 
lookup() (codecs モジュール) 
lookup() (unicodedata モジュール) 
lookup_error() (codecs モジュール) 
loop() (asyncore モジュール) 
lower() (string のメソッド) 
lower() (string モジュール) 
lowercase (string モジュール) 
lseek() (os モジュール) 
lshift() (operator モジュール) 
lstat() (os モジュール) 
lstrip() (string のメソッド) 
lstrip() (string モジュール) 
lsub() (IMAP4_stream のメソッド) 
lt() (operator モジュール) 
M (re モジュール) 
mac_ver() (platform モジュール) 
machine() (platform モジュール) 
macros (netrc の属性) 
mailbox (standard モジュール) 
main() (py_compile モジュール) 
main() (unittest モジュール) 
major() (os モジュール) 
make_cookies() (CookieJar のメソッド) 
make_file() (difflib モジュール) 
make_form() (fl モジュール) 
make_header() (email.Header モジュール) 
make_msgid() (email.Utils モジュール) 
make_parser() (xml.sax モジュール) 
make_table() (difflib モジュール) 
makedev() (os モジュール) 
makedirs() (os モジュール) 
makefile() (socket のメソッド) 
makefolder() (MH のメソッド) 
makeLogRecord() (logging モジュール),[Link] 
makePickle() (SocketHandler のメソッド) 
makeRecord() (Textbox のメソッド) 
makeSocket() (DatagramHandler のメソッド) 
makeSocket() (SocketHandler のメソッド) 
maketrans() (string モジュール) 
map_table_b2() (stringprep モジュール) 
map_table_b3() (stringprep モジュール) 
mapcolor() (fl モジュール) 
maps() (nis モジュール) 
marshal (組み込み モジュール) 
match() (nis モジュール) 
match() (re モジュール) 
match() (RegexObject のメソッド) 
math (組み込み モジュール),[Link],[Link] max() (audioop モジュール) 
max() (Context のメソッド) 
max (date の属性) 
max (datetime の属性) 
max() (Decimal のメソッド) 
max (time の属性) 
max (timedelta の属性) 
max() (組み込み関数) MAX_INTERPOLATION_DEPTH (ConfigParser モジュール) 
maxarray (Repr の属性) 
maxdeque (Repr の属性) 
maxdict (Repr の属性) 
maxfrozenset (Repr の属性) 
maxint (sys モジュール) 
MAXLEN (mimify モジュール) 
maxlevel (Repr の属性) 
maxlist (Repr の属性) 
maxlong (Repr の属性) 
maxother (Repr の属性) 
maxpp() (audioop モジュール) 
maxset (Repr の属性) 
maxstring (Repr の属性) 
maxtuple (Repr の属性) 
maxunicode (sys モジュール) 
MAXYEAR (datetime モジュール) 
MB_ICONASTERISK (winsound モジュール) 
MB_ICONEXCLAMATION (winsound モジュール) 
MB_ICONHAND (winsound モジュール) 
MB_ICONQUESTION (winsound モジュール) 
MB_OK (winsound モジュール) 
md5() (md5 モジュール) 
md5 (組み込み モジュール) 
message_from_file() (email.Parser モジュール) 
MessageBeep() (winsound モジュール) 
MessageClass (BaseHTTPRequestHandler の属性) 
methods (class descriptor の属性) 
MethodType (types モジュール) 
microsecond (datetime の属性) 
microsecond (time の属性) 
mime_decode_header() (mimify モジュール) 
mime_encode_header() (mimify モジュール) 
mimetypes (standard モジュール) 
MimeWriter (standard モジュール) 
mimify() (mimify モジュール) 
mimify (standard モジュール) 
min() (Context のメソッド) 
min (date の属性) 
min (datetime の属性) 
min() (Decimal のメソッド) 
min (time の属性) 
min (timedelta の属性) 
min() (組み込み関数) minmax() (audioop モジュール) 
minor() (os モジュール) 
minus() (Context のメソッド) 
minute (datetime の属性) 
minute (time の属性) 
MINYEAR (datetime モジュール) 
mirrored() (unicodedata モジュール) 
misc_header (Cmd の属性) 
mkd() (FTP のメソッド) 
mkdir() (os モジュール) 
mkdtemp() (tempfile モジュール),[Link] 
mkfifo() (os モジュール) 
mknod() (os モジュール) 
mkstemp() (tempfile モジュール) 
mktime() (time モジュール) 
mktime_tz() (email.Utils モジュール) 
mktime_tz() (rfc822 モジュール) 
mmap() (mmap モジュール) 
mmap (組み込み モジュール) 
mod() (operator モジュール) 
mode (file の属性) 
mode (TarInfo の属性) 
modf() (math モジュール) 
modified() (RobotFileParser のメソッド) 
module (class descriptor の属性) 
module (function descriptor の属性) 
module() (new モジュール) 
modules (sys モジュール) 
ModuleType (types モジュール) 
MON_1 ... MON_12 (locale モジュール) 
mono2grey() (imageop モジュール) month() (calendar モジュール) 
month (date の属性) 
month (datetime の属性) 
monthcalendar() (calendar モジュール) 
monthrange() (calendar モジュール) 
more() (simple_producer のメソッド) 
mouseinterval() (curses モジュール) 
mousemask() (curses モジュール) 
move() (Textbox のメソッド) 
move() (window のメソッド) 
movemessage() (Folder のメソッド) 
msftoblock() (CD player のメソッド) 
msftoframe() (cd モジュール) 
msg (httplib モジュール) 
msg() (Telnet のメソッド) 
MSG_* (socket モジュール) 
msvcrt (組み込み モジュール) 
mt_interact() (Telnet のメソッド) 
mtime() (RobotFileParser のメソッド) 
mtime (TarInfo の属性) 
mul() (audioop モジュール) 
multifile (standard モジュール) 
MULTILINE (re モジュール) 
multiply() (Context のメソッド) 
mvderwin() (window のメソッド) 
mvwin() (window のメソッド) 
myrights() (IMAP4_stream のメソッド) 
name (Attr の属性) 
name (class descriptor の属性) 
name (Cookie の属性) 
name (DocTest の属性) 
name (DocumentType の属性) 
name (file の属性) 
name (function descriptor の属性) 
name (os モジュール) 
name2codepoint (htmlentitydefs モジュール) 
NamedTemporaryFile() (tempfile モジュール) 
namelist() (ZipFile のメソッド) 
nameprep() (encodings.idna モジュール) 
namespace() (IMAP4_stream のメソッド) 
namespaceURI (Node の属性) 
napms() (curses モジュール) 
ndiff() (difflib モジュール) 
ne() (operator モジュール) 
neg() (operator モジュール) 
netrc (standard モジュール) 
netscape (LWPCookieJar の属性) 
new() (hmac モジュール) 
new() (md5 モジュール) 
new() (sha モジュール) 
new (組み込み モジュール) 
new_alignment() (writer のメソッド) 
new_font() (writer のメソッド) 
new_margin() (writer のメソッド) 
new_module() (imp モジュール) 
new_panel() (curses.panel モジュール) 
new_spacing() (writer のメソッド) 
new_styles() (writer のメソッド) 
newconfig() (al モジュール) 
newgroups() (NNTPDataError のメソッド) 
newlines (file の属性) 
newnews() (NNTPDataError のメソッド) 
newpad() (curses モジュール) 
newwin() (curses モジュール) 
next() (csv reader のメソッド) 
next() (dbhash のメソッド) 
next() (file のメソッド) 
next() (iterator のメソッド) 
next() (mailbox のメソッド) 
next() (MultiFile のメソッド) 
next() (NNTPDataError のメソッド) 
next() (Queue のメソッド) 
next() (TarFile のメソッド) 
nextfile() (fileinput モジュール) 
nextkey() (gdbm モジュール) 
nextpart() (MimeWriter のメソッド) 
nextSibling (Node の属性) 
ngettext() (NullTranslations のメソッド) 
NI_* (socket モジュール) 
nice() (os モジュール) 
nis (extension モジュール) 
nl() (curses モジュール) 
NL (tokenize モジュール) 
nl_langinfo() (locale モジュール) 
nlargest() (heapq モジュール) 
nlst() (FTP のメソッド) 
node() (platform モジュール) 
nodelay() (window のメソッド) 
nodeName (Node の属性) 
nodeType (Node の属性) 
nodeValue (Node の属性) 
NODISC (cd モジュール) 
noecho() (curses モジュール) 
NOEXPR (locale モジュール) 
nofill (HTMLParser の属性) 
nok_builtin_names (RExec の属性) 
noload() (Unpickler のメソッド) 
nonblock() (audio device のメソッド) 
NoneType (types モジュール) 
nonl() (curses モジュール) 
noop() (IMAP4_stream のメソッド) 
noop() (POP3_SSL のメソッド) 
noqiflush() (curses モジュール) 
noraw() (curses モジュール) 
normalize() (Context のメソッド) 
normalize() (Decimal のメソッド) 
normalize() (locale モジュール) 
NORMALIZE_WHITESPACE (doctest モジュール) 
normalvariate() (random モジュール) 
normcase() (os.path モジュール) 
normpath() (os.path モジュール) 
not_() (operator モジュール) 
notationDecl() (DTDHandler のメソッド) 
NotationDeclHandler() (xmlparser のメソッド) 
notations (DocumentType の属性) 
notify() (Condition のメソッド) 
notifyAll() (Condition のメソッド) 
notimeout() (window のメソッド) 
NotStandaloneHandler() (xmlparser のメソッド) 
noutrefresh() (window のメソッド) 
now() (datetime のメソッド) 
NSIG (signal モジュール) 
nsmallest() (heapq モジュール) 
ntohl() (socket モジュール) 
ntohs() (socket モジュール) 
numeric() (unicodedata モジュール) 
nurbscurve() (gl モジュール) 
nurbssurface() (gl モジュール) 
nvarray() (gl モジュール) 
O_APPEND (os モジュール) 
O_BINARY (os モジュール) 
O_CREAT (os モジュール) 
O_DSYNC (os モジュール) 
O_EXCL (os モジュール) 
O_NDELAY (os モジュール) 
O_NOCTTY (os モジュール) 
O_NONBLOCK (os モジュール) 
O_RDONLY (os モジュール) 
O_RDWR (os モジュール) 
O_RSYNC (os モジュール) 
O_SYNC (os モジュール) 
O_TRUNC (os モジュール) 
O_WRONLY (os モジュール) 
obufcount() (audio device のメソッド),[Link] 
obuffree() (audio device のメソッド) 
octdigits (string モジュール) 
offset (ExpatError の属性) 
OK (curses モジュール) 
ok_builtin_modules (RExec の属性) 
ok_file_types (RExec の属性) 
ok_path (RExec の属性) 
ok_posix_names (RExec の属性) 
ok_sys_names (RExec の属性) 
onecmd() (Cmd のメソッド) 
open() (aifc モジュール) 
open() (anydbm モジュール) 
open() (cd モジュール) 
open() (codecs モジュール) 
open() (dbhash モジュール) 
open() (dbm モジュール) 
open() (dl モジュール) 
open() (dumbdbm モジュール) 
open() (gdbm モジュール) 
open() (os モジュール) 
open() (ossaudiodev モジュール) 
open() (posixfile モジュール) 
open() (shelve モジュール) 
open() (sunau モジュール) 
open() (sunaudiodev モジュール) 
open() (tarfile モジュール) 
open() (Telnet のメソッド) 
open() (Template のメソッド) 
open() (URLopener のメソッド) 
open_osfhandle() (msvcrt モジュール) 
open_unknown() (URLopener のメソッド) 
opendir() (dircache モジュール) 
openfolder() (MH のメソッド) 
openfp() (sunau モジュール) 
openfp() (wave モジュール) 
OpenKey() (_winreg モジュール) 
OpenKeyEx() (_winreg モジュール) 
openlog() (syslog モジュール) 
openmessage() (Message のメソッド) 
openmixer() (ossaudiodev モジュール) 
openport() (al モジュール) 
openpty() (os モジュール) 
openpty() (pty モジュール) 
operator (組み込み モジュール) 
opname (dis モジュール) 
options (Example の属性) 
options() (SafeConfigParser のメソッド) 
optionxform() (SafeConfigParser のメソッド) 
optparse (standard モジュール) 
or_() (operator モジュール) 
ordered_attributes (xmlparser の属性) 
os (standard モジュール) os (標準 モジュール),[Link] 
os.path (standard モジュール) 
ossaudiodev (組み込み モジュール) 
output() (BaseCookie のメソッド) 
output() (Morsel のメソッド) 
output_charset (email.Charset モジュール) 
output_charset() (NullTranslations のメソッド) 
output_codec (email.Charset モジュール) 
output_difference() (OutputChecker のメソッド) 
OutputString() (Morsel のメソッド) 
OutputType (cStringIO モジュール) 
Overflow (decimal のクラス) 
overlay() (window のメソッド) 
overwrite() (window のメソッド) 
P_DETACH (os モジュール) 
P_NOWAIT (os モジュール) 
P_NOWAITO (os モジュール) 
P_OVERLAY (os モジュール) 
P_WAIT (os モジュール) 
pack() (struct モジュール) 
pack_array() (Packer のメソッド) 
pack_bytes() (Packer のメソッド) 
pack_double() (Packer のメソッド) 
pack_farray() (Packer のメソッド) 
pack_float() (Packer のメソッド) 
pack_fopaque() (Packer のメソッド) 
pack_fstring() (Packer のメソッド) 
pack_list() (Packer のメソッド) 
pack_opaque() (Packer のメソッド) 
pack_string() (Packer のメソッド) 
PAGER (環境変数) 
pair_content() (curses モジュール) 
pair_number() (curses モジュール) 
pardir (os モジュール) 
parent (BaseHandler の属性) 
parentNode (Node の属性) 
paretovariate() (random モジュール) 
parse() (cgi モジュール) 
parse() (compiler モジュール) 
parse() (DocTestParser のメソッド) parse() (Parser のメソッド) 
parse() (RobotFileParser のメソッド) 
parse() (xml.dom.minidom モジュール) 
parse() (xml.dom.pulldom モジュール) 
parse() (xml.sax モジュール) 
Parse() (xmlparser のメソッド) 
parse() (XMLReader のメソッド) 
parse_and_bind() (readline モジュール) 
parse_header() (cgi モジュール) 
parse_multipart() (cgi モジュール) 
parse_qs() (cgi モジュール) 
parse_qsl() (cgi モジュール) 
parseaddr() (email.Utils モジュール) 
parseaddr() (rfc822 モジュール) 
parsedate() (email.Utils モジュール) 
parsedate() (rfc822 モジュール) 
parsedate_tz() (email.Utils モジュール) 
parsedate_tz() (rfc822 モジュール) 
parseFile() (compiler モジュール) 
ParseFile() (xmlparser のメソッド) 
ParseFlags() (imaplib モジュール) 
parseframe() (CD parser のメソッド) 
parser (組み込み モジュール) 
ParserCreate() (xml.parsers.expat モジュール) 
parsesequence() (Folder のメソッド) 
parsestr() (Parser のメソッド) 
parseString() (xml.dom.minidom モジュール) 
parseString() (xml.dom.pulldom モジュール) 
parseString() (xml.sax モジュール) 
partial() (IMAP4_stream のメソッド) 
pass_() (POP3_SSL のメソッド) 
path (BaseHTTPRequestHandler の属性) 
path (Cookie の属性) 
path (os モジュール) 
path (sys モジュール) 
PATH (環境変数),[Link],[Link],[Link],[Link],[Link],[Link],[Link],[Link] 
path_return_ok() (CookiePolicy のメソッド) 
pathconf() (os モジュール) 
pathconf_names (os モジュール) 
pathname2url() (urllib モジュール) 
pathsep (os モジュール) 
pattern (RegexObject の属性) 
pause() (signal モジュール) 
PAUSED (cd モジュール) 
pdb (standard モジュール) 
pformat() (pprint モジュール) 
pformat() (PrettyPrinter のメソッド) 
pi (cmath モジュール) 
pi (math モジュール) 
pick() (gl モジュール) 
pickle() (copy_reg モジュール) 
pickle (standard モジュール) pickle (標準 モジュール),[Link],[Link],[Link],[Link] 
pid (Popen の属性) 
pid (Popen4 の属性) 
pipe() (os モジュール) 
pipes (standard モジュール) 
PKG_DIRECTORY (imp モジュール) 
pkgutil (standard モジュール) 
platform() (platform モジュール) 
platform (standard モジュール) 
platform (sys モジュール) 
play() (CD player のメソッド) 
playabs() (CD player のメソッド) 
PLAYING (cd モジュール) 
PlaySound() (winsound モジュール) 
playtrack() (CD player のメソッド) 
playtrackabs() (CD player のメソッド) 
plock() (os モジュール) 
plus() (Context のメソッド) 
pm() (pdb モジュール) 
pnum (cd モジュール) 
poll() (LogRecord のメソッド) 
poll() (Popen のメソッド) 
poll() (Popen4 のメソッド) 
poll() (select モジュール) 
pop() (array のメソッド) 
pop() (fifo のメソッド) 
pop() (MultiFile のメソッド) 
pop() (SystemRandom のメソッド) 
pop_font() (formatter のメソッド) 
pop_margin() (formatter のメソッド) 
pop_source() (shlex のメソッド) 
pop_style() (formatter のメソッド) 
popen() (os モジュール) 
popen() (platform モジュール) 
popen2() (os モジュール) 
popen2() (popen2 モジュール) 
popen2 (standard モジュール) 
popen3() (os モジュール) 
popen3() (popen2 モジュール) 
popen4() (os モジュール) 
popen4() (popen2 モジュール) 
popleft() (SystemRandom のメソッド) 
poplib (standard モジュール) 
port (Cookie の属性) 
port_specified (Cookie の属性) 
posix (TarFile の属性) 
posix (組み込み モジュール) 
posixfile (組み込み モジュール) 
post() (audio device のメソッド) 
post() (NNTPDataError のメソッド) 
post_mortem() (pdb モジュール) 
postcmd() (Cmd のメソッド) 
postloop() (Cmd のメソッド) 
pow() (math モジュール) 
pow() (operator モジュール) 
power() (Context のメソッド) 
pprint() (pprint モジュール) 
pprint() (PrettyPrinter のメソッド) 
pprint (standard モジュール) 
prcal() (calendar モジュール) 
preamble (email.Message モジュール) 
precmd() (Cmd のメソッド) 
prefix (Attr の属性) 
preloop() (Cmd のメソッド) 
preorder() (ASTVisitor のメソッド) 
prepare_input_source() (xml.sax.saxutils モジュール) 
prepend() (Template のメソッド) 
preventremoval() (CD player のメソッド) 
previous() (dbhash のメソッド) 
previous() (Queue のメソッド) 
previousSibling (Node の属性) 
print_callees() (Stats のメソッド) 
print_callers() (Stats のメソッド) 
print_directory() (cgi モジュール) 
print_environ() (cgi モジュール) 
print_environ_usage() (cgi モジュール) 
print_exception() (traceback モジュール) 
print_form() (cgi モジュール) 
print_last() (traceback モジュール) 
print_stack() (traceback モジュール) 
print_stats() (Stats のメソッド) 
print_tb() (traceback モジュール) 
printable (string モジュール) 
printdir() (ZipFile のメソッド) 
prmonth() (calendar モジュール) 
process_message() (SMTPServer のメソッド) 
processingInstruction() (ContentHandler のメソッド) 
ProcessingInstructionHandler() (xmlparser のメソッド) 
processor() (platform モジュール) 
profile (standard モジュール) 
prompt (Cmd の属性) 
prompt_user_passwd() (FancyURLopener のメソッド) 
propagate (logging モジュール) 
property_declaration_handler (xml.sax.handler モジュール) 
property_dom_node (xml.sax.handler モジュール) 
property_lexical_handler (xml.sax.handler モジュール) 
property_xml_string (xml.sax.handler モジュール) 
protocol_version (BaseHTTPRequestHandler の属性) 
PROTOCOL_VERSION (IMAP4_stream の属性) 
proxy() (weakref モジュール) 
ProxyType (weakref モジュール) 
ProxyTypes (weakref モジュール) 
prstr() (fm モジュール) 
ps1 (sys モジュール) 
ps2 (sys モジュール) 
pstats (標準 モジュール) 
ptime (cd モジュール) 
pty (standard モジュール) 
punctuation (string モジュール) 
push() (async_chat のメソッド) 
push() (fifo のメソッド) 
push() (InteractiveConsole のメソッド) 
push() (MultiFile のメソッド) 
push_alignment() (formatter のメソッド) 
push_font() (formatter のメソッド) 
push_margin() (formatter のメソッド) 
push_source() (shlex のメソッド) 
push_style() (formatter のメソッド) 
push_token() (shlex のメソッド) 
push_with_producer() (async_chat のメソッド) 
put() (Queue のメソッド) 
put_nowait() (Queue のメソッド) 
putch() (msvcrt モジュール) 
putenv() (os モジュール) 
putheader() (HTTPSConnection のメソッド) 
putp() (curses モジュール) 
putrequest() (HTTPSConnection のメソッド) 
putsequences() (Folder のメソッド) 
putwin() (window のメソッド) 
pwlcurve() (gl モジュール) 
py_compile (standard モジュール) 
PY_COMPILED (imp モジュール) 
PY_FROZEN (imp モジュール) 
PY_RESOURCE (imp モジュール) 
PY_SOURCE (imp モジュール) 
pyclbr (standard モジュール) 
pydoc (standard モジュール) 
pyexpat (組み込み モジュール) 
python_build() (platform モジュール) 
python_compiler() (platform モジュール) 
PYTHON_DOM (環境変数) 
python_version() (platform モジュール) 
python_version_tuple() (platform モジュール) 
PYTHONDOCS (環境変数) 
PYTHONPATH (環境変数),[Link],[Link],[Link] 
PYTHONSTARTUP (環境変数),[Link],[Link] 
PYTHONY2K (環境変数),[Link],[Link] 
PyZipFile (zipfile のクラス) 
qdevice() (fl モジュール) 
qenter() (fl モジュール) 
qiflush() (curses モジュール) 
qread() (fl モジュール) 
qreset() (fl モジュール) 
qsize() (Queue のメソッド) 
qtest() (fl モジュール) 
quantize() (Context のメソッド) 
quantize() (Decimal のメソッド) 
QueryInfoKey() (_winreg モジュール) 
queryparams() (al モジュール) 
QueryValue() (_winreg モジュール) 
QueryValueEx() (_winreg モジュール) 
Queue (standard モジュール) 
quick_ratio() (SequenceMatcher のメソッド) 
quit() (FTP のメソッド) 
quit() (NNTPDataError のメソッド) 
quit() (POP3_SSL のメソッド) 
quit() (SMTP のメソッド) 
quopri (standard モジュール) 
quote() (email.Utils モジュール) 
quote() (rfc822 モジュール) 
quote() (urllib モジュール) 
QUOTE_ALL (csv モジュール) 
QUOTE_MINIMAL (csv モジュール) 
QUOTE_NONE (csv モジュール) 
QUOTE_NONNUMERIC (csv モジュール) 
quote_plus() (urllib モジュール) 
quoteattr() (xml.sax.saxutils モジュール) 
quotechar (Dialect の属性) 
quotes (shlex の属性) 
quoting (Dialect の属性) 
r_eval() (RExec のメソッド) 
r_exec() (RExec のメソッド) 
r_execfile() (RExec のメソッド) 
r_import() (RExec のメソッド) 
R_OK (os モジュール) 
r_open() (RExec のメソッド) 
r_reload() (RExec のメソッド) 
r_unload() (RExec のメソッド) 
radians() (math モジュール) 
radians() (turtle モジュール) 
RADIXCHAR (locale モジュール) 
randint() (random モジュール) 
randint() (whrandom モジュール) 
random() (random モジュール) 
random (standard モジュール) 
random() (whrandom モジュール) 
randrange() (random モジュール) 
ratecv() (audioop モジュール) 
ratio() (SequenceMatcher のメソッド) 
raw() (curses モジュール) 
raw_input() (InteractiveConsole のメソッド) 
raw_input() (組み込み関数) 
re (MatchObject の属性) 
re (standard モジュール) re (標準 モジュール),[Link],[Link] 
read() (array のメソッド) 
read() (audio device のメソッド),[Link] 
read() (BZ2File のメソッド) 
read() (Chunk のメソッド) 
read() (file のメソッド) 
read() (HTTPSConnection のメソッド) 
read() (IMAP4_stream のメソッド) 
read() (imgfile モジュール) 
read() (LogRecord のメソッド) 
read() (MimeTypes のメソッド) 
read() (MultiFile のメソッド) read() (os モジュール) 
read() (Queue のメソッド) 
read() (RobotFileParser のメソッド) 
read() (SafeConfigParser のメソッド) 
read() (StreamReader のメソッド) 
read() (ZipFile のメソッド) 
read_all() (Telnet のメソッド) 
read_byte() (Queue のメソッド) 
read_eager() (Telnet のメソッド) 
read_history_file() (readline モジュール) 
read_init_file() (readline モジュール) 
read_lazy() (Telnet のメソッド) 
read_mime_types() (mimetypes モジュール) 
read_sb_data() (Telnet のメソッド) 
read_some() (Telnet のメソッド) 
read_token() (shlex のメソッド) 
read_until() (Telnet のメソッド) 
read_very_eager() (Telnet のメソッド) 
read_very_lazy() (Telnet のメソッド) 
readable() (async_chat のメソッド) 
readable() (dispatcher のメソッド) 
readda() (CD player のメソッド) 
reader() (csv モジュール) 
readfp() (MimeTypes のメソッド) 
readfp() (SafeConfigParser のメソッド) 
readframes() (aifc のメソッド) 
readframes() (AU_read のメソッド) 
readframes() (Wave_read のメソッド) 
readline() (BZ2File のメソッド) 
readline() (file のメソッド) 
readline() (IMAP4_stream のメソッド) 
readline() (MultiFile のメソッド) 
readline() (Queue のメソッド) 
readline() (StreamReader のメソッド) 
readline (組み込み モジュール) readlines() (BZ2File のメソッド) 
readlines() (file のメソッド) 
readlines() (MultiFile のメソッド) 
readlines() (StreamReader のメソッド) 
readlink() (os モジュール) 
readmodule() (pyclbr モジュール) 
readmodule_ex() (pyclbr モジュール) 
readsamps() (audio port のメソッド) 
readscaled() (imgfile モジュール) 
READY (cd モジュール) 
real_quick_ratio() (SequenceMatcher のメソッド) 
realpath() (os.path モジュール) 
reason (httplib モジュール) 
reccontrols() (mixer device のメソッド) 
recent() (IMAP4_stream のメソッド) 
rectangle() (curses.textpad モジュール) 
recv() (dispatcher のメソッド) 
recv() (socket のメソッド) 
recvfrom() (socket のメソッド) 
redirect redirect_request() (HTTPRedirectHandler のメソッド) 
redisplay() (readline モジュール) 
redraw_form() (form のメソッド) 
redraw_object() (FORMS object のメソッド) 
redrawln() (window のメソッド) 
redrawwin() (window のメソッド) 
ReferenceType (weakref モジュール) 
refilemessages() (Folder のメソッド) 
refill_buffer() (async_chat のメソッド) 
refresh() (window のメソッド) 
register() (atexit モジュール) 
register() (codecs モジュール) 
register_dialect() (csv モジュール) 
register_error() (codecs モジュール) 
register_function() (SimpleXMLRPCRequestHandler のメソッド) 
register_function() (SimpleXMLRPCServer のメソッド) 
register_instance() (SimpleXMLRPCRequestHandler のメソッド) 
register_instance() (SimpleXMLRPCServer のメソッド) 
register_introspection_functions() (SimpleXMLRPCRequestHandler のメソッド),[Link] 
register_multicall_functions() (SimpleXMLRPCRequestHandler のメソッド),[Link] 
register_optionflag() (doctest モジュール) 
registerDOMImplementation() (xml.dom モジュール) 
RegLoadKey() (_winreg モジュール) 
release() (Condition のメソッド) 
release() (Semaphore のメソッド) 
release() (Textbox のメソッド) 
release() (Timer のメソッド),[Link] 
release_lock() (imp モジュール) 
reload() (built-in function) reload() (組み込み関数),[Link],[Link] 
remainder() (Context のメソッド) 
remainder_near() (Context のメソッド) 
remainder_near() (Decimal のメソッド) 
remove() (array のメソッド) 
remove_history_item() (readline モジュール) 
remove_option() (SafeConfigParser のメソッド) 
remove_section() (SafeConfigParser のメソッド) 
removeAttribute() (Element のメソッド) 
removeAttributeNode() (Element のメソッド) 
removeAttributeNS() (Element のメソッド) 
removecallback() (CD parser のメソッド) 
removeChild() (Node のメソッド) 
removedirs() (os モジュール) 
removeFilter() (Textbox のメソッド),[Link] 
removeHandler() (Textbox のメソッド) 
removemessages() (Folder のメソッド) 
rename() (FTP のメソッド) 
rename() (IMAP4_stream のメソッド) 
rename() (os モジュール) 
renames() (os モジュール) 
reorganize() (gdbm モジュール) 
repeat() (itertools モジュール) 
repeat() (operator モジュール) 
repeat() (Timer のメソッド) 
replace() (date のメソッド) 
replace() (datetime のメソッド) 
replace() (string のメソッド) 
replace() (string モジュール) 
replace() (Textbox のメソッド) 
replace() (time のメソッド) 
replace_errors() (codecs モジュール) 
replace_header() (Message のメソッド) 
replace_history_item() (readline モジュール) 
replace_whitespace (TextWrapper の属性) 
replaceChild() (Node のメソッド) 
report() (dircmp のメソッド) 
REPORT_CDIFF (doctest モジュール) 
report_failure() (DocTestRunner のメソッド) 
report_full_closure() (dircmp のメソッド) 
REPORT_NDIFF (doctest モジュール) 
REPORT_ONLY_FIRST_FAILURE (doctest モジュール) 
report_partial_closure() (dircmp のメソッド) 
report_start() (DocTestRunner のメソッド) 
report_success() (DocTestRunner のメソッド) 
REPORT_UDIFF (doctest モジュール) 
report_unbalanced() (SGMLParser のメソッド) 
report_unexpected_exception() (DocTestRunner のメソッド) 
REPORTING_FLAGS (doctest モジュール) 
repr() (Repr のメソッド) 
repr() (repr モジュール) 
repr (standard モジュール) 
repr1() (Repr のメソッド) 
request() (HTTPSConnection のメソッド) 
request_version (BaseHTTPRequestHandler の属性) 
requires() (test.test_support モジュール) 
reserved (ZipInfo の属性) 
reset() (audio device のメソッド) 
reset() (DOMEventStream のメソッド) 
reset() (IncrementalParser のメソッド) 
reset() (Packer のメソッド) 
reset() (SGMLParser のメソッド) reset() (statcache モジュール) 
reset() (StreamReader のメソッド) 
reset() (StreamWriter のメソッド) 
reset() (Template のメソッド) reset() (turtle モジュール) 
reset() (Unpacker のメソッド) 
reset() (XMLParser のメソッド) 
reset_prog_mode() (curses モジュール) 
reset_shell_mode() (curses モジュール) 
resetbuffer() (InteractiveConsole のメソッド) 
resetlocale() (locale モジュール) 
resetparser() (CD parser のメソッド) 
resetwarnings() (warnings モジュール) 
resize() (Queue のメソッド) 
resolution (date の属性) 
resolution (datetime の属性) 
resolution (time の属性) 
resolution (timedelta の属性) 
resolveEntity() (EntityResolver のメソッド) 
resource (組み込み モジュール) 
response() (IMAP4_stream のメソッド) 
responses (BaseHTTPRequestHandler の属性) 
restore() (difflib モジュール) 
retr() (POP3_SSL のメソッド) 
retrbinary() (FTP のメソッド) 
retrieve() (URLopener のメソッド) 
retrlines() (FTP のメソッド) 
return_ok() (CookiePolicy のメソッド) 
returncode (Popen の属性) 
returns_unicode (xmlparser の属性) 
reverse() (array のメソッド) 
reverse() (audioop モジュール) 
reverse_order() (Stats のメソッド) 
revert() (FileCookieJar のメソッド) 
rewind() (aifc のメソッド) 
rewind() (AU_read のメソッド) 
rewind() (Wave_read のメソッド) 
rewindbody() (AddressList のメソッド) 
rexec (standard モジュール) 
rexec (標準 モジュール) 
rfc2965 (LWPCookieJar の属性) 
rfc822 (standard モジュール) rfc822 (標準 モジュール) 
rfile (BaseHTTPRequestHandler の属性) 
rfind() (string のメソッド) 
rfind() (string モジュール) 
rgb_to_hls() (colorsys モジュール) 
rgb_to_hsv() (colorsys モジュール) 
rgb_to_yiq() (colorsys モジュール) 
rgbimg (組み込み モジュール) 
right() (turtle モジュール) 
right_list (dircmp の属性) 
right_only (dircmp の属性) 
rindex() (string のメソッド) 
rindex() (string モジュール) 
rjust() (string のメソッド) 
rjust() (string モジュール) 
rlcompleter (standard モジュール) 
rlecode_hqx() (binascii モジュール) 
rledecode_hqx() (binascii モジュール) 
RLIMIT_AS (resource モジュール) 
RLIMIT_CORE (resource モジュール) 
RLIMIT_CPU (resource モジュール) 
RLIMIT_DATA (resource モジュール) 
RLIMIT_FSIZE (resource モジュール) 
RLIMIT_MEMLOCK (resource モジュール) 
RLIMIT_NOFILE (resource モジュール) 
RLIMIT_NPROC (resource モジュール) 
RLIMIT_OFILE (resource モジュール) 
RLIMIT_RSS (resource モジュール) 
RLIMIT_STACK (resource モジュール) 
RLIMIT_VMEM (resource モジュール) 
RLock() (threading モジュール) 
rmd() (FTP のメソッド) 
rmdir() (os モジュール) 
rms() (audioop モジュール) 
rmtree() (shutil モジュール) 
rnopen() (bsddb モジュール) 
robotparser (standard モジュール) 
rotate() (SystemRandom のメソッド) 
Rounded (decimal のクラス) 
rpop() (POP3_SSL のメソッド) 
rset() (POP3_SSL のメソッド) 
rshift() (operator モジュール) 
rsplit() (string のメソッド) 
rsplit() (string モジュール) 
rstrip() (string のメソッド) 
rstrip() (string モジュール) 
RTLD_LAZY (dl モジュール) 
RTLD_NOW (dl モジュール) 
ruler (Cmd の属性) 
run() (DocTestRunner のメソッド) 
run() (pdb モジュール) 
run() (Profile のメソッド) 
run() (profile モジュール) 
run() (scheduler のメソッド) 
run() (TestCase のメソッド) 
run() (TestSuite のメソッド) 
run() (Thread のメソッド) 
run_docstring_examples() (doctest モジュール) 
run_suite() (test.test_support モジュール) 
run_unittest() (test.test_support モジュール) 
runcall() (pdb モジュール) 
runcall() (Profile のメソッド) 
runcode() (InteractiveConsole のメソッド) 
runctx() (Profile のメソッド) 
runctx() (profile モジュール) 
runeval() (pdb モジュール) 
runsource() (InteractiveConsole のメソッド) 
RUSAGE_BOTH (resource モジュール) 
RUSAGE_CHILDREN (resource モジュール) 
RUSAGE_SELF (resource モジュール) 
S (re モジュール) 
s_eval() (RExec のメソッド) 
s_exec() (RExec のメソッド) 
s_execfile() (RExec のメソッド) 
S_IFMT() (stat モジュール) 
S_IMODE() (stat モジュール) 
s_import() (RExec のメソッド) 
S_ISBLK() (stat モジュール) 
S_ISCHR() (stat モジュール) 
S_ISDIR() (stat モジュール) 
S_ISFIFO() (stat モジュール) 
S_ISLNK() (stat モジュール) 
S_ISREG() (stat モジュール) 
S_ISSOCK() (stat モジュール) 
s_reload() (RExec のメソッド) 
s_unload() (RExec のメソッド) 
safe_substitute() (Template のメソッド) 
saferepr() (pprint モジュール) 
same_files (dircmp の属性) 
same_quantum() (Context のメソッド) 
same_quantum() (Decimal のメソッド) 
samefile() (os.path モジュール) 
sameopenfile() (os.path モジュール) 
samestat() (os.path モジュール) 
sample() (random モジュール) 
save() (FileCookieJar のメソッド) 
save_bgn() (HTMLParser のメソッド) 
save_end() (HTMLParser のメソッド) 
scanf() (re モジュール) 
sched (standard モジュール) 
sci() (fpformat モジュール) 
script_from_examples() (doctest モジュール) 
scroll() (window のメソッド) 
ScrolledText (standard モジュール) 
scrollok() (window のメソッド) 
search() (IMAP4_stream のメソッド) 
search() (re モジュール) 
search() (RegexObject のメソッド) 
SEARCH_ERROR (imp モジュール) 
second (datetime の属性) 
second (time の属性) 
section_divider() (MultiFile のメソッド) 
sections() (SafeConfigParser のメソッド) 
secure (Cookie の属性) 
seed() (random モジュール) 
seed() (whrandom のメソッド) 
seed() (whrandom モジュール) 
seek() (BZ2File のメソッド) 
seek() (CD player のメソッド) 
seek() (Chunk のメソッド) 
seek() (file のメソッド) 
seek() (MultiFile のメソッド) 
seek() (Queue のメソッド) 
SEEK_CUR (posixfile モジュール) 
SEEK_END (posixfile モジュール) 
SEEK_SET (posixfile モジュール) 
seekblock() (CD player のメソッド) 
seektrack() (CD player のメソッド) 
select() (gl モジュール) 
select() (IMAP4_stream のメソッド) 
select() (select モジュール) 
select (組み込み モジュール) 
Semaphore() (threading モジュール) 
send() (DatagramHandler のメソッド) 
send() (dispatcher のメソッド) 
send() (HTTPSConnection のメソッド) 
send() (IMAP4_stream のメソッド) 
send() (socket のメソッド) 
send() (SocketHandler のメソッド) 
send_error() (BaseHTTPRequestHandler のメソッド) 
send_flowing_data() (writer のメソッド) 
send_header() (BaseHTTPRequestHandler のメソッド) 
send_hor_rule() (writer のメソッド) 
send_label_data() (writer のメソッド) 
send_line_break() (writer のメソッド) 
send_literal_data() (writer のメソッド) 
send_paragraph() (writer のメソッド) 
send_query() (gopherlib モジュール) 
send_response() (BaseHTTPRequestHandler のメソッド) 
send_selector() (gopherlib モジュール) 
sendall() (socket のメソッド) 
sendcmd() (FTP のメソッド) 
sendmail() (SMTP のメソッド) 
sendto() (socket のメソッド) 
sep (os モジュール) 
sequence2ast() (parser モジュール) 
sequenceIncludes() (operator モジュール) 
SequenceMatcher (difflib のクラス) 
server_version (BaseHTTPRequestHandler の属性) 
server_version (SimpleHTTPRequestHandler の属性) 
set() (Event のメソッド) 
set() (mixer device のメソッド) 
set() (Morsel のメソッド) 
set() (SafeConfigParser のメソッド),[Link] 
set_allowed_domains() (DefaultCookiePolicy のメソッド) 
set_blocked_domains() (DefaultCookiePolicy のメソッド) 
set_boundary() (Message のメソッド) 
set_call_back() (FORMS object のメソッド) 
set_charset() (Message のメソッド) 
set_completer() (readline モジュール) 
set_completer_delims() (readline モジュール) 
set_cookie() (CookieJar のメソッド) 
set_cookie_if_ok() (CookieJar のメソッド) 
set_debug() (gc モジュール) 
set_debuglevel() (FTP のメソッド) 
set_debuglevel() (HTTPSConnection のメソッド) 
set_debuglevel() (NNTPDataError のメソッド) 
set_debuglevel() (POP3_SSL のメソッド) 
set_debuglevel() (SMTP のメソッド) 
set_debuglevel() (Telnet のメソッド) 
set_default_type() (Message のメソッド) 
set_event_call_back() (fl モジュール) 
set_form_position() (form のメソッド) 
set_graphics_mode() (fl モジュール) 
set_history_length() (readline モジュール) 
set_location() (Queue のメソッド) 
set_nonstandard_attr() (Cookie のメソッド) 
set_ok() (CookiePolicy のメソッド) 
set_option_negotiation_callback() (Telnet のメソッド) 
set_output_charset() (NullTranslations のメソッド) 
set_param() (Message のメソッド) 
set_pasv() (FTP のメソッド) 
set_payload() (Message のメソッド) 
set_policy() (CookieJar のメソッド) 
set_position() (Unpacker のメソッド) 
set_pre_input_hook() (readline モジュール) 
set_proxy() (Request のメソッド) 
set_recsrc() (mixer device のメソッド) 
set_seq1() (SequenceMatcher のメソッド) 
set_seq2() (SequenceMatcher のメソッド) 
set_seqs() (SequenceMatcher のメソッド) 
set_server_documentation() (DocXMLRPCRequestHandler のメソッド),[Link] 
set_server_name() (DocXMLRPCRequestHandler のメソッド),[Link] 
set_server_title() (DocXMLRPCRequestHandler のメソッド),[Link] 
set_spacing() (formatter のメソッド) 
set_startup_hook() (readline モジュール) 
set_terminator() (async_chat のメソッド) 
set_threshold() (gc モジュール) 
set_trace() (pdb モジュール) 
set_type() (Message のメソッド) 
set_unittest_reportflags() (doctest モジュール) 
set_unixfrom() (Message のメソッド) 
set_url() (RobotFileParser のメソッド) 
set_userptr() (Textbox のメソッド) 
setacl() (IMAP4_stream のメソッド) 
setAttribute() (Element のメソッド) 
setAttributeNode() (Element のメソッド) 
setAttributeNodeNS() (Element のメソッド) 
setAttributeNS() (Element のメソッド) 
SetBase() (xmlparser のメソッド) 
setblocking() (socket のメソッド) 
setByteStream() (InputSource のメソッド) 
setcbreak() (tty モジュール) 
setchannels() (audio configuration のメソッド) 
setCharacterStream() (InputSource のメソッド) 
setcheckinterval() (sys モジュール) 
setcomptype() (aifc のメソッド) 
setcomptype() (AU_write のメソッド) 
setcomptype() (Wave_write のメソッド) 
setconfig() (audio port のメソッド) 
setContentHandler() (XMLReader のメソッド) 
setcontext() (decimal モジュール) 
setcontext() (MH のメソッド) 
setcurrent() (Folder のメソッド) 
setDaemon() (Thread のメソッド) 
setdefaultencoding() (sys モジュール) 
setdefaulttimeout() (socket モジュール) 
setdlopenflags() (sys モジュール) 
setDocumentLocator() (ContentHandler のメソッド) 
setDTDHandler() (XMLReader のメソッド) 
setegid() (os モジュール) 
setEncoding() (InputSource のメソッド) 
setEntityResolver() (XMLReader のメソッド) 
setErrorHandler() (XMLReader のメソッド) 
seteuid() (os モジュール) 
setFeature() (XMLReader のメソッド) 
setfillpoint() (audio port のメソッド) 
setfirstweekday() (calendar モジュール) 
setfloatmax() (audio configuration のメソッド) 
setfmt() (audio device のメソッド) 
setFormatter() (Textbox のメソッド) 
setframerate() (aifc のメソッド) 
setframerate() (AU_write のメソッド) 
setframerate() (Wave_write のメソッド) 
setgid() (os モジュール) 
setgroups() (os モジュール) 
setinfo() (audio device のメソッド) 
setitem() (operator モジュール) 
setlast() (Folder のメソッド) 
setLevel() (Textbox のメソッド),[Link] 
setliteral() (SGMLParser のメソッド) 
setliteral() (XMLParser のメソッド) 
setlocale() (locale モジュール) 
setLocale() (XMLReader のメソッド) 
setLoggerClass() (logging モジュール) 
setlogmask() (syslog モジュール) 
setmark() (aifc のメソッド) 
setMaxConns() (CacheFTPHandler のメソッド) 
setmode() (msvcrt モジュール) 
setName() (Thread のメソッド) 
setnchannels() (aifc のメソッド) 
setnchannels() (AU_write のメソッド) 
setnchannels() (Wave_write のメソッド) 
setnframes() (aifc のメソッド) 
setnframes() (AU_write のメソッド) 
setnframes() (Wave_write のメソッド) 
setnomoretags() (SGMLParser のメソッド) 
setnomoretags() (XMLParser のメソッド) 
setoption() (jpeg モジュール) 
setparameters() (audio device のメソッド) 
setparams() (aifc のメソッド) 
setparams() (al モジュール) 
setparams() (AU_write のメソッド) 
setparams() (Wave_write のメソッド) 
setpath() (fm モジュール) 
setpgid() (os モジュール) 
setpgrp() (os モジュール) 
setpos() (aifc のメソッド) 
setpos() (AU_read のメソッド) 
setpos() (Wave_read のメソッド) 
setprofile() (sys モジュール) 
setprofile() (threading モジュール) 
setProperty() (XMLReader のメソッド) 
setPublicId() (InputSource のメソッド) 
setqueuesize() (audio configuration のメソッド) 
setquota() (IMAP4_stream のメソッド) 
setraw() (tty モジュール) 
setrecursionlimit() (sys モジュール) 
setregid() (os モジュール) 
setreuid() (os モジュール) 
setrlimit() (resource モジュール) 
sets (standard モジュール) 
setsampfmt() (audio configuration のメソッド) 
setsampwidth() (aifc のメソッド) 
setsampwidth() (AU_write のメソッド) 
setsampwidth() (Wave_write のメソッド) 
setscrreg() (window のメソッド) 
setsid() (os モジュール) 
setslice() (operator モジュール) 
setsockopt() (socket のメソッド) 
setstate() (random モジュール) 
setSystemId() (InputSource のメソッド) 
setsyx() (curses モジュール) 
setTarget() (MemoryHandler のメソッド) 
setTimeout() (CacheFTPHandler のメソッド) 
settimeout() (socket のメソッド) 
settrace() (sys モジュール) 
settrace() (threading モジュール) 
settscdump() (sys モジュール) 
setuid() (os モジュール) 
setUp() (TestCase のメソッド) 
setupterm() (curses モジュール) 
SetValue() (_winreg モジュール) 
SetValueEx() (_winreg モジュール) 
setwidth() (audio configuration のメソッド) 
sgmllib (standard モジュール) sgmllib (標準 モジュール) 
sha (組み込み モジュール) 
shelve (standard モジュール) 
shelve (標準 モジュール) 
shlex (standard モジュール) 
shortDescription() (TestCase のメソッド) 
shouldFlush() (BufferingHandler のメソッド) 
shouldFlush() (MemoryHandler のメソッド) 
show() (Textbox のメソッド) 
show_choice() (fl モジュール) 
show_file_selector() (fl モジュール) 
show_form() (form のメソッド) 
show_input() (fl モジュール) 
show_message() (fl モジュール) 
show_object() (FORMS object のメソッド) 
show_question() (fl モジュール) 
showsyntaxerror() (InteractiveConsole のメソッド) 
showtraceback() (InteractiveConsole のメソッド) 
showwarning() (warnings モジュール) 
shuffle() (random モジュール) 
shutdown() (IMAP4_stream のメソッド) 
shutdown() (logging モジュール) 
shutdown() (socket のメソッド) 
shutil (standard モジュール) 
SIG* (signal モジュール) 
SIG_DFL (signal モジュール) 
SIG_IGN (signal モジュール) 
signal() (signal モジュール) 
signal (組み込み モジュール),[Link] 
SimpleXMLRPCServer (standard モジュール) 
sin() (cmath モジュール) 
sin() (math モジュール) 
sinh() (cmath モジュール) 
sinh() (math モジュール) 
site (standard モジュール) 
sitecustomize ( モジュール),[Link] 
size() (FTP のメソッド) 
size() (Queue のメソッド) 
size (TarInfo の属性) 
sizeofimage() (rgbimg モジュール) 
skip() (Chunk のメソッド) 
skipinitialspace (Dialect の属性) 
skippedEntity() (ContentHandler のメソッド) 
slave() (NNTPDataError のメソッド) 
sleep() (time モジュール) 
slice() (built-in function) slice() (組み込み関数),[Link] 
SliceType (types モジュール) 
smtpd (standard モジュール) 
smtplib (standard モジュール) 
SND_ALIAS (winsound モジュール) 
SND_ASYNC (winsound モジュール) 
SND_FILENAME (winsound モジュール) 
SND_LOOP (winsound モジュール) 
SND_MEMORY (winsound モジュール) 
SND_NODEFAULT (winsound モジュール) 
SND_NOSTOP (winsound モジュール) 
SND_NOWAIT (winsound モジュール) 
SND_PURGE (winsound モジュール) 
sndhdr (standard モジュール) 
sniff() (Sniffer のメソッド) 
SO_* (socket モジュール) 
SOCK_DGRAM (socket モジュール) 
SOCK_RAW (socket モジュール) 
SOCK_RDM (socket モジュール) 
SOCK_SEQPACKET (socket モジュール) 
SOCK_STREAM (socket モジュール) 
socket() (IMAP4_stream のメソッド) 
socket() (socket モジュール) 
socket (SocketServer protocol) socket (組み込み モジュール),[Link],[Link] 
socketpair() (socket モジュール) 
SocketServer (standard モジュール) 
SocketType (socket モジュール) 
softspace (file の属性) 
SOL_* (socket モジュール) 
SOMAXCONN (socket モジュール) 
sort() (IMAP4_stream のメソッド) 
sort_stats() (Stats のメソッド) 
sortTestMethodsUsing (TestLoader の属性) 
source (Example の属性) 
source (shlex の属性) 
sourcehook() (shlex のメソッド) 
span() (MatchObject のメソッド) 
spawn() (pty モジュール) 
spawnl() (os モジュール) 
spawnle() (os モジュール) 
spawnlp() (os モジュール) 
spawnlpe() (os モジュール) 
spawnv() (os モジュール) 
spawnve() (os モジュール) 
spawnvp() (os モジュール) 
spawnvpe() (os モジュール) 
specified_attributes (xmlparser の属性) 
speed() (audio device のメソッド) 
split() (os.path モジュール) 
split() (re モジュール) 
split() (RegexObject のメソッド) 
split() (shlex モジュール) 
split() (string のメソッド) 
split() (string モジュール) 
splitdrive() (os.path モジュール) 
splitext() (os.path モジュール) 
splitfields() (string モジュール) 
splitlines() (string のメソッド) 
sprintf-style formatting sqrt() (cmath モジュール) 
sqrt() (Context のメソッド) 
sqrt() (Decimal のメソッド) 
sqrt() (math モジュール) 
ssl() (IMAP4_stream のメソッド) 
ssl() (socket モジュール) 
ST_ATIME (stat モジュール) 
ST_CTIME (stat モジュール) 
ST_DEV (stat モジュール) 
ST_GID (stat モジュール) 
ST_INO (stat モジュール) 
ST_MODE (stat モジュール) 
ST_MTIME (stat モジュール) 
ST_NLINK (stat モジュール) 
ST_SIZE (stat モジュール) 
ST_UID (stat モジュール) 
stack() (inspect モジュール) 
standard_b64decode() (base64 モジュール) 
standard_b64encode() (base64 モジュール) 
standend() (window のメソッド) 
standout() (window のメソッド) 
starmap() (itertools モジュール) 
start() (MatchObject のメソッド) 
start() (Profile のメソッド) 
start() (Thread のメソッド) 
start_color() (curses モジュール) 
start_new_thread() (thread モジュール) 
startbody() (MimeWriter のメソッド) 
StartCdataSectionHandler() (xmlparser のメソッド) 
StartDoctypeDeclHandler() (xmlparser のメソッド) 
startDocument() (ContentHandler のメソッド) 
startElement() (ContentHandler のメソッド) 
StartElementHandler() (xmlparser のメソッド) 
startElementNS() (ContentHandler のメソッド) 
startfile() (os モジュール) 
startmultipartbody() (MimeWriter のメソッド) 
StartNamespaceDeclHandler() (xmlparser のメソッド) 
startPrefixMapping() (ContentHandler のメソッド) 
startswith() (string のメソッド) 
startTest() (TestResult のメソッド) 
starttls() (SMTP のメソッド) 
stat() (NNTPDataError のメソッド) 
stat() (os モジュール) 
stat() (POP3_SSL のメソッド) 
stat (standard モジュール) stat() (statcache モジュール) 
stat (標準 モジュール) 
stat_float_times() (os モジュール) 
statcache (standard モジュール) 
status (httplib モジュール) 
status() (IMAP4_stream のメソッド) 
statvfs() (os モジュール) 
statvfs (standard モジュール) 
statvfs (標準 モジュール) 
stderr (Popen の属性) 
stderr (sys モジュール) 
stdin (Popen の属性) 
stdin (sys モジュール) 
stdout (Popen の属性) stdout (sys モジュール) 
stereocontrols() (mixer device のメソッド) 
STILL (cd モジュール) 
stop() (CD player のメソッド) 
stop() (Profile のメソッド) 
stop() (TestResult のメソッド) 
stopListening() (logging モジュール) 
stopTest() (TestResult のメソッド) 
storbinary() (FTP のメソッド) 
store() (IMAP4_stream のメソッド) 
storlines() (FTP のメソッド) 
str() (locale モジュール) 
strcoll() (locale モジュール) 
strerror() (os モジュール) 
strftime() (date のメソッド) 
strftime() (datetime のメソッド) 
strftime() (time のメソッド) 
strftime() (time モジュール) 
strict_domain (LWPCookieJar の属性) 
strict_errors() (codecs モジュール) 
strict_ns_domain (LWPCookieJar の属性) 
strict_ns_set_initial_dollar (LWPCookieJar の属性) 
strict_ns_set_path (LWPCookieJar の属性) 
strict_ns_unverifiable (LWPCookieJar の属性) 
strict_rfc2965_unverifiable (LWPCookieJar の属性) 
string (MatchObject の属性) 
string (standard モジュール) string (標準 モジュール),[Link],[Link] 
StringIO (standard モジュール) 
stringprep (standard モジュール) 
StringType (types モジュール) 
StringTypes (types モジュール) 
strip() (string のメソッド) 
strip() (string モジュール) 
strip_dirs() (Stats のメソッド) 
stripspaces (Textbox の属性) 
strptime() (time モジュール) 
struct (組み込み モジュール),[Link],[Link] 
struct_time (time モジュール) 
strxfrm() (locale モジュール) 
sub() (operator モジュール) 
sub() (re モジュール) 
sub() (RegexObject のメソッド) 
subdirs (dircmp の属性) 
subn() (re モジュール) 
subn() (RegexObject のメソッド) 
Subnormal (decimal のクラス) 
subpad() (window のメソッド) 
subprocess (standard モジュール) 
subscribe() (IMAP4_stream のメソッド) 
subsequent_indent (TextWrapper の属性) 
substitute() (Template のメソッド) 
substract() (Context のメソッド) 
subwin() (window のメソッド) 
suffix_map (mimetypes モジュール),[Link] 
suite() (parser モジュール) 
suiteClass (TestLoader の属性) 
summarize() (DocTestRunner のメソッド) 
sunau (standard モジュール) 
SUNAUDIODEV (standard モジュール) 
sunaudiodev (組み込み モジュール),[Link] SUNAUDIODEV (標準 モジュール) 
super (class descriptor の属性) 
supports_unicode_filenames (os.path モジュール) 
swapcase() (string のメソッド) 
swapcase() (string モジュール) 
sym() (TarInfo のメソッド) 
sym_name (symbol モジュール) 
symbol (standard モジュール) 
symlink() (os モジュール) 
sync() (audio device のメソッド) 
sync() (dbhash のメソッド) 
sync() (gdbm モジュール) 
sync() (Queue のメソッド),[Link] 
syncdown() (window のメソッド) 
syncok() (window のメソッド) 
syncup() (window のメソッド) 
syntax_error() (XMLParser のメソッド) 
sys (組み込み モジュール) 
sys_version (BaseHTTPRequestHandler の属性) 
sysconf() (os モジュール) 
sysconf_names (os モジュール) 
syslog() (syslog モジュール) 
syslog (組み込み モジュール) 
system() (os モジュール) 
system() (platform モジュール) 
system.listMethods() (ServerProxy のメソッド) 
system.methodHelp() (ServerProxy のメソッド) 
system.methodSignature() (ServerProxy のメソッド) 
system_alias() (platform モジュール) 
systemId (DocumentType の属性) 
T_FMT (locale モジュール) 
T_FMT_AMPM (locale モジュール) 
tabnanny (standard モジュール) 
tagName (Element の属性) 
takewhile() (itertools モジュール) 
tan() (cmath モジュール) 
tan() (math モジュール) 
tanh() (cmath モジュール) 
tanh() (math モジュール) 
TAR_GZIPPED (tarfile モジュール) 
TAR_PLAIN (tarfile モジュール) 
tarfile (standard モジュール) 
TarFile (tarfile のクラス) 
target (ProcessingInstruction の属性) 
tb_lineno() (traceback モジュール) 
tcdrain() (termios モジュール) 
tcflow() (termios モジュール) 
tcflush() (termios モジュール) 
tcgetattr() (termios モジュール) 
tcgetpgrp() (os モジュール) 
Tcl() (Tkinter モジュール) 
TCP_* (socket モジュール) 
tcsendbreak() (termios モジュール) 
tcsetattr() (termios モジュール) 
tcsetpgrp() (os モジュール) 
tearDown() (TestCase のメソッド) 
tee() (itertools モジュール) 
tell() (aifc のメソッド),[Link] 
tell() (AU_read のメソッド) 
tell() (AU_write のメソッド) 
tell() (BZ2File のメソッド) 
tell() (Chunk のメソッド) 
tell() (file のメソッド) 
tell() (MultiFile のメソッド) 
tell() (Queue のメソッド) 
tell() (Wave_read のメソッド) 
tell() (Wave_write のメソッド) 
telnetlib (standard モジュール) 
TEMP (環境変数) 
tempdir (tempfile モジュール) 
tempfile (standard モジュール) 
template (string の属性) 
template (tempfile モジュール) 
tempnam() (os モジュール) 
TemporaryFile() (tempfile モジュール) 
termattrs() (curses モジュール) 
termios (組み込み モジュール) 
termname() (curses モジュール) 
test() (mutex のメソッド) 
test (standard モジュール) 
test (UnexpectedException の属性) 
test.test_support (standard モジュール) 
testandset() (mutex のメソッド) 
testfile() (doctest モジュール) 
TESTFN (test.test_support モジュール) 
testMethodPrefix (TestLoader の属性) 
testmod() (doctest モジュール),[Link] 
tests (imghdr モジュール) 
testsource() (doctest モジュール),[Link] 
testsRun (TestResult の属性) 
textdomain() (gettext モジュール) 
THOUSEP (locale モジュール) 
thread() (IMAP4_stream のメソッド) 
Thread (threading のクラス) 
thread (組み込み モジュール) 
threading (standard モジュール) 
tie() (fl モジュール) 
tigetflag() (curses モジュール) 
tigetnum() (curses モジュール) 
tigetstr() (curses モジュール) 
time (datetime のクラス) 
time() (datetime のメソッド) 
time() (time モジュール) 
time (組み込み モジュール) Time2Internaldate() (imaplib モジュール) 
timedelta (datetime のクラス) 
timegm() (calendar モジュール) 
timeit (standard モジュール) 
timeit() (Timer のメソッド) 
timeout() (window のメソッド) 
Timer (threading のクラス) 
times() (os モジュール) 
timetuple() (date のメソッド) 
timetuple() (datetime のメソッド) 
timetz() (datetime のメソッド) 
timezone (time モジュール) 
title() (string のメソッド) 
Tix (standard モジュール) 
tix_addbitmapdir() (tixCommand のメソッド) 
tix_cget() (tixCommand のメソッド) 
tix_configure() (tixCommand のメソッド) 
tix_filedialog() (tixCommand のメソッド) 
tix_getbitmap() (tixCommand のメソッド) 
tix_getimage() (tixCommand のメソッド) 
TIX_LIBRARY (環境変数) 
tix_option_get() (tixCommand のメソッド) 
tix_resetoptions() (tixCommand のメソッド) 
Tkinter (standard モジュール) 
TMP (環境変数) 
TMP_MAX (os モジュール) 
TMPDIR (環境変数) 
tmpfile() (os モジュール) 
tmpnam() (os モジュール) 
to_eng_string() (Context のメソッド) 
to_eng_string() (Decimal のメソッド) 
to_integral() (Context のメソッド) 
to_integral() (Decimal のメソッド) 
to_sci_string() (Context のメソッド) 
to_splittable() (Charset のメソッド) 
ToASCII() (encodings.idna モジュール) 
tobuf() (TarInfo のメソッド) 
tochild (Popen4 の属性) 
today() (date のメソッド) 
today() (datetime のメソッド) 
tofile() (array のメソッド) 
togglepause() (CD player のメソッド) 
tok_name (token モジュール) 
token (shlex の属性) 
token (standard モジュール) 
tokeneater() (tabnanny モジュール) 
tokenize (standard モジュール) 
tokenize() (tokenize モジュール) 
tolist() (array のメソッド) 
tolist() (AST のメソッド) 
tomono() (audioop モジュール) 
toordinal() (date のメソッド) 
toordinal() (datetime のメソッド) 
top() (POP3_SSL のメソッド) 
top() (Textbox のメソッド) 
top_panel() (curses.panel モジュール) 
toprettyxml() (Node のメソッド) 
tostereo() (audioop モジュール) 
tostring() (array のメソッド) 
totuple() (AST のメソッド) 
touchline() (window のメソッド) 
touchwin() (window のメソッド) 
tounicode() (array のメソッド) 
ToUnicode() (encodings.idna モジュール) 
tovideo() (imageop モジュール) 
toxml() (Node のメソッド) 
tparm() (curses モジュール) 
trace() (inspect モジュール) 
traceback (standard モジュール) 
tracebacklimit (sys モジュール) 
TracebackType (types モジュール) 
tracer() (turtle モジュール) 
transfercmd() (FTP のメソッド) 
translate() (string のメソッド) 
translate() (string モジュール) 
translate_references() (XMLParser のメソッド) 
translation() (gettext モジュール) 
truediv() (operator モジュール) 
truncate() (file のメソッド) 
truth() (operator モジュール) 
ttob() (imgfile モジュール) 
ttob() (rgbimg モジュール) 
tty (standard モジュール) 
ttyname() (os モジュール) 
tuple2ast() (parser モジュール) 
TupleType (types モジュール) 
turnoff_sigfpe() (fpectl モジュール) 
turnon_sigfpe() (fpectl モジュール) 
turtle (standard モジュール) 
type (TarInfo の属性) type() (組み込み関数),[Link] 
typeahead() (curses モジュール) 
typecode (array の属性) 
typed_subpart_iterator() (email.Iterators モジュール) 
types (standard モジュール) types (標準 モジュール),[Link] 
types_map (mimetypes モジュール),[Link] 
TypeType (types モジュール) 
TZ (環境変数),[Link],[Link],[Link],[Link],[Link] 
tzinfo (datetime のクラス) 
tzinfo (datetime の属性) 
tzinfo (time の属性) 
tzname() (datetime のメソッド) 
tzname() (time のメソッド),[Link] 
tzname (time モジュール) 
tzset() (time モジュール) 
U (re モジュール) 
ugettext() (GNUTranslations のメソッド) 
ugettext() (NullTranslations のメソッド) 
uid() (IMAP4_stream のメソッド) 
uid (TarInfo の属性) 
uidl() (POP3_SSL のメソッド) 
ulaw2lin() (audioop モジュール) 
umask() (os モジュール) 
uname() (os モジュール) 
uname() (platform モジュール) 
uname (TarInfo の属性) 
UnboundMethodType (types モジュール) 
unconsumed_tail (Queue の属性) 
unctrl() (curses モジュール) 
unctrl() (curses.ascii モジュール) 
Underflow (decimal のクラス) 
undoc_header (Cmd の属性) 
unescape() (xml.sax.saxutils モジュール) 
unfreeze_form() (form のメソッド) 
unfreeze_object() (FORMS object のメソッド) 
ungetch() (curses モジュール) 
ungetch() (msvcrt モジュール) 
ungetmouse() (curses モジュール) 
ungettext() (GNUTranslations のメソッド) 
ungettext() (NullTranslations のメソッド) 
unhexlify() (binascii モジュール) 
UNICODE (re モジュール) 
unicodedata (standard モジュール) 
UnicodeType (types モジュール) 
unidata_version (unicodedata モジュール) 
unified_diff() (difflib モジュール) 
uniform() (random モジュール) 
uniform() (whrandom モジュール) 
unittest (standard モジュール) 
unixfrom (AddressList の属性) 
unknown_charref() (SGMLParser のメソッド) 
unknown_charref() (XMLParser のメソッド) 
unknown_endtag() (SGMLParser のメソッド) 
unknown_endtag() (XMLParser のメソッド) 
unknown_entityref() (SGMLParser のメソッド) 
unknown_entityref() (XMLParser のメソッド) 
unknown_open() (BaseHandler のメソッド) 
unknown_open() (HTTPErrorProcessor のメソッド) 
unknown_open() (UnknownHandler のメソッド) 
unknown_starttag() (SGMLParser のメソッド) 
unknown_starttag() (XMLParser のメソッド) 
unlock() (mutex のメソッド) 
unmimify() (mimify モジュール) 
unpack() (struct モジュール) 
unpack_array() (Unpacker のメソッド) 
unpack_bytes() (Unpacker のメソッド) 
unpack_double() (Unpacker のメソッド) 
unpack_farray() (Unpacker のメソッド) 
unpack_float() (Unpacker のメソッド) 
unpack_fopaque() (Unpacker のメソッド) 
unpack_fstring() (Unpacker のメソッド) 
unpack_list() (Unpacker のメソッド) 
unpack_opaque() (Unpacker のメソッド) 
unpack_string() (Unpacker のメソッド) 
unparsedEntityDecl() (DTDHandler のメソッド) 
UnparsedEntityDeclHandler() (xmlparser のメソッド) 
unqdevice() (fl モジュール) 
unquote() (email.Utils モジュール) 
unquote() (rfc822 モジュール) 
unquote() (urllib モジュール) 
unquote_plus() (urllib モジュール) 
unregister() (LogRecord のメソッド) 
unregister_dialect() (csv モジュール) 
unsubscribe() (IMAP4_stream のメソッド) 
untouchwin() (window のメソッド) 
unused_data (Queue の属性) 
up() (turtle モジュール) 
update() (hmac のメソッド) 
update() (md5 のメソッド) 
update() (sha のメソッド) 
update_panels() (curses.panel モジュール) 
upper() (string のメソッド) 
upper() (string モジュール) 
uppercase (string モジュール) 
urandom() (os モジュール) 
url (ServerProxy の属性) 
url2pathname() (urllib モジュール) 
urlcleanup() (urllib モジュール) 
urldefrag() (urlparse モジュール) 
urlencode() (urllib モジュール) 
urljoin() (urlparse モジュール) 
urllib (standard モジュール) 
urllib (標準 モジュール) urllib2 (standard モジュール) 
urlopen() (urllib モジュール) 
urlopen() (urllib2 モジュール) 
urlparse (standard モジュール) 
urlparse() (urlparse モジュール) urlparse (標準 モジュール) 
urlretrieve() (urllib モジュール) 
urlsafe_b64decode() (base64 モジュール) 
urlsafe_b64encode() (base64 モジュール) 
urlsplit() (urlparse モジュール) 
urlunparse() (urlparse モジュール) 
urlunsplit() (urlparse モジュール) 
use_default_colors() (curses モジュール) 
use_env() (curses モジュール) 
use_rawinput (Cmd の属性) 
UseForeignDTD() (xmlparser のメソッド) 
user() (POP3_SSL のメソッド) 
user (standard モジュール) 
USER (環境変数) 
UserDict (standard モジュール) 
UserList (standard モジュール) 
USERNAME (環境変数) 
userptr() (Textbox のメソッド) 
UserString (standard モジュール) 
utcfromtimestamp() (datetime のメソッド) 
utcnow() (datetime のメソッド) 
utcoffset() (datetime のメソッド) 
utcoffset() (time のメソッド),[Link] 
utctimetuple() (datetime のメソッド) 
utime() (os モジュール) 
uu (standard モジュール) 
uu (標準 モジュール) V 
value (Cookie の属性) 
value (Morsel の属性) 
value_decode() (BaseCookie のメソッド) 
value_encode() (BaseCookie のメソッド) 
values() (Message のメソッド) 
varray() (gl モジュール) 
vbar (ScrolledText の属性) 
VERBOSE (re モジュール) 
verbose (tabnanny モジュール) 
verbose (test.test_support モジュール) 
verify() (SMTP のメソッド) 
version (Cookie の属性) 
version (curses モジュール) 
version (httplib モジュール) 
version (marshal モジュール) 
version() (platform モジュール) 
version (sys モジュール) 
version (URLopener の属性) 
version_info (sys モジュール) 
version_string() (BaseHTTPRequestHandler のメソッド) 
vline() (window のメソッド) 
vnarray() (gl モジュール) 
voidcmd() (FTP のメソッド) 
volume (ZipInfo の属性) 
vonmisesvariate() (random モジュール) 
W_OK (os モジュール) 
wait() (Condition のメソッド) 
wait() (Event のメソッド) 
wait() (os モジュール) 
wait() (Popen のメソッド) 
wait() (Popen4 のメソッド) 
waitpid() (os モジュール) 
walk() (compiler モジュール) 
walk() (compiler.visitor モジュール) 
walk() (Message のメソッド) 
walk() (os モジュール) 
walk() (os.path モジュール) 
want (Example の属性) 
warn() (warnings モジュール) 
warn_explicit() (warnings モジュール) 
warning() (ErrorHandler のメソッド) 
warning() (logging モジュール) 
warning() (Textbox のメソッド) 
warnings (standard モジュール) 
warnoptions (sys モジュール) 
wasSuccessful() (TestResult のメソッド) 
wave (standard モジュール) 
weakref (extension モジュール) 
webbrowser (standard モジュール) 
weekday() (calendar モジュール) 
weekday() (date のメソッド) 
weekday() (datetime のメソッド) 
weibullvariate() (random モジュール) 
WEXITSTATUS() (os モジュール) 
wfile (BaseHTTPRequestHandler の属性) 
what() (imghdr モジュール) 
what() (sndhdr モジュール) 
whathdr() (sndhdr モジュール) 
whichdb (standard モジュール) 
whichdb() (whichdb モジュール) 
whitespace_split (shlex の属性) 
whrandom (standard モジュール) 
width (TextWrapper の属性) 
width() (turtle モジュール) 
WIFEXITED() (os モジュール) 
WIFSIGNALED() (os モジュール) 
WIFSTOPPED() (os モジュール) 
Wimp$ScrapDir (環境変数) 
win32_ver() (platform モジュール) 
window() (Textbox のメソッド) 
winsound (組み込み モジュール) 
winver (sys モジュール) 
WNOHANG (os モジュール) 
wordchars (shlex の属性) 
wrap() (textwrap モジュール) 
wrap() (TextWrapper のメソッド) 
wrapper() (curses.wrapper モジュール) 
writable() (async_chat のメソッド) 
writable() (dispatcher のメソッド) 
write() (array のメソッド) 
write() (audio device のメソッド),[Link] 
write() (BZ2File のメソッド) 
write() (file のメソッド) 
write() (Generator のメソッド) 
write() (imgfile モジュール) 
write() (InteractiveConsole のメソッド) 
write() (LogRecord のメソッド) 
write() (os モジュール) 
write() (Queue のメソッド) 
write() (SafeConfigParser のメソッド) 
write() (StreamWriter のメソッド) 
write() (Telnet のメソッド) write() (turtle モジュール) 
write() (ZipFile のメソッド) 
write_byte() (Queue のメソッド) 
write_history_file() (readline モジュール) 
writeall() (audio device のメソッド) 
writeframes() (aifc のメソッド) 
writeframes() (AU_write のメソッド) 
writeframes() (Wave_write のメソッド) 
writeframesraw() (aifc のメソッド) 
writeframesraw() (AU_write のメソッド) 
writeframesraw() (Wave_write のメソッド) 
writelines() (BZ2File のメソッド) 
writelines() (file のメソッド) 
writelines() (StreamWriter のメソッド) 
writepy() (PyZipFile のメソッド) 
writerow() (csv writer のメソッド) 
writerows() (csv writer のメソッド) 
writesamps() (audio port のメソッド) 
writestr() (ZipFile のメソッド) 
writexml() (Node のメソッド) 
WSTOPSIG() (os モジュール) 
WTERMSIG() (os モジュール) 
X (re モジュール) 
X_OK (os モジュール) 
xatom() (IMAP4_stream のメソッド) 
xdrlib (standard モジュール) 
xgtitle() (NNTPDataError のメソッド) 
xhdr() (NNTPDataError のメソッド) 
XHTML_NAMESPACE (xml.dom モジュール) 
xml.dom (standard モジュール) 
xml.dom.minidom (standard モジュール) 
xml.dom.pulldom (standard モジュール) 
xml.parsers.expat (standard モジュール) 
xml.sax (standard モジュール) 
xml.sax.handler (standard モジュール) 
xml.sax.saxutils (standard モジュール) 
xml.sax.xmlreader (standard モジュール) 
XML_NAMESPACE (xml.dom モジュール) 
xmlcharrefreplace_errors_errors() (codecs モジュール) 
xmllib (standard モジュール) 
XMLNS_NAMESPACE (xml.dom モジュール) 
XMLParserType (xml.parsers.expat モジュール) 
xmlrpclib (standard モジュール) 
xor() (operator モジュール) 
xover() (NNTPDataError のメソッド) 
xpath() (NNTPDataError のメソッド) 
xrange() (built-in function) xrange() (組み込み関数),[Link] 
XRangeType (types モジュール) 
xreadlines() (BZ2File のメソッド) 
xreadlines() (file のメソッド) 
year (date の属性) 
year (datetime の属性) 
YESEXPR (locale モジュール) 
yiq_to_rgb() (colorsys モジュール) 
zfill() (string のメソッド) zfill() (string モジュール) 
日本語訳: Python ドキュメント翻訳プロジェクト 
Python には様々な著者により寄稿された非常に多くのドキュメント類があります。 
ドキュメントの作者は、このガイドと Python 配布物で提供されている雛形ファイルを組み合わせて使い、ドキュメント全体やドキュメントの各セクションを作成したり維持したりできます。 Python のドキュメントを寄贈したいと思っているなら、そのためにLaTeXをわざわざ学ぶ必要はありません; 平文での寄贈も大歓迎です。 
1 初めに Python のドキュメントは、このフリーなプログラミング言語の長所であると考えられてきました。 
その理由は多々ありますが、最も重要なのは、Python の作者である Guido van Rossum が、言語やそのライブラリのドキュメントの提供と、ドキュメントの作成と維持の手助けする上でのユーザコミュニティの継続的な参加に早期から関わっていたことです。 コミュニティの参加には、バグ報告の作成から、単にドキュメントをより完全で利用しやすいものにできる場合に素朴な提案をするといったことまで、いくつものやりかたがあります。 
筆者自身、ドキュメントの維持に参加している中で、こうしたコミュニティから寄せられる入力全てが有用だと確信させられました。 このドキュメントは、Python のドキュメントの作者、あるいは潜在的な作者向けのものです。 
もっと具体的にいうと、標準ドキュメントに貢献したり、標準ドキュメントと同じツールを使って別のドキュメントを開発する人々向けです。 
このガイドは Python 以外のトピックに Python ドキュメント作成ツールを使う作者にとってはあまり有用ではなく、ツールを全く使用しない作者にもあまり有用ではないでしょう。 このガイドに書かれていることは、Python ドキュメント作成ツールを使う著者の支援を目的としています。 
ガイドには、標準ドキュメントのソース配布に関する情報、ドキュメントタイプに関する議論、ドキュメントクラス中で定義されているマークアップについてのリファレンス、ドキュメントを処理する上で必要な外部ツールのリスト、ドキュメントリソースと共に提供されているツールに関するリファレンスが入っています。 
ガイドの末尾には、Python ドキュメントの将来の方向性と、詳細な情報をどこで取得できるかについて議論した章もあります。 仮に、あなたが Python のドキュメントを寄贈したいと思っている一方で、LaTeX を学んだり、このドキュメントに書かれているマークアップ構造を学んだりする時間や気力を持てないとしても、あなたを Python プロジェクトへの協力者として迎え入れる余地はあります。 
既存のドキュメントを改善したり、欠けているドキュメントを提供してもらえるなら、現在のドキュメント製作チームがいつでも喜んでマークアップを行い、テキストを組み込みます。 
手助けしたいという気持ちをお持ちなら、このドキュメントに書かれていることを障害のように思わないでくださいね! 
B.2 翻訳者一覧 (敬称略) 
B. バグ報告 
A.6 SGI 特有の拡張モジュール 
C. 歴史とライセンス 
3.2 標準型の階層 
3.1 オブジェクト、値、および型 
3.3 特殊メソッド名 
以下は Python に組み込まれている型のリストです。 
(C、Java、または実装に使われているその他の言語で書かれた) 拡張モジュールでは、その他に新たな型を定義することができます。 
将来のバージョンのPython では、型の階層に新たな型 (整数を使って効率的に記憶される有理数型、など) を追加することができるかもしれません。 
以下に説明する型のいくつかには、`特殊属性 (special attribute)' と題された段落が連ねられています。 
これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。 
特殊属性の定義は将来変更される可能性があります。 
この型には単一の値しかありません。 
(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。 
) 真値は真 (true)です。 
真値は真 (true)です。 
数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。 
数値オブジェクトは変更不能です;一度値が生成されると、二度と変更されることはありません。 
Pythonの数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。 
Python は整数、浮動小数点数、複素数の間で区別を行っています: 
整数型 (integer) 
整数型は、全ての数 (whole numbers) を表す数学的集合内における要素を表現する型です。 
以下に三つの整数型を示します: 
(通常の) 整数型 (plain integer) 
長整数型 (long integer) 
長整数は無限の定義域を持ち、利用可能な (仮想) メモリサイズの制限のみをうけます。 
長整数はシフト演算やマスク演算のためにバイナリ表現をもつものと仮定されます。 負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表されます。 
ブール型 (boolean) 
ブール型は、真値 False または True を表現します。 
整数表現に関する規則は、シフト演算やマスク演算において、負の整数も含めて最も有意義な解釈ができるように、かつ通常の整数と長整数との間で定義域を切り替える際にできるだけ混乱しないように決められています。 
左シフト以外の演算では、演算結果がオーバフローを起こさずに整数の定義域の値になる場合は、長整数を使った場合でも、被演算子に整数と長整数を混合した場合でも同じ結果になります。 
浮動小数点数型 (floating point number) 
この型は計算機レベルで倍精度とされている浮動小数点数を表現します。 
複素数型 (complex number) 
この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。 
浮動小数点について述べたのと同じ性質が当てはまります。 
複素数 z の実数部および虚数部は、それぞれ読み出し専用属性 z.real および z.imagで取り出すことができます。 
シーケンス型 (sequence) 
を使うと、シーケンスの要素数を返します。 シーケンスの長さが n の場合、インデクスは 0, 1, ..., n-1からなる集合です。 
シーケンスはスライス操作 (slice) もサポートしています: 
a[i:j] とすると、i = k j であるインデクス kをもつ全ての要素を選択します。 
式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。 
シーケンスは、変更可能なものか、そうでないかで区別されています: 
変更不能なシーケンス (immutable sequence) 
変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 
(オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります;しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。 ) 
以下の型は変更不能なシーケンス型です: 
文字列型 (string) 
文字列の各要素は文字 (character) です。 
文字型 (character type)は存在しません; 単一の文字は、要素が一つだけの文字列として表現されます。 各文字は (少なくとも) 8-bit のバイト列を表現します。 
組み込み関数 chr() 
およびord() 
を使うと、文字と非負の整数で表されたバイト値の間で変換を行えます。 
0-127 の値を持つバイト値は、通常 同じ ASCII 値をもつ文字を表現していますが、値をどう解釈するかはプログラムにゆだねられています。 
文字列データ型はまた、例えばファイルから読み出されたデータを記憶するといった用途で、バイト値のアレイを表現するために用いられます。 
(ネイティブの文字セットが ASCIIでないシステムでは、chr() や ord() が ASCII と EBCDIC との間で対応付けを行っており、文字列間の比較で ASCII 順が守られる限り、文字列の内部表現として EBCDIC を使ってもかまいません。 誰か他にもっとましなルールをお持ちですか?) 
Unicode 文字列型 
Unicode オブジェクトの各要素は Unicode コード単位です。 
Unicode コード単位とは、単一の Unicode オブジェクトで、Unicode 序数を表現する 16-bit または 32-bit の値を保持できるものです (この序数の最大値は sys.maxunicode で与えられており、コンパイル時にPython がどう設定されているかに依存します)。 
Unicode オブジェクト内にサロゲートペア (surrogate pair) があってもよく、Python はサロゲートペアを二つの別々の Unicode 要素として報告します。 
組み込み関数 unichr() 
は、コード単位と非負の整数で表されたUnicode 標準 3.0 で定義された Unicode 序数との間で変換を行います。 
他の文字エンコード形式との相互変換は、 Unicode メソッド encode および組み込み関数 unicode() 
で行うことができます。 タプル型 (tuple) 
タプルの要素は任意の Python オブジェクトにできます。 二つまたはそれ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。 
単一の要素からなるタプル(単集合 `singleton') を作るには、要素を表現する式の直後にカンマをつけます (単一の式だけではタプルを形成しません。 これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです) 。 
要素の全くない丸括弧の対を作ると空のタプルになります。 
変更可能なシーケンス型 (mutable sequence) 
変更可能なシーケンスは、作成した後で変更することができます。 
変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、del (delete) 文を使って要素を削除することができます。 
Python に最初から組み込まれている変更可能なシーケンス型は、今のところ一つだけです: 
リスト型 (list) 
リストの要素は任意の Python オブジェクトにできます。 
拡張モジュール array 
では、別の変更可能なシーケンス型を提供しています。 
マップ型 (mapping) 
Python に最初から組み込まれているマップ型は、今のところ一つだけです: 
辞書型 (dictionary) 
ほとんどどんな値でもインデクスとして使えるような、有限個のオブジェクトからなる集合を表します。 
、gdbm 
、およびbsddb 
では、別のマップ型を提供しています。 
呼び出し可能型 (callable type) 
関数呼び出し操作 (5.3.4 節、``呼び出し (call)''参照) を行うことができる型です: 
ユーザ定義関数 (user-defined function) 
ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます(7.5 節、``関数定義'' 参照)。 
関数は、仮引数(formal parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。 
特殊属性: 
関数のドキュメンテーション文字列です。 ドキュメンテーションがない場合は None になります。 
書き込み可能 
func_doc の別名です。 
関数の名前です。 
func_name の別名です。 
__module__ 関数が定義されているモジュールの名前です。 
モジュール名がない場合は None になります。 
デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には Noneになります。 
コンパイルされた関数本体を表現するコードオブジェクトです。 
関数のグローバル変数の入った辞書 (への参照) です -- この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。 
読み出し専用 
任意の関数属性をサポートするための名前空間が収められています。 
None または関数の個々の自由変数(引数以外の変数) に対して値を結び付けているセル (cell) 群からなるタプルになります。 
「書き込み可能」 とラベルされている属性のほとんどは、代入された値の型をチェックします。 
バージョン 2.4 で 変更 された仕様:func_name は書き込み可能になりました 
関数オブジェクトはまた、任意の属性を設定したり取得したりできます。 この機能は、例えば関数にメタデータを付与したい場合などに使えます。 
関数の get や set には、通常のドット表記を使います。 
現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。 
組み込み関数の属性は将来サポートする予定です。 
関数定義に関するその他の情報は、関数のコードオブジェクトから得られます; 後述の内部型 (internal type) に関する説明を参照してください。 
ユーザ定義メソッド (user-defined method) 
ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス(あるいは None) を任意の呼び出し可能オブジェクト (通常はユーザ定義関数) と結合し (combine) ます。 
クラスやインスタンスから他のユーザ定義メソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、その動作は関数オブジェクトの場合と同様ですが、新たなインスタンスのim_func 属性はもとのメソッドオブジェクトの属性ではなく、新たなインスタンスの属性になります。 
クラスやインスタンスからクラスメソッドオブジェクトを取得する方法でユーザ定義メソッドオブジェクトを生成した場合、im_self 属性はクラス自体 (im_class 属性と同じ) となり、im_func 属性はクラスメソッドの根底にある関数オブジェクトになります。 
場合によっては、属性をローカルな変数に代入しておき、その変数を使って関数呼び出しを行うと効果的な最適化になります。 また、上記の変換はユーザ定義関数に対してのみ起こるので注意してください;その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) は、変換を受けずに取り出されます。 
それから、クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに変換できないと知っておくことも重要です; 結合メソッドへの変換が行われるのは、関数がクラスの一属性である場合 だけ です。 
ジェネレータ関数 (generator function) 
yield 文 (6.8 節、``yield 文'' 参照)を使う関数またはメソッドは、ジェネレータ関数 (generator function) と呼ばれます。 
このような関数は、呼び出された際に、常にイテレータオブジェクトを返します。 このイテレータオブジェクトは関数の本体を実行するために用いられます: イテレータの next()メソッドを呼び出すと、yield 文で値を出力する処理まで関数の実行が行われます。 
関数が return 文を実行するか、関数を最後まで実行し終えると、StopIteration 例外が送出され、イテレータが返す値の集合はそこで終わります。 
組み込み関数 (built-in function) 
組み込み関数オブジェクトは C 関数へのラッパです。 
組み込みメソッド (built-in method) 
実際には組み込み関数を別の形で隠蔽したもので、こちらの場合にはC 関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。 
組み込みメソッドの例は、alist をリストオブジェクトとしたときの 
alist.append() です。 この場合には、読み出し専用の属性 __self__ はalist で表されるオブジェクトになります。 
クラス型 (class type) 
クラス型、あるいは ``新しいクラス型 (new-style class)'' や呼び出し可能オブジェクトです。 
クラス型オブジェクトは通常、そのクラスの新たなインスタンスを生成する際のファクトリクラスとして振舞いますが、__new__() をオーバライドして、バリエーションを持たせることもできます。 
呼び出しの際に使われた引数は __new__() に渡され、さらに典型的な場合では新たなインスタンスを初期化するために __init__() に渡されます。 
旧クラス型 (classic class) 
(旧) クラスオブジェクトは後で詳しく説明します。 
クラスオブジェクトが呼び出されると、新たにクラスインスタンス (後述) が生成され、返されます。 
この操作には、クラスの __init__() メソッドの呼び出し (定義されている場合) が含まれています。 
呼び出しの際に使われた引数は、すべて __init__() メソッドに渡されます。 
__init__() メソッドがない場合、クラスは引数なしで呼び出さなければなりません。 
クラスインスタンス (class instance) 
クラスインスタンスは後で詳しく説明します。 
クラスインスタンスはクラスが __call__() メソッドを持っている場合にのみ呼び出すことができます; x(arguments) とすると、x.__call__(arguments) 呼び出しを短く書けます。 
モジュール (module) 
モジュールは import 文で import します (6.12 節、``import 文'' 参照)。 
モジュールオブジェクトは、辞書オブジェクト (モジュール内で定義されている関数が func_globals 属性で参照している辞書です) で実装された名前空間を持っています。 
クラス 
要求している属性が静的メソッドオブジェクトの場合、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。 
クラスから取り出した属性と実際に __dict__ に入っているものが異なるような他の場合については、3.3.2 節を参照してください。 
クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。 
クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。 
特殊属性: __name__ はクラス名です;__module__ はクラスが定義されているモジュールの名前です;__dict__ はクラスの名前空間が入った辞書です;__bases__ は基底クラスの入った (空、あるいは単要素を取りえる) タプルで、基底クラスリストの順番になっています; __doc__ はクラスのドキュメンテーション文字列です。 ドキュメンテーション文字列がない場合には None になります。 
クラスインスタンス 
クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して生成します。 
クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはこの辞書が最初に検索されます。 
辞書内に属性が見つからず、かつインスタンスのクラスに該当する属性名がある場合、検索はクラス属性にまで広げられます。 見つかったクラス属性がユーザ定義関数オブジェクトや、インスタンスのクラス (C とします) やその基底クラスに関連付けられている非結合のユーザ定義メソッドオブジェクトの場合、im_class 属性が C で im_self 属性がインスタンスになっている結合ユーザ定義メソッドオブジェクトに変換されます。 
静的メソッドやクラスメソッドオブジェクトもまた、C から取り出した場合と同様に変換されます;上記の ``クラス'' を参照してください。 
クラスから取り出した属性と実際に __dict__ に入っているものが異なるような他の場合については、3.3.2 節を参照してください。 クラス属性が見つからず、かつオブジェクトのクラスが__getattr__() メソッドを持っている場合、このメソッドを呼び出して属性名の検索を充足させます。 
属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。 
クラスで __setattr__() や__delattr__() メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。 
クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 
3.3 節、 ``特殊メソッド名'' を参照してください。 
特殊属性: __dict__ は属性の辞書です;__class__ はインスタンスのクラスです。 ファイル (file) 
ファイル 
オブジェクトは開かれたファイルを表します。 
ファイルオブジェクトは組み込み関数 open() 
や、 os.popen(),os.fdopen(), および socke オブジェクトのmakefile() 
メソッド (その他の拡張モジュールで提供されている関数やメソッド) で生成されます。 
sys.stdin,sys.stdout およびsys.stderr といったオブジェクトは、インタプリタの標準入力 
ファイルオブジェクトに関する完全な記述については、 
インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。 これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。 
コードオブジェクト 
コードオブジェクトは バイトコンパイルされた (byte-compiled)実行可能な Python コード、別名 バイトコード (bytecode) を表現します。 コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 (関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません(実行時に計算される値を表現するため)。 
関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を(直接、間接に関わらず) 含みません。 
読み出し専用の特殊属性: co_name は関数名を表します;co_argcount は固定引数 (positional argument) の数です;co_nlocals は関数が使う (引数を含めた) ローカル変数の数です;co_varnames はローカル変数名の入ったタプルです (引数名から始まっています); co_cellvars はネストされた関数で参照されているローカル変数の名前が入ったタプルです; co_freevars は自由変数の名前が入ったタプルです。 co_code はバイトコード列を表現している文字列です;co_consts はバイトコードで使われているリテラルの入ったタプルです; co_names はバイトコードで使われている名前の入ったタプルです; co_filename はバイトコードのコンパイルが行われたファイル名です; co_firstlineno は関数の最初の行番号です; co_lnotab はバイトコードオフセットから行番号への対応付けをコード化した文字列です (詳細についてはインタプリタのソースコードを参照してください); co_stacksize は関数で(ローカル変数の分も含めて) 必要なスタックサイズです; co_flags はインタプリタ用の様々なフラグをコード化した整数です。 
以下のフラグビットが co_flags で定義されています: 0x04 ビットは、関数が "*arguments" 構文を使って任意の数の固定引数を受理できる場合に立てられます;0x08 ビットは、関数が "**keywords" 構文を使ってキーワード引数を受理できる場合に立てられます;0x20 ビットは、関数がジェネレータである場合に立てられます。 
将来機能 (future feature) 宣言 ("from __future__ import division")もまた、co_flags のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: 0x2000 ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、0x10 および 0x1000 ビットが使われていました。 co_flags のその他のビットは将来に内部的に利用するために予約されています。 
フレーム (frame) オブジェクト 
フレームオブジェクトは実行フレーム (execution frame) を表します。 
実行フレームはトレースバックオブジェクト内に出現します (下記参照)。 
読み出し専用の特殊属性: f_back は (呼び出し側にとっての) 以前のスタックフレームです。 呼び出し側がスタックフレームの最下段である場合には None です; f_code は現在のフレームで実行しようとしているコードオブジェクトです; f_locals はローカル変数を検索するために使われる辞書です;f_globals はグローバル変数用です; f_builtins は組み込みの (Python 固有の) 名前です;f_restricted は、関数が制限つき実行 (restricted execution) モードで実行されているかどうかを示すフラグです; f_lasti は厳密な命令コード (コードオブジェクト中のバイトコード文字列へのインデクス) です。 
書き込み可能な特殊属性: f_trace が None でない場合、各ソースコード行の先頭で呼び出される関数になります; f_exc_type, f_exc_value, f_exc_traceback は、現在のフレームでもっとも最近捕捉された例外を表します;f_lineno はフレーム中における現在の行番号です -- トレース関数(trace function) 側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ) 。 
デバッガでは、f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも呼ばれます) を実装できます。 
トレースバック (traceback) オブジェクト 
トレースバックオブジェクトは例外のスタックトレースを表現します。 
トレースバックオブジェクトは例外が発生した際に生成されます。 
例外ハンドラを検索して実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。 
例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります(7.4 節 ``try 文'' を参照)。 
トレースバックは sys.exc_traceback として得ることができ、sys.exc_info() が返すタプルの三番目の要素としても得られます.インタフェースとしては後者の方が推奨されていますが、これはプログラムがマルチスレッドを使っている場合に正しく動作するからです。 プログラムに適切なハンドラがない場合、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行されている場合、sys.last_traceback として得ることもできます。 
読み出し専用の特殊属性: tb_next はスタックトレース内の(例外の発生しているフレームに向かって) 次のレベルです。 次のレベルが存在しない場合には None になります;tb_frame は現在のレベルにおける実行フレームを指します;tb_lineno は例外の発生した行番号です; tb_lasti は厳密な命令コードです。 
トレースバック内の行番号や最後に実行された命令は、try 文内で例外が発生し、かつ対応する except 節や finally 節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。 
スライス (slice) オブジェクト 
スライスオブジェクトは 拡張スライス構文 (extended slice syntax)が使われた際にスライスを表現するために使われます。 
拡張スライス構文とは、二つのコロンや、コンマで区切られた複数のスライスや省略符号 (ellipse)を使ったスライスで、例えば a[i:j:step] 、 a[i:j, k:l] 、あるいは a[..., i:j] です。 スライスオブジェクトは組み込み関数slice() 
で生成されます。 
読み出し専用の特殊属性: start は下境界 (lower bound) です;stop は上境界 (upper bound) です; step はステップ値(step value) です; それぞれ省略されている場合には None になります。 
これらの属性は任意の型の値をとることができます。 
スライスオブジェクトはメソッドを一つサポートします: 
このメソッドは単一の整数引数 length を取り、length 個の要素からなるシーケンスに適用した際にスライスオブジェクトから提供することになる、拡張スライスに関する情報を計算します。 
静的メソッド (static method) オブジェクト 
静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。 
静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。 
静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。 
静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。 
静的オブジェクトは組み込みコンストラクタstaticmethod() で生成されます。 
クラスメソッドオブジェクト 
クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。 
このようにして取得したクラスメソッドオブジェクトの動作については、上の ``ユーザ定義メソッド (user-defined method)'' で説明されています。 
クラスメソッドオブジェクトは組み込みのコンストラクタ classmethod() で生成されます。 
この文書について... 
このドキュメントは、 
LaTeX2HTML 変換ツールを使って生成されています。 
A..2 翻訳者一覧 
1. はじめに 
1. はじめに 
2.1 組み込み関数 
2.2 非必須組み込み関数 (Non-essential Built-in Functions) 
2.4 組み込み例外 
2.5 組み込み定数 
3. Python ランタイム サービス 
3.1 sys -- システムパラメータと関数 
3.2 gc -- ガベージコレクタ インターフェース 
3.3 weakref -- 弱参照 
3.3.3 拡張型における弱参照 
3.4 fpectl -- 浮動小数点例外の制御 
3.4.1 例 
3.4.2 制限と他に考慮すべきこと 
3.5 atexit -- 終了ハンドラ 
3.5.1 atexit 例 
3.6 types -- 組み込み型の名前 
3.7 UserDict -- 辞書オブジェクトのためのクラスラッパー 
3.8 UserList -- リストオブジェクトのためのクラスラッパー 
3.9 UserString -- 文字列オブジェクトのためのクラスラッパー 
3.10 operator -- 関数形式の標準演算子 
3.10.1 演算子から関数への対応表 
3.11 inspect -- 使用中オブジェクトの情報を取得する 
3.11.1 型とメンバ 
3.11.2 ソース参照 
3.11.3 クラスと関数 
3.11.4 インタープリタ スタック 
3.12 traceback -- スタックトレースの表示や取り出し 
3.12.1 トレースバックの例 
3.13 linecache -- テキストラインにランダムアクセスする 
3.14 pickle -- Python オブジェクトの整列化 
3.14.1 他の Python モジュールとの関係 
3.14.2 データストリームの形式 
3.14.3 使用法 
3.14.4 何を pickle 化したり unpickle 化できるのか? 
3.14.5 pickle 化プロトコル 
3.14.6 Unpickler をサブクラス化する 
3.14.7 例 
3.15 cPickle -- より高速な pickle 
3.16 copy_reg -- pickleサポート関数を登録する 
3.17 shelve -- Python オブジェクトの永続化 
3.17.1 制限事項 
3.17.2 使用例 
3.18 copy -- 浅いコピーおよび深いコピー操作 
3.19 marshal -- 内部使用向けの Python オブジェクト整列化 
3.20 warnings -- 警告の制御 
3.20.1 警告カテゴリ 
3.20.2 警告フィルタ 
3.20.3 利用可能な関数 
3.21 imp -- import内部へアクセスする 
3.21.1 例 
3.22 pkgutil -- パッケージ拡張ユーティリティ 
3.23 code -- インタプリタ基底クラス 
3.23.1 対話的なインタプリタオブジェクト 
3.23.2 対話的なコンソールオブジェクト 
3.24 codeop -- Pythonコードをコンパイルする 
3.25 pprint -- データ出力の整然化 
3.25.1 PrettyPrinter オブジェクト 
3.26 repr -- もう一つのrepr()の実装 
3.26.1 Reprオブジェクト 
3.26.2 Reprオブジェクトをサブクラス化する 
3.27 new -- ランタイム内部オブジェクトの作成 
3.28 site -- サイト固有の設定フック 
3.29 user --ユーザー設定のフック 
3.30 __builtin__ -- 組み込み関数 
3.31 __main__ -- トップレベルのスクリプト環境 
3.32 __future__ -- Future ステートメントの定義 
4. 文字列処理 
4.1 string -- 一般的な文字列操作 
4.1.2 テンプレート文字列 
4.1.3 文字列操作関数 
4.1.4 撤廃された文字列関数 
4.2 re -- 正規表現操作 
4.2.1 正規表現のシンタクス 
4.2.2 マッチング vs 検索 
4.2.3 モジュール コンテンツ 
4.2.4 正規表現オブジェクト 
4.2.5 MatchObject オブジェクト 
4.2.6 例 
4.3 struct -- 文字列データをパックされたバイナリデータとして解釈する 
4.4 difflib -- 差異の計算を助ける 
4.4.1 SequenceMatcherオブジェクト 
4.4.2 SequenceMatcher の例 
4.4.3 Differ オブジェクト 
4.4.4 Differ の例 
4.5 fpformat -- 浮動小数点の変換 
4.6 StringIO -- ファイルのように文字列を読み書きする 
4.7 cStringIO -- 高速化された StringIO 
4.8 textwrap -- テキストの折り返しと詰め込み 
4.9 codecs -- codec レジストリと基底クラス 
4.9.1 Codec 基底クラス 
4.9.2 標準エンコーディング 
4.9.3 encodings.idna -- アプリケーションにおける国際化ドメイン名 (IDNA) 
4.10 unicodedata -- Unicode データベース 
4.11 stringprep -- インターネットのための文字列調製 
5. 各種サービス 
5.1 pydoc -- ドキュメント生成とオンラインヘルプシステム 
5.2 doctest -- 対話モードを使った使用例の内容をテストする 
5.2.1 簡単な利用法: docstring 中の例題をチェックする 
5.2.2 簡単な利用法: テキストファイル中の例題をチェックする 
5.2.7 基本 API 
5.2.8 単位テスト API 
5.2.9 拡張 API 
5.2.10 デバッグ 
5.2.11 提言 5.2.12 進んだ使い方 
5.3 unittest -- 単体テストフレームワーク 
5.3.1 基礎的な例 
5.3.2 テストの構成 
5.3.3 既存テストコードの再利用 
5.3.4 クラスと関数 
5.3.5 TestCase オブジェクト 
5.3.6 TestSuite オブジェクト 
5.3.7 TestResultオブジェクト 
5.3.8 TestLoader オブジェクト 
5.4 test -- Python用回帰テストパッケージ 
5.4.1 testパッケージのためのユニットテストを書く 
5.4.2 test.regrtestを使ってテストを実行する 
5.4.3 test.test_support -- テストのためのユーティリティ関数 
5.5 decimal -- 10進浮動小数点数の算術演算 
5.5.2 Decimal オブジェクト 
5.5.3 Context オブジェクト 
5.5.4 シグナル 
5.5.5 浮動小数点数に関する注意 
5.5.6 スレッドを使った処理 
5.5.7 レシピ 
5.6 math -- 数学関数 
5.7 cmath -- 複素数のための数学関数 
5.8 random -- 擬似乱数を生成する 
5.9 whrandom -- 擬似乱数生成器 
5.10 bisect -- 配列二分法アルゴリズム 
5.10.1 使用例 
5.11 collections -- 高性能なコンテナ・データ型 
5.11.1 レシピ 
5.12 heapq -- ヒープキューアルゴリズム 
5.12.1 理論 
5.13 array -- 効率のよい数値アレイ 
5.14 sets -- ユニークな要素の順序なしコレクション 
5.14.1 Set オブジェクト 
5.14.2 使用例 
5.14.3 不変に自動変換するためのプロトコル 
5.15 itertools -- 効率的なループ実行のためのイテレータ生成関数 
5.15.1 Itertool関数 
5.15.2 例 
5.15.3 レシピ 
5.16 ConfigParser --設定ファイルの構文解析器 
5.16.1 RawConfigParser オブジェクト 
5.16.2 ConfigParser オブジェクト 
5.16.3 SafeConfigParser オブジェクト 
5.17 fileinput --複数の入力ストリームをまたいだ行の繰り返し処理をサポートする。 
5.18 calendar -- 一般的なカレンダーに関する関数群 
5.19 cmd -- 行指向のコマンドインタープリタのサポート 
5.19.1 Cmdオブジェクト 
5.20 shlex -- 単純な字句解析 
5.20.1 モジュールの内容 5.20.2 shlex オブジェクト 
5.20.3 解析規則 
6. 汎用オペレーティングシステムサービス 
6.1 os -- 雑多なオペレーティングシステムインタフェース 
6.1.1 プロセスのパラメタ 
6.1.2 ファイルオブジェクトの生成 
6.1.3 ファイル記述子の操作 
6.1.4 ファイルとディレクトリ 
6.1.5 プロセス管理 
6.1.6 雑多なシステム情報 
6.1.7 雑多な関数 
6.2 os.path --共通のパス名操作 
6.3 dircache -- キャッシュされたディレクトリ一覧の生成 
6.4 stat -- stat() の返す内容を解釈する 
6.5 statcache -- os.stat() の最適化 
6.6 statvfs -- os.statvfs() で使われる定数群 
6.7 filecmp -- ファイルおよびディレクトリの比較 
6.7.1 dircmp クラス 
6.8 subprocess -- サブプロセス管理 
6.8.1 subprocess モジュールを使う 
6.8.2 Popen オブジェクト 
6.8.3 古い関数を subprocess モジュールで置き換える 
6.9 popen2 -- アクセス可能な I/O ストリームを持つ子プロセス生成 
6.9.1 Popen3 および Popen4 オブジェクト 
6.9.2 フロー制御の問題 
6.10 datetime -- 基本的な日付型および時間型 
6.10.1 利用可能なデータ型 
6.10.2 timedelta オブジェクト 
6.10.3 date オブジェクト 
6.10.4 datetime オブジェクト 
6.10.5 time オブジェクト 
6.10.6 tzinfo オブジェクト 
6.10.7 strftime() の振る舞い 
6.11 time -- 時刻データへのアクセスと変換 
6.12 sched -- イベントスケジューラ 
6.12.1 スケジューラオブジェクト 
6.13 mutex -- 排他制御 
6.13.1 mutex オブジェクト 
6.14 getpass -- 可搬性のあるパスワード入力機構 
6.15 curses -- 文字セル表示のための端末操作 
6.15.1 関数 
6.15.2 Window オブジェクト 
6.15.3 定数 
6.16 curses.textpad -- curses プログラムのためのテキスト入力ウィジェット 
6.16.1 Textbox オブジェクト 
6.17 curses.wrapper -- curses プログラムのための端末ハンドラ 
6.19 curses.panel -- curses のためのパネルスタック拡張 
6.19.1 関数 
6.19.2 Panel オブジェクト 
6.20 getopt --コマンドラインオプションのパーザ 
6.21 optparse -- より強力なコマンドラインオプション解析器 
6.21.3 リファレンスガイド 
6.21.4 オプション処理コールバック 
6.22 tempfile -- 一時的なファイルやディレクトリの生成 
6.23 errno -- 標準の errno システムシンボル 
6.24 glob -- Unix 形式のパス名のパターン展開 
6.25 fnmatch -- Unix ファイル名のパターンマッチ 
6.26 shutil -- 高レベルなファイル操作 
6.26.1 使用例 
6.27 locale -- 国際化サービス 
6.27.1 ロケールの背景、詳細、ヒント、助言および補足説明 
6.27.2 Python 拡張の作者と、Python を埋め込むようなプログラムに関して 
6.27.3 メッセージカタログへのアクセス 
6.28 gettext -- 多言語対応に関する国際化サービス 
6.28.2 クラスに基づいた API 
6.28.3 プログラムやモジュールを国際化する 
6.28.4 謝辞 
6.29 logging -- Python 用ロギング機能 
6.29.1 Logger オブジェクト 
6.29.2 基本的な使い方 
6.29.3 複数の出力先にログを出力する 
6.29.4 ログイベントをネットワーク越しに送受信する 
6.29.5 Handler オブジェクト 
6.29.6 Formatter オブジェクト 
6.29.7 Filter オブジェクト 
6.29.8 LogRecord オブジェクト 
6.29.9 スレッド安全性 
6.29.10 環境設定 
6.30 platform -- 実行中プラットフォームの固有情報を参照する 
6.30.1 クロス プラットフォーム 
6.30.2 Java プラットフォーム 
6.30.3 Windows プラットフォーム 
6.30.4 Mac OS プラットフォーム 
6.30.5 Unix プラットフォーム 
7. オプションのオペレーティングシステムサービス 
7.1 signal -- 非同期イベントにハンドラを設定する 
7.1.1 例 
7.2 socket -- 低レベルネットワークインターフェース 
7.2.1 socket オブジェクト 
7.2.2 SSL オブジェクト 
7.2.3 例 
7.3 select -- I/O 処理の完了を待機する 
7.3.1 ポーリングオブジェクト 
7.4 thread -- マルチスレッドのコントロール 
7.5 threading -- 高水準のスレッドインタフェース 
7.5.1 Lock オブジェクト 
7.5.2 RLock オブジェクト 
7.5.3 Condition オブジェクト 
7.5.4 Semaphore オブジェクト 
7.5.5 Event オブジェクト 
7.5.6 Thread オブジェクト 
7.5.7 Timer オブジェクト 
7.6 dummy_thread -- thread の代替モジュール 
7.7 dummy_threading -- threading の代替モジュール 
7.8 Queue -- 同期キュークラス 
7.8.1 キューオブジェクト 
7.9 mmap --メモリマップファイル 
7.10 anydbm -- DBM 形式のデータベースへの汎用アクセスインタフェース 
7.11 dbhash -- BSD データベースライブラリへの DBM 形式のインタフェース 
7.11.1 データベースオブジェクト 
7.12 whichdb -- どのDBMモジュールがデータベースを作ったかを推測する 
7.13 bsddb -- Berkeley DB ライブラリへのインタフェース 
7.13.1 ハッシュ、BTree、およびレコードオブジェクト 
7.14 dumbdbm -- 可搬性のある DBM 実装 
7.14.1 Dumbdbm オブジェクト 
7.15 zlib -- gzip 互換の圧縮 
7.16 gzip -- gzip ファイルのサポート 
7.17 bz2 -- bzip2 互換の圧縮ライブラリ 
7.17.1 ファイルの圧縮(解凍) 
7.17.2 逐次的な圧縮(解凍) 
7.17.3 一括圧縮(解凍) 
7.18 zipfile -- ZIP アーカイブの処理 
7.18.1 ZipFile オブジェクト 
7.18.2 PyZipFile オブジェクト 
7.18.3 ZipInfo オブジェクト 
7.19 tarfile -- tar アーカイブファイルを読み書きする 
7.19.1 TarFile オブジェクト 
7.19.2 TarInfo オブジェクト 
7.19.3 例 
7.20 readline -- GNU readline のインタフェース 
7.20.1 例 
7.21 rlcompleter -- GNU readline向け補完関数 
7.21.1 Completerオブジェクト 
8. Unix独特のサービス 
8.1 posix -- 最も一般的な POSIX システムコール群 
8.1.1 ラージファイルのサポート 
8.1.2 モジュールの内容 
8.2 pwd -- パスワードデータベースへのアクセスを提供する 
8.3 grp -- グループデータベースへのアクセス 
8.4 crypt -- Unix パスワードをチェックするための関数 
8.5 dl -- 共有オブジェクトのC関数の呼び出し 
8.5.1 Dlオブジェクト 
8.6 dbm -- UNIX dbmのシンプルなインタフェース 
8.7 gdbm -- GNU による dbm の再実装 
8.8 termios -- POSIX スタイルの端末制御 
8.8.1 使用例 
8.9 tty -- 端末制御のための関数群 
8.10 pty -- 擬似端末ユーティリティ 
8.11 fcntl -- fcntl() および ioctl() システムコール 
8.12 pipes -- シェルパイプラインへのインタフェース 
8.12.1 テンプレートオブジェクト 
8.13 posixfile -- ロック機構をサポートするファイル類似オブジェクト 
8.14 resource -- リソース使用状態の情報 
8.14.1 リソースの制限 
8.14.2 リソースの使用状態 
8.15 nis -- Sun の NIS (Yellow Pages) へのインタフェース 
8.16 syslog -- Unix syslog ライブラリルーチン群 
8.17 commands -- コマンド実行ユーティリティ 
9. Pythonデバッガ 
9.1 デバッガコマンド 
9.2 どのように動作しているか 
10. Python プロファイラ 
10.1 プロファイラとは 
10.2 旧バージョンのプロファイラとの違い 
10.3 インスタント・ユーザ・マニュアル 
10.4 決定論的プロファイリングとは何か? 
10.5 リファレンス・マニュアル 
10.5.1 Stats クラス 
10.6 制限事項 
10.7 キャリブレーション(補正) 
10.8 拡張 -- プロファイラの改善 
10.9 hotshot -- ハイパフォーマンス・ロギング・プロファイラ 
10.9.1 プロファイル・オブジェクト 
10.9.2 hotshot データの利用 
10.9.3 使用例 
10.10 timeit -- 小さなコード断片の実行時間計測 
10.10.1 コマンドライン・インターフェース 
10.10.2 使用例 
11. インターネットプロトコルとその支援 
11.1 webbrowser --便利なウェブブラウザコントローラー 
11.1.1 ブラウザコントローラーオブジェクト 
11.2 cgi -- CGI (ゲートウェイインタフェース規格) のサポート 
11.2.1 はじめに 
11.2.2 cgi モジュールを使う 
11.2.3 高水準インタフェース 
11.2.4 古いクラス群 
11.2.5 関数 
11.2.6 セキュリティへの配慮 
11.2.7 CGI スクリプトを Unix システムにインストールする 
11.2.8 CGI スクリプトをテストする 
11.2.9 CGI スクリプトをデバッグする 
11.2.10 よくある問題と解決法 
11.3 cgitb -- CGI スクリプトのトレースバック管理機構 
11.4 urllib -- URL による任意のリソースへのアクセス 
11.4.1 URLopener オブジェクト 
11.4.2 使用例 
11.5 urllib2 -- URL を開くための拡張可能なライブラリ 
11.5.1 Request オブジェクト 
11.5.2 OpenerDirector オブジェクト 
11.5.3 BaseHandler オブジェクト 
11.5.4 HTTPRedirectHandler オブジェクト 
11.5.5 HTTPCookieProcessor オブジェクト 
11.5.6 ProxyHandler オブジェクト 
11.5.7 HTTPPasswordMgr オブジェクト 
11.5.8 AbstractBasicAuthHandler オブジェクト 
11.5.9 HTTPBasicAuthHandler オブジェクト 
11.5.10 ProxyBasicAuthHandler オブジェクト 
11.5.11 AbstractDigestAuthHandler オブジェクト 
11.5.12 HTTPDigestAuthHandler オブジェクト 
11.5.13 ProxyDigestAuthHandler オブジェクト 
11.5.14 HTTPHandler オブジェクト 
11.5.15 HTTPSHandler オブジェクト 
11.5.16 FileHandler オブジェクト 
11.5.17 FTPHandler オブジェクト 
11.5.18 CacheFTPHandler オブジェクト 
11.5.19 GopherHandler オブジェクト 
11.5.20 UnknownHandler オブジェクト 
11.5.21 HTTPErrorProcessor オブジェクト 
11.5.22 例 
11.6 httplib -- HTTP プロトコルクライアント 
11.6.1 HTTPConnection オブジェクト 
11.6.2 HTTPResponse オブジェクト 
11.6.3 例 
11.7 ftplib --FTPプロトコルクライアント 
11.7.1 FTP オブジェクト 
11.8 gopherlib -- gopher プロトコルのクライアント 
11.9 poplib -- POP3 プロトコルクライアント 
11.9.1 POP3 オブジェクト 
11.9.2 POP3 の例 
11.10 imaplib -- IMAP4 プロトコルクライアント 
11.10.1 IMAP4 オブジェクト 
11.10.2 IMAP4 の使用例 
11.11 nntplib -- NNTP プロトコルクライアント 
11.11.1 NNTP オブジェクト 
11.12 smtplib -- SMTP プロトコル クライアント 
11.12.1 SMTP オブジェクト 
11.12.2 SMTP 使用例 
11.13 smtpd -- SMTP サーバ 
11.13.1 SMTPServer オブジェクト 
11.13.2 DebuggingServer オブジェクト 
11.13.3 PureProxy オブジェクト 
11.14 telnetlib -- Telnet クライアント 
11.14.1 Telnet オブジェクト 
11.15 urlparse -- URL を解析して構成要素にする 
11.16 SocketServer -- ネットワークサーバ構築のためのフレームワーク 
11.17 BaseHTTPServer -- 基本的な機能を持つ HTTP サーバ 
11.18 SimpleHTTPServer -- 簡潔な HTTP リクエストハンドラ 
11.19 CGIHTTPServer -- CGI 実行機能付き HTTP リクエスト処理機構 
11.20 cookielib -- HTTP クライアント用の Cookie 処理 
11.20.1 CookieJar および FileCookieJar オブジェクト 
11.20.2 FileCookieJar のサブクラスと web ブラウザとの連携 
11.20.3 CookiePolicy オブジェクト 
11.20.4 DefaultCookiePolicy オブジェクト 
11.20.5 Cookie オブジェクト 
11.20.6 使用例 
11.21 Cookie --HTTPの状態管理 
11.21.1 Cookieオブジェクト 
11.21.2 Morselオブジェクト 
11.21.3 例 
11.22 xmlrpclib -- XML-RPC クライアントアクセス 
11.22.1 ServerProxy オブジェクト 
11.22.5 Fault オブジェクト 
11.22.6 ProtocolError オブジェクト 
11.22.7 MultiCall オブジェクト 
11.22.8 補助関数 
11.22.9 クライアントのサンプル 
11.23 SimpleXMLRPCServer -- 基本的なXML-RPCサーバー 
11.23.1 SimpleXMLRPCServer オブジェクト 
11.24 DocXMLRPCServer -- セルフ-ドキュメンティング XML-RPC サーバ 
11.24.1 DocXMLRPCServer オブジェクト 
11.25 asyncore -- 非同期ソケットハンドラ 
11.25.1 asyncoreの例:簡単なHTTPクライアント 
11.26 asynchat -- 非同期ソケット コマンド/レスポンス ハンドラ 
11.26.1 asynchat - 補助クラスと関数 
11.26.2 asynchat 使用例 
12. インターネット上のデータの操作 
12.1 formatter -- 汎用の出力書式化機構 
12.1.1 formatter インタフェース 
12.1.2 formatter 実装 
12.1.3 writer インタフェース 
12.1.4 writer 実装 
12.2 email -- 電子メールと MIME 処理のためのパッケージ 
12.2.1 電子メールメッセージの表現 
12.2.2 電子メールメッセージを解析(パース)する 
12.2.3 MIME 文書を生成する 
12.2.4 電子メールおよび MIME オブジェクトをゼロから作成する 
12.2.5 国際化されたヘッダ 
12.2.6 文字セットの表現 
12.2.7 エンコーダ 
12.2.8 例外および障害クラス 
12.2.9 雑用ユーティリティ 
12.2.10 イテレータ 
12.2.11 パッケージの履歴 
12.2.12 mimelib との違い 
12.2.13 使用例 
12.3 mailcap -- mailcap ファイルの操作 
12.4 mailbox -- 様々なメールボックス形式の読み出し 
12.4.1 Mailbox オブジェクト 
12.5 mhlib -- MH のメイルボックスへのアクセス機構 
12.5.1 MH オブジェクト 
12.5.2 Folder オブジェクト 
12.5.3 Message オブジェクト 
12.6 mimetools -- MIME メッセージを解析するためのツール 
12.6.1 Message オブジェクトの追加メソッド 
12.7 mimetypes -- ファイル名を MIME 型へマップする 
12.7.1 Mime型 オブジェクト 
12.8 MimeWriter -- 汎用 MIME ファイルライター 
12.8.1 MimeWriter オブジェクト 
12.9 mimify -- 電子メイルメッセージの MIME 処理 
12.10 multifile -- 個別の部分を含んだファイル群のサポート 
12.10.1 MultiFile オブジェクト 
12.10.2 MultiFile の例 
12.11 rfc822 -- RFC 2822 準拠のメイルヘッダ読み出し 
12.11.1 Message オブジェクト 
12.11.2 AddressList オブジェクト 
12.12 base64 -- RFC 3548: Base16, Base32, Base64 テータの符号化 
12.13 binascii -- バイナリデータと ASCIIデータとの間での変換 
12.14 binhex -- binhex4 形式ファイルのエンコードおよびデコード 
12.14.1 注記 
12.15 quopri -- MIME quoted-printable 形式データのエンコードおよびデコード 
12.16 uu -- uuencode形式のエンコードとデコード 
12.17 xdrlib -- XDR データのエンコードおよびデコード 
12.17.1 Packer オブジェクト 
12.17.2 Unpacker オブジェクト 
12.17.3 例外 
12.18 netrc -- netrc ファイルの処理 
12.18.1 netrc オブジェクト 
12.19 robotparser -- robots.txt のためのパーザ 
12.20 csv -- CSV ファイルの読み書き 
12.20.1 モジュールの内容 
12.20.2 Dialect クラスと書式化パラメタ 
12.20.3 reader オブジェクト 
12.20.4 writer オブジェクト 
12.20.5 使用例 
13. 構造化マークアップツール 
13.1 HTMLParser -- HTML および XHTML のシンプルなパーザ 
13.1.1 HTML パーザアプリケーションの例 
13.2 sgmllib -- 単純な SGML パーザ 
13.3 htmllib -- HTML 文書の解析器 
13.3.1 HTMLParser オブジェクト 
13.4 htmlentitydefs -- HTML 一般エンティティの定義 
13.5 xml.parsers.expat -- Expat を使った高速な XML 解析 
13.5.2 ExpatError 例外 
13.5.3 例 
13.5.4 内容モデルの記述 
13.5.5 Expat エラー定数 
13.6 xml.dom -- 文書オブジェクトモデル (DOM) API 
13.6.1 モジュールの内容 
13.6.2 DOM 内のオブジェクト 
13.6.3 適合性 
13.7 xml.dom.minidom -- 軽量な DOM 実装 
13.7.1 DOM オブジェクト 
13.7.2 DOM の例 
13.7.3 minidom と DOM 標準 
13.8 xml.dom.pulldom -- 部分的な DOM ツリー構築のサポート 
13.8.1 DOMEventStream オブジェクト 
13.9 xml.sax -- SAX2 パーサのサポート 
13.9.1 SAXException オブジェクト 
13.10 xml.sax.handler -- SAX ハンドラの基底クラス 
13.10.1 ContentHandler オブジェクト 
13.10.2 DTDHandler オブジェクト 
13.10.3 EntityResolver オブジェクト 
13.10.4 ErrorHandler オブジェクト 
13.11 xml.sax.saxutils -- SAX ユーティリティ 
13.12 xml.sax.xmlreader -- XML パーサのインターフェース 
13.12.1 XMLReader オブジェクト 
13.12.2 IncrementalParser オブジェクト 
13.12.3 Locator オブジェクト 
13.12.4 InputSource オブジェクト 
13.12.5 The Attributes インターフェース 
13.12.6 AttributesNS インターフェース 
13.13 xmllib -- XML ドキュメントのパーサ 
13.13.1 XML 名前空間 
14. マルチメディアサービス 
14.1 audioop -- 生の音声データを操作する 
14.2 imageop -- 生の画像データを操作する 
14.3 aifc -- AIFFおよびAIFCファイルの読み書き 
14.4 sunau -- Sun AUファイルの読み書き 
14.4.1 AU_read オブジェクト 
14.4.2 AU_write オブジェクト 
14.5 wave -- WAVファイルの読み書き 
14.5.1 Wave_read オブジェクト 
14.5.2 Wave_write オブジェクト 
14.6 chunk --IFFチャンクデータの読み込み 
14.7 colorsys -- 色体系間の変換 
14.8 rgbimg -- ``SGI RGB''ファイルを読み書きする 
14.9 imghdr -- 画像の形式を決定する 
14.10 sndhdr -- サウンドファイルの識別 
14.11 ossaudiodev --OSS互換オーディオデバイスへのアクセス 
14.11.1 オーディオデバイスオブジェクト 
14.11.2 ミキサデバイスオブジェクト 
15. 暗号関連のサービス 
15.1 hmac -- メッセージ認証のための鍵付きハッシュ化 
15.2 md5 -- MD5 メッセージダイジェストアルゴリズム 
15.3 sha -- SHA-1 メッセージダイジェストアルゴリズム 
16. Tkを用いたグラフィカルユーザインターフェイス 
16.1 Tkinter -- Tcl/Tk への Python インタフェース 
16.1.1 Tkinter モジュール 
16.1.2 Tkinter お助け手帳 (life preserver) 
16.1.3 Tcl/Tk を (本当に少しだけ) 見渡してみる 
16.1.4 基本的な Tk プログラムと Tkinter との対応関係 
16.1.5 Tk と Tkinter はどのように関わっているのか 
16.1.6 簡単なリファレンス 
16.2 Tix -- Tkの拡張ウィジェット 
16.2.1 Tixを使う 
16.2.2 Tixウィジェット 
16.2.3 Tixコマンド 
16.3 ScrolledText -- スクロールするテキストウィジェット 
16.4 turtle -- Tkのためのタートルグラフィックス 
16.4.1 PenとRawPenオブジェクト 
16.5.1 メニュー 
16.5.2 基本的な編集とナビゲーション 
16.5.3 構文の色づけ 
16.6 他のグラフィカルユーザインタフェースパッケージ 
17. 制限実行 (restricted execution) 
17.1 rexec -- 制限実行のフレームワーク 
17.1.1 RExec オブジェクト 
17.1.2 制限された環境を定義する 
17.1.3 例 
17.2 Bastion -- オブジェクトに対するアクセスの制限 
18. Python言語サービス 
18.1 parser -- Python解析木にアクセスする 
18.1.1 ASTオブジェクトを作成する 
18.1.2 ASTオブジェクトを変換する 
18.1.3 ASTオブジェクトに対する問い合わせ 
18.1.4 例外とエラー処理 
18.1.5 ASTオブジェクト 
18.1.6 例 
18.2 symbol -- Python解析木と共に使われる定数 
18.3 token -- Python解析木と共に使われる定数 
18.4 keyword -- Pythonキーワードチェック 
18.5 tokenize -- Pythonソースのためのトークナイザ 
18.6 tabnanny -- あいまいなインデントの検出 
18.7 pyclbr -- Python クラスブラウザーサポート 
18.7.1 クラス記述オブジェクト 
18.7.2 関数記述オブジェクト (Function Descriptor Object) 
18.8 py_compile --Pythonソースファイルのコンパイル 
18.9 compileall -- Pythonライブラリをバイトコンパイル 
18.10 dis -- Pythonバイトコードの逆アセンブラ 
18.10.1 Pythonバイトコード命令 
18.11 distutils -- Python モジュールの構築とインストール 
19. Python コンパイラパッケージ 
19.1 基本的なインターフェイス 
19.2 制限 
19.3 Python 抽象構文 
19.3.1 AST ノード 
19.3.2 代入ノード 
19.3.3 サンプル 
19.4 Visitor を使って AST をわたり歩く 
19.5 バイトコード生成 
20. SGI IRIX 特有のサービス 
20.1 al --SGIのオーディオ機能 
20.1.1 コンフィギュレーションオブジェクト 
20.1.2 ポートオブジェクト 
20.2 AL --alモジュールで使われる定数 
20.3 cd --SGIシステムのCD-ROMへのアクセス 
20.3.1 プレーヤーオブジェクト 
20.3.2 パーザオブジェクト 
20.4 fl --グラフィカルユーザーインターフェースのためのFORMSライブラリ 
20.4.1 flモジュールに定義されている関数 
20.4.2 フォームオブジェクト 
20.4.3 FORMSオブジェクト 
20.5 FL --flモジュールで使用される定数 
20.6 flp --保存されたFORMSデザインをロードする関数 
20.7 fm -- Font Manager インターフェース 
20.8 gl -- Graphics Library インターフェース 
20.9 DEVICE --glモジュールで使われる定数 
20.10 GL --glモジュールで使われる定数 
20.11 imgfile -- SGI imglib ファイルのサポート 
20.12 jpeg -- JPEGファイルの読み書きを行う 
21. SunOS 特有のサービス 
21.1 sunaudiodev --Sunオーディオハードウェアへのアクセス 
21.1.1 オーディオデバイスオブジェクト 
21.2 SUNAUDIODEV --sunaudiodevで使われる定数 
22. MS Windows 特有のサービス 
22.1 msvcrt - MS VC++実行時システムの有用なルーチン群 
22.1.1 ファイル操作関連 
22.1.2 コンソール I/O 関連 
22.1.3 その多の関数 
22.2 _winreg - Windows レジストリへのアクセス 
22.2.1 レジストリハンドルオブジェクト 
22.3 winsound -- Windows 用の音声再生インタフェース 
A. ドキュメント化されていないモジュール 
A.1 フレームワーク 
A.2 雑多な有用ユーティリティ 
A.3 プラットフォーム特有のモジュール 
A.4 マルチメディア関連 
A.5 撤廃されたもの 
A.6 SGI 特有の拡張モジュール 
B. バグ報告 
Python ライブラリリファレンス 
1. はじめに 
リリース 2.4 ,平成18年6月27日 更新 ご意見やご指摘をお寄せになりたい方は、 
このライブラリリファレンスマニュアルでは、Macintosh用のPython拡張に関して詳しく記述します。 
Pythonの肩のこらない入門編が必要なら、 
を読んでください。 
は、構文や意味論に関する疑問を解決するため、それなりに分かった人が読むべきものです。 
最後にひとつ。 
インタプリタの拡張と組み込み Extending and Embedding the Python Interpreter 
という名のマニュアルでは、Pythonへ新たに拡張機能を追加する方法と、他のアプリケーションに組み込む方法について述べています。 
AEServer (MiniAEFrame 、ホ・ッ・鬣ケ) 
AEText (aetypes 、ホ・ッ・鬣ケ) 
Boolean (aetypes 、ホ・ッ・鬣ケ) 
Comparison (aetypes 、ホ・ッ・鬣ケ) 
ComponentItem (aetypes 、ホ・ッ・鬣ケ) 
Enum (aetypes 、ホ・ッ・鬣ケ) 
IC (ic 、ホ・ッ・鬣ケ) 
InsertionLoc (aetypes 、ホ・ッ・鬣ケ) 
IntlText (aetypes 、ホ・ッ・鬣ケ) 
IntlWritingCode (aetypes 、ホ・ッ・鬣ケ) 
Keyword (aetypes 、ホ・ッ・鬣ケ) 
Logical (aetypes 、ホ・ッ・鬣ケ) 
MiniApplication (MiniAEFrame 、ホ・ッ・鬣ケ) 
NProperty (aetypes 、ホ・ッ・鬣ケ) 
ObjectSpecifier (aetypes 、ホ・ッ・鬣ケ) 
Ordinal (aetypes 、ホ・ッ・鬣ケ) 
QDPoint (aetypes 、ホ・ッ・鬣ケ) 
QDRectangle (aetypes 、ホ・ッ・鬣ケ) 
Range (aetypes 、ホ・ッ・鬣ケ) 
RGBColor (aetypes 、ホ・ッ・鬣ケ) 
StyledText (aetypes 、ホ・ッ・鬣ケ) 
TalkTo (aetools 、ホ・ッ・鬣ケ) 
Type (aetypes 、ホ・ッ・鬣ケ) 
Unknown (aetypes 、ホ・ッ・鬣ケ) 
_quit() (Application 、ホ・皈ス・テ・ノ) 
_start() (TalkTo 、ホ・皈ス・テ・ノ) 
aetools (standard モジュール) 
aetypes (standard モジュール) 
applesingle (standard モジュール) 
Application() (FrameWork モジュール) 
as_pathname() (FSSpec のメソッド) 
as_tuple() (FSSpec のメソッド) 
AskFileForOpen() (EasyDialogs モジュール) 
AskFileForSave() (EasyDialogs モジュール) 
AskFolder() (EasyDialogs モジュール) 
AskPassword() (EasyDialogs モジュール) 
AskString() (EasyDialogs モジュール) 
AskYesNoCancel() (EasyDialogs モジュール) 
asyncevents() (Application のメソッド) 
autoGIL (extension モジュール) 
BUFSIZ (macostools モジュール) 
buildtools (standard モジュール) 
callback() (AEServer のメソッド) 
Carbon.AE (standard モジュール) 
Carbon.AH (standard モジュール) 
Carbon.App (standard モジュール) 
Carbon.CaronEvt (standard モジュール) 
Carbon.CF (standard モジュール) 
Carbon.CG (standard モジュール) 
Carbon.Cm (standard モジュール) 
Carbon.Ctl (standard モジュール) 
Carbon.Dlg (standard モジュール) 
Carbon.Evt (standard モジュール) 
Carbon.Fm (standard モジュール) 
Carbon.Folder (standard モジュール) 
Carbon.Help (standard モジュール) 
Carbon.List (standard モジュール) 
Carbon.Menu (standard モジュール) 
Carbon.Mlte (standard モジュール) 
Carbon.Qd (組み込み モジュール) 
Carbon.Qdoffs (組み込み モジュール) 
Carbon.Qt (standard モジュール) 
Carbon.Res (standard モジュール) 
Carbon.Scrap (standard モジュール) 
Carbon.Snd (standard モジュール) 
Carbon.TE (standard モジュール) 
Carbon.Win (standard モジュール) 
cfmfile (standard モジュール) 
close() (Window のメソッド) 
ColorPicker (extension モジュール) 
copy() (macostools モジュール) 
copytree() (macostools モジュール) 
Creator (FInfo の属性) 
curval (ProgressBar の属性) 
data (Alias の属性) 
data (FSSpec の属性) 
DebugStr() (MacOS モジュール) 
DialogWindow() (FrameWork モジュール) 
distutils ( モジュール) 
do_activate() (IC のメソッド) 
do_activate() (ScrolledWindow のメソッド) 
do_char() (Application のメソッド) 
do_contentclick() (Window のメソッド) 
do_controlhit() (ControlsWindow のメソッド) 
do_controlhit() (ScrolledWindow のメソッド) 
do_dialogevent() (Application のメソッド) 
do_itemhit() (DialogWindow のメソッド) 
do_postresize() (ScrolledWindow のメソッド) 
do_postresize() (Window のメソッド) 
do_update() (Window のメソッド) 
EasyDialogs (standard モジュール) 
FindApplication() (macfs モジュール) 
findertools (standard モジュール) 
FindFolder() (macfs モジュール) 
FInfo() (macfs モジュール) 
Flags (FInfo の属性) 
Fldr (FInfo の属性) 
FrameWork (standard モジュール) FrameWork (標準 モジュール) 
FSSpec() (macfs モジュール) 
gensuitemodule (standard モジュール) 
getabouttext() (Application のメソッド) 
GetArgv() (EasyDialogs モジュール) 
GetColor() (ColorPicker モジュール) 
GetCreatorAndType() (MacOS モジュール) 
GetCreatorType() (FSSpec のメソッド) 
GetDates() (FSSpec のメソッド) 
GetDirectory() (macfs モジュール) 
GetErrorString() (MacOS モジュール) 
GetFInfo() (FSSpec のメソッド) 
GetInfo() (Alias のメソッド) 
getscrollbarvalues() (ScrolledWindow のメソッド) 
GetTicks() (MacOS モジュール) 
HandleEvent() (MacOS モジュール) 
ic (組み込み モジュール) 
icglue (組み込み モジュール) 
icopen (standard モジュール) 
idle() (Application のメソッド) 
inc() (ProgressBar のメソッド) 
installaehandler() (AEServer のメソッド) 
installAutoGIL() (autoGIL モジュール) 
keysubst() (aetools モジュール) 
label() (ProgressBar のメソッド) 
launch() (findertools モジュール) 
launchurl() (IC のメソッド) 
launchurl() (ic モジュール) 
linkmodel (MacOS モジュール) 
Location (FInfo の属性) 
mac (組み込み モジュール) 
macerrors (standard モジュール) macerrors (標準 モジュール) 
macfs (standard モジュール) 
MacOS (組み込み モジュール) 
macostools (standard モジュール) 
macpath (standard モジュール) 
macresource (standard モジュール) 
mainloop() (Application のメソッド) 
makeusermenus() (Application のメソッド) 
mapfile() (IC のメソッド) 
mapfile() (ic モジュール) 
maptypecreator() (IC のメソッド) 
maptypecreator() (ic モジュール) 
maxval (ProgressBar の属性) 
Menu() (FrameWork モジュール) 
MenuBar() (FrameWork モジュール) 
MenuItem() (FrameWork モジュール) 
Message() (EasyDialogs モジュール) 
MiniAEFrame (standard モジュール) 
mkalias() (macostools モジュール) 
mkcwproject (standard モジュール) 
move() (findertools モジュール) 
Nav (standard モジュール) 
NewAlias() (FSSpec のメソッド) 
NewAliasMinimal() (FSSpec のメソッド) 
NewAliasMinimalFromFullPath() (macfs モジュール) 
nsremote (standard モジュール) 
open() (DialogWindow のメソッド) 
open() (Window のメソッド) 
openrf() (MacOS モジュール) 
os (標準 モジュール) 
os.path (標準 モジュール) 
pack() (aepack モジュール) 
packevent() (aetools モジュール) 
parseurl() (IC のメソッド) 
parseurl() (ic モジュール) 
PixMapWrapper (standard モジュール) 
preferences (standard モジュール) 
Print() (findertools モジュール) 
processfile() (gensuitemodule モジュール) 
processfile_fromresource() (gensuitemodule モジュール) 
ProgressBar() (EasyDialogs モジュール) 
PromptGetFile() (macfs モジュール) 
py_resource (standard モジュール) 
PYTHONPATH (環境変数) 
pythonprefs (standard モジュール) 
quietconsole (standard モジュール) 
RawAlias() (macfs モジュール) 
RawFSSpec() (macfs モジュール) 
Resolve() (Alias のメソッド) 
ResolveAliasFile() (macfs モジュール) 
restart() (findertools モジュール) 
runtimemodel (MacOS モジュール) 
scalebarvalues() (ScrolledWindow のメソッド) 
SchedParams() (MacOS モジュール) 
scrollbar_callback() (ScrolledWindow のメソッド) 
scrollbars() (ScrolledWindow のメソッド) 
send() (TalkTo のメソッド) 
Separator() (FrameWork モジュール) 
set() (ProgressBar のメソッド) 
setarrowcursor() (FrameWork モジュール) 
SetCreatorAndType() (MacOS モジュール) 
SetCreatorType() (FSSpec のメソッド) 
SetDates() (FSSpec のメソッド) 
SetEventHandler() (MacOS モジュール) 
SetFInfo() (FSSpec のメソッド) 
SetFolder() (macfs モジュール) 
settypecreator() (IC のメソッド) 
settypecreator() (ic モジュール) 
setwatchcursor() (FrameWork モジュール) 
shutdown() (findertools モジュール) 
sleep() (findertools モジュール) 
splash() (MacOS モジュール) 
StandardGetFile() (macfs モジュール) 
StandardPutFile() (macfs モジュール) 
SubMenu() (FrameWork モジュール) 
SysBeep() (MacOS モジュール) 
title() (ProgressBar のメソッド) 
touched() (macostools モジュール) 
Type (FInfo の属性) 
unpack() (aepack モジュール) 
unpackevent() (aetools モジュール) 
Update() (Alias のメソッド) 
updatescrollbars() (ScrolledWindow のメソッド) 
videoreader (standard モジュール) 
W (standard モジュール) 
waste (standard モジュール) 
Window() (FrameWork モジュール) 
windowbounds() (FrameWork モジュール) 
1. C や C++ による Python の拡張 
1.1 簡単な例 
1. C や C++ による Python の拡張 
グローバルモジュールインデクス 
モジュール名の後ろにある注釈は、利用できるプラットフォームを表しています。 
ご意見やご指摘をお寄せになりたい方は、 
C.3 差分翻訳者一覧 (敬称略) 
1. Mac OS 9でPythonを利用する 
1.1 MacPython-OSXの取得とインストール 
1.1.1 Python スクリプトの実行方法 
1.1.2 GUI つきのスクリプトの実行 
1.1.3 設定 
1.2 MacPython-OS9 の取得とインストール 
1.2.1 対話型インタプリタを使う 
1.2.2 Pythonスクリプトの走らせ方 
1.2.3 コマンドライン引数をシミュレートする 
1.2.4 Pythonスクリプトを作成する 
1.3 統合開発環境 
1.3.1 ``Python Interactive''ウィンドウを使う 
1.3.2 Pythonスクリプトを書く 
1.3.3 統合開発環境の中からスクリプトを実行する 
1.3.4 ``Save as'' と ``Save as Applet'' の違い 
2. MacPython モジュール 
2.1 mac -- os モジュールの実装 
2.2 macpath -- MacOS のパス操作関数 
2.3 macfs --様々なファイルシステム関連のサービス 
2.3.1 FSSpec オブジェクト 
2.3.2 エイリアスオブジェクト 
2.3.3 FInfo オブジェクト 
2.4 ic --インターネット設定へのアクセス 
2.4.1 IC オブジェクト 
2.5 MacOS -- Mac OS インタプリタ機能へのアクセス 
2.6 macostools --ファイル操作を便利にするルーチン集 
2.7 findertools --finder のApple Eventsインターフェース 
2.8 EasyDialogs -- 基本的な Macintosh ダイアログ 
2.8.1 プログレスバーオブジェクト 
2.9 FrameWork -- 対話型アプリケーション・フレームワーク 
2.9.1 アプリケーションオブジェクト 
2.9.2 ウィンドウオブジェクト 
2.9.3 コントロールウィンドウオブジェクト 
2.9.4 スクロールウィンドウオブジェクト 
2.9.5 ダイアログウィンドウオブジェクト 
2.10 autoGIL -- イベントループ中のグローバルインタープリタの取り扱い 
3. MacPython OSA モジュール 
3.1 gensuitemodule -- OSA スタプ作成パッケージ 
3.2 aetools -- OSA クライアントのサポート 
3.3 aepack -- Python変数とAppleEventデータコンテナ間の変換 
3.4 aetypes -- AppleEvent オブジェクト 
3.5 MiniAEFrame --オープンスクリプティングアーキテクチャサーバのサポート 
3.5.1 AEServer オブジェクト 
4. MacOS ツールボックスモジュール 
4.2 Carbon.AH -- Apple ヘルプ 
4.3 Carbon.App -- アピアランスマネージャ 
4.25 ColorPicker -- 色選択ダイアログ 
5. 文書化されていないモジュール 
5.1 applesingle -- AppleSingle デコーダー 
5.2 buildtools -- BuildAppletとその仲間のヘルパーモジュール 
5.3 py_resource -- Python コードからのリソース生成 
5.4 cfmfile -- コードフラグメントリソースを扱うモジュール 
5.5 icopen -- open()と Internet Config の置き換え 
5.6 macerrors -- MacOSのエラー 
5.7 macresource -- スクリプトのリソースを見つける 
5.8 Nav -- NavServices の呼出し 
5.9 mkcwproject -- CodeWarrior プロジェクトの作成 
5.10 nsremote -- Netscape OSAモジュールのラッパー 
5.11 PixMapWrapper -- PixMapオブジェクトのラッパー 
5.12 preferences -- アプリケーション初期設定管理プログラム 
5.13 pythonprefs -- Python の初期設定管理プログラム 
5.14 quietconsole -- 不可視の標準出力 
5.15 videoreader -- QuickTime ムービーの読み込み 
5.16 W -- FrameWork 上に作られたウイジェット 
5.17 waste -- Apple製ではない TextEdit の置き換え 
A. 歴史とライセンス 
A.1 Python の歴史 
Macintoshモジュールリファレンス 
Python はインタプリタ形式の、オブジェクト指向な高レベルプログラミング言語で、動的なセマンティクスを持っています。 
Python の高レベルな組み込みデータ構造は、動的な型付け機能や動的な結合機能と組み合わせることで、迅速なアプリケーション開発や既存のソフトウェアコンポーネント間をつなぐスクリプト言語、または糊 (glue) 言語として Python を魅力的な存在にしています。 
Python は単純で学びやすい文法なので、可読性が高まり、プログラムのメンテナンスにかかるコストを低減します。 
Python は、プログラムのモジュール化や再利用を助けるモジュールとパッケージをサポートします。 
Python インタプリタと多数の標準ライブラリは、ほとんどのプラットフォームでソースコード形式でもバイナリ形式でも無料で入手することができ、無料で配布することができます。 このリファレンスマニュアルでは、Python 言語の文法と、``コアとなるセマンティクス'' について記述します。 
このマニュアルはそっけない書き方かもしれませんが、的確かつ完璧な記述を目指しています。 必須でない組み込みオブジェクト型や組み込み関数、組み込みモジュールに関するセマンティクスは、 
で述べられています。 
形式ばらない Python 言語入門には、 
C 言語あるいは C++ プログラマ向けには、このマニュアルとは別に二つのマニュアルがあります: 
Python インタプリタの拡張と埋め込み 
では、Python 拡張モジュールを書くための高レベルな様式について述べています。 また、 
Python/C API リファレンスマニュアル 
では、C/C++ プログラマが利用できるインタフェースについて詳細に記述しています。 
・ 
__abs__() (numeric object 、ホ・皈ス・テ・ノ) 
__add__() (numeric object 、ホ・皈ス・テ・ノ) 
__and__() (numeric object 、ホ・皈ス・テ・ノ) 
__builtin__ (チネ、゜ケ モジュール),[Link] 
__call__() (object のメソッド) 
__coerce__() (numeric object のメソッド) 
__complex__() (numeric object のメソッド) 
__contains__() (container object のメソッド) 
__del__() (object のメソッド) 
__delattr__() (object のメソッド) 
__delete__() (object のメソッド) 
__delitem__() (container object のメソッド) 
__delslice__() (sequence object のメソッド) 
__div__() (numeric object のメソッド) 
__divmod__() (numeric object のメソッド) 
__eq__() (object のメソッド) 
__float__() (numeric object のメソッド) 
__floordiv__() (numeric object のメソッド) 
__ge__() (object のメソッド) 
__get__() (object のメソッド) 
__getattr__() (object のメソッド) 
__getattribute__() (object のメソッド) 
__getitem__() (container object のメソッド) 
__getslice__() (sequence object のメソッド) 
__gt__() (object のメソッド) 
__hash__() (object のメソッド) 
__hex__() (numeric object のメソッド) 
__iadd__() (numeric object のメソッド) 
__iand__() (numeric object のメソッド) 
__idiv__() (numeric object のメソッド) 
__ifloordiv__() (numeric object のメソッド) 
__ilshift__() (numeric object のメソッド) 
__imod__() (numeric object のメソッド) 
__import__() (組み込み関数) 
__imul__() (numeric object のメソッド) 
__init__() (object のメソッド) __init__.py 
__int__() (numeric object のメソッド) 
__invert__() (numeric object のメソッド) 
__ior__() (numeric object のメソッド) 
__ipow__() (numeric object のメソッド) 
__irshift__() (numeric object のメソッド) 
__isub__() (numeric object のメソッド) 
__iter__() (container object のメソッド) 
__itruediv__() (numeric object のメソッド) 
__ixor__() (numeric object のメソッド) 
__le__() (object のメソッド) 
__len__() (container object のメソッド) 
__long__() (numeric object のメソッド) 
__lshift__() (numeric object のメソッド) 
__lt__() (object のメソッド) 
__main__ (組み込み モジュール),[Link],[Link] 
__mod__() (numeric object のメソッド) 
__mul__() (numeric object のメソッド) 
__ne__() (object のメソッド) 
__neg__() (numeric object のメソッド) 
__oct__() (numeric object のメソッド) 
__or__() (numeric object のメソッド) 
__pos__() (numeric object のメソッド) 
__pow__() (numeric object のメソッド) 
__radd__() (numeric object のメソッド) 
__rand__() (numeric object のメソッド) 
__rcmp__() (object のメソッド) 
__rdiv__() (numeric object のメソッド) 
__rdivmod__() (numeric object のメソッド) 
__repr__() (object のメソッド) 
__rfloordiv__() (numeric object のメソッド) 
__rlshift__() (numeric object のメソッド) 
__rmod__() (numeric object のメソッド) 
__rmul__() (numeric object のメソッド) 
__ror__() (numeric object のメソッド) 
__rpow__() (numeric object のメソッド) 
__rrshift__() (numeric object のメソッド) 
__rshift__() (numeric object のメソッド) 
__rsub__() (numeric object のメソッド) 
__rtruediv__() (numeric object のメソッド) 
__rxor__() (numeric object のメソッド) 
__set__() (object のメソッド) 
__setattr__() (object method) __setattr__() (object のメソッド) 
__setitem__() (container object のメソッド) 
__setslice__() (sequence object のメソッド) 
__str__() (object のメソッド) 
__sub__() (numeric object のメソッド) 
__truediv__() (numeric object のメソッド) 
__unicode__() (object のメソッド) 
__xor__() (numeric object のメソッド) 
abs() (組み込み関数) 
array (標準 モジュール) 
bsddb (標準 モジュール) 
chr() (組み込み関数),[Link] 
cmp() (組み込み関数) 
compile() (組み込み関数) 
complex() (組み込み関数) 
divmod() (組み込み関数),[Link] 
キーワード 
キーワード,[Link],[Link],[Link],[Link] 
eval() (組み込み関数),[Link],[Link] 
execfile() (組み込み関数) 
キーワード,[Link],[Link],[Link] 
float() (組み込み関数) 
キーワード,[Link] 
gdbm (標準 モジュール) 
globals() (組み込み関数) 
hex() (組み込み関数) 
id() (組み込み関数) 
indices() (slice のメソッド) 
input() (組み込み関数) 
int() (組み込み関数) 
len() (組み込み関数),[Link],[Link] 
locals() (組み込み関数) 
long() (組み込み関数) 
oct() (組み込み関数) 
open() (組み込み関数) 
ord() (組み込み関数),[Link],[Link] 
pow() (組み込み関数),[Link],[Link],[Link] 
range() (組み込み関数) 
raw_input() (組み込み関数) 
repr() (組み込み関数),[Link],[Link] 
slice() (組み込み関数) 
str() (組み込み関数),[Link] 
sys (組み込み モジュール),[Link],[Link],[Link] 
type() (組み込み関数) 
unichr() (組み込み関数) 
unicode() (組み込み関数),[Link] 
except ・ュ。 
Python 2.4 ドキュメント - June 27, 2006 
Python ドキュメント 
チュートリアル 
(ここから読み始めてください) 
Python 更新情報 (英語) 
(一つ前のメジャーリリースからの変更) 
(全ドキュメントにすばやくアクセスできます) ライブラリリファレンス 
(枕の下にいつも置いておきましょう) Macintosh モジュールリファレンス 
(Macintosh を使っているならこれも) Python モジュールのインストール 
(管理者向け) Python モジュールの配布 
(開発者,パッケージ作成者向け) 
リファレンスマニュアル 
(弁語士向け) 拡張と埋め込み 
(C/C++ プログラマ向けチュートリアル) Python/C API 
(C/C++ プログラマ向けリファレンス) Python ドキュメントの作成 
(ドキュメント作者用の情報) 
ドキュメント作成本部 (英語) 
(すべての人に) 
Python How-To ガイド (英語) 
(専門的な話題) 
Python ライブラリリファレンス 
Python 言語のコア部分では、これらの型に対してリテラル表現形式を与え、意味づけ上のいくつかの制約を与えていますが、完全にその意味づけを定義しているわけではありません。 
(一方で、言語のコア部分では演算子のスペルや優先順位のような構文法的な属性を定義しています。 ) このライブラリにはまた、組み込み関数と例外が納められています --組み込み関数および例外は、全ての Python で書かれたコード上で、import 文を使わずに使うことができるオブジェクトです。 
あるモジュールは C 言語で書かれ、Python インタプリタに組み込まれています; 一方別のモジュールは Python で書かれ、ソースコードの形式で取り込まれます。 
つまり、このマニュアルを最初から読み始め、読み飽き始めたところで次の章に進めば、Python ライブラリで利用できるモジュールやサポートしているアプリケーション領域の概要をそこそこ理解できるということです。 
もちろん、このマニュアルを小説のように読む必要はありません-- (マニュアルの先頭部分にある) 目次にざっと目を通したり、(最後尾にある) 索引でお目当ての関数やモジュール、用語を探すことだってできます。 
もしランダムな項目について勉強してみたいのなら、ランダムにページを選び ( 
参照)、そこから1, 2 節読むこともできます。 
Python モジュールのインストール 
7 日本語訳について 
1. 導入 
1.1 本マニュアルにおける表記法 
2. 字句解析 
2.1 行構造 
2.1.1 論理行 (logical line) 
2.1.2 物理行 (physical line) 
2.1.3 コメント 
2.1.4 エンコード宣言 (encoding declaration) 
2.1.5 明示的な行継続 
2.1.6 非明示的な行継続 
2.1.7 空行 
2.1.8 インデント 
2.1.9 トークン間の空白 
2.2 その他のトークン 
2.3 識別子 (identifier) およびキーワード (keyword) 
2.3.1 キーワード (keyword) 
2.3.2 予約済みの識別子種 (reserved classes of identifiers) 
2.4.3 数値リテラル 
2.4.4 整数および長整数リテラル 
2.4.5 浮動小数点数リテラル 
2.4.6 虚数 (imaginary) リテラル 
2.5 演算子 (operator) 
2.6 デリミタ (delimiter) 
3.3.1 基本的なカスタマイズ 
3.3.2 属性値アクセスをカスタマイズする 
3.3.3 クラス生成をカスタマイズする 
3.3.4 呼び出し可能オブジェクトをエミュレートする 
3.3.5 コンテナをエミュレートする 
3.3.6 シーケンス型エミュレーションで使われるその他のメソッド 
3.3.7 数値型をエミュレーションする 
3.3.8 型強制規則 (coercion rule) 
4.1 名前づけと束縛 (naming and binding) 
4.1.1 動的な機能とのやりとり 
5.1 算術変換 (arithmetic conversion) 
5.2 アトム、原子的要素 (atom) 
5.2.1 識別子 (identifier、または名前 (name)) 
5.2.2 リテラル 
5.2.3 丸括弧形式 (parenthesized form) 
5.2.4 リスト表現 
5.2.5 ジェネレータ式 
5.2.6 辞書表現 
5.2.7 文字列変換 
5.3 一次語 (primary) 
5.3.1 属性参照 
5.3.2 添字表記 (subscription) 
5.3.3 スライス表記 (slicing) 
5.3.4 呼び出し (call) 
5.4 べき乗演算 (power operator) 
5.5 単項算術演算 (unary arithmetic operation) 
5.6 二項算術演算 (binary arithmetic operation) 
5.7 シフト演算 (shifting operation) 
5.8 ビット単位演算の二項演算 (binary bit-wise operation) 
5.11 ラムダ (lambda) 
5.12 式のリスト 
5.13 評価順序 
5.14 まとめ 
6. 単純文 (simple statement) 
6.1 式文 (expression statement) 
6.2 Assert 文 (assert statement) 
6.3 代入文 (assignment statement) 
6.3.1 累算代入文 (augmented assignment statement) 
6.4 pass 文 
6.5 del 文 
6.6 print 文 
6.7 return 文 
6.8 yield 文 
6.9 raise 文 
6.10 break 文 
6.11 continue 文 
6.12 import 文 
6.12.1 future 文 (future statement) 
6.13 global 文 
6.14 exec 文 
7. 複合文 (compound statement) 
7.1 if 文 
7.2 while 文 
7.3 for 文 
7.4 try 文 
7.5 関数定義 
7.6 クラス定義 
8. トップレベル要素 
8.1 完全な Python プログラム 
8.2 ファイル入力 
8.3 対話的入力 
8.4 式入力 
Python リファレンスマニュアル 
1 はじめに 
Email: distutils-sig@python.org 日本語訳: Python ドキュメント翻訳プロジェクト 
平成18年6月27日 
このドキュメントでは、 Python モジュール配布ユーティリティ(Python Distribution Utilities, ``Distutils'') について、 エンドユーザの視点に立ち、サードパーティ製のモジュールや拡張モジュールの構築やインストールによって標準の Python に機能を追加する方法について述べます。 
1.1 もっとも簡単な場合: ありふれたインストール作業 
1.2 新しい標準: Distutils 
2 標準的なビルド・インストール作業 
2.1 プラットフォームによる違い 
2.2 ビルド作業とインストール作業を分割する 
2.3 ビルドの仕組み 
2.4 インストールの仕組み 
3 別の場所へのインストール 
3.1 別の場所へのインストール: home スキーム 
3.2 別の場所へのインストール: Unix (prefix スキーム) 
3.3 別の場所へのインストール (prefix を使う方法): Windows 
4 カスタムのインストール 
4.1 Python サーチパスの変更 
5 Distutils 設定ファイル 
5.1 設定ファイルの場所と名前 
5.2 設定ファイルの構文 
6 拡張モジュールのビルド: 小技と豆知識 
6.1 コンパイラ/リンカのフラグをいじるには 
6.2 Windows で非 Microsoft コンパイラを使ってビルドするには 
3.1 sys --システムパラメータと関数 
3.2 gc --ガベージコレクタ インターフェース 
3.3 weakref --弱参照 
3.4 fpectl --浮動小数点例外の制御 
3.5 atexit --終了ハンドラ 
3.6 types --組み込み型の名前 
3.7 UserDict --辞書オブジェクトのためのクラスラッパー 
3.8 UserList --リストオブジェクトのためのクラスラッパー 
3.9 UserString --文字列オブジェクトのためのクラスラッパー 
3.10 operator --関数形式の標準演算子 
3.11 inspect --使用中オブジェクトの情報を取得する 
3.12 traceback --スタックトレースの表示や取り出し 
3.13 linecache --テキストラインにランダムアクセスする 
3.16 copy_reg --pickleサポート関数を登録する 
3.17 shelve --Python オブジェクトの永続化 
3.18 copy -- 浅いコピーおよび深いコピー操作 
3.19 marshal --内部使用向けの Python オブジェクト整列化 
3.20 warnings --警告の制御 
3.21 imp --import内部へアクセスする 
3.22 pkgutil --パッケージ拡張ユーティリティ 
3.23 code --インタプリタ基底クラス 
3.24 codeop --Pythonコードをコンパイルする 
3.25 pprint --データ出力の整然化 
3.26 repr --もう一つのrepr()の実装 
3.27 new --ランタイム内部オブジェクトの作成 
3.28 site --サイト固有の設定フック 
3.29 user --ユーザー設定のフック 
3.30 __builtin__ --組み込み関数 
3.31 __main__ --トップレベルのスクリプト環境 
3.32 __future__ --Future ステートメントの定義 
4.1 string --一般的な文字列操作 
4.2 re -- 正規表現操作 
4.3 struct --文字列データをパックされたバイナリデータとして解釈する 
4.4 difflib --差異の計算を助ける 
4.5 fpformat --浮動小数点の変換 
4.6 StringIO --ファイルのように文字列を読み書きする 
4.7 cStringIO --高速化された StringIO 
4.8 textwrap --テキストの折り返しと詰め込み 
4.9 codecs --codec レジストリと基底クラス 
4.9.3 encodings.idna --アプリケーションにおける国際化ドメイン名 (IDNA) 
4.10 unicodedata --Unicode データベース 
4.11 stringprep --インターネットのための文字列調製 
5.1 pydoc --ドキュメント生成とオンラインヘルプシステム 
5.2 doctest --対話モードを使った使用例の内容をテストする 
5.2.1 簡単な利用法: docstring 中の例題をチェックする 
5.2.2 簡単な利用法: テキストファイル中の例題をチェックする 
5.3 unittest --単体テストフレームワーク 
5.4 test --Python用回帰テストパッケージ 
5.4.3 test.test_support --テストのためのユーティリティ関数 
5.5 decimal --10進浮動小数点数の算術演算 
5.6 math --数学関数 
5.7 cmath --複素数のための数学関数 
5.8 random --擬似乱数を生成する 
5.9 whrandom --擬似乱数生成器 
5.10 bisect --配列二分法アルゴリズム 
5.11 collections --高性能なコンテナ・データ型 
5.12 heapq --ヒープキューアルゴリズム 
5.13 array --効率のよい数値アレイ 
5.14 sets --ユニークな要素の順序なしコレクション 
5.15 itertools --効率的なループ実行のためのイテレータ生成関数 
5.16 ConfigParser --設定ファイルの構文解析器 
5.17 fileinput --複数の入力ストリームをまたいだ行の繰り返し処理をサポートする。 
5.18 calendar --一般的なカレンダーに関する関数群 
5.19 cmd --行指向のコマンドインタープリタのサポート 
5.20 shlex --単純な字句解析 
6.1 os --雑多なオペレーティングシステムインタフェース 
6.2 os.path --共通のパス名操作 
6.3 dircache --キャッシュされたディレクトリ一覧の生成 
6.4 stat --stat() の返す内容を解釈する 
6.5 statcache --os.stat() の最適化 
6.6 statvfs --os.statvfs() で使われる定数群 
6.7 filecmp --ファイルおよびディレクトリの比較 
6.9 popen2 --アクセス可能な I/O ストリームを持つ子プロセス生成 
6.10 datetime --基本的な日付型および時間型 
6.11 time --時刻データへのアクセスと変換 
6.12 sched --イベントスケジューラ 
6.13 mutex --排他制御 
6.14 getpass-- 可搬性のあるパスワード入力機構 
6.15 curses --文字セル表示のための端末操作 
6.16 curses.textpad --curses プログラムのためのテキスト入力ウィジェット 
6.17 curses.wrapper --curses プログラムのための端末ハンドラ 
6.19 curses.panel --curses のためのパネルスタック拡張 
6.20 getopt --コマンドラインオプションのパーザ 
6.21 optparse --より強力なコマンドラインオプション解析器 
6.22 tempfile -- 一時的なファイルやディレクトリの生成 
6.23 errno --標準の errno システムシンボル 
6.24 glob --Unix 形式のパス名のパターン展開 
6.25 fnmatch --Unix ファイル名のパターンマッチ 
6.26 shutil --高レベルなファイル操作 
6.27 locale --国際化サービス 
6.28 gettext --多言語対応に関する国際化サービス 
6.29 logging --Python 用ロギング機能 
7.1 signal --非同期イベントにハンドラを設定する 
7.2 socket --低レベルネットワークインターフェース 
7.3 select --I/O 処理の完了を待機する 
7.4 thread --マルチスレッドのコントロール 
7.5 threading --高水準のスレッドインタフェース 
7.6 dummy_thread --thread の代替モジュール 
7.7 dummy_threading --threading の代替モジュール 
7.8 Queue --同期キュークラス 
7.10 anydbm -- DBM 形式のデータベースへの汎用アクセスインタフェース 
7.11 dbhash --BSD データベースライブラリへの DBM 形式のインタフェース 
7.12 whichdb --どのDBMモジュールがデータベースを作ったかを推測する 
7.13 bsddb -- Berkeley DB ライブラリへのインタフェース 
7.14 dumbdbm --可搬性のある DBM 実装 
7.15 zlib --gzip 互換の圧縮 
7.16 gzip --gzip ファイルのサポート 
7.17 bz2 --bzip2 互換の圧縮ライブラリ 
7.18 zipfile -- ZIP アーカイブの処理 
7.20 readline --GNU readline のインタフェース 
7.21 rlcompleter --GNU readline向け補完関数 
8.1 posix --最も一般的な POSIX システムコール群 
8.2 pwd --パスワードデータベースへのアクセスを提供する 
8.3 grp --グループデータベースへのアクセス 
8.4 crypt --Unix パスワードをチェックするための関数 
8.5 dl --共有オブジェクトのC関数の呼び出し 
8.6 dbm --UNIX dbmのシンプルなインタフェース 
8.7 gdbm -- GNU による dbm の再実装 
8.8 termios --POSIX スタイルの端末制御 
8.9 tty --端末制御のための関数群 
8.10 pty --擬似端末ユーティリティ 
8.11 fcntl --fcntl() および ioctl() システムコール 
8.12 pipes --シェルパイプラインへのインタフェース 
8.13 posixfile --ロック機構をサポートするファイル類似オブジェクト 
8.14 resource --リソース使用状態の情報 
8.15 nis --Sun の NIS (Yellow Pages) へのインタフェース 
8.16 syslog --Unix syslog ライブラリルーチン群 
8.17 commands --コマンド実行ユーティリティ 
10.9 hotshot --ハイパフォーマンス・ロギング・プロファイラ 
10.10 timeit --小さなコード断片の実行時間計測 
11.1 webbrowser --便利なウェブブラウザコントローラー 
11.2 cgi --CGI (ゲートウェイインタフェース規格) のサポート 
11.3 cgitb -- CGI スクリプトのトレースバック管理機構 
11.4 urllib --URL による任意のリソースへのアクセス 
11.5 urllib2 --URL を開くための拡張可能なライブラリ 
11.6 httplib --HTTP プロトコルクライアント 
11.7 ftplib --FTPプロトコルクライアント 
11.8 gopherlib --gopher プロトコルのクライアント 
11.9 poplib --POP3 プロトコルクライアント 
11.10 imaplib --IMAP4 プロトコルクライアント 
11.11 nntplib --NNTP プロトコルクライアント 
11.12 smtplib --SMTP プロトコル クライアント 
11.13 smtpd --SMTP サーバ 
11.14 telnetlib --Telnet クライアント 
11.15 urlparse --URL を解析して構成要素にする 
11.16 SocketServer -- ネットワークサーバ構築のためのフレームワーク 
11.17 BaseHTTPServer --基本的な機能を持つ HTTP サーバ 
11.18 SimpleHTTPServer --簡潔な HTTP リクエストハンドラ 
11.19 CGIHTTPServer -- CGI 実行機能付き HTTP リクエスト処理機構 
11.20 cookielib --HTTP クライアント用の Cookie 処理 
11.21 Cookie --HTTPの状態管理 
11.23 SimpleXMLRPCServer --基本的なXML-RPCサーバー 
11.24 DocXMLRPCServer --セルフ-ドキュメンティング XML-RPC サーバ 
11.25 asyncore --非同期ソケットハンドラ 
11.26 asynchat --非同期ソケット コマンド/レスポンス ハンドラ 
12.1 formatter --汎用の出力書式化機構 
12.2 email --電子メールと MIME 処理のためのパッケージ 
12.3 mailcap --mailcap ファイルの操作 
12.4 mailbox --様々なメールボックス形式の読み出し 
12.5 mhlib --MH のメイルボックスへのアクセス機構 
12.6 mimetools --MIME メッセージを解析するためのツール 
12.7 mimetypes --ファイル名を MIME 型へマップする 
12.8 MimeWriter --汎用 MIME ファイルライター 
12.9 mimify --電子メイルメッセージの MIME 処理 
12.10 multifile --個別の部分を含んだファイル群のサポート 
12.11 rfc822 --RFC 2822 準拠のメイルヘッダ読み出し 
12.12 base64 --RFC 3548: Base16, Base32, Base64 テータの符号化 
12.13 binascii --バイナリデータと ASCIIデータとの間での変換 
12.14 binhex --binhex4 形式ファイルのエンコードおよびデコード 
12.15 quopri --MIME quoted-printable 形式データのエンコードおよびデコード 
12.16 uu --uuencode形式のエンコードとデコード 
12.17 xdrlib --XDR データのエンコードおよびデコード 
12.18 netrc --netrc ファイルの処理 
13.1 HTMLParser --HTML および XHTML のシンプルなパーザ 
13.2 sgmllib --単純な SGML パーザ 
13.3 htmllib --HTML 文書の解析器 
13.4 htmlentitydefs --HTML 一般エンティティの定義 
13.5 xml.parsers.expat --Expat を使った高速な XML 解析 
13.6 xml.dom --文書オブジェクトモデル (DOM) API 
13.7 xml.dom.minidom --軽量な DOM 実装 
13.8 xml.dom.pulldom --部分的な DOM ツリー構築のサポート 
13.9 xml.sax --SAX2 パーサのサポート 
13.10 xml.sax.handler --SAX ハンドラの基底クラス 
13.11 xml.sax.saxutils --SAX ユーティリティ 
13.12 xml.sax.xmlreader --XML パーサのインターフェース 
13.13 xmllib --XML ドキュメントのパーサ 
14.1 audioop -- 生の音声データを操作する 
14.2 imageop --生の画像データを操作する 
14.3 aifc --AIFFおよびAIFCファイルの読み書き 
14.4 sunau --Sun AUファイルの読み書き 
14.5 wave --WAVファイルの読み書き 
14.6 chunk --IFFチャンクデータの読み込み 
14.7 colorsys --色体系間の変換 
14.8 rgbimg -- ``SGI RGB''ファイルを読み書きする 
14.9 imghdr --画像の形式を決定する 
14.10 sndhdr -- サウンドファイルの識別 
14.11 ossaudiodev --OSS互換オーディオデバイスへのアクセス 
15.1 hmac --メッセージ認証のための鍵付きハッシュ化 
15.2 md5 --MD5 メッセージダイジェストアルゴリズム 
15.3 sha --SHA-1 メッセージダイジェストアルゴリズム 
16.1 Tkinter --Tcl/Tk への Python インタフェース 
16.2 Tix -- Tkの拡張ウィジェット 
16.3 ScrolledText -- スクロールするテキストウィジェット 
16.4 turtle --Tkのためのタートルグラフィックス 
17.1 rexec --制限実行のフレームワーク 
17.2 Bastion -- オブジェクトに対するアクセスの制限 
18.1 parser --Python解析木にアクセスする 
18.2 symbol --Python解析木と共に使われる定数 
18.3 token --Python解析木と共に使われる定数 
18.4 keyword --Pythonキーワードチェック 
18.5 tokenize --Pythonソースのためのトークナイザ 
18.6 tabnanny --あいまいなインデントの検出 
18.7 pyclbr --Python クラスブラウザーサポート 
18.8 py_compile --Pythonソースファイルのコンパイル 
18.9 compileall --Pythonライブラリをバイトコンパイル 
18.10 dis --Pythonバイトコードの逆アセンブラ 
18.11 distutils --Python モジュールの構築とインストール 
20.1 al --SGIのオーディオ機能 
20.2 AL --alモジュールで使われる定数 
20.3 cd --SGIシステムのCD-ROMへのアクセス 
20.4 fl --グラフィカルユーザーインターフェースのためのFORMSライブラリ 
20.5 FL --flモジュールで使用される定数 
20.6 flp --保存されたFORMSデザインをロードする関数 
20.7 fm --Font Manager インターフェース 
20.8 gl --Graphics Library インターフェース 
20.9 DEVICE --glモジュールで使われる定数 
20.10 GL --glモジュールで使われる定数 
20.11 imgfile --SGI imglib ファイルのサポート 
20.12 jpeg --JPEGファイルの読み書きを行う 
21.1 sunaudiodev --Sunオーディオハードウェアへのアクセス 
21.2 SUNAUDIODEV --sunaudiodevで使われる定数 
22.1 msvcrt -MS VC++実行時システムの有用なルーチン群 
22.2 _winreg -Windows レジストリへのアクセス 
22.3 winsound --Windows 用の音声再生インタフェース 
1. Mac OS 9でPythonを利用する 
2.1 mac --os モジュールの実装 
2.2 macpath --MacOS のパス操作関数 
2.3 macfs --様々なファイルシステム関連のサービス 
2.4 ic --インターネット設定へのアクセス 
2.5 MacOS --Mac OS インタプリタ機能へのアクセス 
2.6 macostools --ファイル操作を便利にするルーチン集 
2.7 findertools --finder のApple Eventsインターフェース 
2.8 EasyDialogs --基本的な Macintosh ダイアログ 
2.9 FrameWork --対話型アプリケーション・フレームワーク 
2.10 autoGIL --イベントループ中のグローバルインタープリタの取り扱い 
3.1 gensuitemodule --OSA スタプ作成パッケージ 
3.2 aetools --OSA クライアントのサポート 
3.3 aepack --Python変数とAppleEventデータコンテナ間の変換 
3.4 aetypes --AppleEvent オブジェクト 
3.5 MiniAEFrame --オープンスクリプティングアーキテクチャサーバのサポート 
4.25 ColorPicker --色選択ダイアログ 
ブール演算は、全ての Python 演算子の中で、最も低い優先順位になっています: 
ブール演算のコンテキストや、式が制御フロー文中で使われる最には、以下の値: None 、すべての数値型におけるゼロ、空のシーケンス (文字列、タプル、およびリスト) 、空のマップ型 (辞書) 、は偽 (false) であると解釈されます。 
それ以外の値は真 (true) であると解釈されます。 演算子 not は、引数が偽である場合には 1 を、それ以外の場合には 0 になります。 
式 
は、まず x を評価します;x が偽なら、x の値を返します; それ以外の場合には、y の値を評価し、その結果を返します。 
は、まず x を評価します; x が真なら、x の値を返します; それ以外の場合には、y の値を評価し、その結果を返します。 
(and も not も、返す値を 0 や 1 に制限するのではなく、最後に評価した引数の値を返すので注意してください。 この仕様は、例えば s を文字列として、s が空文字列の場合にデフォルトの値に置き換えるような場合に、s or 'foo' と書くと期待通りの値になるために便利なことがあります。 
not は、式の値でなく独自に値を作成して返すので、引数と同じ型の値を返すような処理に煩わされることはありません。 例えば、 not 'foo' は、 '' ではなく 0 になります) 
Cmdインスタンスは、次のメソッドを持ちます: 
プロンプトを繰り返し出し、入力を受け取り、受け取った入力から取り去った先頭の語を解析し、その行の残りを引数としてアクションメソッドへディスパッチします。 オプションの引数は、最初のプロンプトの前に表示されるバナーあるいは紹介用の文字列です(これはクラスメンバintroをオーバーライドします)。 
モジュールがロードされているなら、入力は自動的にbashのような履歴リスト編集機能を受け継ぎます(例えば、Control-Pは直前のコマンドへのスクロールバック、Control-Nは次のものへ進む、Control-Fはカーソルを右へ非破壊的に進める、Control-Bはカーソルを非破壊的に左へ移動させる等)。 
入力のファイル終端は、文字列'EOF'として渡されます。 メソッドdo_foo()を持っている場合に限って、インタープリタのインスタンスはコマンド名"foo"を認識します。 
特別な場合として、文字"?"で始まる行はメソッドdo_help()へディスパッチします。 
プロンプトに答えてタイプしたかのように引数を解釈実行します。 
これをオーバーライドすることがあるかもしれませんが、通常は必要ないでしょう。 便利な実行フックについては、precmd()とpostcmd()メソッドを参照してください。 
戻り値は、インタープリタによるコマンドの解釈実行をやめるかどうかを示すフラグです。 
コマンド str に対応する do_*() メソッドがある場合、そのメソッドの返り値が返されます。 そうでない場合は default() メソッドからの返り値が返されます。 
プロンプトに空行が入力されたときに呼び出されるメソッド。 
このメソッドがオーバーライドされていないなら、最後に入力された空行でないコマンドが繰り返されます。 
コマンドの先頭の語が認識されないときに、入力行に対して呼び出されます。 
このメソッドがオーバーライドされていないなら、エラーメッセージを表示して戻ります。 
利用可能なコマンド固有のcomplete_*()が存在しないときに、入力行を補完するために呼び出されるメソッド。 
デフォルトでは、空行を返します。 
コマンド行lineが解釈実行される直前、しかし入力プロンプトが作られ表示された後に実行されるフックメソッド。 
このメソッドはCmd内のスタブであって、サブクラスでオーバーライドされるために存在します。 
戻り値はonecmd()メソッドが実行するコマンドとして使われます。 precmd()の実装では、コマンドを書き換えるかもしれないし、あるいは単に変更していないlineを返すかもしれません。 
コマンドディスパッチが終わった直後に実行されるフックメソッド。 
このメソッドの戻り値は、stopに対応する内部フラグの新しい値として使われます。 偽を返すと、実行を続けます。 
cmdloop()が呼び出されたときに一度だけ実行されるフックメソッド。 
cmdloop()が戻る直前に一度だけ実行されるフックメソッド。 このメソッドはCmd内のスタブであって、サブクラスでオーバーライドされるために存在します。 
Cmdのサブクラスのインスタンスは、公開されたインスタンス変数をいくつか持っています: 
入力を求めるために表示されるプロンプト。 
コマンドの先頭の語として受け入れられる文字の文字列。 
最後の空でないコマンドプリフィックス。 
紹介またはバナーとして表示される文字列。 
cmdloop()メソッドに引数を与えるために、オーバーライドされるかもしれません。 
ヘルプの出力に文書化されたコマンドの部分がある場合に表示するヘッダ。 
ヘルプの出力にその他のヘルプ見出しがある(すなわち、do_*()メソッドに対応していないhelp_*()メソッドが存在する)場合に表示するヘッダ。 
ヘルプの出力に文書化されていないコマンドの部分がある(すなわち、対応するhelp_*()メソッドを持たないdo_*()メソッドが存在する)場合に表示するヘッダ。 
ヘルプメッセージのヘッダの下に、区切り行を表示するために使われる文字。 
空のときは、ルーラ行が表示されません。 
デフォルトでは、"="です。 
フラグ、デフォルトでは真。 
真ならば、cmdloop()はプロンプトを表示して次のコマンド読み込むためにraw_input()を使います。 
偽ならば、sys.stdout.write()とsys.stdin.readline()が使われます。 (これが意味するのは、 
を import することによって、それをサポートするシステム上では、インタープリタが自動的に Emacs形式の行編集とコマンド履歴のキーストロークをサポートするということです。 ) 
ConfigParserクラスはRawConfigParserのインターフェースをいくつかのメソッドについて拡張し、省略可能な引数を追加しています。 
sectionのoption変数を取得します。 
rawが真でない時には、全ての"%"置換はコンストラクタに渡されたデフォルト値か、vars が与えられていればそれを元にして展開されてから返されます。 
指定したsection 内の各オプションに対して、(name, value) のペアからなるリストを返します。 
省略可能な引数はget()メソッドと同じ意味を持ちます。 バージョン 2.3 で 新たに追加 された仕様です。 
1.2.5.2 モジュール検索パスにモジュールを追加する 
EditPythonPrefs を使うと、 Python の振る舞いを自分の好みに合わせられます。 
EditPythonPrefs には二つの用途があります。 ひとつは環境設定を行うという普通の使い方、もうひとつは Python のエンジンをドロップして、使いたいインタプリタのバージョンを制御するというものです。 
後者は、たとえば普段はプログラムが正常終了した時には出力ウィンドウを閉じるようにしておきたいけれども、出力ウィンドウを閉じないようなPythonInterpreter のコピーをもうひとつ作っておきたいような場合に便利です。 デフォルトの設定を変更するには、 EditPythonPrefs をダブルクリックします。 
インタプリタのどれかひとつの設定だけを変更したければ、インタプリタをEditPythonPrefs の上にドロップします。 
同じやり方を使えば、EditPythonPrefs を使って Python IDE や作成したアプレットの設定を変更できます - 節や 1.3.4 節を参照してください。 
1.3.1 ``Python Interactive''ウィンドウを使う 
Python IDE(統合開発環境) は独立したアプリケーションで、Python コードのテキストエディタや、クラスブラウザ、グラフィカルデバッガなどとして動作します。 
1.3.3 統合開発環境の中からスクリプトを実行する 
1.3.4 ``Save as'' と ``Save as Applet'' の違い Python スクリプトを書いたら、ファイルを 「アプレット」としても保存できます (``File''メニューの``Save as applet''を選びます) 。 
アプレットとして保存すると、ファイルやフォルダをスクリプトにドロップすることで、コマンドライン引数で渡すのと同じようにスクリプトにファイルやフォルダを渡せるという、大きな利点があります。 
詳しくはPythonの標準ドキュメントを参照してください。 スクリプトをアプレットとして保存しても、 Python がインストールされていないシステムでは実行できないので注意してください。 
1.3.2 Pythonスクリプトを書く 
1.3.4 ``Save as'' と 
Python IDEの最前面のウィンドウで全部実行(run all)ボタンを押すと、そのウィンドウのスクリプトを実行できます。 
しかし、仮に Python の習慣通りに "if __name__ == "__main__":" と書いても、スクリプトはデフォルトでは「__main__」に ならない ことに注意しておきましょう。 
そういう風に動作させるには、ドキュメントウィンドウの一番右上の小さな黒い三角形から、``Run as __main__''オプションを選ばねばなりません。 
このオプションはアプリケーションではなくファイル に関連付けられているので注意してください。 
とはいえ、このオプションは保存後もそのまま残ります。 止めたければ、再度このオプションを選んでください。 
Python IDE は、対話的に使うだけでなく、Python プログラムを書き上げたり、順次保存したりでき、全体や一部分の実行もできます。 「File」メニューの適当なメニューアイテムを選択すれば新たにスクリプトを作成したり、前に保存したスクリプトを開いたり、 現在開いているスクリプトを保存したりできます。 
デフォルトでは、ファイルのPython IDE をクリエータコードにして保存します。 従って、ファイルのアイコンをダブルクリックするとファイルを編集用に開きます。 
この動作を変更して、PythonInterpreter で開いて実行するようしたいと思う場合もあるでしょう。 
そうするには、単に「save options」から「Python Interpreter」を選ぶだけです。 
このオプションはアプリケーションではなくファイル に関連付けられているので注意してください。 
MimeWriter インスタンスには以下のメソッドがあります: 
MIMEメッセージに新しいヘッダ行を追加します。 
key は、そのヘッダの名前であり、そして valueで、そのヘッダの値を明示的に与えます。 
省略可能な引数 prefixは、ヘッダが挿入される場所を決定します;"0" は最後に追加することを意味し、"1" は先頭への挿入です。 
デフォールトは最後に追加することです。 
今まで集められたヘッダすべてが書かれ(そして忘れられ)るようにします。 これは、もし全く本体が必要でない場合に役に立ちます。 
例えば、ヘッダのような情報を保管するために(誤って)使用された、型 message/rfc822 のサブパート用。 
メッセージの本体に書くのに使用できるファイルのようなオブジェクトを返します。 
コンテント-型は、与えられた ctype に設定され、省略可能なパラメータ plistは、コンテント-型定義のための追加のパラメータを与えます。 prefix は、そのデフォールトが先頭への挿入以外は addheader() でのように働きます。 
メッセージ本体を書くのに使うことができるファイルのようなオブジェクトを返します。 
サブパートは、nextpart()を使って作成するべきです。 
マルチパートメッセージの個々のパートを表す、 MimeWriterの新しいインスタンスを返します。 
これは、そのパートを書くのにも、また複雑なマルチパートを再帰的に作成するのにも使うことができます。 
メッセージは、nextpart() を使う前に,最初 startmultipartbody() で初期化しなければなりません。 
これは、マルチパートメッセージの最後のパートを指定するのに使うことができ、マルチパートメッセージを書くときは いつでも使うべきです。 
MultiFile インスタンスには以下のメソッドがあります: 
一行データを読みます。 
その行が (セクション分割子や終了マーカや本物のEOF でない) データの場合、行データを返します。 
その行がもっとも最近スタックにプッシュされた境界パターンにマッチした場合、'' を返し、マッチした内容が終了マーカかそうでないかによって self.last を1 か 0 に設定します。 
行がその他のスタックされている境界パターンにマッチした場合、エラーが送出されます。 
背後のストリームオブジェクトにおけるファイルの終端に到達した場合、全ての境界がスタックから除去されていない限りこのメソッドは Error を送出します。 
このパートの残りの全ての行を文字列のリストとして返します。 
次のセクションまでの全ての行を読みます。 
読んだ内容を単一の(複数行にわたる) 文字列として返します。 
このメソッドにはsize 引数をとらないので注意してください! 
ファイルを seek します。 
seek する際のインデクスは現在のセクションの開始位置からの相対位置になります。 pis および whence 引数はファイルの seek における引数と同じように解釈されます。 
現在のセクションの先頭に対して相対的なファイル位置を返します。 
次のセクションまで行を読み飛ばします (すなわち、セクション分割子または終了マーカが消費されるまで行データを読みます)。 
次のセクションがあった場合には真を、終了マーカが発見された場合には偽を返します。 
最も最近スタックにプッシュされた境界パターンを最有効化します。 
str がデータの場合に真を返し、セクション分割子の可能性がある場合には偽を返します。 
このメソッドは行の先頭が (全ての MIME 境界が持っている) '- -' 以外になっているかを調べるように実装されていますが、導出クラスで上書きできるように宣言されています。 
このテストは実際の境界テストにおいて高速性を保つために使われているので注意してください; このテストが常に false を返す場合、テストが失敗するのではなく、単に処理が遅くなるだけです。 
境界文字列をスタックにプッシュします。 
この境界文字列の適切に修飾されたバージョンが入力ファイル中に見つかった場合、セクション分割子または終了マーカであると解釈されます。 
それ以降の全てのデータ読み出しは、pop() を呼んで境界文字列を除去するか、next() を呼んで境界文字列を再有効化しないかぎり、ファイル終端を示す空文字列を返します。 一つ以上の境界をプッシュすることは可能です。 
もっとも最近プッシュされた境界に遭遇すると EOF が返ります; その他の境界に遭遇するとエラーが送出されます。 
セクション境界をポップします。 
この境界はもはや EOF として解釈されません。 
境界をセクション分割子にします。 
標準では、このメソッドは(全ての MIME 境界が持っている) '- 
-' を境界文字列の先頭に追加しますが、これは導出クラスで上書きできるように宣言されています。 
末尾の空白は無視されることから考えて、このメソッドでは LF や CR-LF を追加する必要はありません。 
境界文字列を終了マーカ行にします。 
標準では、このメソッドは(MIME マルチパートデータのメッセージ終了マーカのように) '- 
-' を境界文字列の先頭に追加し、かつ'- 
-' を境界文字列の末尾に追加しますが、これは導出クラスで上書きできるように宣言されています。 
末尾の空白は無視されることから考えて、このメソッドでは LF や CR-LF を追加する必要はありません。 
最後に、MultiFile インスタンスは二つの公開されたインスタンス変数を持っています: 
現在のパートにおける入れ子の深さです。 
最後に見つかったファイル終了イベントがメッセージ終了マーカであった場合に真となります。 
クラスQueueはキューオブジェクトを実装しており、以下のメソッドを持っています。 
このクラスは、他のキュー構造(例えばスタック)を実装するために派生させられるますが、継承可能なインタフェースはここでは説明しません。 
詳しいことはソースコードを見てください。 
公開メソッドは次のものです: 
キューの大まかなサイズを返します。 
マルチスレッドセマンティクスにおいて、この値は信頼できません。 
キューが空ならTrueを返し、そうでないならFalseを返します。 マルチスレッドセマンティクスにおいて、この値は信頼できません。 
キューが満杯ならTrueを返し、そうでないならFalseを返します。 マルチスレッドセマンティクスにおいて、この値は信頼できません。 
itemをキューに入れます。 
もしオプション引数blockがTrueでtimeoutがNone(デフォルト)ならば、フリースロットが利用可能になるまでブロックします。 
バージョン 2.3 で 新たに追加 された仕様:the timeout parameter 
put(item, False)と同じ意味です。 
キューからアイテムを取り除き、それを返します。 
もしオプション引数blockがTrueでtimeoutがNone(デフォルト)ならば、アイテムが利用可能になるまでブロックします。 
もしtimeoutが正の値の場合、最大でtimeout秒間ブロックし、その時間内でアイテムが利用可能にならなければ、例外Emptyを送出します。 
他方(blockがFalse)、直ちにアイテムが利用できるならば、それを返します。 できないならば、例外Emptyを送出します(この場合timeoutは無視されます)。 
get(False)と同じ意味です。 
RawConfigParserクラスのインスタンスは以下のメソッドを持ちます: 
インスタンス全体で使われるデフォルト値の辞書を返します。 
利用可能なセクションのリストを返します。 DEFAULTはこのリストに含まれません。 
sectionという名前のセクションをインスタンスに追加します。 
同名のセク ションが存在した場合、DuplicateSectionErrorが発生します。 has_section 
指定したセクションがコンフィグレーションファイルに存在するかを返します。 
DEFAULTセクションは存在するとみなされません。 
sectionで指定したセクションで利用できるオプションのリストを返します。 
与えられたセクションが存在してかつオプションが与えられていれば True を返し、そうでなければ False を返します。 バージョン 1.6 で 新たに追加 された仕様です。 
ファイル名のリストを読んで解析をこころみ、うまく解析できたファイル名のリストを返します。 
もしfilenamesが文字列かユニコード文字列なら、1つのファイル名として扱われます。 
filenamesで指定されたファイルが開けない場合、そのファイルは無視されます。 この挙動は設定ファイルが置かれる可能性のある場所(例えば、カレントディレクトリ、ホームディレクトリ、システム全体の設定を行うディレクトリ)を設定して、そこに存在する設定ファイルを読むことを想定して設計されています。 
設定ファイルが存在しなかった場合、ConfigParser のインスタンスは空のデータセットを持ちます。 
初期値の設定ファイルを先に読み込んでおく必要があるアプリケーションでは、readfp())をread()の前に呼び出すことでそのような動作を実現できます: 
バージョン 2.4 で 変更 された仕様:うまく解析できたファイル名のリストを返す 
fpで与えられるファイルかファイルのようなオブジェクトを読み込んで構文解析します(readline()メソッドだけを使います)。 
もしfilenameが省略されてfpがname属性を持っていればfilenameの代わりに使われます。 
ファイル名の初期値は"???"です。 get 
sectionのoptionを整数として評価する関数です。 
sectionのoptionを浮動小数点数として評価する関数です。 
指定した section の option 値をブール値に型強制する便宜メソッドです。 
option として受理できる値は、真 (True) としては"1"、 "yes"、 "true"、 "on" 、偽 (False) としては"0"、 "no"、 "false"、 "off" です。 
これらの文字列値に対しては大文字小文字の区別をしません。 
その他の値の場合には ValueError を送出します。 
与えられたsectionのそれぞれのオプションについて(name, value)ペアのリストを返します。 
与えられたセクションが存在していれば、オプションを指定された値に設定します。 セクションが存在しなければ NoSectionError を発生させます。 
RawConfigParser (あるいはraw パラメータをセットしたConfigParser) を文字列型でない値の 内部的な 格納場所として使うことは可能ですが、すべての機能 (置換やファイルへの出力を含む) がサポートされるのは文字列を値として使った場合だけです。 バージョン 1.6 で 新たに追加 された仕様です。 
設定を文字列表現に変換してファイルオブジェクトに書き出します。 
この文字列表現はread()で読み込むことができます。 バージョン 1.6 で 新たに追加 された仕様です。 
指定されたsectionから指定されたoptionを削除します。 セクションが存在しなければ、NoSectionError を起こします。 
存在するオプションを削除した時は True を、そうでない時は False を返します。 
バージョン 1.6 で 新たに追加 された仕様です。 remove_section 
指定されたsectionを設定から削除します。 もし指定されたセクションが存在すればTrue、そうでなければFalseを返します。 
入力ファイル中に見つかったオプション名か,クライアントコードから渡されたオプション名 option を,内部で利用する形式に変換します。 
デフォルトではoptionを全て小文字に変換した名前が返されます。 
サブルクラスではこの関数をオーバーライドすることでこの振舞いを替えることができます。 たとえば、このメソッドをstr()に設定することで大小文字の差を区別するように変更することができます。 
Reprインスタンスは様々なオブジェクト型の表現にサイズ制限を与えるために使えるいくつかのメンバーと、特定のオブジェクト型を書式化するメソッドを提供します。 
再帰的な表現を作る場合の深さ制限。 
デフォルトは6です。 
指定されたオブジェクト型に対するエントリ表現の数についての制限。 
長整数の表現のおける文字数の最大値。 
中央の数字が抜け落ちます。 
デフォルトは40です。 
文字列の表現における文字数の制限。 
文字列の``通常の''表現は文字の材料だということに注意してください: 表現にエスケープシーケンスが必要とされる場合は、表現が短縮されたときにこれらはマングルされます。 
デフォルトは30です。 
この制限はReprオブジェクトに利用できる特定の書式化メソッドがないオブジェクト型のサイズをコントロールするために使われます。 maxstringと同じようなやり方で適用されます。 
デフォルトは20です。 
インスタンスが強制する書式化を使う組み込みrepr()と等価なもの。 
repr()が使う再帰的な実装。 
これはどの書式化メソッドを呼び出すかを決定するためにobjの型を使い、それをobjとlevelに渡します。 
再帰呼び出しにおいてlevelの値に対して 
level - 1を与える再帰的な書式化を実行するために、型に固有のメソッドはrepr1()を呼び出します。 
型名に基づく名前をもつメソッドとして、特定の型に対する書式化メソッドは実装されます。 
メソッド名では、typeはstring.join(string.split(type(obj).__name__, '_'))に置き換えられます。 これらのメソッドへのディスパッチはrepr1()によって処理されます。 
再帰的に値の書式を整える必要がある型固有のメソッドは、"self.repr1(subobj, level - 1)"を呼び出します。 
次の例は最低限必要なメールアドレス(`To' と `From')を含んだメッセージを送信するものです。 
この例ではRFC 822ヘッダの加工もしていません。 
メッセージに含まれるヘッダは、メッセージに含まれる必要があり、特に、明確な'To'、と'From'アドレスはメッセージヘッダに含まれている必要があります。 
SMTPクラスインスタンスは次のメソッドを提供します: 
コネクション間でやりとりされるメッセージ出力のレベルをセットします。 
メッセージの冗長さはlevelに応じて決まります。 
ホスト名とポート番号をもとに接続します。 
サーバへコマンドcmdを送信します。 
応答待ちのときに、サーバへのコネクションが失われると、SMTPServerDisconnectedが上がります。 
SMTPサーバに"HELO"コマンドで身元を示します。 
デフォルトではhostname引数はローカルホストを指します。 
通常はsendmail()が呼びだすため、これを明示的に呼び出す必要はありません。 
"EHLO"を利用し、ESMTPサーバに身元を明かします。 
デフォルトではhostname引数はローカルホストを指します。 
また、ESMTPオプションのために応答を調べたものは、has_extn()に備えて保存されます。 
has_extn()をメールを送信する前に使わない限り、明示的にこのメソッドを呼び出す必要があるべきではなく、sendmail()が必要とした場合に呼ばれます。 
、 has_extn 
nameが拡張SMTPサービスセットに含まれている場合にはTrueを返し、そうでなければFalseを返します。 大小文字は区別されません。 
"VRFY"を利用してSMTPサーバにアドレスの妥当性をチェックします。 妥当である場合はコード250と完全なRFC 822アドレス(人名)のタプルを返します。 
それ以外の場合は、400以上のエラーコードとエラー文字列を返します。 
注意:ほとんどのサイトはスパマーの裏をかくためにSMTPの"VRFY"は使用不可になっています。 
サーバが"HELO"に返答できなかった。 
サーバがユーザ名/パスワードでの認証に失敗した。 
どんな認証方法も見付からなかった。 
TLS(Transport Layer Security)モードでSMTPコネクションを出し、全てのSMTPコマンドは暗号化されます。 
これはehlo()をもう一度呼びだすときにするべきです。 
keyfileとcertfileが提供された場合に、 
モジュールのssl()関数が通るようになります。 
メールを送信します。 
必要な引数はRFC 822のfromアドレス文字列、RFC 822のtoアドレス文字列のリスト、メッセージ文字列です。 送信側は"MAIL FROM"コマンドで使用されるmail_optionsのESMTPオプション("8bitmime"のような)のリストを得るかもしれません。 
全ての"RCPT"コマンドで使われるべきESMTPオプション(例えば"DSN"コマンド)は、rcpt_optionsを通して利用することができます。 
(もし送信先別にESMTPオプションを使う必要があれば、メッセージを送るためにmail、rcpt、dataといった下位レベルのメソッドを使う必要があります。 ) 
注意:配送エージェントはfrom_addr、to_addrs引数を使い、メッセージのエンベロープを構成します。 SMTPはメッセージヘッダを修正しません。 
まだセッションが無い場合は、"EHLO"または"HELO"コマンドでセッションを作ります。 ESMTPの場合は"EHLO"が先に試されます。 
また、サーバがESMTP対応ならば、メッセージサイズとそれぞれ指定されたオプションも渡します。 
(featureオプションがあればサーバの広告をセットします)"EHLO"が失敗した場合は、ESMTPオプションの無い"HELO"が試されます。 このメソッドはメールが受け入れられたときは普通に戻りますが、そうでない場合は例外を投げます。 
このメソッドが例外を投げられなければ、誰かが送信したメールを得るべきです。 
また、例外を投げれなかった場合は、拒絶された受取人ごとへの1つのエントリーと共に、辞書を返します。 
各エントリーは、サーバーによって送られたSMTPエラーコードおよびエラーメッセージのタプルを含んでいます。 このメソッドは次の例外を上げることがあります: 
全ての受信を拒否され、誰にもメールが届けられませんでした。 
例外オブジェクトのrecipients属性は、受信拒否についての情報の入った辞書オブジェクトです。 (辞書は少なくとも一つは受信されたときに似ています)。 
サーバが"HELP"に返答しませんでした。 
サーバがfrom_addrを弾きました。 
サーバが予期しないエラーコードを返しました。 (受信拒否以外) 
また、この他の注意として、例外が上がった後もコネクションは開いたままになっています。 
SMTPセッションを終了し、コネクションを閉じます。 
下位レベルのメソッドは標準SMTP/ESMTPコマンド"HELP"、 "RSET"、"NOOP"、"MAIL"、"RCPT"、"DATA"に対応しています。 
通常これらは直接呼ぶ必要はなく、また、ドキュメントもありません。 
詳細はモジュールのコードを調べてください。 
SafeConfigParser は ConfigParser と同様の拡張インターフェイスをもっていますが、以下のような機能が追加されています: 
open()によって返されるWave_readオブジェクトには、以下のメソッドがあります: 
ストリームを閉じ、このオブジェクトのインスタンスを使用できなくします。 
これはオブジェクトのガベージコレクション時に自動的に呼び出されます。 
オーディオチャンネル数(モノラルなら1、ステレオなら2)を返します。 
サンプルサイズをバイト数で返します。 
サンプリングレートを返します。 
オーディオフレーム数を返します。 
圧縮形式を返します('NONE'だけがサポートされている形式です)。 
getcomptype()を人に判読可能な形にしたものです。 通常、'NONE'に対して'not compressed'が返されます。 
get*()メソッドが返すのと同じ(nchannels, sampwidth, framerate,nframes, comptype, compname)のタプルを返します。 
現在のポインタからn個のオーディオフレームの値を読み込んで、バイトごとに文字に変換して文字列を返します。 
ファイルのポインタをオーディオストリームの先頭に戻します。 
以下の2つのメソッドは 
モジュールとの互換性のために定義されていますが、何も面白いことはしません。 
Noneを返します。 
エラーを発生します。 
以下の2つのメソッドは共通の``位置''を定義しています。 ``位置''は他の関数とは独立して実装されています。 
ファイルのポインタを指定した位置に設定します。 
ファイルの現在のポインタ位置を返します。 
open()によって返されるWave_writeオブジェクトには、以下のメソッドがあります: 
nframesが正しいか確認して、ファイルを閉じます。 このメソッドはオブジェクトの削除時に呼び出されます。 
チャンネル数を設定します。 
サンプルサイズをnバイトに設定します。 
サンプリングレートをnに設定します。 
フレーム数をnに設定します。 
あとからフレームが書き込まれるとフレーム数は変更されます。 
圧縮形式とその記述を設定します。 
tupleは(nchannels, sampwidth,framerate, nframes, comptype, compname)で、それぞれset*()のメソッドの値にふさわしいものでなければなりません。 
全ての変数を設定します。 
ファイルの中の現在位置を返します。 Wave_read.tell()とWave_read.setpos()メソッドでお断りしたことがこのメソッドにも当てはまります。 
nframesの修正なしにオーディオフレームを書き込みます。 
オーディオフレームを書き込んでnframesを修正します。 
writeframes()やwriteframesraw()メソッドを呼び出したあとで、どんなパラメータを設定しようとしても不正となることに注意して下さい。 そうするとwave.Errorを発生します。 
Python ドキュメントについて 
Python ドキュメントは、もともと Guido van Rossum 一人の手で書かれたものですが、ここ数年ではだんだんと Python コミュニティ自体の取り組みになってきています。 
ドキュメントに関する一般的なコメントや質問は、電子メールならdocs@python.org に送ってください。 
このドキュメントに書かれている情報の使い方に関する質問は、Python のニュースグループ、 comp.lang.python、またはPython メーリングリスト (ニュースグループと橋渡しされていて、同じ情報が流れます) に送ってください。 
上で挙げたチャネルではいずれも、決して HTML メールを送らないようにしてください。 よろしくお願いします。 
ユーザ名/パスワードを取得し、再度サーバへのリクエストを試みることで、サーバからの認証リクエストを処理します。 
authreq はリクエストにおいてレルムに関する情報が含まれているヘッダの名前、host は認証を行う対象のホスト名、req は (失敗した) Request オブジェクト、そして headers はエラーヘッダでなくてはなりません。 
6.6 バッファプロトコル (buffer protocol) 
6.5 イテレータプロトコル (iterator protocol) 
6. 抽象オブジェクトレイヤ (abstract objects 
7. 具象オブジェクト (concrete object) 
文字ベースの入力として使える読み出し専用メモリ上の位置へのポインタを返します。 
obj 引数は単一セグメントからなる文字バッファインタフェースをサポートしていなければなりません。 
成功すると 0を返し、buffer をメモリの位置に、 buffer_len をバッファの長さに設定します。 
エラーの際には -1 を返し、TypeError をセットします。 バージョン 1.6 で 新たに追加 された仕様です。 
任意のデータを収めた読み出し専用のメモリ上の位置へのポインタを返します。 
obj 引数は単一セグメントからなる読み出し可能バッファインタフェースをサポートしていなければなりません。 
成功すると 0を返し、buffer をメモリの位置に、 buffer_len をバッファの長さに設定します。 
エラーの際には -1 を返し、TypeError をセットします。 バージョン 1.6 で 新たに追加 された仕様です。 
o が単一セグメントからなる読み出し可能バッファインタフェースをサポートしている場合に 1 を返します。 
それ以外の場合には0 を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
書き込み可能なメモリ上の位置へのポインタを返します。 
obj 引数は単一セグメントからなる文字バッファインタフェースをサポートしていなければなりません。 
成功すると 0を返し、buffer をメモリの位置に、 buffer_len をバッファの長さに設定します。 
エラーの際には -1 を返し、TypeError をセットします。 バージョン 1.6 で 新たに追加 された仕様です。 
authreq はリクエストにおいてレルムに関する情報が含まれているヘッダの名前、host は認証を行う対象のホスト名、req は (失敗した) Request オブジェクト、そして headers はエラーヘッダでなくてはなりません。 
6. 抽象オブジェクトレイヤ (abstract objects layer) 
5.5 引数の解釈と値の構築 
6.1 オブジェクトプロトコル (object protocol) 
6. 抽象オブジェクトレイヤ (abstract objects layer) 
この章で説明する関数は、Python オブジェクトとのやりとりを型や(数値型全て、シーケンス型全てといった) 大まかなオブジェクト型の種類に関係なく行います。 
関数を適用対象でないオブジェクトに対して使った場合、 Python の例外が送出されることになります。 
6.1 オブジェクトプロトコル (object protocol) 
6.2 数値型プロトコル (number protocol) 
6.3 シーケンス型プロトコル (sequence protocol) 
6.4 マップ型プロトコル (mapping protocol) 
6.1 オブジェクトプロトコル (object protocol) 
Jes俍 Cea Avi 
Gerhard H醺ing 
Fran槢is Pinard 
Hern睹 Martez Foffani 
。「・ィ。シ・讌ッ・ゥ。「隕・ィ・オ・ハ・「ェエサ、ヒ、ハ、熙ソ、、ハ蓮 
AddressList インスタンスは以下のメソッドを持ちます: 
アドレスリスト中のアドレスの数を返します。 
アドレスリストの正規化 (canonicalize) された文字列表現を返します。 
アドレスはカンマで分割された "name" host@domain 形式になります。 
二つの AddressList 被演算子中の双方に含まれるアドレスについて、重複を除いた (集合和の) 全てのアドレスを含む新たな AddressList インスタンスを返します。 
__add__() のインプレース演算版です; AddressList インスタンスと右側値 alist との集合和をとり、その結果をインスタンス自体と置き換えます。 
左側値のAddressList インスタンスのアドレスのうち、右側値中に含まれていないもの全てを含む (集合差分の) 新たな AddressList インスタンスを返します。 
__sub__() のインプレース演算版で、alist にも含まれているアドレスを削除します。 
最後に、AddressList インスタンスは public なインスタンス変数を一つ持ちます: 
アドレスあたり一つの文字列ペアで構成されるタプルからなるリストです。 
各メンバ中では、最初の要素は正規化された名前部分で、二つ目は実際の配送アドレス ("@" で分割されたユーザ名 と ホスト.ドメインからなるペア) です。 
8.3 高度なデバッガサポート (advanced debugger support) 
8.2 プロファイルとトレース (profiling and 
8. 初期化 (initialization)、終了処理 (finalization)、スレッド 
9. メモリ管理 
以下の関数は高度なデバッグツールでの使用のためだけのものです。 
インタプリタ interp に関連付けられているスレッドからなるリストのうち、先頭にある PyThreadState オブジェクトを返します。 
AppleEventハンドラをインストールします。 classeとtypeは4文字のOSAクラスとタイプの指定子で、ワイルドカード'****'も使えます。 
対応するAppleEventを受けるとパラメータがデコードされ、与えたコールバックが呼び出されます。 
与えたコールバックは、OSAダイレクトオブジェクトを1番目のパラメータとして呼び出されます。 
他のパラメータは4文字の指定子を名前にしたキーワード引数として渡されます。 
他に3つのキーワード・パラメータが渡されます。 つまり、_classと_typeはクラスとタイプ指定子で、_attributesはAppleEvent属性を持つ辞書です。 
与えたメソッドの返り値はaetools.packevent()でパックされ、リプライとして送られます。 
現在のクラス設計にはいくつか重大な問題があることに注意してください。 
引数に名前ではない4文字の指定子を持つAppleEventはまだ実装されていないし、イベントの送信側にエラーを返すこともできません。 
この問題は将来のリリースまで先送りにされています。 
newconfig()で返されるコンフィギュレーションオブジェクトには以下のメソッドがあります: 
キューサイズを返します。 
キューサイズを設定します。 
サンプルサイズを返します。 
サンプルサイズを設定します。 
チャンネル数を返します。 
チャンネル数を設定します。 
サンプルのフォーマットを返します。 
サンプルのフォーマットを設定します。 
浮動小数点数でサンプルデータの最大値を返します。 
浮動小数点数でサンプルデータの最大値を設定します。 
openport()で返されるポートオブジェクトには以下のメソッドがあります: 
ポートを閉じます。 
ファイルディスクリプタを整数で返します。 
バッファに存在するサンプルの数を返します。 
バッファの空きに入れることのできるサンプルの数を返します。 
必要ならブロックして、キューから指定のサンプル数を読み込みます。 生データを文字列として(例えば、サンプルサイズが2バイトならサンプル当たり2バイトがbig-endian(high byte、low byte)で)返します。 
必要ならブロックして、キューにサンプルを書き込みます。 
サンプルはreadsamps()で返される値のようにエンコードされていなければなりません。 
`fill point'を返します。 
`fill point'を設定します。 
現在のポートのコンフィギュレーションを含んだコンフィギュレーションオブジェクトを返します。 
コンフィギュレーションを引数に取り、そのコンフィギュレーションに設定します。 
最後のエラーについてのステイタスの情報を返します。 
エイリアス (Alias) レコードの生データです。 リソースへの書き込みや他のプログラムへの転送に適した形式です。 
エイリアスを解決します。 
エイリアスが相対エイリアスとして作成されている場合は、どこからの相対かを示すファイルを渡さねばなりません。 
エイリアスが指し示すファイルの FSSpec と、Alias オブジェクト自体が検索処理中に変更されたかどうかを示すフラグを返します。 
ファイルは実在しないが、ファイルまでのパスは実在する場合、有効な FSSpec を返します。 
CのルーチンGetAliasInfo()へのインタフェースです。 
エイリアスを、file に指定したファイルを指すように更新します。 
file2 を指定していれば、相対エイリアスを作成します。 
今のところ、リソースはAlias オブジェクトとして直接操作できません。 
そのため、Update()を呼んだ後か、Resolve()でエイリアスに変更があったと分かった後は、Pythonプログラム側でAlias オブジェクトからdataの値を取りだし、リソースを修正しておく責任があります。 
10.1 オブジェクトをヒープ上にメモリ確保する 
10. オブジェクト実装サポート (object implementation 
10.2 共通のオブジェクト構造体 (common object 
戻り値: 
新たな参照. 
借りた参照. 
新たにメモリ確保されたオブジェクト op に対し、型と初期状態での参照 (initial reference) を初期化します。 
初期化されたオブジェクトを返します。 
type からそのオブジェクトが循環参照ガベージ検出の機能を有する場合、検出機構が監視対象とするオブジェクトのセットに追加されます。 オブジェクトの他のフィールドには影響を及ぼしません。 
PyObject_Init() の全ての処理を行い、可変サイズオブジェクトの場合には長さ情報も初期化します。 
C 構造体型 TYPE と Python 型オブジェクト type を使って新たな Python オブジェクトをメモリ確保します。 
Python オブジェクトヘッダで定義されていないフィールドは初期化されません;オブジェクトの参照カウントは 1 になります。 
メモリ確保のサイズは型オブジェクトの tp_basicsize で決定します。 
Python オブジェクトヘッダで定義されていないフィールドは初期化されません。 
確保されたメモリは、TYPE 構造体に加え、vartype の tp_itemsizeフィールドで指定されているサイズ中の size フィールドを収容できます。 
この関数は、例えばタプルのように生成時にサイズを決定できるオブジェクトを実装する際に便利です。 
一連の複数のフィールドに対するアロケーション操作を一つにして埋め込むと、アロケーション回数が減り、メモリ管理の処理効率が向上します。 
PyObject_New() や PyObject_NewVar() で確保されたメモリを解放します。 
この関数は、通常オブジェクトの型に指定されている tp_dealloc ハンドラ内で呼び出します。 
この関数を呼び出した後では、オブジェクトのメモリ領域はもはや有効なPython オブジェクトを表現してはいないので、オブジェクトのフィールドに対してアクセスしてはなりません。 
安全性と引き換えにパフォーマンスを高めるためのPyObject_New()のマクロ版です。 
type が NULL かどうかチェックしません。 
安全性と引き換えにパフォーマンスを高めるためのPyObject_NewVar()のマクロ版です。 
type が NULL かどうかチェックしません。 
PyObject_Del()のマクロ版です。 
name と関数のテーブルに基づいて新たなモジュールオブジェクトを生成し、生成されたモジュールオブジェクトを返します。 
バージョン 2.3 で 変更 された仕様:以前のバージョンの Python では、methods 引数の値としてNULL をサポートしていませんでした 
doc が NULLでない場合、モジュールの docstring として使われます。 
self がNULLでない場合、モジュール内の各関数の第一引数として渡されます (NULLの時には第一引数も NULLになります)。 
(この関数は実験的な機能のために追加されたもので、現在の Python のバージョンで使われてはいないはずです。 
) apiver に渡してよい値は、PYTHON_API_VERSION で定義されている定数だけです。 
注意:この関数のほとんどの用途は、代わりにPy_InitModule3()を使えるはずです; 本当にこの関数を使いたいときにだけ利用してください 
Python からは None に見えるオブジェクトです。 
この値へのアクセスは、このオブジェクトへのポインタを評価するPy_None マクロを使わねばなりません。 
6. 汎用オペレーティングシステムサービス 
本章に記述されたモジュールは、ファイルの取り扱いや時間計測のような(ほぼ)すべてのオペレーティングシステムで利用可能な機能にインターフェースを提供します。 
これらのインターフェースは、UnixもしくはCのインターフェースを基に作られますが、ほとんどの他のシステムで同様に利用可能です。 
概要を以下に記述します。 
雑多なオペレーティングシステムインタフェース。 
共通のパス名操作。 
キャッシュメカニズムを備えたディレクトリ一覧生成。 
ファイルの stat を調べ、その結果を記憶します。 
os.statvfs() の返す値を解釈するために使われる定数群。 
ファイル群を効率的に比較します。 
サブプロセス管理 
アクセス可能な I/O ストリームを持つ子プロセス生成。 
基本的な日付型および時間型。 
時刻データへのアクセスと変換 
一般的な目的のためのイベントスケジューラ 
排他制御のためのロックとキュー 
ポータブルなパスワードとユーザーIDの検索 
可搬性のある端末操作を提供する curses ライブラリへのインタフェース. 
curses ウィンドウ内での Emacs ライクな入力編集機能。 
curses プログラムのための端末設定ラッパ。 
ASCII 文字に関する定数および集合帰属関数。 
curses ウィンドウに深さの概念を追加するパネルスタック拡張。 
ポータブルなコマンドラインオプションのパーザ。 長短の両方の形式をサポートします。 
より便利で柔軟性に富んだ強力なコマンドライン解析ライブラリ 
一時的なファイルやディレクトリを生成。 
標準の errno システムシンボル。 
Unix シェル形式のパス名のパターン展開。 
Unix シェル形式のファイル名のパターンマッチ。 
コピーを含む高レベルなファイル操作。 
国際化サービス。 
多言語対応に関する国際化サービス。 
PEP 282 に基づくPython 用のロギングモジュール。 
実行中プラットフォームからできるだけ多くの固有情報を取得する 
2 標準的なビルド・インストール作業 
3.1 別の場所へのインストール: home スキーム 
しばしば、サードパーティ製 Python モジュールをインストールするための標準の場所以外にモジュールをインストールしなければならなかったり、単にそうしたくなるときがあります。 
例えばUnix システムでは、標準のサードパーティ製モジュールディレクトリに対する書き込み権限を持っていないかもしれません。 
または、あるモジュールを、ローカルで使っている Python に標準のモジュールの一部として組み込む前にテストしてみたいと思うかもしれません。 
既存の配布物をアップグレードする際には特にそうでしょう:実際にアップグレードする前に、既存のスクリプトの基本となる部分が新たなバージョンでも動作するか確認したいはずです。 Distutils の install コマンドは、別の場所へ配布物をインストールする作業を単純で苦労のない作業にするように設計されています。 
基本的なアイデアは、インストール先のベースディレクトリを指定しておき、install コマンドがそのベースディレクトリ下にファイル群をインストールするための一連のディレクトリ (インストールスキーム: installation scheme) を作成するというものです。 
詳細はプラットフォームによって異なるので、以下の節から自分のプラットフォームに当てはまるものを読んでください。 
``home スキーム'' の背後にある考え方は、Python モジュールを個人用のモジュール置き場でビルドし、維持するというものです。 
このスキームの名前は Unixの「ホーム」ディレクトリの概念からとりました。 というのも、 Unixのユーザにとって、自分のホームディレクトリを/usr/ や /usr/local/ のようにレイアウトするのはよくあることだからです。 
とはいえ、このスキームはどのオペレーティングシステムのユーザでも使えます。 新たなモジュールのインストールは単純で、 
python setup.py install --home=dir のようにします。 
このとき、--home オプションを使ってディレクトリを指定します。 
面倒臭がりの人は、単にチルダ(~) をタイプするだけでかまいません; install コマンドがチルダをホームディレクトリに展開してくれます: 
--home オプションは、インストールのベースディレクトリを指定します。 
ファイルはインストールベース下の以下のディレクトリに保存されます: 
ファイルの種類 
インストール先ディレクトリ 
オーバライドするためのオプション 
pure モジュール配布物 
非 pure モジュール配布物 
スクリプト 
データ 
バージョン 2.4 で 変更 された仕様:--home は Unixでしかサポートされていませんでした 
あるインストール済みの Python を使ってモジュールのビルド/インストールを (例えば setup スクリプトを実行して) 行いたいけれども、別のインストール済みの Python のサードパーティ製モジュール置き場(あるいは、そう見えるようなディレクトリ構造) に、ビルドされたモジュールをインストールしたい場合には、``prefix スキーム'' が便利です。 
そんな作業はまったくありえそうにない、と思うなら、確かにその通りです -- ``home スキーム'' を先に説明したのもそのためです。 
とはいえ、prefix スキームが有用なケースは少なくとも二つあります。 まず、多くの Linux ディストリビューションは、 Python を /usr/localではなく /usr に置いていることを考えてください。 
この場合は、Python はローカルの計算機ごとのアドオン (add-on) ではなく、``システム''の一部となっているので、/usr に置くのは全く正当なことです。 
しかしながら、 Python モジュールをソースコードからインストールしていると、モジュールを /usr/lib/python2.X 
ではなく /usr/local/lib/python2.X 
に置きたいと思うかもしれません。 
これを行うには 
からモジュールを探すでしょうが、モジュールは別の場所、例えば/mnt/@server/export/lib/python2.X 
にインストールしなければならないかもしれません。 
この場合には、 
のようにします。 どちらの場合も、--prefix オプションでインストールベースディレクトリを決め、 --exec-prefix でプラットフォーム固有のファイル置き場名として使う、プラットフォーム固有インストールベースディレクトリを決めます。 
(プラットフォーム固有のファイルとは、現状では単に非 pure モジュール配布物のことを意味しますが、 C ライブラリやバイナリ実行可能形式などに拡張されるかもしれません。 
) --exec-prefix が指定されていなければ、デフォルトの --prefixになります。 
ファイルは以下のようにインストールされます: 
--prefix や --exec-prefix が実際に他のインストール済み Python の場所を指している必要はありません;上に挙げたディレクトリがまだ存在しなければ、インストール時に作成されます。 ちなみに、prefix スキームが重要な本当の理由は、単に標準の Unix インストールが prefix スキームを使っているからです。 
ただし、そのときには、 --prefix や --exec-prefix は Python 自体が sys.prefix や sys.exec_prefix を使って決めます。 
というわけで、読者は prefix スキームを決して使うことはあるまいと思っているかもしれませんが、python setup.py install をオプションを何もつけずに実行していれば、常に prefix スキームを使っていることになるのです。 拡張モジュールを別のインストール済み Python にインストールしても、拡張モジュールのビルド方法による影響を受けることはありません:特に、拡張モジュールをコンパイルする際には、setup スクリプトを実行する際に使う Python インタプリタと一緒にインストールされている Python ヘッダファイル (Python.h とその仲間たち) を使います。 
上で述べてきたやり方でインストールされた拡張モジュールを実行するインタプリタと、インタプリタをビルドする際に用いた別のインタプリタとの互換性を保証するのはユーザの責任です。 
これを行うには、二つのインタプリタが同じバージョンの Python (ビルドが違っていたり、同じビルドのコピーということもあり得ます) であるかどうかを確かめます。 
(もちろん、--prefix や --exec-prefix が別のインストール済み Python の場所すら指していなければどうにもなりません。 ) 
Windows はユーザのホームディレクトリという概念がなく、Windows 環境下で標準的にインストールされた Python は Unixよりも単純な構成をしているので、 Windows で追加のパッケージを別の場所に入れる場合には、伝統的に --prefix が使われてきました。 
とすると、モジュールを現在のドライブのTempPython ディレクトリにインストールしますインストールベースディレクトリは、 --prefix オプションだけで決まります; --exec-prefix オプションは、Windowsではサポートされていません。 ファイルは以下のような構成でインストールされます: 
2 ソースコード配布物を作成する: sdist command 
1 distutils.core -- Distutils のコア機能 
1.1 インクルードファイル 
1.2 オブジェクト、型および参照カウント 
1.2.1 参照カウント 
1.2.2 型 
1.3 例外 
1.4 Python の埋め込み 
2. 超高レベルレイヤ 
3. 参照カウント 
4. 例外処理 
4.1 標準例外 
4.2 文字列例外の廃止 
5. ユーティリティ関数 
5.1 オペレーティングシステム関連のユーティリティ 
5.2 プロセス制御 
5.3 モジュールの import 
5.4 データ整列化 (data marshalling) のサポート 
5.5 引数の解釈と値の構築 
7. 具象オブジェクト (concrete object) レイヤ 
7.1 基本オブジェクト (fundamental object) 
7.1.1 型オブジェクト (type object) 
7.1.2 None オブジェクト 
7.2 数値型オブジェクト (numeric object) 
7.2.1 (通常)整数型オブジェクト (plain integer object) 
7.2.2 Bool 型オブジェクト 
7.2.3 長整数型オブジェクト (long integer object) 
7.2.4 浮動小数点型オブジェクト (floating point object) 
7.2.5 浮動小数点オブジェクト (complex number object) 
7.3 シーケンスオブジェクト (sequence object) 
7.3.1 文字列オブジェクト (string object) 
7.3.2 Unicode オブジェクト (Unicode object) 
7.3.4 タプルオブジェクト (tuple object) 
7.4 マップ型オブジェクト (mapping object) 
7.4.1 辞書オブジェクト (dictionary object) 
7.5 その他のオブジェクト 
7.5.1 ファイルオブジェクト (file object) 
7.5.2 インスタンスオブジェクト (instance object) 
7.5.3 メソッドオブジェクト (method object) 
7.5.4 モジュールオブジェクト (module object) 
7.5.5 イテレータオブジェクト (iterator object) 
7.5.6 デスクリプタオブジェクト (descriptor object) 
7.5.7 スライスオブジェクト (slice object) 
7.5.8 弱参照オブジェクト (weak reference object) 
7.5.9 Cオブジェクト (CObject) 
7.5.10 セルオブジェクト (cell object) 
7.5.11 ジェネレータオブジェクト 
7.5.12 DateTime オブジェクト 
8. 初期化 (initialization)、終了処理 (finalization)、スレッド 
8.1 スレッド状態 (thread state) とグローバルインタプリタロック (global interpreter lock) 
8.2 プロファイルとトレース (profiling and tracing) 
9.1 概要 
9.2 メモリインタフェース 
9.3 例 
10. オブジェクト実装サポート (object implementation support) 
10.2 共通のオブジェクト構造体 (common object structure) 
10.3 型オブジェクト 
10.4 マップ型オブジェクト構造体 (mapping object structure) 
10.5 数値オブジェクト構造体 (number object structure) 
10.6 シーケンスオブジェクト構造体 (sequence object structure) 
10.7 バッファオブジェクト構造体 (buffer object structure) 
10.8 イテレータプロトコルをサポートする 
10.9 循環参照ガベージコレクションをサポートする 
2.9.1 アプリケーションオブジェクト アプリケーションオブジェクトのメソッドは各種ありますが、次のメソッドをあげておきます。 
アプリケーションでメニューを使う必要がある場合、このメソッドをオーバーライドします。 
属性 menubar にメニューを追加します。 
このメソッドをオーバーライドすることで、アプリケーションの説明を記述するテキスト文字列を返します。 
代わりに、do_about() メソッドをオーバーライドすれば、もっと凝った``アバウト''メッセージを出す事ができます。 
このルーチンがメインイベントループで、作成したアプリケーションが動き出すためにはこれを呼ぶことになります。 
代わりにself._quit()を呼んでください。 イベントループは小さなパーツに分割されていて、各々をオーバーライドできるようになっています。 
これらのメソッドは、デフォルトでウィンドウとダイアログや、ドラッグとリサイズの操作、 AppleEvent、非FrameWorkのウィンドウに関するウィンドウの操作などに関するイベントを分岐することなどまで面倒をみてくれます。 原則として、全てのイベントハンドラは、イベントが完全に取り扱われた場合は 1 を返さなくてはいけませんし、それ以外では 0 を返さなくてはいけません(例えば、前面のウィンドウは FrameWork ウィンドウではない場合を考えてください)。 
非同期でイベント操作をしたい場合は、非ゼロの引数でこのメソッドを呼んでください。 
こうすることで、イベントが生じた時に、内部のインタプリタのループで、アプリケーションイベントハンドラ async_dispatch が呼ばれることになります。 
すると、長時間の計算を行っている場合でも、FrameWorkウィンドウがアップデートされ、ユーザーインターフェースが動き続けるようになります。 ただし、インタプリタの動作が減速し、非リエントラントのコード (例えばFrameWork自身など)に奇妙な動作が見られるかもしれません。 
デフォルトでは async_dispatch はすぐに our_dispatch を呼びますが、このメソッドをオーバーライドすると、特定のイベントを非同期で操作しても良くなります。 
処理しないイベントは Sioux などに渡されることになります。 onあるいはoff値が返されます。 
実行中の mainloop() 呼び出しを、次の適当なタイミングで終了させます。 
ユーザーが文字 c をタイプした時に呼ばれます。 
イベントの全詳細はevent構造体の中にあります。 
このメソッドはウィンドウオブジェクト内で使うためにも提供されています。 
このオブジェクトのウィンドウが最前面にある場合は、アプリケーション全般について本ハンドラをオーバーライドします。 do_dialogevent 
イベントループ内部で最初に呼ばれて、モードレスダイアログイベントを処理します。 
デフォルトではメソッドは単にイベントを適切なダイアログに分岐するだけです(関連したダイアログウィンドウオブジェクトを経由してではありません)。 
特別にダイアログイベント(キーボードショートカットなど)を処理する必要がある場合にオーバーライドしてください。 
イベントが無い場合にメインイベントループから呼ばれます。 
null イベントも渡されます(つまりマウス位置などを監視することができます)。 
5.4 データ整列化 (data marshalling) 
これらの関数は独自の拡張モジュール用の関数やメソッドを作成する際に便利です。 
詳しい情報や用例は 
例外として、括弧で囲われていない書式化単位文字列が単一のアドレス引数に対応する場合がいくつかあります。 
以下の説明では、引用符のついた形式は書式化単位です;(丸)括弧で囲った部分は書式化単位に対応する Python のオブジェクト型です; [角] 括弧は値をアドレス渡しする際に使う C の変数型です。 
"s" (文字列型または Unicode オブジェクト型) [const char *] 
Python の文字列または Unicode オブジェクトを、キャラクタ文字列を指す C のポインタに変換します。 
変換先の文字列自体の記憶領域を提供する必要はありません;キャラクタ型ポインタ変数のアドレスを渡すと、すでに存在している文字列へのポインタをその変数に記録します。 
C 文字列は NUL で終端されています。 
Python の文字列型は、NUL バイトが途中に埋め込まれていてはなりません; もし埋め込まれていればTypeError 例外を送出します。 Unicode オブジェクトはデフォルトエンコーディングを使ってC 文字列に変換されます。 
変換に失敗すると UnicodeError を送出します。 
"s#" (文字列型、Unicode オブジェクト型または任意の読み出しバッファ互換型)[const char *, int] これは "s" の変化形で、値を二つの変数に記録します。 
一つ目の変数はキャラクタ文字列へのポインタで、二つ目はその長さです。 
この書式化単位の場合には、Python 文字列に null バイトが埋め込まれていてもかまいません。 
Unicode オブジェクトの場合、デフォルトエンコーディングでの変換が可能ならば、変換したオブジェクトから文字列へのポインタを返します。 
その他の読み出しバッファ互換オブジェクトは生の内部データ表現への参照を返します。 
"z" (文字列型または None) [const char *] 
"s" に似ていますが、Python オブジェクトは None でもよく、その場合には C のポインタは NULLにセットされます。 
"z#" (文字列型、None、または任意の読み出しバッファ互換型) [const char *, int] 
"s#" の "s" を "z" にしたような意味です。 
"u" (Unicode オブジェクト型) [Py_UNICODE *] 
Python の Unicode オブジェクトを、NUL で終端された 16 ビットのUnicode (UTF-16) データに変換します。 
"s" と同様に、Unicode データバッファ用に記憶領域を提供する必要はありません;Py_UNICODE 型ポインタ変数のアドレスを渡すと、すでに存在しているUnicode データへのポインタをその変数に記録します。 
"u#" (Unicode オブジェクト型) [Py_UNICODE *, int] 
"es" (文字列型、Unicode オブジェクト型または任意の読み出しバッファ互換型)[const char *encoding, char **buffer] 
これは "s" の変化形で、Unicode オブジェクトや Unicode に変換可能なオブジェクトをキャラクタ型バッファにエンコードするために用いられます。 
NUL バイトが埋め込まれていない文字列でのみ動作します。 この書式化単位には二つの引数が必要です。 
一つ目は入力にのみ用いられ、NUL で終端されたエンコード名文字列を指す const char* 型でなければなりません。 
指定したエンコード名を Python が理解できない場合には例外を送出します。 
第二の引数は char** でなければなりません; この引数が参照しているポインタの値は、引数に指定したテキストの内容が入ったバッファへのポインタになります。 
テキストは最初の引数に指定したエンコード方式でエンコードされます。 
PyArg_ParseTuple() を使うと、必要なサイズのバッファを確保し、そのバッファにエンコード後のデータをコピーして、*buffer がこの新たに確保された記憶領域を指すように変更します。 
呼び出し側には、確保されたバッファを使い終わった後にPyMem_Free() で解放する責任があります。 
"et" (文字列型、Unicode オブジェクト型または文字列バッファ互換型) [const char *encoding, char **buffer] 
"es" と同じです。 ただし、8 ビット幅の文字列オブジェクトをエンコードし直さずに渡します。 
その代わり、実装では文字列オブジェクトがパラメタに渡したエンコードを使っているものと仮定します。 
"es#" (文字列型、Unicode オブジェクト型または文字列バッファ互換型) [const char *encoding, char **buffer, int *buffer_length] 
"s#" の変化形で、Unicode オブジェクトや Unicode に変換可能なオブジェクトをキャラクタ型バッファにエンコードするために用いられます。 
"es" 書式化単位と違って、この変化形はバイトが埋め込まれていてもかまいません。 この書式化単位には三つの引数が必要です。 
一つ目は入力にのみ用いられ、NUL で終端されたエンコード名文字列を指す const char* 型かNULLでなければなりません。 NULLの場合にはデフォルトエンコーディングを使います。 
指定したエンコード名を Python が理解できない場合には例外を送出します。 
第二の引数は char** でなければなりません; この引数が参照しているポインタの値は、引数に指定したテキストの内容が入ったバッファへのポインタになります。 
テキストは最初の引数に指定したエンコード方式でエンコードされます。 
呼び出し側には、確保されたバッファを使い終わった後にPyMem_Free() で解放する責任があります。 *buffer が非 NULL のポインタ (すでにメモリ確保済みのバッファ) を指している場合、PyArg_ParseTuple() はこのメモリ位置をバッファとして用い、*buffer_length の初期値をバッファサイズとして用います。 
PyArg_ParseTuple() は次にエンコード済みのデータをバッファにコピーして、NUL で終端します。 
バッファの大きさが足りなければ ValueError がセットされます。 どちらの場合も、 *buffer_length は終端の NUL バイトを含まないエンコード済みデータの長さにセットされます。 
"et#" (文字列型、Unicode オブジェクト型または文字列バッファ互換型) [const char *encoding, char **buffer] 
"es#" と同じです。 ただし、文字列オブジェクトをエンコードし直さずに渡します。 
その代わり、実装では文字列オブジェクトがパラメタに渡したエンコードを使っているものと仮定します。 
"b" (整数型) [char] 
Python の整数型を、 C の char 型の小さな整数に変換します。 
"B" (整数型) [unsigned char] 
Python の整数型を、オーバフローチェックを行わずに、 C の unsigned char 型の小さな整数に変換します。 
バージョン 2.3 で 新たに追加 された仕様です。 
"h" (整数型) [short int] 
Python の整数型を、 C の short int 型に変換します。 
"H" (整数型) [unsigned short int] 
Python の整数型を、オーバフローチェックを行わずに、 C の unsigned short int 型に変換します。 
"i" (整数型) [int] 
Python の整数型を、 C の int 型に変換します。 
"I" (整数型) [unsigned int] 
Python の整数型を、オーバフローチェックを行わずに、 C の unsigned int 型に変換します。 
"l" (整数型) [long int] 
Python の整数型を、 C の long int 型に変換します。 
"k" (整数型) [unsigned long] 
Python の整数型を、オーバフローチェックを行わずに、 C の unsigned long int 型に変換します。 
"L" (整数型) [PY_LONG_LONG] 
Python の整数型を、 C の long long 型に変換します。 
この書式化単位は、long long 型 (または Windows の _int64 型) がサポートされているプラットフォームでのみ利用できます。 
Convert a Python integer to a C long long. This format isonly available on platforms that support long long (or_int64 on Windows). "K" (整数型) [unsigned PY_LONG_LONG] 
Python の整数型を、オーバフローチェックを行わずに、 C の unsigned long long 型に変換します。 
この書式化単位は、unsigned long long 型 (または Windows の unsigned _int64 型) がサポートされているプラットフォームでのみ利用できます。 
"c" (長さ 1 の文字列型) [char] 
長さ 1 の文字列として表現されている Python キャラクタをC の char 型に変換します。 
"f" (浮動小数点型) [float] 
Python の浮動小数点型を、 C の float 型に変換します。 
"d" (浮動小数点型) [double] 
Python の浮動小数点型を、 C の double 型に変換します。 
"D" (複素数型) [Py_complex] 
Python の複素数型を、 C の Py_complex 構造体に変換します。 
"O" (オブジェクト) [PyObject *] 
Python オブジェクトを (一切変換を行わずに) C の Python オブジェクト型ポインタに保存します。 
これにより、C プログラムは実際のオブジェクトを受け渡しされます。 
オブジェクトの参照カウントは増加しません。 
保存されるポインタが NULLになることはありません。 
"O!" (オブジェクト) [typeobject, PyObject *] 
Python オブジェクトを C の Python オブジェクト型ポインタに保存します。 
"O" に似ていますが、二つの C の引数をとります: 一つ目の引数はPython の型オブジェクトへのアドレスで、二つ目の引数はオブジェクトへのポインタが保存されている (PyObject* の) C の変数へのアドレスです。 
Python オブジェクトが指定した型ではない場合、TypeError を送出します。 
"O" (オブジェクト) [converter, anything] 
Python オブジェクトを converter 関数を介して C の変数に変換します。 
二つの引数をとります: 一つ目は関数で、二つ目は (任意の型の) C 変数へのアドレスをvoid * 型に変換したものです。 
converter は以下のようにして呼び出されます: 
ここで object は変換対象の Python オブジェクトで、address は PyArg_Parse*() に渡した void* 型の引数です。 
戻り値 status は変換に成功した際に 1、失敗した場合には 0 になります。 
変換に失敗した場合、converter 関数は例外を送出しなくてはなりません。 
"S" (文字列型) [PyStringObject *] 
"O" に似ていますが、Python オブジェクトは文字列オブジェクトでなければなりません。 
オブジェクトが文字列オブジェクトでない場合にはTypeErrorを送出します。 
C 変数は PyObject* で宣言しておいてもかまいません。 
"U" (Unicode 文字列型) [PyUnicodeObject *] 
"O" に似ていますが、Python オブジェクトは Unicode オブジェクトでなければなりません。 
オブジェクトが Unicode オブジェクトでない場合にはTypeErrorを送出します。 
"t#" (読み出し専用キャラクタバッファ) [char *, int] 
"s#" に似ていますが、読み出し専用バッファインタフェースを実装している任意のオブジェクトを受理します。 
char* 変数はバッファの最初のバイトを指すようにセットされ、int はバッファの長さにセットされます。 
単一セグメントからなるバッファオブジェクトだけを受理します;それ以外の場合には TypeError を送出します。 
"w" (読み書き可能なキャラクタバッファ) [char *] 
"s" と同様ですが、読み書き可能なバッファインタフェースを実装している任意のオブジェクトを受理します。 
呼び出し側は何らかの別の手段でバッファの長さを決定するか、あるいは"w#" を使わねばなりません。 
単一セグメントからなるバッファオブジェクトだけを受理します;それ以外の場合には TypeError を送出します。 
"w#" (読み書き可能なキャラクタバッファ) [char *, int] 
"s#" に似ていますが、読み書き可能なバッファインタフェースを実装している任意のオブジェクトを受理します。 
char* 変数はバッファの最初のバイトを指すようにセットされ、int はバッファの長さにセットされます。 
"(items)" (タプル) [matching-items] 
オブジェクトはitems に入っている書式化単位の数だけの長さを持つPython のシーケンス型でなくてはなりません。 
各 C 引数は items 内の個々の書式化単位に対応づけできねばなりません。 
シーケンスの書式化単位は入れ子構造にできます。 
注意:Python のバージョン 1.5.2 より以前は、この書式化指定文字列はパラメタ列ではなく、個別のパラメタが入ったタプルでなければなりませんでした。 
このため、以前は TypeError を引き起こしていたようなコードが現在は例外を出さずに処理されるかもしれません。 
とはいえ、既存のコードにとってこれは問題ないと思われます。 
Python 整数型を要求している場所に Python 長整数型を渡すのは可能です; しかしながら、適切な値域チェックはまったく行われません --値を受け取るためのフィールドが、値全てを受け取るには小さすぎる場合、上桁のビット群は暗黙のうちに切り詰められます (実際のところ、このセマンティクスは C のダウンキャスト (downcast) から継承しています -- その恩恵は人それぞれかもしれませんが)。 その他、書式化文字列において意味を持つ文字がいくつかあります。 
それらの文字は括弧による入れ子内には使えません。 
以下に文字を示します: 
Python 引数リスト中で、この文字以降の引数がオプションであることを示します。 
オプションの引数に対応する C の変数はデフォルトの値で初期化しておかねばなりません -- オプションの引数が省略された場合、PyArg_ParseTuple() は対応する C 変数の内容に手を加えません。 
この文字があると、書式化単位の記述はそこで終わります;コロン以降の文字列は、エラーメッセージにおける関数名(PyArg_ParseTuple() が送出する例外の``付属値 (associated value)'') として使われます。 
この文字があると、書式化単位の記述はそこで終わります;セミコロン以降の文字列は、デフォルトエラーメッセージを置き換える エラーメッセージとして使われます。 
言うまでもなく、":" と ";" は相互に排他の文字です。 
呼び出し側に提供される Python オブジェクトの参照は全て 借りた (borrowed) ものです; オブジェクトの参照カウントをデクリメントしてはなりません!以下の関数に渡す補助引数 (additional argument) は、書式化文字列から決定される型へのアドレスでなければなりません; 補助引数に指定したアドレスは、タプルから入力された値を保存するために使います。 
上の書式化単位のリストで説明したように、補助引数を入力値として使う場合がいくつかあります; その場合、対応する書式化単位の指定する形式に従うようにせねばなりません。 変換を正しく行うためには、arg オブジェクトは書式化文字に一致しなければならず、かつ書式化文字列内の書式化単位に全て値が入るようにせねばなりません。 
成功すると、PyArg_Parse*() 関数は真を返します。 それ以外の場合には偽を返し、適切な例外を送出します。 
固定引数のみを引数にとる関数のパラメタを解釈して、ローカルな変数に変換します。 
成功すると真を返します;失敗すると偽を返し、適切な例外を送出します。 
PyArg_ParseTuple() と同じですが、可変長の引数ではなく va_list を引数にとります。 
固定引数およびキーワード引数をとる関数のパラメタを解釈して、ローカルな変数に変換します。 
成功すると真を返します;失敗すると偽を返し、適切な例外を送出します。 
PyArg_ParseTupleAndKeywords() と同じですが、可変長の引数ではなく va_list を引数にとります。 
``旧形式'' の関数における引数リストを分析するために使われる関数です -- 旧形式の関数は、引数解釈手法にMETH_OLDARGS を使います。 
新たに書かれるコードでのパラメタ解釈にはこの関数の使用は奨められず、標準のインタプリタにおけるほとんどのコードがもはや引数解釈のためにこの関数を使わないように変更済みです。 
この関数を残しているのは、この関数が依然として引数以外のタプルを分析する上で便利だからですが、この目的においては将来も使われつづけるかもしれません。 
パラメータ取得を簡単にした形式で、引数の型を指定する書式化文字列を使いません。 
パラメタの取得にこの手法を使う関数は、関数宣言テーブル、またはメソッド宣言テーブル内でMETH_VARARGS として宣言しなくてはなりません。 
実引数の入ったタプルは args に渡します;このタプルは本当のタプルでなくてはなりません。 
タプルの長さは少なくとも min で、max を超えてはなりません;min と max が等しくてもかまいません。 
補助引数を関数に渡さなくてはならず、各補助引数はPyObject* 変数へのポインタでなくてはなりません; これらの補助引数には、args の値が入ります; 値の参照は借りた参照です。 
この例におけるPyArg_UnpackTuple() 呼び出しは、PyArg_ParseTuple() を使った以下の呼び出し: 
PyArg_ParseTuple(args, "O|O:ref", object, callback) と全く等価です。 
バージョン 2.2 で 新たに追加 された仕様です。 
PyArg_Parse*() ファミリの関数が受け取るのと似た形式の書式化文字列および値列に基づいて、新たな値を生成します。 
生成した値を返します。 エラーの場合にはNULL を返します;NULL を返す場合、例外を送出するでしょう。 
Py_BuildValue() は常にタプルを生成するとは限りません。 
この関数がタプルを生成するのは、書式化文字列に二つ以上の書式化単位が入っているときだけです。 
書式化文字列が空の場合、None を返します; 書式化単位が厳密に一つだけ入っている場合、書式化単位で指定されている何らかのオブジェクト単体を返します。 
サイズがゼロや 1 のタプルを返すように強制するには、丸括弧で囲われた書式化文字列を使います。 書式化単位 "s" や "s#" の場合のように、オブジェクトを構築する際にデータを供給するためにメモリバッファをパラメタとして渡す場合には、指定したデータはコピーされます。 
Py_BuildValue()が生成したオブジェクトは、呼び出し側が提供したバッファを決して参照しません。 
これらの文字を使うと、長い書式化文字列をちょっとだけ読みやすくできます。 
"s" (文字列型) [char *] 
null 終端された C 文字列から Python オブジェクトに変換します。 
C 文字列ポインタが NULLの場合、 None になります。 
"s#" (文字列型) [char *, int] 
C 文字列とその長さから Python オブジェクトに変換します。 
C 文字列ポインタが NULLの場合、長さは無視され None になります。 
"s" と同じです。 
"s#" と同じです。 
null 終端された Unicode (UCS-2 または UCS-4) データのバッファからPython オブジェクトに変換します。 
Unicode バッファポインタが NULLの場合、 None になります。 
null 終端された Unicode (UCS-2 または UCS-4) データのバッファとその長さから Python オブジェクトに変換します。 
Unicode バッファポインタが NULLの場合、長さは無視されNone になります。 
通常の C の int を Python の整数オブジェクトに変換します。 
"i" と同じです。 
C の long int を Python の整数オブジェクトに変換します。 
文字を表す通常の C の int を、長さ 1 の Python の文字列オブジェクトに変換します。 
C の double を Python の浮動小数点数に変換します。 
"d" と同じです。 
"D" (複素数型) [Py_complex *] 
C の Py_complex 構造体を Python の複素数に変換します。 
Python オブジェクトを手を加えずに渡します (ただし、参照カウントは1 インクリメントします)。 
渡したオブジェクトが NULL ポインタの場合、この引数を生成するのに使った何らかの呼び出しがエラーになったのが原因であると仮定して、例外をセットします。 従ってこのとき Py_BuildValue() は NULL を返しますがPy_BuildValue() 自体は例外を送出しません。 
例外をまだ送出していなければSystemError をセットします。 
"S" (オブジェクト) [PyObject *] 
"O" と同じです。 
"N" (オブジェクト) [PyObject *] 
"O" と同じです。 ただし、オブジェクトの参照カウントをインクリメントしません。 
オブジェクトが引数リスト内のオブジェクトコンストラクタ呼び出しによって生成されている場合に便利です。 
anything を converter 関数を介して Python オブジェクトに変換します。 
この関数は anything (void * と互換の型でなければなりません) を引数にして呼び出され、``新たな'' オブジェクトを返すか、失敗した場合には NULL を返すようにしなければなりません。 
"(items)" (タプル型) [matching-items] 
C の値からなる配列を、同じ要素数を持つ Python のタプルに変換します。 
"[items]" (リスト型) [matching-items] 
C の値からなる配列を、同じ要素数を持つ Python のリストに変換します。 
"{items}" (辞書型) [matching-items] 
C の値からなる配列を Python の辞書に変換します。 
一連のペアからなるC の値が、それぞれキーおよび値となって辞書に追加されます。 
書式化文字列に関するエラーが生じると、SystemError 例外をセットして NULL を返します。 
1.2.2.2 クリエータをセットしてダブルクリックする 
1.2 MacPython-OS9 の取得とインストール 
1.2.4 Pythonスクリプトを作成する 
1.2.3 コマンドライン引数をシミュレートする MacPython-OS9 でコマンドライン引数をシミュレートするには 2 つの方法があります。 
インタプリタオプションを使う場合 
スクリプトを起動する時、オプションキーを押しながら行います。 
Python インタプリタオプションのダイアログボックスが現われます。 
``Set Unix-style command line..''ボタンをクリックします。 
``Argument''フィールドに引数をタイプします。 
``OK''をクリックします。 
``Run''をクリックします。 
ドラッグ&ドロップを使う場合。 スクリプトをアプレットとして保存した場合 (1.3.4 節参照)、 「ドラッグ&ドロップ」でコマンドライン引数もシミュレートできます。 
この場合、アプレットにドロップしたファイルの名前が sys.argv に追加され、ドロップしたファイル名はスクリプト側からはコマンドラインでタイプされたかのように見えます。 
Unix システムと同様、sys.srgv の最初の要素はアプレット自体へのパスになります。 残りの要素はアプレットにドロップしたファイルの名前です。 
Assert 文 
は、プログラム内にデバッグ用アサーション(debugging assertion) を仕掛けるための便利な方法です: 
単純な形式 "assert expression" は、 
と等価です。 拡張形式 "assert expression1, expression2" は、 
と等価です。 
上記の等価関係は、 __debug__ とAssertionError 
が、同名の組み込み変数を参照しているという前提の上に成り立っています。 
現在の実装では、組み込み変数 __debug__ は通常は 1 であり、インタプリタに (コマンドラインオプション -O で) 最適化を要求すると0 になります。 
現状のコード生成器は、コンパイル時に最適化が要求されていると assert 文に対するコードを全く出力しません。 
実行に失敗した式のソースコードをエラーメッセージ内に入れる必要はありません; メッセージはスタックトレース内で表示されます。 __debug__ への代入は不正な操作です。 
組み込み変数の値は、インタプリタが開始するときに決定されます。 
6.2 Assert 文 (assert 
6.3.1 累算代入文 (augmented assignment 
代入文 
は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変更したりするために使われます: 
(末尾の三つのシンボルの構文については5.3 節を参照してください。 )代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、後者はタプルになることを思い出してください) を評価し、得られた単一の結果オブジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。 
代入はターゲット (リスト) の形式に従って再帰的に行われます。 
ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス)の一部である場合、この変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作であるか判断しなければなりません。 代入が不可能な場合には例外を発行することもできます。 
型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えられています (3.2 節を参照してください). 
ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に定義されています。 
ターゲットリストが単一のターゲットからなる場合: オブジェクトはそのターゲットに代入されます。 
ターゲットリストが、カンマで区切られた複数のターゲットからなるリストの場合: オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるシーケンスでなければならず、その各要素は左から右へと対応するターゲットに代入されます。 
(これは Python 1.5で緩和された規則です; 以前のバージョンでは、代入するオブジェクトはタプルでなければなりませんでした。 
文字列もシーケンスなので、今では"a, b = "xy"" のような代入は文字列が正しい長さを持つ限り正規の操作になります。 ) 
単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義されています。 
ターゲットが識別子 (名前) の場合: 
名前が現在のコードブロック内の global 文に書かれていない場合: 名前は現在のローカル名前空間内のオブジェクトに束縛されます。 
それ以外の場合: 名前は現在のグローバル名前空間内のオブジェクトに束縛されます。 
名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。 
再束縛によって、以前その名前に束縛されていたオブジェクトの参照カウント (reference count) がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ (destructor 
) が (存在すれば) 呼び出されます。 
ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合:オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるシーケンスでなければならず、その各要素は左から右へと対応するターゲットに代入されます。 
ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。 
値は代入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、 TypeError が送出されます。 
次に、このオブジェクトに対して、被代入オブジェクトを指定した属性に代入してよいか問い合わせます; 代入を実行できない場合、例外 (通常は AttributeError ですが、必然ではありません)を送出します。 
ターゲットが添字表記の場合: 参照されている一次語の式が値評価されます。 
まず、値は変更可能なシーケンスオブジェクト (例えばリスト)か、マップオブジェクト (例えば辞書) でなければなりません。 
次に、添字表記の表す式が値評価されます。 
一次語が変更可能なシーケンスオブジェクト (例えばリスト) の場合、まず添字は整数でなければなりません。 
添字が負数の場合、シーケンスの長さが加算されます。 
添字は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはなりません。 次に、添字をインデクスに持つ要素に非代入オブジェクトを代入してよいか、シーケンスに問い合わせます。 
範囲を超えたインデクスに対してはIndexError が送出されます (添字指定されたシーケンスに代入を行っても、リスト要素の新たな追加はできません)。 
一次語がマップオブジェクト (例えば辞書) の場合、まず添字はマップのキー型と互換性のある型でなくてはなりません。 次に、添字を被代入オブジェクトに関連付けるようなキー/データの対を生成するようマップオブジェクトに問い合わせます。 
この操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。 
ターゲットがスライスの場合: 参照されている一次語の式が値評価されます。 
まず、値は変更可能なシーケンスオブジェクト (例えばリスト)でなければなりません。 
被代入オブジェクトは同じ型を持ったシーケンスオブジェクトでなければなりません。 
次に、スライスの下境界と上境界を示す式があれば評価されます; デフォルト値はそれぞれゼロとシーケンスの長さです。 
上下境界は整数にならなければなりません。 
いずれかの境界が負数になった場合、シーケンスの長さが加算されます。 
最終的に、境界はゼロからシーケンスの長さまでの内包になるようにクリップされます。 
最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに問い合わせます。 
オブジェクトで許されている限り、スライスの長さは被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの長さが変更されます。 
(現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。 
)警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入(例えば、"a, b = b, a" を行うと、二つの変数を入れ替えます) を定義しても `安全 (safe)' に代入できますが、代入対象となる変数群 の間で オーバラップがある場合は安全ではありません!例えば、以下のプログラムは "[0, 2]" を出力してしまいます: 
11.26.1 asynchat - 補助クラスと関数 
以下のサンプルは、async_chatでHTTPリクエストを読み込む処理の一部です。 
Webサーバは、クライアントからの接続毎にhttp_request_handlerオブジェクトを作成します。 
次の簡単な例では、あるモジュールを import した時にカウンタを初期化しておき、プログラムが終了するときにアプリケーションがこのモジュールを明示的に呼び出さなくてもカウンタが更新されるようにする方法を示しています。 
register() に指定した固定引数とキーワードパラメタは登録した関数を呼び出す際に渡されます。 
アトムの形になっている識別子 (identifier) は名前 (name) です。 
名前づけや束縛については、4.1 節を参照してください。 名前があるオブジェクトに束縛されている場合、名前アトムを評価するとそのオブジェクトになります。 
名前が束縛されていない場合、アトムを評価しようとするとNameError 例外を送出します。 
プライベートな名前の難号化 (mangling): 
クラス定義内にテキストの形で書かれた識別子で、二つ以上のアンダースコアから始まり、末尾が二つ以上のアンダースコアになっていないものは、そのクラスの プライベートな名前 (private name) とみなされます。 プライベートな名前は、コードが生成される前に、より長い形式の名前に変換されます。 
この変換では、クラス名の先頭にあるアンダースコアを全てはぎとり、先頭にアンダースコアを一つ挿入して、名前の前に付加します。 
例えば、クラス Ham 内の識別子 __spam は、_Ham__spam に変換されます。 
変換は識別子が使われている構文的コンテキストとは独立しています。 
変換された名前が非常に長い(255 文字以上) の場合には、実装によっては名前の切り詰めが起きるかもしれません。 
クラス名がアンダースコアだけから成り立つ場合には、変換は行われません。 
Python では、文字列リテラルと、様々な数値リテラルをサポートしています: 
リテラルを評価すると、指定した型 (文字列、整数、長整数、浮動小数点数、複素数) の指定した値を持つオブジェクトになります。 
浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。 
同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。 
アトム (原子的要素: atom) は、式を構成する基本単位です。 
もっとも単純なアトムは、識別子またはリテラルになります。 
逆クオートや丸括弧、波括弧、または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類されます。 
アトムの構文定義は以下のようになります: 
5.2.1 識別子 (identifier、または名前 (name)) 
3.3.2.1 新しい形式のクラスのための別の属性アクセス 
以下のメソッドを定義して、クラスインスタンスへの属性値アクセス (属性値の使用、属性値への代入、x.name の削除) の意味をカスタマイズすることができます。 
属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわち、self のインスタンス属性でなく、かつクラスツリーにも見つからなかった場合) に呼び出されます。 このメソッドは (計算された) 属性値を返すか、AttributeError例外を送出しなければなりません。 
少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないようにして (代わりに他のオブジェクトに挿入することで)属性値が完全に制御されているように見せかけられることに注意してください。 
新形式のクラスで実際に完全な制御を行う方法は、以下の__getattribute__() メソッドを参照してください。 
属性値への代入が試みられた際に呼び出されます。 
このメソッドは通常の代入メカニズム (すなわち、インスタンス辞書への値の代入)の代わりに呼び出されます。 
name は属性名で、value はその属性に代入する値です。 
__setattr__() の中でインスタンス属性値への代入が必要な場合、単に "self.name = value" としてはなりません -- このようにすると、自分自身に対する再帰呼び出しがおきてしまいます。 
その代わりに、インスタンス属性の辞書に値を挿入してください。 
例えば、"self.__dict__[name] = value" とします。 新しい形式のクラスでは、インスタンス辞書にアクセスするのではなく、基底クラスのメソッドを同じ属性名で呼び出します。 
例えば、"object.__setattr__(self, name, value)" とします。 __delattr__ 
__setattr__() に似ていますが、代入ではなく値の削除を行います。 
このメソッドを実装するのは、オブジェクトにとって"del obj.name 
" が意味がある場合だけにしなければなりません。 
3.3.2.1 新しい形式のクラスのための別の属性アクセス 
3.3.2.2 デスクリプタ (descriptor) の実装 
3.3.2.3 デスクリプタを呼び出す 
属性参照は、一次語の後ろにピリオドと名前を連ねたものです: 
一次語の値評価結果は、例えばモジュール、リスト、インスタンスといった、属性参照をサポートする型でなければなりません。 
オブジェクトは次に、指定した名前が識別子名となっているような属性を生成するよう問い合わせされます。 
問い合わせた属性が得られない場合、例外AttributeError が送出されます。 
それ以外の場合、オブジェクトは属性オブジェクトの型と値を決定し、生成して返します。 
同じ属性参照を複数回評価したとき、互いに異なる属性オブジェクトになることがあります。 
このインターフェースは 
Attributesinterface (セクション13.12.5参照) のサブタイプです。 
修飾名の値を返す。 
修飾名 name に対応する (namespace,localname) のペアを返す。 
(namespace, localname) のペアに対応する修飾名を返す。 
すべての属性の修飾名を返す。 
Attributes オブジェクトは copy()、get()、has_key()、items()、 keys()、values() などを含む、マッピング・プロトコルの一部を実装したものです。 
さらに次のメソッドも提供されています。 : 
属性の数を返す。 
属性の名前を返す。 
属性名 name のタイプを返す。 通常は 'CDATA'。 
属性 name の値を返す。 
上述のopen()によって返されるAU_readオブジェクトには、以下のメソッドがあります: 
(これはオブジェクトのガベージコレクション時に自動的に呼び出されます。 ) 
オーディオチャンネル数(モノラルなら1、ステレオなら2)を返します。 
圧縮形式を返します。 'ULAW'、'ALAW'、'NONE'がサポートされている形式です。 
getcomptype()を人に判読可能な形にしたものです。 
上述の形式に対して、それぞれ'CCITT G.711 u-law'、'CCITT G.711 A-law'、'not compressed'がサポートされています。 
get*()メソッドが返すのと同じ(nchannels, sampwidth, framerate,nframes, comptype, compname)のタプルを返します。 
n個のオーディオフレームの値を読み込んで、バイトごとに文字に変換した文字列を返します。 
データはlinear形式で返されます。 
もし元のデータがu-LAW形式なら、変換されます。 
tell()で返される値をposとして使用しなければなりません。 
返される値はファイルの実際の位置に対して何も操作はしません。 
以下の2つのメソッドは 
モジュールとの互換性のために定義されていますが、何も面白いことはしません。 
上述のopen()によって返されるWave_writeオブジェクトには、以下のメソッドがあります: 
サンプルサイズを(バイト数で)設定します。 
フレームレートを設定します。 
フレーム数を設定します。 
あとからフレームが書き込まれるとフレーム数は変更されます。 
圧縮形式とその記述を設定します。 'NONE'と'ULAW'だけが、出力時にサポートされている形式です。 
全ての変数を設定します。 
ファイルの中の現在位置を返します。 AU_read.tell()とAU_read.setpos()メソッドでお断りしたことがこのメソッドにも当てはまります。 
writeframes()やwriteframesraw()メソッドを呼び出したあとで、どんなパラメータを設定しようとしても不正となることに注意して下さい。 
オーディオデバイスオブジェクトはopen()で返され、このオブジェクトには以下のメソッドが定義されています(controlオブジェクトは除きます。 これにはgetinfo()、setinfo()、fileno()、drain()だけが定義されています): 
このメソッドはデバイスを明示的に閉じます。 
オブジェクトを削除しても、それを参照しているものがあって、すぐに閉じてくれない場合に便利です。 
閉じられたデバイスを使うことはできません。 
デバイスに関連づけられたファイルディスクリプタを返します。 
これは、後述のSIGPOLLの通知を組み立てるのに使われます。 
このメソッドは全ての出力中のプロセスが終了するまで待って、それから制御が戻ります。 このメソッドの呼び出しはそう必要ではありません:オブジェクトを削除すると自動的にオーディオデバイスを閉じて、暗黙のうちに吐き出します。 
このメソッドは全ての出力中のものを捨て去ります。 
ユーザの停止命令に対する反応の遅れ(1秒までの音声のバッファリングによって起こります)を避けるのに使われます。 
このメソッドは入出力のボリューム値などの情報を引き出して、オーディオステータスのオブジェクト形式で返します。 
このオブジェクトには何もメソッドはありませんが、現在のデバイスの状態を示す多くの属性が含まれます。 
属性の名称と意味はsun/audioio.hと 
audio(7I)に記載があります。 
メンバー名は相当するCのものとは少し違っています:ステータスオブジェクトは1つの構造体です。 
その中の構造体であるplayのメンバーには名前の初めに"o_"がついていて、recordには"i_"がついています。 
そのため、Cのメンバーであるplay.sample_rateはo_sample_rateとして、record.gainはi_gainとして参照され、monitor_gainはそのままmonitor_gainで参照されます。 
このメソッドは録音側でバッファリングされるサンプル数を返します。 
つまり、プログラムは同じ大きさのサンプルに対するread()の呼び出しをブロックしません。 
このメソッドは再生側でバッファリングされるサンプル数を返します。 
残念ながら、この数値はブロックなしに書き込めるサンプル数を調べるのには使えません。 というのは、カーネルの出力キューの長さは可変だからです。 
このメソッドはオーディオ入力からsizeのサイズのサンプルを読み込んで、Pythonの文字列として返します。 
この関数は必要なデータが得られるまで他の操作をブロックします。 
このメソッドはオーディオデバイスのステータスパラメータを設定します。 
パラメータstatusはgetinfo()で返されたり、プログラムで変更されたオーディオステータスオブジェクトです。 
パラメータとしてオーディオサンプルをPython文字列を受け取り、再生します。 もし十分なバッファの空きがあればすぐに制御が戻り、そうでないならブロックされます。 
オーディオデバイスはSIGPOLLを介して様々なイベントの非同期通知に対応しています。 
Pythonでこれをどのようにしたらできるか、例を挙げます: 
6.3.1 累算代入文 (augmented assignment statement) 累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです: 
累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、結果をもとのターゲットに代入します。 
ターゲットは一度しか評価されません。 x += 1 のような累算代入式は、x = x + 1 のように書き換えてほぼ同様の動作にできますが、厳密に等価にはなりません。 
累算代入の方では、x は一度しか評価されません。 
同様に、累算代入で行われる二項演算は、場合によってインプレース演算 が行われることを除き、通常の二項演算と同じです。 属性参照のターゲットの場合、代入前の初期値は getattr() で取り出され、演算結果は setattr() で代入されます。 
二つのメソッドが同じ変数を参照するという必然性はないので注意してください。 
例えば: 
class A:x = 3 # class variablea = A()a.x += 1 # writes a.x as 4 leaving A.x as 3 のように、getattr() がクラス変数を参照していても、setattr() はインスタンス変数への書き込みを行ってしまいます。 
1.2 幕間小話: エラーと例外 
1.4 モジュールのメソッドテーブルと初期化関数 
先ほどの関数の例に戻ると、今度は以下の実行文を理解できるはずです: 
この実行文は、PyArg_ParseTuple() がセットする例外によって、引数リストに何らかのエラーが生じたときにNULL (オブジェクトへのポインタを返すタイプの関数におけるエラー標示値) を返します。 
エラーでなければ、引数として与えた文字列値はローカルな変数 command にコピーされています。 
この操作はポインタ代入であり、ポインタが指している文字列に対して変更が行われるとは想定されていません (従って、標準 C では、変数 command は "const char* command" として適切に定義せねばなりません)。 次の文では、PyArg_ParseTuple() で得た文字列を渡して Unix 関数 system() を呼び出しています: 
spam.system() は sts を Python オブジェクトとして返さねばなりません。 
これには、PyArg_ParseTuple()の逆ともいうべき関数Py_BuildValue() を使います:Py_BuildValue() は書式化文字列と任意の数の C の値を引数にとり、新たな Python オブジェクトを返します。 Py_BuildValue() に関する詳しい情報は後で示します。 
上の場合では、Py_BuildValue() は整数オブジェクトを返します。 
(そう、整数ですら、 Python においてはヒープ上のオブジェクトなのです! )何ら有用な値を返さない関数 (void を返す関数) に対応する Python の関数はNone を返さねばなりません。 
関数に None を返させるには、以下のような慣用句を使います(この慣用句はPy_RETURN_NONE マクロに実装されています): 
Py_None は特殊な Pyhton オブジェクトである None に対応する C での名前です。 
これまで見てきたようにほとんどのコンテキストで ``エラー'' を意味する NULL ポインタとは違い、None は純粋なPython のオブジェクトです。 
BaseHandler オブジェクトは直接的に役に立つ 2 つのメソッドと、その他として導出クラスで使われることを想定したメソッドを提供します。 
以下は直接的に使うためのメソッドです: 
親オブジェクトとして、director を追加します。 
全ての親オブジェクトを削除します。 
以下のメンバおよびメソッドは BaseHandler から導出されたクラスでのみ使われます: 
注意:慣習的に、 
protocol_request() や 
protocol_response() といったメソッドを定義しているサブクラスは*Processor と名づけ、その他は*Handlerと名づけることになっています 
有効な OpenerDirector です。 この値は違うプロトコルを使って URL を開く場合やエラーを処理する際に使われます。 
このメソッドは BaseHandler では定義されて いません。 しかし、全ての URL をキャッチさせたいなら、サブクラスで定義する必要があります。 
このメソッドが定義されていた場合、OpenerDirector から呼び出されます。 このメソッドは OpenerDirector の メソッドopen() が返す値について記述されているようなファイル類似のオブジェクトか、None を返さなくてはなりません。 
このメソッドが送出する例外は、真に例外的なことが起きない限り、URLError を送出しなければなりません (例えば、MemoryError を URLError をマップしてはいけません)。 
このメソッドはプロトコル固有のオープンメソッドが呼び出される前に呼び出されます。 protocol_open( 
戻り値は default_open と同じでなければなりません。 
このメソッドは BaseHandler では定義されて いません。 しかしその他の処理されなかった HTTP エラーを処理する機能をもたせたいなら、サブクラスで定義する必要があります。 
このメソッドはエラーに遭遇したOpenerDirector から自動的に呼び出されます。 その他の状況では普通呼び出すべきではありません。 
nnn は 3 桁の 10 進数からなる HTTP エラーコードでなくてはなりません。 
戻り値もまた、urlopen() の戻り値と同じインタフェースを実装したオブジェクトでなければなりません。 
このクラスは、文字列(NULを含む)で初期化することができます。 Binaryの内容は、属性で参照します。 
Binaryインスタンスがカプセル化しているバイナリデータ。 
このデータは8bitクリーンです。 
以下のメソッドは、主に内部的にマーシャル/アンマーシャル時に使用されます: 
指定されたbase64文字列をデコードし、インスタンスのデータとします。 
バイナリ値をbase64でエンコードし、出力ストリームオブジェクト outに出力します。 
また、__cmp__で定義される演算子を使用することができます。 
5.5 単項算術演算 (unary arithmetic 
二項算術演算は、慣習的な優先順位を踏襲しています。 
演算子のいずれかは、特定の非数値型にも適用されるので注意してください。 
べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません: 
* (乗算: multiplication) 演算は、引数間の積になります。 
引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または長整数) 型で他方がシーケンス型かのどちらかでなければなりません。 前者の場合、数値は共通の型に変換された後乗算されます。 
後者の場合、シーケンスの繰り返し操作が行われます。 繰り返し数を負にすると、空のシーケンスになります。 
/ (除算: division) および // (切り捨て除算: floor division)は、引数間の商になります。 
数値引数はまず共通の型に変換されます。 
整数または長整数の除算結果は、同じ型の整数になります; この場合、結果は数学的な除算に関数 `floor' を適用したものになります。 
ゼロによる除算を行うと ZeroDivisionError 例外を送出します。 
% (モジュロ: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。 
数値引数はまず共通の型に変換されます。 
右引数値がゼロの場合には、ZeroDivisionError 例外が送出されます。 
引数値は浮動小数点でもよく。 例えば 3.14%0.7 は 0.34 になります (3.14 は 4*0.7 + 0.34 だからです)。 
モジュロ演算子は常に第二引数と同じ符号 (またはゼロ)の結果になります; モジュロ演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 
整数による除算演算やモジュロ演算は、恒等式: x == (x/y)*y + (x%y) と関係しています。 
整数除算やモジュロはまた、組み込み関数 divmod():divmod(x, y) == (x/y, x%y) と関係しています。 
これらの恒等関係は浮動小数点の場合には維持されません;x/y が floor(x/y) や floor(x/y) - 1 に置き換えられた場合、これらの恒等式は近似性を維持します。 
リリース 2.3 で撤廃されました。 
切り捨て除算演算子、モジュロ演算子、およびdivmod() 関数は、複素数に対してはもはや定義されていません。 
目的に合うならば、代わりに abs() を使って浮動小数点に変換してください。 
+ (加算) 演算は、引数を加算した値を返します。 引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。 
前者の場合、数値は共通の型に変換され、加算されます。 
後者の場合、シーケンスは結合 (concatenate) されます。 
- (減算) 演算は、引数間で減算を行った値を返します。 
数値引数はまず共通の型に変換されます。 
...の絶対値よりも小さくなります。 5.2 
例えば、Python の浮動小数点型がIEEE754 倍精度数型になっているプラットフォームを仮定すると、-1e-100 % 1e100 は 1e100 と同じ符号になるはずなのに、計算結果は -1e-100 + 1e100 となります。 これは数値計算的には厳密に 1e100 と等価です。 
mathモジュールの関数 fmod() は、最初の引数と符号が一致するような値を返すので、上記の場合には -1e-100 を返します。 どちらのアプローチが適切かは、アプリケーションに依存します。 
...置き換えられた場合、これらの恒等式は近似性を維持します。 
x が y の整数倍に非常に近い場合、丸め誤差によって floor(x/y) は (x-x%y)/y よりも大きな値になる可能性があります。 
そのような場合、 Python はdivmod(x,y)[0] * y + x % y が x に非常に近くなるという関係を保つために、後者の値を返します。 
一般には、bisect() 関数は数値データを分類するのに役に立ちます。 
この例では、bisect() を使って、(たとえば)順序のついた数値の区切り点の集合に基づいて、試験全体の成績の文字を調べます。 
区切り点は 85 以上は `A'、 75..84 は `B'、などです。 grades = "FEDCBA" breakpoints = [30, 44, 66, 75, 85] from bisect import bisect def grade(total):... return grades[bisect(breakpoints, total)]... grade(66)'C' map(grade, [33, 99, 77, 44, 12, 88])['E', 'A', 'B', 'D', 'F', 'A'] 
通常および長整数型ではさらに、ビット文字列に対してのみ意味のある演算をサポートしています。 
演算 
結果 
注釈 
ビット単位の x と y の 論理和 
ビット単位の x と y の 論理積 
x の n ビット左シフト 
x の n ビット右シフト 
x のビット反転 
注釈: 
負値のシフト数は不正であり、ValueError が送出されます。 
n ビットの左シフトは、オーバフローチェックを行わないpow(2, n) による乗算と等価です。 
n ビットの右シフトは、オーバフローチェックを行わないpow(2, n) による除算と等価です。 
以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります: 
演算子は、引数間でビット単位の AND をとった値になります。 引数は整数または長整数でなければなりません。 
引数は共通の型に変換されます。 
^ 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値になります。 引数は整数または長整数でなければなりません。 
引数は共通の型に変換されます。 
| 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値になります。 
引数は整数または長整数でなければなりません。 
スペース、タブ、フォームフィード、およびコメントのみを含む論理行は無視されます (すなわち、NEWLINE トークンは生成されません)。 
文を対話的に入力している際には、空行の扱いは行読み込み-評価-出力(read-eval-print) ループの実装によって異なるかもしれません。 
標準的な実装では、完全な空行でできた論理行 (すなわち、空白文字もコメントも全く含まない空行) は、複数行からなる実行文の終端を示します。 
コードオブジェクトは、関数本体のような ``擬似コンパイルされた''Python の実行可能コードを表すために実装系によって使われます。 コードオブジェクトはグローバルな実行環境への参照を持たない点で関数オブジェクトとは異なります。 
コードオブジェクトは組み込み関数 compile() によって返され、関数オブジェクトの func_code 属性として取り出すことができます。 
を読んで下さい。 
このオブジェクトは拡張スライス表記によって使われます ( 
を参照してください)。 
特殊な操作は何もサポートしていません。 
省略表記オブジェクトは一つだけで、その名前は Ellipsis (組み込み名) です。 Ellipsis と書き表されます。 
ファイルオブジェクト 
ファイル操作が I/O 関連の理由で失敗した場合例外 IOErrorが送出されます。 
この理由には例えば seek() を端末デバイスに行ったり、読み出し専用で開いたファイルに書き込みを行うといった、何らかの理由によってそのファイルで定義されていない操作を行ったような場合も含まれます。 ファイルは以下のメソッドを持ちます: 
ファイルを閉じます。 
閉じられたファイルはそれ以後読み書きすることはできません。 ファイルが開かれていることが必要な操作は、ファイルが閉じられた後はすべて ValueError を送出します。 
close を一度以上呼び出してもかまいません。 
stdio の fflush() のように、内部バッファをフラッシュします。 
ファイル類似のオブジェクトによっては、この操作は何も行いません。 
背後にある実装系がオペレーティングシステムに I/O 操作を要求するために用いる、整数の ``ファイル記述子'' を返します。 
この値は他の用途として、 
モジュールや os.read()やその仲間のような、ファイル記述子を必要とする低レベルのインタフェースで役に立ちます。 
注意:ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメソッドを提供すべきではありません。 
ファイルが tty (または類似の) デバイスに接続されている場合 True を返し、そうでない場合 False を返します。 
注意:ファイル類似のオブジェクトが実際のファイルに関連付けられていない場合、このメソッドを実装すべきではありません。 
ファイルオブジェクトはそれ自身がイテレータです。 すなわち、iter(f) は (f が閉じられていない限り) f を返します。 
for ループ (例えば for line in f: print line) のようにファイルがイテレータとして使われた場合、next() メソッドが繰り返し呼び出されます。 
個のメソッドは次の入力行を返すか、または EOF に到達したときにStopIteration を送出します。 
ファイル内の各行に対するfor ループ (非常によくある操作です) を効率的な方法で行うために、next() メソッドは隠蔽された先読みバッファを使います。 
先読みバッファを使った結果として、(readline() のような) 他のファイルメソッドと next() を組み合わせて使うとうまく動作しません。 
しかし、seek() を使ってファイル位置を絶対指定しなおすと、先読みバッファはフラッシュされます。 バージョン 2.3 で 新たに追加 された仕様です。 
最大で size バイトをファイルから読み込みます (size バイトを取得する前に EOF に到達した場合、それ以下の長さになります)size 引数が負であるか省略された場合、EOF に到達するまでの全てのデータを読み込みます。 
読み出されたバイト列は文字列オブジェクトとして返されます。 
直後に EOF に到達した場合、空の文字列が返されます。 
(端末のようなある種のファイルでは、 EOF に到達した後でファイルを読みつづけることにも意味があります。 
) このメソッドは、size バイトに可能な限り近くデータを取得するために、背後の C 関数fread() を 1 度以上呼び出すかもしれないので注意してください。 
また、非ブロック・モードでは、size パラメータが与えられなくても、要求されたよりも少ないデータが返される場合があることに注意してください。 
ファイルから一行を読み出します。 
末尾の改行文字は文字列中に残されます(ですが、ファイルが不完全な行で終わっている場合は何も残らないかもしれません)。 
注意: stdio の fgets() と違い、入力中にヌル文字 ('0') が含まれていれば、ヌル文字を含んだ文字列が返されます。 
readline() を使ってに到達するまで読み出し、EOF読み出された行を含むリストを返します。 
オプションの sizehint 引数が存在すれば、EOFまで読み出す代わりに完全な行を全体で大体 sizehint バイトになるように(おそらく内部バッファサイズを切り詰めて) 読み出します。 
ファイル類似のインタフェースを実装しているオブジェクトは、sizehint を実装できないか効率的に実装できない場合には無視してもかまいません。 
個のメソッドは iter(f) と同じ結果を返します。 バージョン 2.1 で 新たに追加 された仕様です。 
リリース 2.3 で撤廃されました。 
代わりに "for line in file " を使ってください。 
stdio の fseek() と同様に、ファイルの現在位置を返します。 whence 引数はオプションで、標準の値は 0(絶対位置指定) です; 他に取り得る値は 1 (現在のファイル位置から相対的に seek する) および 2 (ファイルの末端から相対的にseek する) です。 
戻り値はありません。 
ファイルを追記モード(モード 'a' または 'a+') で開いた場合、書き込みを行うまでに行ったseek() 操作はすべて元に戻されるので注意してください。 
ファイルが追記のみの書き込みモード ('a') で開かれた場合、このメソッドは実質何も行いませんが、読み込みが可能な追記モード('a+') で開かれたファイルでは役に立ちます。 
ファイルをテキストモード ('t') で開いた場合、tell() が返すオフセットのみが正しい値になります。 
他のオフセット値を使った場合、その振る舞いは未定義です。 全てのファイルオブジェクトが seek できるとは限らないので注意してください。 
stdio の ftell() と同様、ファイルの現在位置を返します。 
ファイルのサイズを切り詰めます。 
オプションの size が存在すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。 
標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。 
現在のファイル位置は変更されません。 
指定されたサイズがファイルの現在のサイズを越える場合、その結果はプラットフォーム依存なので注意してください: 可能性としては、ファイルは変更されないか、指定されたサイズまでゼロで埋められるか、指定されたサイズまで未定義の新たな内容で埋められるか、があります。 利用可能な環境: Windows, 多くの Unix 系。 
文字列をファイルに書き込みます。 
バッファリングによって、flush() または close() が呼び出されるまで実際にファイル中に文字列が書き込まれないこともあります。 
文字列からなるシーケンスをファイルに書き込みます。 
ファイルはイテレータプロトコルをサポートします。 
各反復操作では 
現在のファイルオブジェクトの状態を示すブール値です。 
この値は読み出し専用の属性です; close() メソッドがこの値を変更します。 全てのファイル類似オブジェクトで利用可能とは限りません。 
このファイルが使っているエンコーディングです。 
Unicode 文字列がファイルに書き込まれる際、Unicode 文字列はこのエンコーディングを使ってバイト文字列に変換されます。 さらに、ファイルが端末に接続されている場合、この属性は端末が使っているとおぼしきエンコーディング(この情報は端末がうまく設定されていない場合には不正確なこともあります)を与えます。 
この属性は読み出し専用で、すべてのファイル類似オブジェクトにあるとは限りません。 
またこの値は None のこともあり、この場合、ファイルはUnicode 文字列の変換のためにシステムのデフォルトエンコーディングを使います。 
ファイルの I/O モードです。 
ファイルが組み込み関数 open() で作成された場合、この値は引数 mode の値になります。 
この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。 
ファイルオブジェクトが open() を使って生成された時のファイルの名前です。 
そうでなければ、ファイルオブジェクト生成の起源を示す何らかの文字列になり、"..." の形式をとります。 
この値は読み出し専用の属性で、全てのファイル類似オブジェクトに存在するとは限りません。 
Python をビルドするとき、--with-universal-newlines オプションがconfigure に指定された場合(デフォルト)、この読み出し専用の属性が存在します。 一般的な改行に変換する読み出しモードで開かれたファイルにおいて、この属性はファイルの読み出し中に遭遇した改行コードを追跡します。 
取り得る値は 'r'、'n'、'rn'、None (不明または、まだ改行していない)、見つかった全ての改行文字を含むタプルのいずれかです。 最後のタプルは、複数の改行慣例に遭遇したことを示します。 
一般的な改行文字を使う読み出しモードで開かれていないファイルの場合、この属性の値は None です。 
print 文を使った場合、他の値を出力する前にスペース文字を出力する必要があるかどうかを示すブール値です。 ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能なsoftspace 属性を持たなければならず、この値はゼロに初期化されなければなりません。 
この値は Python で実装されているほとんどのクラスで自動的に初期化されます (属性へのアクセス手段を上書きするようなオブジェクトでは注意が必要です); C で実装された型では、書き込み可能な softspace 属性を提供しなければなりません。 
注意:この属性は print 文を制御するために用いられますが、print の内部状態を乱さないために、その実装を行うことはできません。 
file() は Python 2.2 で新しく追加されました。 
古いバージョンの組み込み関数 open() は file()の別名です。 
...何も残らないかもしれません)。 
改行を残す利点は、空の文字列が返るとEOF を示し、紛らわしくなくなるからです。 
また、ファイルの最後の行が改行で終わっているかそうでない (ありえることです!) か(例えば、ファイルを行単位で読みながらその完全なコピーを作成した場合には問題になります) を調べることができます。 
このオブジェクトは明示的に値を返さない関数によって返されます。 
このオブジェクトには特有の操作はありません。 
ヌルオブジェクトは一つだけで、None (組み込み名) と名づけられています。 None と書き表されます。 
型オブジェクトは様々なオブジェクト型を表します。 
オブジェクトの型は組み込み関数 type() でアクセスされます。 
型オブジェクトには特有の操作はありません。 
標準モジュール 
には全ての組み込み型名が定義されています。 
型は type 'int' のように書き表されます。 
7.2.1 (通常)整数型オブジェクト (plain integer 
7.2.3 長整数型オブジェクト (long integer 
7.2.2 Bool 型オブジェクト Python の Bool 型は整数のサブクラスとして実装されています。 
ブール型の値は、Py_False と Py_True の 2 つしかありません。 
従って、通常の生成/削除関数はブール型にはあてはまりません。 
とはいえ、以下のマクロが利用できます。 
o が PyBool_Type の場合に真を返します。 
バージョン 2.3 で 新たに追加 された仕様です。 PyObject* 
Python における False オブジェクトです。 
このオブジェクトはメソッドを持ちません。 
参照カウントの点では、他のオブジェクトと同様に扱う必要があります。 
Python における True オブジェクトです。 
Py_False に適切な参照カウントのインクリメントを行って、関数から返すためのマクロです。 
バージョン 2.4 で 新たに追加 された仕様です。 Py_RETURN_TRUE 
Py_True に適切な参照カウントのインクリメントを行って、関数から返すためのマクロです。 バージョン 2.4 で 新たに追加 された仕様です。 
v の値に応じてPy_True またはPy_False を返します。 バージョン 2.3 で 新たに追加 された仕様です。 
このクラスは全てのPythonの値で初期化することができ、生成されるインスタンスは指定した値の真偽値によってのみ決まります。 
Booleanという名前から想像される通りに各種のPython演算子を実装しており、__cmp__(),__repr__(), __int__(), __nonzero__()で定義される演算子を使用することができます。 以下のメソッドは、主に内部的にアンマーシャル時に使用されます: 
出力ストリームオブジェクト out に、XML-RPCエンコーディングのBoolean値を出力します。 
x が偽なら y 、そうでなければ x 
x が偽なら x 、そうでなければ y 
x が偽なら True 、そうでなければ False 
これらの演算子は、演算を行う上で必要がない限り、二つ目の引数を評価しません。 
"not" は非ブール演算子よりも低い演算優先度なので、not a == b 
は not (a == b) と評価され、 
は構文エラーとなります。 
break 文は for ループや while ループ内のネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義には現れません。 
break 文は、文を囲う最も内側のループを終了させ、ループにオプションの else 節がある場合にはelse 節に飛びます。 
for ループを break によって終了すると、ループ制御ターゲットはその時の値を保持します。 
break が finally 節を伴う try 文の外側に処理を渡す際には、ループを実際に抜ける前にそのfinally 節が実行されます。 
ブラウザコントローラーには2つのメソッドが定義されていて、モジュールレベルの便利な2つの関数に相当します: 
このコントローラーでハンドルされたブラウザでurlを表示します。 
newがtrueなら、可能であればブラウザの新しいウィンドウが開きます。 
可能であれば、このコントローラーでハンドルされたブラウザの新しいウィンドウでurlを開きますが、そうでない場合はブラウザのただ1つのウィンドウでurlを開きます。 
インスタンス化したハッシュ、B-Tree, およびレコードオブジェクトは辞書型と同じメソッドをサポートするようになります。 
加えて、以下に列挙したメソッドもサポートします。 バージョン 2.3.1 で 変更 された仕様:辞書型メソッドを追加しました 
データベースの背後にあるファイルを閉じます。 
オブジェクトはアクセスできなくなります。 
これらのオブジェクトには oepn メソッドがないため、再度ファイルを開くためには、新たな bsddb モジュールを開く関数を呼び出さなくてはなりません。 
DB ファイルに収められているキーからなるリストを返します。 
リスト内のキーの順番は決まっておらず、あてにはなりません。 
特に、異なるファイル形式の DB 間では返されるリストの順番が異なります。 
引数 key が DB ファイルにキーとして含まれている場合 1 を返します。 
カーソルを key で示される要素に移動し、キー及び値からなるタプルを返します。 
(bopen を使って開かれる) B-Treeデータベースでは、key が実際にはデータベース内に存在しなかった場合、カーソルは並び順が key の次に来るような要素を指し、その場所のキー及び値が返されます。 
他のデータベースでは、データベース中に key が見つからなかった場合 KeyError が送出されます。 
カーソルを DB ファイルの最初の要素に設定し、その要素を返します。 
B-Tree データベースの場合を除き、ファイル中のキーの順番は決まっていません。 データベースが空の場合、このメソッドは bsddb.error を発生させます。 
カーソルを DB ファイルの次の要素に設定し、その要素を返します。 
B-Tree データベースの場合を除き、ファイル中のキーの順番は決まっていません。 
カーソルを DB ファイルの直前の要素に設定し、その要素を返します。 
B-Tree データベースの場合を除き、ファイル中のキーの順番は決まっていません。 
(hashopen() で開かれるような) ハッシュ表データベースではサポートされていません。 
カーソルを DB ファイルの最後の要素に設定し、その要素を返します。 
ファイル中のキーの順番は決まっていません。 
(hashopen() で開かれるような) ハッシュ表データベースではサポートされていません。 データベースが空の場合、このメソッドは bsddb.error を発生させます。 
ディスク上のファイルをデータベースに同期させます。 
以下はプログラム例です: 
10.6 シーケンスオブジェクト構造体 (sequence object 
10.8 イテレータプロトコルをサポートする 
バッファインタフェースは、あるオブジェクトの内部データを一連のデータチャンク (chunk) として見せるモデルを外部から利用できるようにします。 各チャンクはポインタ/データ長からなるペアで指定します。 
チャンクはセグメント(segment) と呼ばれ、メモリ内に不連続的に配置されるものと想定されています。 バッファインタフェースを利用できるようにしたくないオブジェクトでは、PyTypeObject 構造体の tp_as_buffer メンバをNULLにしなくてはなりません。 
利用できるようにする場合、tp_as_buffer はPyBufferProcs 構造体を指さねばなりません。 注意: 
PyTypeObject 構造体の tp_flags メンバの値を 0 でなく Py_TPFLAGS_DEFAULT にしておくことがとても重要です。 
この設定は、PyBufferProcs 構造体に bf_getcharbuffer スロットが入っていることを Python ランタイムに教えます。 
Python の古いバージョンには bf_getcharbuffer メンバが存在しないので、古い拡張モジュールを使おうとしている新しいバージョンのPython インタプリタは、このメンバがあるかどうかテストしてから使えるようにする必要があるのです。 
バッファプロトコルの実装を定義している関数群へのポインタを保持するのに使われる構造体です。 最初のスロットはbf_getreadbuffer で、getreadbufferproc 型です。 
このスロットが NULLの場合、オブジェクトは内部データの読み出しをサポートしません。 
そのような仕様には意味がないので、実装を行う側はこのスロットに値を埋めるはずですが、呼び出し側では非 NULL の値かどうかきちんと調べておくべきです。 次のスロットは bf_getwritebuffer で、getwritebufferproc 型です。 
オブジェクトが返すバッファに対して書き込みを許可しない場合はこのスロットをNULL にできます。 第三のスロットは bf_getsegcount で、getsegcountproc 型です。 
このスロットは NULL であってはならず、オブジェクトにいくつセグメントが入っているかを呼び出し側に教えるために使われます。 
PyString_Type や PyBuffer_Typeオブジェクトのような単純なオブジェクトには単一のセグメントしか入っていません。 最後のスロットは bf_getcharbuffer で、getcharbufferproc です。 
例えば、オブジェクトが浮動小数点数を保持するように設定されたアレイの場合、呼び出し側が bf_getcharbuffer を使って 8 ビット文字列としてデータを取り出そうとすると例外を送出するようにできます。 この、内部バッファを ``テキスト'' として取り出すという概念は、本質的にはバイナリで、文字ベースの内容を持ったオブジェクト間の区別に使われます。 
注意:現在のポリシでは、文字 (character) はマルチバイト文字でもかまわないと決めているように思われます。 
従って、サイズ N のバッファが N 個のキャラクタからなるとはかぎらないことになります。 
型構造体中のフラグビットで、bf_getcharbuffer スロットが既知の値になっていることを示します。 
このフラグビットがセットされていたとしても、オブジェクトがバッファインタフェースをサポートしていることや、bf_getcharbuffer スロットが NULLでないことを示すわけではありません。 
読み出し可能なバッファセグメントへのポインタを返します。 
この関数は例外を送出してもよく、送出する場合には -1 を返さねばなりません。 
segment に渡す値はゼロまたは正の値で、bf_getsegcountスロット関数が返すセグメント数よりも必ず小さな値でなければなりません。 
成功すると、バッファメモリのサイズを返し、 *ptrptr をバッファメモリを指すポインタ値にセットします。 
読み出し可能なバッファセグメントへのポインタを *ptrptr 
に返し、セグメントの長さを関数の戻り値として返します。 
エラーによる例外の場合には -1 を-1 を返さねばなりません。 
オブジェクトが呼び出し専用バッファしかサポートしていない場合にはTypeError を、segment が存在しないセグメントを指している場合には SystemError を送出しなければなりません。 
バッファを構成するメモリセグメントの数を返します。 
lenp が NULLでない場合、この関数の実装は全てのセグメントのサイズ (バイト単位) の合計値を *lenp を介して報告しなければなりません。 
この関数呼び出しは失敗させられません。 
セグメント segment のメモリバッファを ptrptr に入れ、メモリバッファのサイズを返します。 
がメモリバッファを表す値になるようにセットされます。 
7.3.2.2 メソッドおよびスロット関数 (slot function) 
C で実装された Python オブジェクトは、``バッファインタフェース(buffer interface)'' と呼ばれる一連の関数を公開していることがあります。 
これらの関数は、あるオブジェクトのデータを生 (raw) のバイト列形式で公開するために使います。 
このオブジェクトの使い手は、バッファインタフェースを使うことで、オブジェクトをあらかじめコピーしておく必要なしに、オブジェクトのデータに直接アクセスできます。 バッファインタフェースをサポートするオブジェクトの例として、文字列型とアレイ (array) 型の二つがあります。 
文字列オブジェクトは、その内容をバッファインタフェースのバイト単位形式で公開しています。 
アレイもその内容を公開していますが、注意する必要があるのはアレイの要素は複数バイトの値になりうる、ということです。 バッファインタフェースの使い手の一例として、ファイルオブジェクトのwrite() メソッドがあります。 
バッファインタフェースを介してバイト列を公開しているオブジェクトは全て、ファイルへの書き出しができます。 
``バッファオブジェクト'' はヘッダファイル bufferobject.h の中で定義されています (このファイルは Python.h がインクルードしています)。 
バッファオブジェクトは、 Python プログラミングのレベルからは文字列オブジェクトと非常によく似ているように見えます:スライス、インデクス指定、結合、その他標準の文字列操作をサポートしています。 
しかし、バッファオブジェクトのデータは二つのデータソース:何らかのメモリブロックか、バッファインタフェースを公開している別のオブジェクト、のいずれかに由来しています。 バッファオブジェクトは、他のオブジェクトのバッファインタフェースからPython プログラマにデータを公開する方法として便利です。 
バッファオブジェクトはゼロコピーなスライス機構 (zero-copy slicing mechanism) としても使われます。 
ブロックメモリを参照するというバッファオブジェクトの機能を使うことで、任意のデータをきわめて簡単にPython プログラマに公開できます。 
メモリブロックは巨大でもかまいませんし、C 拡張モジュール内の定数配列でもかまいません。 また、オペレーティングシステムライブラリ側に渡す前の、操作用の生のブロックメモリでもかまいませんし、構造化されたデータをネイティブのメモリ配置形式でやりとりするためにも使えます。 
この PyObject のサブタイプはバッファオブジェクトを表現します。 
Python バッファ型 (buffer type) を表現するPyTypeObject です;Python レイヤにおける types.BufferType 
と同じオブジェクトです 。 
この定数は、PyBuffer_FromObject() またはの PyBuffer_FromReadWriteObject() size パラメタに渡します。 
このパラメタを渡すと、PyBufferObject は指定された offset からバッファの終わりまでを base オブジェクトとして参照します。 
このパラメタを使うことで、関数の呼び出し側が base オブジェクトのサイズを調べる必要がなくなります。 
引数がPyBuffer_Type 型のときに真を返します。 
新たな読み出し専用バッファオブジェクトを返します。 
base が読み出し専用バッファに必要なバッファプロトコルをサポートしていない場合や、厳密に一つのバッファセグメントを提供していない場合にはTypeError を送出し、offset がゼロ以下の場合にはValueError を送出します。 
バッファオブジェクトはは base オブジェクトに対する参照を保持し、バッファオブジェクトのの内容は base オブジェクトの offsetから size バイトのバッファインタフェースへの参照になります。 
size が Py_END_OF_BUFFER の場合、新たに作成するバッファオブジェクトの内容は base から公開されているバッファの末尾までにわたります。 
新たな書き込み可能バッファオブジェクトを返します。 
パラメタおよび例外は PyBuffer_FromObject と同じです。 
base オブジェクトが書き込み可能バッファに必要なバッファプロトコルを公開していない場合、TypeError を送出します。 
メモリ上の指定された場所から指定されたサイズのデータを読み出せる、新たな読み出し専用バッファオブジェクトを返します。 
この関数が返すバッファオブジェクトが存続する間、ptr で与えられたメモリバッファがデアロケートされないようにするのは呼び出し側の責任です。 
size がゼロ以下の場合にはValueError を送出します。 
size には Py_END_OF_BUFFER を指定してはなりません; 指定すると、ValueError を送出します。 
PyBuffer_FromMemory() に似ていますが、書き込み可能なバッファを返します。 
size バイトのメモリバッファを独自に維持する新たな書き込み可能バッファオブジェクトを返します。 
size がゼロまたは正の値でない場合、ValueError を送出します。 
(PyObject_AsWriteBuffer() が返すような)メモリバッファは特に整列されていないので注意して下さい。 
1.8 拡張モジュール関数のキーワードパラメタ 
Py_BuildValue() は、PyArg_ParseTuple()の認識する一連の書式化単位に似た書式化単位を認識します。 ただし(関数への出力ではなく、入力に使われる) 引数はポインタではなく、ただの値でなければなりません。 
書式化文字列が空なら、None を返します。 きっかり一つの書式化単位なら、その書式化単位が記述している何らかのオブジェクトになります。 
サイズが 0 や 1 のタプル返させたいのなら、書式化文字列を丸括弧で囲います。 以下に例を示します (左に呼び出し例を、右に構築される Python 値を示します): 
3.1 拡張モジュールの配布 
4.1 型どおりのアプローチ 
4. Windows 上での C および C++ 拡張モジュールのビルド 
この章では Windows 向けの Python 拡張モジュールを Microsoft Visual C++を使って作成する方法について簡単に述べ、その後に拡張モジュールのビルドがどのように動作するのかについて詳しい背景を述べます。 
この説明は、Python 拡張モジュールを作成する Windows プログラマと、Unix と Windows の双方でうまくビルドできるようなソフトウェアの作成に興味がある Unix プログラマの双方にとって有用です。 モジュールの作者には、この節で説明している方法よりも、 distutils によるアプローチで拡張モジュールをビルドするよう勧めます。 
また、Python をビルドした際に使われた C コンパイラが必要です;通常は Microsoft Visual C++です。 
注意:この章では、Python のバージョン番号が符号化されて入っているたくさんのファイル名について触れます。 
これらのファイル名は"XY" で表されるバージョン名付きで表現されます;"X" は使っている Python リリースのメジャーバージョン番号、"Y" はマイナーバージョン番号です。 
例えば、 Python 2.2.1 を使っているなら、"XY" は実際には"22" になります。 
3.1 拡張モジュールの配布 
3. distutils による C および C++ 拡張モジュールのビルド 
Python 1.4 になってから、動的にリンクされるような拡張モジュールをビルドするためのメイクファイルを作成するような、特殊なメイクファイルをUnix 向けに提供するようになりました。 
Python 2.0 からはこの機構 (いわゆる Makefile.pre.in および Setup ファイルの関係ファイル)はサポートされなくなりました。 インタプリタ自体のカスタマイズはほとんど使われず、 distutils で拡張モジュールをビルドできるようになったからです。 
distutils を使った拡張モジュールのビルドには、ビルドを行う計算機上にdistutils をインストールしていることが必要です。 Python 2.x には distutils が入っており、 Python 1.5 用には個別のパッケージがあります。 
distutils はバイナリパッケージの作成もサポートしているので、ユーザが拡張モジュールをインストールする際に、必ずしもコンパイラが必要というわけではありません。 distutils ベースのパッケージには、駆動スクリプト (driver script)となる setup.py が入っています。 
setup.py は普通の Python プログラムファイルで、ほとんどの場合以下のような見かけになっています: 
この setup.py とファイル demo.c があるとき、以下のコマンド 
を実行すると、demo.c をコンパイルして、"demo" という名前の拡張モジュールをbuild ディレクトリ内に生成します。 
システムによってはモジュールファイルは build/lib.systemサブディレクトリに生成され、demo.so や demo.pydといった名前になることがあります。 setup.py 内では、コマンドの実行はすべて "setup" 関数を呼び出して行います。 
この関数は可変個のキーワード引数をとります。 例ではその一部を使っているにすぎません。 
もっと具体的にいうと、例の中ではパッケージをビルドするためのメタ情報と、パッケージの内容を指定しています。 
通常、パッケージには Python ソースモジュールやドキュメント、サブパッケージ等といった別のファイルも入ります。 
distutils の機能に関する詳細は、 
Python モジュールの配布 
に書かれているdistutils のドキュメントを参照してください; この節では、拡張モジュールのビルドについてのみ説明します。 駆動スクリプトをよりよく構成するために、決め打ちの引数をsetup に入れておくことがよくあります。 
上の例では、setup の "ext_modules" は拡張モジュールのリストで、リストの各々の要素は Extension クラスのインスタンスになっています。 
例えば以下のファイルがその実例です。 
この例では、setup は追加のメタ情報と共に呼び出されます。 配布パッケージを構築する際には、メタ情報の追加が推奨されています。 
拡張モジュール自体については、プリプロセッサ定義、インクルードファイルのディレクトリ、ライブラリのディレクトリ、ライブラリといった指定があります。 distutils はこの情報をコンパイラに応じて異なるやり方で引渡します。 
例えば、Unix では、上の設定は以下のようなコンパイルコマンドになるかもしれません: 
これらのコマンドラインは実演目的で書かれたものです; distutils のユーザは distutils が正しくコマンドを実行すると信用してください。 
5 ビルド済み配布物を作成する 
1 ダム形式のビルド済み配布物を作成する 
``ビルド済み配布物'' とは、おそらく皆さんが通常 ``バイナリパッケージ''とか ``インストーラ'' (背景にしている知識によって違います) と考えているものです。 
とはいえ、配布物が必然的にバイナリ形式になるわけではありません。 
配布物には、 Python ソースコード、かつ/またはバイトコードが入るからです; また、我々はパッケージという呼び方もしません。 
すでに Python の用語として使っているからです (また、 ``インストーラ''という言葉は主流のデスクトップシステム特有の用語です)ビルド済み配布物は、モジュール配布物をインストール作業者にとってできるだけ簡単な状況にする方法です: ビルド済み配布物は、RPM ベースのLinux システムユーザにとってはバイナリ RPM 、Windows ユーザにとっては実行可能なインストーラ、 Debian ベースの Linux システムでは Debian パッケージ、などといった具合です。 
単純な例として、Distutils ソースツリーから以下のコマンドを実行したとします: 
すると、Distutils はモジュール配布物 (ここでは Distutils 自体) をビルドし、``偽の (fake)'' インストールを (build ディレクトリで)行います。 そして現在のプラットフォームにおける標準の形式でビルド済み配布物を生成します。 
デフォルトのビルド済み形式とは、Unixでは``ダム (dumb)'' の tar ファイルで、 Windows ではシンプルな実行形式のインストーラになります。 
(tar ファイルは、特定の場所に手作業で解凍しないと動作しないので、 ``ダム: 賢くない'' 形式とみなします。 )従って、 Unix システムで上記のコマンドを実行すると、Distutils-1.0.plat.tar.gz を作成します; この tarball を正しい場所で解凍すると、ちょうどソース配布物をダウンロードして python setup.py install を実行したのと同じように、正しい場所に Distutils がインストールされます。 
(``正しい場所 (right place)'' とは、ファイルシステムのルート下か、Python の prefix ディレクトリ下で、これはbdist_dumb に指定するコマンドで変わります;デフォルトの設定では、prefix からの相対パスにインストールされるダム配布物が得られます。 
) 言うまでもなく、 pure Python 配布物の場合なら、python setup.py install するのに比べて大して簡単になったとは言えません--しかし、非 pure 配布物で、コンパイルの必要な拡張モジュールを含む場合、拡張モジュールを利用できるか否かという大きな違いになりえます。 
とすると、Unix システムでは、Distutils-1.0.plat.zip を作成します--先にも述べたように、Distutils をインストールするには、このアーカイブ形式をルートディレクトリ下で展開します。 ビルド済み配布物として利用できる形式を以下に示します: 
形式 
説明 
注記 
gzip 圧縮された tar ファイル (.tar.gz) 
compress 圧縮された tar ファイル (.tar.Z) 
tar ファイル (.tar) 
zip ファイル (.zip) 
RPM 形式 
Solaris pkgtool 形式 
Windows 用の自己展開形式 ZIP ファイル 
注記: 
Unixでのデフォルト形式です 
Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用することができます。 
それらの関数をアルファベット順に挙げます。 
この関数は import 
文によって呼び出されます。 
この関数の主な意義は、同様のインタフェースを持つ関数でこの関数を置き換え、import 文の意味を変更できるようにすることです。 
これを行う理由とやり方の例については、標準ライブラリモジュール ihooks 
および 
についても読んでみて下さい。 自分で関数 __import__ を構築する際に便利な操作が定義されています。 
例えば、文 "import spam" は結果として以下の呼び出し:__import__('spam', globals(), locals(), [])になります; 文 "from spam.ham import eggs" は"__import__('spam.ham', globals(), locals(), ['eggs'])" です。 
locals() および ['eggs'] が引数で与えられますが、関数 __import__() は eggs という名のローカル変数を設定しないので注意してください; この操作はそれ以後の import 文のために生成されたコードで行われます。 
(実際、標準の実装では locals引数を全く使わず、import 文のパッケージ文脈を決定するためだけに globals を使います。 )変数 name が package.module の形式であった場合、通常、name という名のモジュール ではなく トップレベルのパッケージ (最初のドットまでの名前) が返されます。 
しかし、空でない fromlist 引数が与えられていれば、nameと名づけられたモジュールが返されます。 
これは異なる種類の import文に対して生成されたバイトコードと互換性をもたせるために行われます;"import spam.ham.eggs" とすると、トップレベルのパッケージspam はインポートする名前空間に置かれなければなりませんが、"from spam.ham import eggs" とすると、変数 eggs を見つけるためには spam.ham サブパッケージを使わなくてはなりません。 
この振る舞いを回避するために、getattr() を使って必要なコンポーネントを展開してください。 
例えば、以下のようなヘルパー関数: 
数値の絶対値を返します。 
引数として通常の整数、長整数、浮動小数点数をとることができます。 
引数が複素数の場合、その大きさ (magnitude) が返されます 
標準の真値テストを使って、値をブール値に変換します。 
このクラスのインスタンスはFalse および True だけです。 
バージョン 2.2.1 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:引数が与えられなかった場合、この関数は False を返します。 
object 引数が呼び出し可能なオブジェクトの場合、真を返します。 そうでなければ偽を返します。 
この関数が真を返しても objectの呼び出しは失敗する可能性がありますが、偽を返した場合は決して成功することはありません。 
クラスは呼び出し可能 (クラスを呼び出すと新しいインスタンスを返します) なことと、クラスのインスタンスがメソッド __call__() を持つ場合には呼び出しが可能なので注意してください。 
ASCII コードが整数 i となるような文字 1 字からなる文字列を返します。 
例えば、chr(97) は文字列 'a' を返します。 この関数は ord() の逆です。 
引数は [0..255] の両端を含む範囲内に収まらなければなりません; i が範囲外の値のときにはValueError が送出されます。 
@classmethod は関数デコレータ形式です。 
詳しくは../ref/ref.htmlPython リファレンスマニュアルの 7 章にある関数定義についての説明を参照してください。 
このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンスとして呼び出すこと (例えば C().f()) もできます。 
バージョン 2.4 で 変更 された仕様:関数デコレータ構文を追加しました 
二つのオブジェクト x および y を比較し、その結果に従って整数を返します。 
戻り値は 
の時にはゼロ、 
string をコードオブジェクトにコンパイルします。 
コードオブジェクトは exec 文で実行したり、 eval() を呼び出して評価できます。 
ある機能を指定するために必要なビットフィールドは、__future__ モジュールの _Feature インスタンスにおけるcompiler_flag 属性で得られます。 
値 real + imag*j の複素数型数を生成するか、文字列または数値を複素数型に変換します。 
それぞれの引数は (複素数を含む) 任意の数値型をとることができます。 imag が省略された場合、標準の値はゼロで、関数は int 、long() および float() のような数値型への変換関数として動作します。 
全ての引数が省略された場合、0j を返します。 
setattr() の親戚となる関数です。 
引数はオブジェクトと文字列です。 
文字列はオブジェクトの属性のどれか一つの名前でなければなりません。 
この関数は与えられた名前の属性を削除しますが、オブジェクトがそれを許す場合に限ります。 
例えば、delattr(x, 'foobar') はdel x.foobar 
と等価です。 
オプションの場所にある引数か、キーワード引数の集合から、新しく辞書オブジェクトを初期化して返します。 
この場合引数中の要素もまた、上に挙げた型のどれかでなくてはならず、加えて正確に 2 個のオブジェクトを持っていなくてはなりません。 
最初の要素は新たな辞書のキーとして、二つ目の要素は辞書の値として使われます。 
同じキーが一度以上与えられた場合、新たな辞書中には最後に与えた値だけが関連付けられます。 キーワード引数が与えられた場合、キーワードとそれに関連付けられた値が辞書の要素として追加されます。 
オプションの場所にあるオブジェクト内とキーワード引数の両方で同じキーが指定されていた場合、辞書中にはキーワード引数の設定値の方が残されます。 例えば、以下のコードはどれも、{"one": 2, "two": 3}と同じ辞書を返します: 
バージョン 2.3 で 変更 された仕様:キーワード引数から辞書を構築する機能が追加されました 
引数がない場合、現在のローカルシンボルテーブルにある名前のリストを返します。 
引数がある場合、そのオブジェクトの有効な属性からなるリストを返そうと試みます。 
この情報はオブジェクトの __dict__属性が定義されている場合、そこから収集されます。 また、クラスまたは型オブジェクトからも集められます。 
dir() は第一に対話プロンプトのために提供されているので、厳密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い名前のセットを与えようとします。 また、この関数の細かい動作はリリース間で変わる可能性があります。 
a, b) 2 つの (複素数でない) 数値を引数として取り、長除法を行ってその商と剰余からなるペアを返します。 
被演算子が型混合である場合、2 進算術演算子での規則が適用されます。 
通常の整数と長整数の場合、結果は (a / b, a % b) と同じです。 
浮動小数点数の場合、結果は (q, a % b)であり、 q は通常 math.floor(a / b) ですが、そうではなく 1 になることもあります。 
いずれにせよ、 
は a に非常に近い値になり、 
がゼロでない値の場合、その符号は b と同じで、 0 = abs(a % b) abs(b)になります。 
バージョン 2.3 で 変更 された仕様:複素数に対する divmod() の使用は廃用されました。 
列挙オブジェクトを返します。 iterable はシーケンス型、イテレータ型、あるいは反復をサポートする他のオブジェクト型でなければなりません。 
文字列とオプションの引数 globals、locals をとります。 
globals を指定する場合には辞書でなくてはなりません。 
locals は任意のマップ型にできます。 
バージョン 2.4 で 変更 された仕様:以前は locals も辞書でなければなりませんでした 
引数 expressionは Python の表現式 (技術的にいうと、条件のリストです) として構文解釈され、評価されます。 このとき辞書 globals および locals はそれぞれグローバルおよびローカルな名前空間として使われます。 
locals 辞書が存在するが、'__builtins__' が欠けている場合、expression を解析する前に現在のグローバル変数を globalsにコピーします。 
このことから、expression は通常標準の 
モジュールへの完全なアクセスを有し、制限された環境が伝播するようになっています。 
locals 辞書が省略された場合、標準の値として globals に設定されます。 
辞書が両方とも省略された場合、表現式は eval が呼び出されている環境の下で実行されます。 
構文エラーは例外として報告されます。 
以下に例を示します: 
この関数は (compile() で生成されるような) 任意のコードオブジェクトを実行するために利用することもできます。 
この場合、文字列の代わりにコードオブジェクトを渡します。 
このコードオブジェクトは引数 kind を 'eval' にしてコンパイルされていなければなりません。 ヒント: 文の動的な実行は exec 文でサポートされています。 
ファイルからの文の実行は関数 execfile() でサポートされています。 
関数 globals() および locals() はそれぞれ現在のグローバルおよびローカルな辞書を返すので、eval() や execfile() で使うことができます。 
この関数は exec 文に似ていますが、文字列の代わりにファイルに対して構文解釈を行います。 
import 文と違って、モジュール管理機構を使いません -- この関数はファイルを無条件に読み込み、新たなモジュールを生成しません。 
引数は文字列とオプションの 2 つの辞書からなります。 
file は読み込まれ、(モジュールのように) Python 文の列として評価されます。 このとき globals および locals がそれぞれグローバルおよびローカルな名前空間として使われます。 
辞書が両方とも省略された場合、表現式は execfiles が呼び出されている環境の下で実行されます。 
戻り値は None です。 
警告:標準では locals は後に述べる関数 locals() のように動作します: 標準の locals 辞書に対する変更を試みてはいけません。 
execfile() の呼び出しが返る時にコードがlocals に与える影響を知りたいなら、明示的に loacals 辞書を渡してください。 execfile() は関数のローカルを変更するための信頼性のある方法として使うことはできません 
新たなファイルオブジェクト (section2.3.9, ``File+ Objects''参照)を返します。 
最初の 2 つの引数は studio の fopen()と同じです: filename は開きたいファイルの名前で、mode はファイルをどのようにして開くかを指定します:読み出しは 'r'、書き込み (ファイルがすでに存在すれば切り詰められます) は 'w'、追記書き込みは 'a' です (いくつかの Unix システムでは、全て の書き込みが現在のファイルシーク位置に関係なくファイルの末尾に追加されます) 。 'r+'、'w+'、および 'a+' はファイルを更新モードで開きます ('w+' はファイルがすでに存在すれば切り詰めるので注意してください) 。 
バイナリとテキストファイルを区別するシステムでは、ファイルをバイナリモードで開くためには 'b'を追加してください (区別しないシステムでは 'b' は無視されます)。 
ファイルを開くことができなければ、IOError が送出されます。 標準の fopen() における mode の値に加えて、'U' または 'rU' を使うことができます。 
Python が全改行文字サポートを行っている (標準ではしています) 場合,ファイルがテキストファイルで開かれますが、行末文字として Unix における慣行である 'n' 、Machintosh における慣行である 'r'、Windows における慣行である 'rn' のいずれを使うこともできます。 
これらの改行文字の外部表現はどれも、Python プログラムからは'n' に見えます。 
Python が全改行文字サポートなしで構築されている場合、mode 'U' は通常のテキストモードと同様になります。 
開かれたファイルオブジェクトはまた、newlinesと呼ばれる属性を持っており、その値は None (改行が見つからなかった場合)、'n'、'r'、 'rn'、または見つかった全ての改行タイプを含むタプルになります。 mode が省略された場合、標準の値は 'r' になります。 
移植性を高めるためには、バイナリファイルを開くときには、mode の値に 'b' を追加しなければなりません。 
(バイナリファイルとテキストファイルを区別なく扱うようなシステムでも、ドキュメンテーションの代わりになるので便利です) 
オプションの bufsize 引数は、ファイルのために必要とするバッファのサイズを指定します: 0 は非バッファリング、 1 は行単位バッファリング、その他の正の値は指定した値 (の近似値) のサイズをもつバッファを使用することを意味します。 
bufsize の値が負の場合、システムの標準を使います。 通常、端末は行単位のバッファリングであり、その他のファイルは完全なバッファリングです。 
省略された場合、システムの標準の値が使われます。 
file() コンストラクタは Python 2.2 で新たに追加されました。 
以前の関数名である open() は互換性のために残されており、file() の別名となっています。 
文字列または数値を浮動小数点数に変換します。 
それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、同じ値の浮動小数点数が (Python の浮動小数点精度で) 返されます。 
引数が指定されなかった場合、0.0 を返します。 
注意:文字列で値を渡す際、背後の C ライブラリによって NaN 
および Infinity 
が返されるかもしれません。 
これらの値を返すような特殊な文字列のセットは完全に C ライブラリに依存しており、バリエーションがあることが知られています。 
要素はiterable から取得します。 
frozenset 型は、update メソッドを持たない代わりにハッシュ化でき、他の set 型の要素にしたり辞書型のキーにしたりできます。 
frozenset の要素自体は変更不能でなければなりません。 
集合 (set) 型の集合を表現するためには、内集合も frozenset オブジェクトでなければなりません。 
iterable を指定しない場合には空の集合 frozenset([]) を返します。 バージョン 2.4 で 新たに追加 された仕様です。 
指定された object の属性を返します。 
name は文字列でなくてはなりません。 文字列がオブジェクトの属性名の一つであった場合、戻り値はその属性の値になります。 
例えば、getattr(x, 'foobar') は x.foobar と等価です。 
指定された属性が存在しない場合、default が与えられている場合にはしれが返されます。 そうでない場合には AttributeErrorが送出されます。 
現在のグローバルシンボルテーブルを表す辞書を返します。 常に現在のモジュールの辞書になります (関数またはメソッドの中ではそれらを定義しているモジュールを指し、この関数を呼び出したモジュールではありません)。 
引数はオブジェクトと文字列です。 
文字列がオブジェクトの属性名の一つであった場合 True を、そうでない場合 False を返します(この関数は getattr(object, name) を呼び出し、例外を送出するかどうかを調べることで実装しています)。 
オブジェクトのハッシュ値を (存在すれれば) 返します。 
ハッシュ値は整数です。 
これらは辞書を検索する際に辞書のキーを高速に比較するために使われます。 
等しい値となる数値は等しいハッシュ値を持ちます (1 と1.0 のように型が異なっていてもです)。 
組み込みヘルプシステムを起動します (この関数は対話的な使用のためのものです)。 
引数が与えられていない場合、対話的ヘルプシステムはインタプリタコンソール上で起動します。 
引数が文字列の場合、文字列はモジュール、関数、クラス、メソッド、キーワード、またはドキュメントの項目名として検索され、ヘルプページがコンソール上に印字されます。 
引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプページが生成されます。 バージョン 2.2 で 新たに追加 された仕様です。 
オブジェクトの ``識別値'' を返します。 
この値は整数 (または長整数)で、このオブジェクトの有効期間は一意かつ定数であることが保証されています。 
オブジェクトの有効期間が重ならない 2 つのオブジェクトは同じ id() 値を持つかもしれません。 
(実装に関する注釈:この値はオブジェクトのアドレスです。 ) 
eval(raw_input(prompt)) と同じです。 
警告:この関数はユーザのエラーに対して安全ではありません! この関数では、入力は有効な Python の式であると期待しています; 入力が構文的に正しくない場合、SyntaxError が送出されます。 
式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。 
(一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要なまさにそのものです) 
モジュールが読み込まれていれば、input()は精緻な行編集およびヒストリ機能を提供します。 一般的なユーザからの入力のための関数としては raw_input() を使うことを検討してください。 
文字列または数値を通常の整数に変換します。 
radix がゼロの場合、文字列の内容から適切な基数を推測します; 変換は整数リテラルと同じです。 
radix が指定されており、x が文字列でない場合、TypeError が送出されます。 それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができます。 
浮動小数点数から整数へ変換では (ゼロ方向に)値を丸めます。 引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。 
引数が与えられなかった場合、0 を返します。 
引数 object が引数 classinfo のインスタンスであるか、(直接または間接的な) サブクラスのインスタンスの場合に真を返します。 
また、classinfo が型オブジェクトであり、object がその型のオブジェクトである場合にも真を返します。 
object がクラスインスタンスや与えられた型のオブジェクトでない場合、この関数は常に偽を返します。 
classinfo をクラスオブジェクトでも型オブジェクトにもせず、クラスや型オブジェクトからなるタプルや、そういったタプルを再帰的に含むタプル (他のシーケンス型は受理されません) でもかまいません。 
classinfo がクラス、型、クラスや型からなるタプル、そういったタプルが再帰構造をとっているタプルのいじれでもない場合、例外 TypeError が送出されます。 バージョン 2.2 で 変更 された仕様:型情報をタプルにした形式のサポートが追加されました。 
class が classinfo の (直接または間接的な) サブクラスである場合に真を返します。 
クラスはそのクラス自体のサブクラスとclasinfo はクラスオブジェクトからなるタプルでもよく、この場合には classinfo のすべてのエントリが調べられます。 
その他の場合では、例外 TypeError が送出されます。 バージョン 2.3 で 変更 された仕様:型情報からなるタプルへのサポートが追加されました 
イテレータオブジェクトを返します。 
2 つ目の引数があるかどうかで、最初の引数の解釈は非常に異なります。 2 つ目の引数がない場合、o は反復プロトコル (__iter__() メソッド) か、シーケンス型プロトコル (引数が 0 から開始する__getitem__() メソッド) をサポートする集合オブジェクトでなければなりません。 
これらのプロトコルが両方ともサポートされていない場合、 TypeError が送出されます。 2 つ目の引数 sentinel が与えられていれば、oは呼び出し可能なオブジェクトでなければなりません。 
オブジェクトの長さ (要素の数) を返します。 
引数はシーケンス型 (文字列、タプル、またはリスト) か、マップ型 (辞書) です。 
sequence の要素と同じ要素をもち、かつ順番も同じなリストを返します。 sequence はシーケンス、反復処理をサポートするコンテナ、あるいはイテレータオブジェクトです。 
sequence がすでにリストの場合、 
sequence[:] と同様にコピーを作成して返します。 
例えば、list('abc') は ['a', 'b', 'c'] およびlist(1, 2, 3) は [1, 2, 3] を返します。 
引数が与えられなかった場合、新しい空のリスト [] を返します。 
現在のローカルシンボルテーブルを表す辞書を更新して返します。 
警告:この辞書の内容は変更してはいけません; 値を変更しても、インタプリタが使うローカル変数の値には影響しません。 
文字列または数値を長整数値に変換します。 
radix 引数は int() と同じように解釈され、x が文字列の時だけ与えることができます。 それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、同じ値の長整数が返されます。 
浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。 
引数が与えられなかった場合、0L を返します。 
function を list の全ての要素に適用し、返された値からなるリストを返します。 
追加の list 引数を与えた場合、function はそれらを引数として取らなければならず、関数はそのリストの全ての要素について個別に適用されます; 他のリストより短いリストがある場合、要素 None で延長されます。 
functionが None の場合、恒等関数であると仮定されます; すなわち、複数のリスト引数が存在する場合、map() は全てのリスト引数に対し、対応する要素からなるタプルからなるリストを返します (転置操作のようなものです)。 
list 引数はどのようなシーケンス型でもかまいません;結果は常にリストになります。 
単一の引数 s の場合、空でないシーケンス (文字列、タプルまたはリスト)の要素のうち最大のものを返します。 
1 個よりも引数が多い場合、引数間で最大のものを返します。 
単一の引数 s の場合、空でないシーケンス (文字列、タプルまたはリスト)の要素のうち最小のものを返します。 
1 個よりも引数が多い場合、引数間で最小のものを返します。 
ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。 
object() は新スタイルのクラスの、基底クラスです。 
これは、新スタイルのクラスのインスタンスに共通のメソッド群を持ちます。 バージョン 2.2 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:この関数はいかなる引数も受け付けません。 以前は、引数を受理しましたが無視していました。 
(任意のサイズの) 整数を 8 進の文字列に変換します。 
結果は Python の式としても使える形式になります。 バージョン 2.4 で 変更 された仕様:以前は符号なしのリテラルしか返しませんでした 
前述の関数 file() の別名です。 
1 文字からなる文字列または Unicode 文字の ASCII 値を返します。 
例えば、ord('a') は整数 97 を返し、ord(u'u2020') は 8224 を返します。 
この値は文字列に対する chr() の逆であり、Unicode 文字に対するunichr() の逆です。 
引数は数値型でなくてはなりません。 
型混合の場合、2 進算術演算における型強制規則が適用されます。 
通常整数および長整数の被演算子に対しては、二つ目の引数が負の数でない限り、結果は (型強制後の)被演算子と同じ型になります;負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型の結果が返されます。 
例えば、 10**2 は 100 を返しますが、 100**-2 は 0.01 を返します。 (最後に述べた機能は Python 2.2 で追加されたものです。 
(この制限は Python 2.2 で追加されました。 
Python 2.1 以前では、3 つの浮動小数点引数を持つ pow() は浮動小数点の丸めに関する偶発誤差により、プラットフォーム依存の結果を返します。 ) 
新しい形式のクラス (object から導出されたクラス) におけるプロパティ属性を返します。 
fget は属性値を取得するための関数で、同様に fset は属性値を設定するための関数です。 また、fdel は属性を削除するための関数です。 
以下に属性 x を扱う典型的な利用法を示します: 
数列を含むリストを生成するための多機能関数です。 
for ループでよく使われます。 
引数は通常の整数でなければなりません。 
step 引数が無視された場合、標準の値 1 になります。 
start 引数が蒸しされた場合標準の値 0 になります。 
完全な形式では、通常の整数列 [start, start + step,start + 2 * step, ...] を返します。 
step が正の値の場合、最後の要素は stop よりも小さい 
の最大値になります;step が負の値の場合、最後の要素は stop よりも大きい 
の最小値になります。 step はゼロであってはなりません (さもなければ ValueErrorが送出されます)。 
引数 proompt が存在する場合、末尾の改行を除いて標準出力に出力されます。 
次に、この関数は入力から 1 行を読み込んで文字列に変換して(末尾の改行を除いて) 返します。 EOF が読み込まれるとEOFError が送出されます。 
モジュールが読み込まれていれば、input()は精緻な行編集およびヒストリ機能を提供します。 
sequence の要素に対して、シーケンスを単一の値に短縮するような形で2 つの引数をもつ function を左から右に累積的に適用します。 
例えば、reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])は ((((1+2)+3)+4)+5) を計算します。 
左引数xは累計の値になり、右引数 y はsequence から取り出した更新値になります。 
オプションの initializerが存在する場合、計算の際にシーケンスの先頭に置かれます。 また、シーケンスが空の場合には標準の値になります。 
initializer が与えられておらず、sequence が単一の要素しか持っていない場合、最初の要素が返されます。 
すでにインポートされた module を再解釈し、再初期化します。 
引数はモジュールオブジェクトでなければならないので、予めインポートに成功していなければなりません。 
この関数はモジュールのソースコードファイルを外部エディタで編集して、Python インタプリタから離れることなく新しいバージョンを試したい際に有効です。 
戻り値は (module 引数と同じ) モジュールオブジェクトです。 reload(module) を実行すると、以下の処理が行われます: 
Python モジュールのコードは再コンパイルされ、モジュールレベルのコードは再度実行されます。 モジュールの辞書中にある、何らかの名前に結び付けられたオブジェクトを新たに定義します。 
拡張モジュール中のinit 関数が二度呼び出されることはありません。 
Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照カウントがゼロにならないかぎり再利用されません。 
モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェクト) を指すよう更新されます。 
以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受けている場合、それらを新たなオブジェクトにバインドし直すことはないので、必要なら自分で名前空間を更新せねばなりません。 
いくつか補足説明があります:モジュールは文法的に正しいが、その初期化には失敗した場合、そのモジュールの最初の import 文はモジュール名をローカルにはバインドしませんが、(部分的に初期化された) モジュールオブジェクトを sys.modules に記憶します。 
従って、モジュールをロードしなおすには、reload() する前にまず import (モジュールの名前を部分的に初期化されたオブジェクトにバインドします)を再度行わなければなりません。 モジュールが再ロードされた再、その辞書 (モジュールのグローバル変数を含みます) はそのまま残ります。 
名前の再定義を行うと、以前の定義を上書きするので、一般的には問題はありません。 
新たなバージョンのモジュールが古いバージョンで定義された名前を定義していない場合、古い定義がそのまま残ります。 
辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有効性を引き出すために使うことができます -- つまり、try 文を使えば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことができます: 
組み込みモジュールや動的にロードされるモジュールを再ロードすることは、不正なやり方ではありませんが、一般的にそれほど便利ではありません。 例外は 
、 
です。 
これは導出クラスの場合でも同じです。 
この関数は多くの型について、eval() に渡されたときに同じ値を持つようなオブジェクトを表す文字列を生成しようとします。 
x を小数点以下 n 桁で丸めた浮動小数点数の値を返します。 
n が省略されると、標準の値はゼロになります。 結果は浮動小数点数です。 
値は最も近い 10 のマイナス n の倍数に丸められます。 二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます(従って、例えば round(0.5) は 1.0 になり、round(-0.5) は -1.0 になります)。 
集合を表現するset 型オブジェクトを返します。 要素は iterable から取得します。 
要素は変更不能でなければなりません。 
集合の集合を表現するには、内集合は frozenset オブジェクトでなければなりません。 
iterable を指定しない場合、新たな空の set 型オブジェクト、set([]) を返します。 バージョン 2.4 で 新たに追加 された仕様です。 
getattr() と対をなす関数です。 
引数はそれぞれオブジェクト、文字列、そして任意の値です。 
文字列はすでに存在する属性の名前でも、新たな属性の名前でもかまいません。 
この関数は指定した値を指定した属性に関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。 
例えば、setattr(x, 'foobar', 123) は 
range(start, stop, step) で指定されるインデクスの集合を表すスライスオブジェクトを返します。 range(start)スライスオブジェクトを返します。 
引数 start および step は標準では None です。 
スライスオブジェクトは読み出し専用の属性 start、stopおよび step を持ち、これらは単に引数で使われた値 (または標準の値) を返します。 
これらの値には、その他のはっきりとした機能はありません; しかしながら、これらの値は Numerical Python 
およびその他のサードパーティによる拡張で利用されています。 
スライスオブジェクトは拡張されたインデクス指定構文が使われる際にも生成されます。 
例えば: "a[start:stop:step]" や "a[start:stop, i]" です。 
function の静的メソッドを返します。 
静的メソッドは暗黙の第一引数を受け取りません。 
静的メソッドの宣言は、以下のように書き慣わされます: class C:@staticmethoddef f(arg1, arg2, ...): ... 
@staticmethod は関数デコレータ形式です。 
オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。 
文字列に対してはその文字列自体を返します。 
repr(object)との違いは、str(object) は常に eval() が受理できるような文字列を返そうと試みるわけではないという点です;この関数の目的は印字可能な文字列を返すところにあります。 
引数が与えられなかった場合、空の文字列 '' を返します。 
文字列からなるシーケンスを結合する高速かつ正しい方法は ''.join(sequence) です。 sum(range(n), m) は reduce(operator.add, range(n), m) と同等です。 
type の上位クラスを返します。 
返された上位クラスオブジェクトが非バインドの場合、二つめの引数は省略されます。 
二つめの引数がオブジェクトの場合、isinstance(obj, type) は真でなくてはなりません。 
super は"super(C, self).__getitem__(name)" のような明示的なドット表記の属性参照の一部として使われているので注意してください。 
これに伴って、super は"super(C, self)[name]" のような文や演算子を使った非明示的な属性参照向けには定義されていないので注意してください。 バージョン 2.2 で 新たに追加 された仕様です。 
sequence の要素と要素が同じで、かつ順番も同じになるタプルを返します。 sequence はシーケンス、反復をサポートするコンテナ、およびイテレータオブジェクトをとることができます。 
sequence がすでにタプルの場合、そのタプルを変更せずに返します。 
例えば、tuple('abc') は ('a', 'b', 'c') を返し、tuple([1, 2, 3]) は (1, 2, 3) を返します。 
object の型を返します。 
返される値は型 
オブジェクトです。 
標準モジュール types 
は、組み込み名を持っていない全ての組み込み型の名前を定義しています。 
オブジェクトの型のテストには、組み込み関数 isinstance() が推奨されています。 
Unicode におけるコードが整数 i になるような文字 1 文字からなるUnicode 文字列を返します。 
例えば、unichr(97) は文字列 u'a'を返します。 
この関数は Unicode 文字列に対する ord() の逆です。 
引数は両端を含めて [0..65535] の範囲でなければなりません。 
それ以外の値に対しては ValueError が送出されます。 バージョン 2.0 で 新たに追加 された仕様です。 
以下のモードのうち一つを使って、object のUnicode 文字列バージョンを返します:もし encoding かつ/または errors が与えられていれば、unicode() は 8 ビットの文字列または文字列バッファになっているオブジェクトを encoding の codec を使ってデコードします。 encoding パラメタはエンコーディング名を与える文字列です;未知のエンコーディングの場合、LookupError が送出されます。 
エラー処理は errors に従って行われます; このパラメタは入力エンコーディング中で無効な文字の扱い方を指定します。 
もっと詳しくいえば、 objectが Unicode 文字列かそのサブクラスなら、デコード処理を一切介することなく Unicode 文字列を返すということです。 __unicode__() メソッドを提供しているオブジェクトの場合、unicode() はこのメソッドを引数なしで呼び出してUnicode 文字列を生成します。 
それ以外のオブジェクトの場合、8 ビットの文字列か、オブジェクトのデータ表現 (representation) を呼び出し、その後デフォルトエンコーディングで 'strict' モードのcodec を使って Unicode 文字列に変換します。 
バージョン 2.0 で 新たに追加 された仕様です。 
バージョン 2.2 で 変更 された仕様:__unicode__() のサポートが追加されました 
引数無しでは、現在のローカルシンボルテーブルに対応する辞書を返します。 
モジュール、クラス、またはクラスインスタンスオブジェクト(またはその他 __dict__ 属性を持つもの) を引数として与えた場合、そのオブジェクトのシンボルテーブルに対応する辞書を返します。 
返される辞書は変更すべきではありません: 変更が対応するシンボルテーブルにもたらす影響は未定義です。 
この関数は range() に非常によく似ていますが、リストの代わりに ``xrange オブジェクト'' を返します。 
このオブジェクトは不透明なシーケンス型で、対応するリストと同じ値を持ちますが、それらの値全てを同時に記憶しません。 
ragne() に対する xrange()の利点は微々たるものです (xrange() は要求に応じて値を生成するからです) ただし、メモリ量の厳しい計算機で巨大な範囲の値を使う時や、(ループがよく break で中断されるといったように) 範囲中の全ての値を使うとは限らない場合はその限りではありません。 
注意: 
xrange() はシンプルさと速度のために定義されている関数であり、その実現のために実装上の制限を課している場合があります。 
Python の C 実装では、全ての引数をネイティブの C long 型 (Python の"short" 整数型) に制限しており、要素数がネイティブの C long 型の範囲内に収まるよう要求しています。 
この関数はタプルのリストを返します。 
このリストの i 番目のタプルは各引数のシーケンス中の i 番目の要素を含みます。 返されるリストは引数のシーケンスのうち長さが最小のものの長さに切り詰められます。 
バージョン 2.4 で 変更 された仕様:これまでは、zip() は少なくとも一つの引数を要求しており、空のリストを返す代わりに TypeError を送出していました 
...新たなモジュールを生成しません。 
この関数は比較利用されない方なので、将来構文にするかどうかは保証できません。 
...場合、システムの標準の値が使われます。 
現状では、setvbuf() を持っていないシステムでは、バッファサイズを指定しても効果はありません。 
バッファサイズを指定するためのインタフェースは setvbuf() を使っては行われていません。 何らかの I/O が実行された後で呼び出されるとコアダンプすることがあり、どのような場合にそうなるかを決定する信頼性のある方法がないからです。 
...にもたらす影響は未定義です。 
現在の実装では、ローカルな値のバインディングは通常は影響を受けませんが、(モジュールのような)他のスコープから取り出した値は影響を受けるかもしれません。 
またこの実装は変更されるかもしれません。 
組み込み例外名、関数名、各種定数名は専用のシンボルテーブル中に存在しています。 
シンボル名を参照するときこのシンボルテーブルは最後に参照されるので、ユーザーが設定したローカルな名前やグローバルな名前によってオーバーライドすることができます。 
組み込み型については参照しやすいようにここで説明されています。 
2.1 この章にある表では、オペレータの優先度を昇順に並べて表わしていて、同じ優先度のオペレータは同じ箱に入れています。 
同じ優先度の二項演算子は左から右への結合順序を持っています。 
の5章をごらんください。 
...組み込み型については参照しやすいようにここで説明されています。 
2.1 ほとんどの説明ではそこで発生しうる例外については説明されていません。 
このマニュアルの将来の版で訂正される予定です。 
7.3.2.1 組み込み codec (built-in codec) 
7.3.2 Unicode オブジェクト (Unicode 
Python では、処理速度を高めるために C で書かれた一そろいのcodec を提供しています。 
これらの codec は全て以下の関数を介して直接利用できます。 以下の API の多くが、 encoding と errors という二つの引数をとります。 
これらのパラメタは、組み込みの Unicode オブジェクトコンストラクタである unicode() における同名のパラメタと同じセマンティクスになっています。 
encoding を NULL にすると、デフォルトエンコーディングである ASCIIを使います。 
ファイルシステムに関する関数の呼び出しでは、ファイル名に対するエンコーディングとしてPy_FileSystemDefaultEncoding を使わねばなりません。 
以下は汎用 codec の API です: 
何らかのエンコード方式でエンコードされた、 size バイトの文字列 s をデコードして Unicode オブジェクトを生成します。 encoding と errors は、組み込み関数 unicode() の同名のパラメタと同じ意味を持ちます。 
使用する codec の検索は、 Python の codecレジストリを使って行います。 
codec が例外を送出した場合にはNULL を返します。 
size で指定されたサイズの Py_UNICODE バッファをエンコードした Python 文字列オブジェクトを返します。 encoding および errors はUnicode 型の encode() メソッドに与える同名のパラメタと同じ意味を持ちます。 
使用する codec の検索は、 Python の codecレジストリを使って行います。 
codec が例外を送出した場合にはNULL を返します。 
以下は UTF-8 codec の APIです: 
UTF-8 でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
codec が例外を送出した場合にはNULL を返します。 
consumed が NULL の場合、PyUnicode_DecodeUTF8()と同じように動作します。 consumed が NULL でない場合、PyUnicode_DecodeUTF8Stateful() は末尾の不完全な UTF-8 バイト列をエラーとみなしません。 
これらのバイト列はデコードされず、デコードされたバイト数を consumed に返します。 バージョン 2.4 で 新たに追加 された仕様です。 
size で指定された長さを持つ Py_UNICODE 型バッファをUTF-8 でエンコードし、 Python 文字列オブジェクトにして返します。 
codec が例外を送出した場合には NULL を返します。 
UTF-8 で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
エラー処理は ``strict'' です。 
codec が例外を送出した場合にはNULL を返します。 
以下は UTF-16 codec の APIです: 
UTF-16 でエンコードされたバッファ s から size バイトデコードして、結果を Unicode オブジェクトで返します。 errors は (NULL でない場合) エラー処理方法を定義します。 
デフォルト値は ``strict'' です。 byteorder が NULL でない場合、デコード機構は以下のように指定されたバイト整列 (byte order) に従ってデコードを開始します: 
*byteorder == -1: リトルエンディアン*byteorder == 0: ネイティブ*byteorder == 1: ビッグエンディアン 
その後、入力データ中に見つかった全てのバイト整列マーカ (byte order mark, BOM) に従って、バイト整列を切り替えます。 
BOM はデコード結果の Unicode 文字列中にはコピーされません。 
デコードを完結した後、*byteorder は入力データの終点現在におけるバイト整列に設定されます。 byteorder が NULL の場合、 codec はネイティブバイト整列のモードで開始します。 
codec が例外を送出した場合にはNULL を返します。 PyObject* 
consumed が NULL の場合、PyUnicode_DecodeUTF16()と同じように動作します。 
consumed が NULL でない場合、PyUnicode_DecodeUTF16Stateful() は末尾の不完全な UTF-16 バイト列(奇数長のバイト列や分割されたサロゲートペア) をエラーとみなしません。 
これらのバイト列はデコードされず、デコードされたバイト数を consumedに返します。 
バージョン 2.4 で 新たに追加 された仕様です。 PyObject* 
s 中の Unicode データを UTF-16 でエンコードした結果が入っているPython 文字列オブジェクトを返します。 
byteorder が 0 でない場合、出力は以下のバイト整列指定に従って書き出されます: 
byteorder == -1: リトルエンディアンbyteorder == 0: ネイティブ (BOM マーカを書き出します)byteorder == 1: ビッグエンディアン 
バイトオーダが 0 の場合、出力結果となる文字列は常にUnicode BOM マーカ (U+FEFF) で始まります。 
それ以外のモードでは、BOM マーカを頭につけません。 Py_UNICODE_WIDE が定義されている場合、単一のPy_UNICODE値はサロゲートペアとして表現されることがあります。 
Py_UNICODE_WIDE が定義されていなければ、各Py_UNICODE 値は UCS-2 文字として表現されます。 codec が例外を送出した場合にはNULL を返します。 
ネイティブバイトオーダの UTF-16 でエンコードされた Python 文字列を返します。 
文字列は常に BOM マーカから始まります。 
エラー処理は ``strict'' です。 
codec が例外を送出した場合にはNULL を返します。 
以下は ``Unicode Escape'' codec の APIです: 
Unicode-Escape でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
size で指定された長さを持つ Py_UNICODE 型バッファをUnicode-Escape でエンコードし、 Python 文字列オブジェクトにして返します。 
codec が例外を送出した場合には NULL を返します。 
Unicode-Escape で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
エラー処理は ``strict'' です。 codec が例外を送出した場合にはNULL を返します。 
以下は ``Raw Unicode Escape'' codec の APIです: 
Raw-Unicode-Escape でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
size で指定された長さを持つ Py_UNICODE 型バッファをRaw-Unicode-Escape でエンコードし、 Python 文字列オブジェクトにして返します。 
codec が例外を送出した場合には NULL を返します。 
Raw-Unicode-Escape で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
以下は Latin-1 codec の APIです:Latin-1 は、 Unicode 序数の最初の 256 個に対応し、エンコード時にはこの 256 個だけを受理します。 
Latin-1 でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
size で指定された長さを持つ Py_UNICODE 型バッファをLatin-1 でエンコードし、 Python 文字列オブジェクトにして返します。 
codec が例外を送出した場合には NULL を返します。 
Latin-1 で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
以下は ASCII codec の APIです:7 ビットの ASCII データだけを受理します。 
その他のコードはエラーになります。 
ASCII でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
codec が例外を送出した場合にはNULL を返します。 
size で指定された長さを持つ Py_UNICODE 型バッファをASCII でエンコードし、 Python 文字列オブジェクトにして返します。 
ASCII で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
以下は mapping codec の APIです:この codec は、多くの様々な codec を実装する際に使われるという点で特殊な codec です (実際、encodings パッケージに入っている標準 codecs のほとんどは、この codec を使っています)。 この codec は、文字のエンコードやデコードにマップ型 (mapping)を使います。 
このため、codec を実現するマップ型に入れる必要がある対応付け関係は、ある文字を別のコード点に対応付けるものだけです。 
エンコードされた size バイトの文字列 s から mapping に指定されたオブジェクトを使って Unicode オブジェクトを生成します。 
size で指定された長さを持つ Py_UNICODE 型バッファをmapping に指定されたオブジェクトを使ってエンコードし、 Python 文字列オブジェクトにして返します。 codec が例外を送出した場合には NULL を返します。 
Unicode オブジェクトを mapping に指定されたオブジェクトを使ってエンコードし、結果を Python 文字列オブジェクトとして返します。 
以下の codec API は Unicode から Unicode への対応付けを行う特殊なものです。 
で 指定された長さを持つ Py_UNICODE バッファを、文字変換マップ table を適用して変換し、変換結果を Unicodeオブジェクトで返します。 
対応付けを行っていない(LookupError を起こすような) 文字序数に対しては、変換は行わず、そのままコピーします。 
以下は MBCS codec の API です。 
この codec は現在のところ、Windows 上だけで利用でき、変換の実装には Win32 MBCS 変換機構(Win32 MBCS converter) を使っています。 
MBCS (または DBCS)はエンコード方式の種類 (class) を表す言葉で、単一のエンコード方式を表すわけでなないので注意してください。 
利用されるエンコード方式 (target encoding) は、 codec を動作させているマシン上のユーザ設定で定義されています。 
MBCS でエンコードされた size バイトの文字列 s からUnicode オブジェクトを生成します。 
size で指定された長さを持つ Py_UNICODE 型バッファをMBCS でエンコードし、 Python 文字列オブジェクトにして返します。 
MBCS で Unicode オブジェクトをエンコードし、結果を Python 文字列オブジェクトとして返します。 
18.10.1 Pythonバイトコード命令 
現在Pythonコンパイラは次のバイトコード命令を生成します。 
STOP_CODE コンパイラにend-of-code(コードの終わり)を知らせます。 
インタプリタでは使われません。 
top-of-stack (TOS)(スタックの先頭)の項目を取り除きます。 
スタックの先頭から二つの項目を入れ替えます。 
スタックの先頭に参照の複製を作ります。 
TOS = +TOSを実行します。 
TOS = -TOSを実行します。 
TOS = not TOSを実行します。 
TOS = `TOS`を実行します。 
TOS = ~TOSを実行します。 
TOS = iter(TOS)を実行します。 
二項演算はスタックからスタックの先頭(TOS)と先頭から二番目のスタック項目を取り除きます。 
演算を実行し、スタックへ結果をプッシュし戻します。 
TOS = TOS1 ** TOSを実行します。 
TOS = TOS1 * TOSを実行します。 
from __future__ import divisionが有効でないとき、TOS = TOS1 / TOSを実行します。 
TOS = TOS1 // TOSを実行します。 
from __future__ import divisionが有効でないとき、TOS = TOS1 / TOSを実行します。 
TOS = TOS1 % TOSを実行します。 
TOS = TOS1 + TOSを実行します。 
TOS = TOS1 - TOSを実行します。 
TOS = TOS1[TOS]を実行します。 
TOSを実行します。 
TOS = TOS1 TOSを実行します。 
TOS = TOS1 ^ TOSを実行します。 
TOS = TOS1 | TOSを実行します。 
インプレース演算はTOSとTOS1を取り除いて結果をスタックへプッシュするという点で二項演算と似ています。 
インプレースにTOS = TOS1 ** TOSを実行します。 
インプレースにTOS = TOS1 * TOSを実行します。 
from __future__ import divisionが有効でないとき、インプレースにTOS = TOS1 / TOSを実行します。 
インプレースにTOS = TOS1 // TOSを実行します。 
from __future__ import divisionが有効でないとき、インプレースにTOS = TOS1 / TOSを実行します。 
インプレースにTOS = TOS1 % TOSを実行します。 
インプレースにTOS = TOS1 + TOSを実行します。 
インプレースにTOS = TOS1 - TOSを実行します。 
インプレースにTOS = TOS1 
インプレースにTOS = TOS1 TOSを実行します。 
インプレースにTOS = TOS1 ^ TOSを実行します。 
インプレースにTOS = TOS1 | TOSを実行します。 
スライス演算は三つまでのパラメータを取ります。 
TOS = TOS[:]を実行します。 
TOS = TOS1[TOS:]を実行します。 
TOS = TOS1[:TOS]を実行します。 
TOS = TOS2[TOS1:TOS]を実行します。 
スライス代入はさらに別のパラメータを必要とします。 
どんな文もそうであるように、スタックに何もプッシュしません。 
TOS[:] = TOS1を実行します。 
TOS1[TOS:] = TOS2を実行します。 
TOS1[:TOS] = TOS2を実行します。 
TOS2[TOS1:TOS] = TOS3を実行します。 
del TOS[:]を実行します。 
del TOS1[TOS:]を実行します。 
del TOS1[:TOS]を実行します。 
del TOS2[TOS1:TOS]を実行します。 
TOS1[TOS] = TOS2を実行します。 
del TOS1[TOS]を実行します。 
その他の演算。 
対話モードのための式文を実行します。 
TOSはスタックから取り除かれプリントされます。 
非対話モードにおいては、式文はPOP_STACKで終了しています。 
sys.stdoutに束縛されたファイル互換のオブジェクトへTOSをプリントします。 
print文に、各項目に対するこのような命令が一つあります。 
PRINT_ITEMと似ていますが、TOSから二番目の項目をTOSにあるファイル互換オブジェクトへプリントします。 
これは拡張print文で使われます。 
sys.stdoutへ改行をプリントします。 
これはprint文がコンマで終わっていない場合にprint文の最後の演算として生成されます。 
PRINT_NEWLINEと似ていますが、TOSのファイル互換オブジェクトに改行をプリントします。 
break文があるためループを終了します。 
continue文があるためループを継続します。 
targetはジャンプするアドレスです(アドレスはFOR_ITER命令であるべきです)。 LOAD_LOCALS 
現在のスコープのローカルな名前空間(locals)への参照をスタックにプッシュします。 これはクラス定義のためのコードで使われます: クラス本体が評価された後、localsはクラス定義へ渡されます。 
関数の呼び出し元へTOSを返します。 
TOSをポップし、それをジェネレータからyieldします。 
"_"で始まっていないすべてのシンボルをモジュールTOSから直接ローカル名前空間へロードします。 
モジュールはすべての名前をロードした後にポップされます。 この演算コードはfrom module import *を実行します。 
exec TOS2,TOS1,TOSを実行します。 
コンパイラは見つからないオプションのパラメータをNoneで埋めます。 
ブロックスタックからブロックを一つ取り除きます。 
フレームごとにブロックのスタックがあり、ネストしたループ、try文などを意味しています。 
finally節を終わらせます。 
インタプリタは例外を再び発生させなければならないかどうか、あるいは、関数が返り外側の次のブロックに続くかどうかを思い出します。 
新しいクラスオブジェクトを作成します。 
TOSはメソッド辞書、TOS1は基底クラスの名前のタプル、TOS2はクラス名です。 
次の演算コードはすべて引数を要求します。 
引数はより重要なバイトを下位にもつ2バイトです。 
del nameを実行します。 ここで、nameiはコードオブジェクトのco_names属性へのインデックスです。 
TOSをcount個のへ個別の値に分け、右から左にスタックに置かれます。 
count個の項目を同じ順番を保ちながら複製します。 
実装上の制限から、countは1から5の間(5を含む)でなければいけません。 
TOS.name = TOS1を実行します。 ここで、nameiはco_namesにおける名前のインデックスです。 
co_namesへのインデックスとしてnameiを使い、del TOS.nameを実行します。 
STORE_NAMEとして機能しますが、グローバルとして名前を記憶します。 
DELETE_NAMEとして機能しますが、グルーバル名を削除します。 
"co_consts[consti]"をスタックにプッシュします。 
"co_names[namei]"に関連付けられた値をスタックにプッシュします。 
スタックからcount個の項目を消費するタプルを作り出し、できたタプルをスタックにプッシュします。 
BUILD_TUPLEとして機能しますが、リストを作り出します。 
スタックに新しい空の辞書オブジェクトをプッシュします。 
引数は無視され、コンパイラによってゼロに設定されます。 
TOSをgetattr(TOS, co_names[namei])と入れ替えます。 
ブール演算を実行します。 
演算名はcmp_op[opname]にあります。 
モジュールco_names[namei]をインポートします。 
モジュールオブジェクトはスタックへプッシュされます。 
現在の名前空間は影響されません: 適切なimport文に対して、それに続くSTORE_FAST命令が名前空間を変更します。 
属性co_names[namei]をTOSに見つかるモジュールからロードします。 
作成されたオブジェクトはスタックにプッシュされ、その後STORE_FAST命令によって記憶されます。 
バイトコードカウンタをdeltaだけ増加させます。 
TOSが真ならば、deltaだけバイトコードカウンタを増加させます。 
TOSはスタックに残されます。 
TOSが偽ならば、deltaだけバイトコードカウンタを増加させます。 
TOSは変更されません。 
バイトコードカウンタをtargetに設定します。 
TOSはイテレータです。 
そのnext()メソッドを呼び出します。 
これが新しい値を作り出すならば、それを(その下にイテレータを残したまま)スタックにプッシュします。 
イテレータが尽きたことを示した場合は、TOSがポップされます。 そして、バイトコードカウンタがdeltaだけ増やされます。 
グルーバル名co_names[namei]をスタック上にロードします。 
ブロックスタックにループのためのブロックをプッシュします。 
ブロックは現在の命令からdeltaバイトの大きさを占めます。 
try-except節からtryブロックをブロックスタックにプッシュします。 
deltaは最初のexceptブロックを指します。 SETUP_FINALLY 
try-except節からtryブロックをブロックスタックにプッシュします。 deltaはfinallyブロックを指します。 
ローカルなco_varnames[var_num]への参照をスタックにプッシュします。 
TOSをローカルなco_varnames[var_num]の中に保存します。 
ローカルなco_varnames[var_num]を削除します。 
セルと自由変数記憶領域のスロットiに含まれるセルへの参照をプッシュします。 
iがco_cellvarsの長さより小さければ、変数の名前はco_cellvars[i]です。 
そうでなければ、それはco_freevars[i - len(co_cellvars)]です。 
セルと自由変数記憶領域のスロットiに含まれるセルをロードします。 
セルが持つオブジェクトへの参照をスタックにプッシュします。 
セルと自由変数記憶領域のスロットiに含まれるセルへTOSを保存します。 
このオペコードは廃止されました。 
例外を発生させます。 argcはraise文へ与えるパラメータの数を0から3の範囲で示します。 
ハンドラはTOS2としてトレースバック、TOS1としてパラメータ、そしてTOSとして例外を見つけられます。 
関数を呼び出します。 
argcの低位バイトは位置パラメータを示し、高位バイトはキーワードパラメータの数を示します。 オペコードは最初にキーワードパラメータをスタック上に見つけます。 
それぞれのキーワード引数に対して、その値はキーの上にあります。 
スタック上のキーワードパラメータの下に位置パラメータはあり、先頭に最も右のパラメータがあります。 
スタック上のパラメータの下には、呼び出す関数オブジェクトがあります。 
新しい関数オブジェクトをスタックにプッシュします。 
TOSは関数に関連付けられたコードです。 
関数オブジェクトはTOSの下にあるargcデフォルトパラメータをもつように定義されます。 
新しい関数オブジェクトを作り出し、そのfunc_closureスロットを設定し、それをスタックにプッシュします。 
TOSは関数に関連付けられたコードです。 コードオブジェクトがN個の自由変数を持っているならば、スタック上の次のN個の項目はこれらの変数に対するセルです。 
関数はセルの前にあるargcデフォルトパラメータも持っています。 
スライスオブジェクトをスタックにプッシュします。 argcは2あるいは3でなければなりません。 
組み込み関数を参照してください。 
大きすぎてデフォルトの二バイトに当てはめることができない引数をもつあらゆるオペコードの前に置かれます。 extは二つの追加バイトを保持し、その後ろのオペコードの引数と一緒になって取られます。 
それらは四バイト引数を構成し、extはその最上位バイトです。 CALL_FUNCTION_VAR 
関数を呼び出します。 argcはCALL_FUNCTIONのように解釈実行されます。 
スタックの先頭の要素はキーワード引数辞書を含んでいおり、その後に変数引数のタプルが続き、さらに明示的なキーワードと位置引数が続きます。 
7.5.8 弱参照オブジェクト (weak reference 
このオブジェクトの使用法に関する情報は、Python インタプリタの拡張と埋め込み 1.12 節、``Providing a C API for an Extension Module,'' を参照してください。 
この PyObject のサブタイプは不透明型値 (opaque value) を表現します。 C 拡張モジュールが Python コードから不透明型値を (void* ポインタで) 他の C コードに渡す必要があるときに便利です。 
正規の import 機構を使って動的にロードされるモジュール内で定義されている C API にアクセスするために、あるモジュール内で定義されている C 関数ポインタを別のモジュールでも利用できるようにするためによく使われます。 
引数が PyCObject の場合に真を返します。 
cobj から PyCObject を生成します。 
関数 destr が NULL でない場合、オブジェクトを再利用する際に呼び出します。 
関数 destr が NULL でない場合、オブジェクトを再利用する際に呼び出します。 引数 desc を使って、デストラクタ関数に追加のコールバックデータを渡せます。 
PyCObject オブジェクト self を生成するのに用いたオブジェクト void * を返します。 
PyCObject オブジェクト self を生成するのに用いたコールバックデータ void * を返します。 
CacheFTPHandler オブジェクトは FTPHandler オブジェクトに以下のメソッドを追加したものです: 
接続のタイムアウトを t 秒に設定します。 
キャッシュ付き接続の最大接続数を m に設定します。 
インスタンスが関数として ``呼ばれた'' 際に呼び出されます;このメソッドが定義されている場合、 
x(arg1, arg2, ...)は 
x.__call__(arg1, arg2, ...) を短く書いたものになります。 
1.7 拡張モジュール関数でのパラメタ展開 
これまでは、Python からの C 関数の呼び出しに重点を置いて述べてきました。 ところでこの逆: C からの Python 関数の呼び出しもまた有用です。 
とりわけ、いわゆる ``コールバック'' 関数をサポートするようなライブラリを作成する際にはこの機能が便利です。 
ある C インタフェースがコールバックを利用している場合、同等の機能を提供する Python コードでは、しばしば Python プログラマにコールバック機構を提供する必要があります; このとき実装では、C で書かれたコールバック関数から Python で書かれたコールパック関数を呼び出すようにする必要があるでしょう。 
もちろん、他の用途も考えられます。 幸運なことに、Python インタプリタは簡単に再帰呼び出しでき、Python 関数を呼び出すための標準インタフェースもあります。 
(Python パーザを特定の入力文字を使って呼び出す方法について詳説するつもりはありません -- この方法に興味があるなら、Python ソースコードの Python/pythonmain.c にある、コマンドラインオプション-c の実装を見てください)Python 関数の呼び出しは簡単です。 
まず、C のコードに対してコールバックを登録しようとする Python プログラムは、何らかの方法でPython の関数オブジェクトを渡さねばなりません。 
このために、コールバック登録関数 (またはその他のインタフェース) を提供せねばなりません。 
このコールバック登録関数が呼び出された際に、引き渡された Python 関数オブジェクトへのポインタをグローバル変数に -- あるいは、どこか適切な場所に -- 保存します(関数オブジェクトをPy_INCREF() するようよく注意してください!)。 
例えば、以下のような関数がモジュールの一部になっていることでしょう: 
static PyObject *my_callback = NULL;static PyObject *my_set_callback(PyObject *dummy, PyObject *args){PyObject *result = NULL;PyObject *temp;if (PyArg_ParseTuple(args, "O:set_callback", temp)) {if (!PyCallable_Check(temp)) {PyErr_SetString(PyExc_TypeError, "parameter must be callable");return NULL;}Py_XINCREF(temp); /* 新たなコールバックへの参照を追加 */Py_XDECREF(my_callback); /* 以前のコールバックを捨てる */my_callback = temp; /* 新たなコールバックを記憶 *//* "None" を返す際の定型句 */Py_INCREF(Py_None);result = Py_None;}return result;} 
この関数はMETH_VARARGS フラグを使ってインタプリタに登録せねばなりません; METH_VARARGS フラグについては、1.4 節、 ``モジュールのメソッドテーブルと初期化関数''で説明しています。 
PyArg_ParseTuple() 関数とその引数については、1.7 節、 ``拡張モジュール関数でのパラメタ展開''に記述しています。 Py_XINCREF() およびPy_XDECREF() は、オブジェクトに対する参照カウントをインクリメント/デクリメントするためのマクロで、NULL ポインタが渡されても安全に操作できる形式です (とはいえ、上の流れではtemp がNULL になることはありません)。 
この関数には二つの引数: Python 関数と Python 関数の引数リストがあり、いずれも任意の Python オブジェクトを表すポインタ型です。 
引数リストは常にタプルオブジェクトでなければならず、その長さは引数の数になります。 
Python 関数を引数なしで呼び出すのなら空のタプルを渡します; 単一の引数で関数を呼び出すのなら、単要素 (singleton) のタプルを渡します。 Py_BuildValue() の書式化文字列中に、ゼロ個または一個以上の書式化コードが入った丸括弧がある場合、この関数はタプルを返します。 
以下に例を示します: 
int arg;PyObject *arglist;PyObject *result;...arg = 123;.../* ここでコールバックを呼ぶ */arglist = Py_BuildValue("(i)", arg);result = PyEval_CallObject(my_callback, arglist);Py_DECREF(arglist); 
PyEval_CallObject() は Python オブジェクトへのポインタを返します; これは Python 関数からの戻り値になります。 
PyEval_CallObject() は、引数に対して``参照カウント中立 (reference-count-neutral)'' です。 
上の例ではタプルを生成して引数リストとして提供しており、このタプルは呼び出し直後に Py_DECREF() しています。 PyEval_CallObject() は ``新しい'' 戻り値を返します: 戻り値が表すオブジェクトは新たなオブジェクトか、既存のオブジェクトの参照カウントをインクリメントしたものです。 
従って、このオブジェクトをグローバル変数に保存したいのでないかぎり、たとえこの戻り値に興味がなくても (むしろ、そうであればなおさら!)何がしかの方法で戻り値オブジェクトを Py_DECREF() しなければなりません。 とはいえ、戻り値をPy_DECREF() する前には、値が NULLでないかチェックしておくことが重要です。 
もし NULLなら、呼び出したPython 関数は例外を送出して終了させられています。 
PyEval_CallObject() を呼び出しているコード自体もまたPython から呼び出されているのであれば、今度は C コードが自分を呼び出している Python コードにエラー標示値を返さねばなりません。 それにより、インタプリタはスタックトレースを出力したり、例外を処理するための Python コードを呼び出したりできます。 
例外の送出が不可能だったり、したくないのなら、PyErr_Clear() を呼んで例外を消去しておかねばなりません。 
例えば以下のようにします: 
if (result == NULL)return NULL; /* エラーを返す */...use result...Py_DECREF(result); 
Python コールバック関数をどんなインタフェースにしたいかによっては、引数リストをPyEval_CallObject() に与えなければならない場合もあります。 
あるケースでは、コールバック関数を指定したのと同じインタフェースを介して、引数リストも渡されているかもしれません。 
また別のケースでは、新しいタプルを構築して引数リストを渡さねばならないかもしれません。 
この場合最も簡単なのはPy_BuildValue() を呼ぶやり方です。 
例えば、整数のイベントコードを渡したければ、以下のようなコードを使うことになるでしょう: 
PyObject *arglist;...arglist = Py_BuildValue("(l)", eventcode);result = PyEval_CallObject(my_callback, arglist);Py_DECREF(arglist);if (result == NULL)return NULL; /* エラーを返す *//* 場合によってはここで結果を使うかもね */Py_DECREF(result); 
"Py_DECREF(arglist)" が呼び出しの直後、エラーチェックよりも前に置かれていることに注意してください! また、厳密に言えば、このコードは完全ではありません: Py_BuildValue() はメモリ不足におちいるかもしれず、チェックしておくべきです。 
呼び出し (call) は、呼び出し可能オブジェクト (callable object, 例えば関数など) を、引数列とともに呼び出します。 引数列は空のシーケンスでもかまいません: 
引数式は全て、呼び出しを試みる前に値評価されます。 
仮引数 (formal parameter) リストの構文については、7.5 を参照してください。 キーワード引数が存在する場合、以下のようにして最初に固定引数(positional argument) に変換されます。 
まず、値の入っていないスロットが仮引数に対して生成されます。 
N 個の固定引数がある場合、固定引数は先頭の N スロットに配置されます。 
次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数パラメタ名と同じなら、最初のスロットを使う、といった具合です)。 
全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。 
(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。 
)デフォルト値が指定されていない、値の埋められていないスロットが残っている場合、TypeError 例外が送出されます。 
このシーケンスの要素は、追加の固定引数のように扱われます;すなわち、固定引数 x1,...,xN と、y1,...,yM になるシーケンス "expression" を使った場合、M+N 個の固定引数 x1,...,xN,y1,...,yMを使った呼び出しと同じになります。 上記の仕様による結果として、"*expression" 構文はたとえキーワード引数 以降に あっても、キーワード引数以前に ("**expression" 引数があればさらにその後に- 下記参照) 処理されます。 
従って: 
def f(a, b):... print a, b... f(b=1, *(2,))2 1 f(a=1, *(2,))Traceback (most recent call last):File "stdin", line 1, in ?TypeError: f() got multiple values for keyword argument 'a' f(1, *(2,))1 2 となります。 
明示的なキーワード引数が "expression" 内のキーワードと重複した場合には、TypeError 例外が送出されます。 "*identifier" や "**identifier" 構文を使った仮引数は、固定引数スロットやキーワード引数名にすることができません。 
ユーザ定義関数のとき: 
関数のコードブロックに引数リストが渡され、実行されます。 
コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については 7.5 で記述しています。 
コードブロックで return 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。 
組み込み関数や組み込みメソッドのとき: 
結果はインタプリタに依存します; 組み込み関数や組み込みメソッドの詳細は、 
Python ライブラリリファレンス 
を参照してください。 
クラスオブジェクトのとき: 
そのクラスの新しいインスタンスが返されます。 
クラスインスタンスメソッドのとき: 
対応するユーザ定義の関数が呼び出されます。 このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。 
クラスインスタンスのとき: 
クラスで __call__()メソッドが定義されていなければなりません; __call__()メソッドが呼び出された場合と同じ効果をもたらします。 
パーザオブジェクト(createparser()で返されます)には以下のメソッドがあります: 
パーザにコールバックを加えます。 
デジタルオーディオストリームの8つの異なるデータタイプのためのコールバックをパーザは持っています。 
これらのタイプのための定数はcdモジュールのレベルで定義されています(上記参照)。 
コールバックは以下のように呼び出されます: func(arg, type, data)、ここでargはユーザが与えた引数、typeはコールバックの特定のタイプ、dataはこのtypeのコールバックに渡されるデータです。 
データのタイプは以下のようにコールバックのタイプによって決まります: 
al.writesamps()へそのまま渡すことのできる文字列。 
プログラム(トラック)ナンバーを示す整数。 
インデックスナンバーを示す整数。 
プログラムの時間を示す分、秒、フレームからなるタプル。 
絶対的な時刻を示す分、秒、フレームからなるタプル。 
CDのカタログナンバーを示す13文字の文字列。 
録音のISRC識別番号を示す12文字の文字列。 
文字列は2文字の国別コード、3文字の所有者コード、2文字の年号、5文字のシリアルナンバーからなります。 
CDのサブコードデータのコントロールビットを示す整数。 
パーザを消去して、使用していたメモリを解放します。 
この呼び出しのあと、オブジェクトは使用できません。 
オブジェクトへの最後の参照が削除されると、自動的にこのメソッドが呼び出されます。 
readda()などから返されたデジタルオーディオCDのデータの1つあるいはそれ以上のフレームをパースします。 
データ内にどういうサブコードがあるかを決定します。 
その前のフレームからサブコードが変化していたら、parseframe()は対応するタイプのコールバックを起動して、フレーム内のサブコードデータをコールバックに渡します。 Cの関数とは違って、1つ以上のデジタルオーディオデータのフレームをこのメソッドに渡すことができます。 
指定したtypeのコールバックを削除します。 
サブコードを追跡しているパーザのフィールドをリセットして、初期状態にします。 ディスクを交換したあと、resetparser()を呼び出さなければなりません。 
``セル (cell)'' オブジェクトは、複数のスコープから参照される変数群を実装するために使われます。 
セルは各変数について作成され、各々の値を記憶します; この値を参照する各スタックフレームにおけるローカル変数には、そのスタックフレームの外側で同じ値を参照しているセルに対する参照が入ります。 
セルで表現された値にアクセスすると、セルオブジェクト自体の代わりにセル内の値が使われます。 
このセルオブジェクトを使った間接参照 (dereference) は、インタプリタによって生成されたバイトコード内でサポートされている必要があります; セルオブジェクトにアクセスした際に、自動的に間接参照は起こりません。 
上記以外の状況では、セルオブジェクトは役に立たないはずです。 
セルオブジェクトに使われる C 構造体です。 
セルオブジェクトに対応する型オブジェクトです。 
ob がセルオブジェクトの場合に真を返します;ob は NULL であってはなりません。 
値 ob の入った新たなセルオブジェクトを生成して返します。 引数を NULL にしてもかまいません。 
cell の内容を返します。 
cell の内容を返しますが、cell が非 NULL でかつセルオブジェクトであるかどうかチェックしません。 
セルオブジェクト cell の内容を value に設定します。 
成功すると 0 を返します。 
セルオブジェクト cell の値を value に設定します。 
参照カウントに対する変更はなく、安全のためのチェックは何も行いません; cell は非NULL でなければならず、かつセルオブジェクトでなければなりません。 
11.2.2 cgi モジュールを使う 
CGI スクリプトは、HTTP サーバによって起動され、通常は HTML のFORM または ISINDEX エレメントを通じてユーザが入力した内容を処理します。 
このモジュールでは、上記のケースの違いに注意しつつ、Python スクリプトに対しては単純なインタフェースを提供しています。 
最初のセクションは複数のヘッダからなり、後続するデータがどのようなものかをクライアントに通知します。 
最小のヘッダセクションを生成するための Python のコードは以下のようなものです: 
print "Content-Type: text/html" # 以降のデータが HTML であることを示す行print # ヘッダ部の終了を示す空行 
二つ目のセクションは通常、ヘッダやインラインイメージ等の付属したテキストをうまくフォーマットして表示できるようにした HTML です。 以下に単純な HTML を出力する Python コードを示します: 
11.2.7 CGI スクリプトを Unix 
これはよく知られているセキュリティホールであり、これによって Web のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意のシェルコマンドを実行させてしまえます。 
URL の一部やフィールド名でさえも信用してはいけません。 CGI へのリクエストはあなたの作ったフォームから送信されるとは限らないからです!安全な方法をとるために、フォームから入力された文字をシェルに渡す場合、文字列に入っているのが英数文字、ダッシュ、アンダースコア、およびピリオドだけかどうかを確認してください。 
クラス定義は、クラスオブジェクトを定義します (3.2 節参照): 
クラス定義は実行可能な文です。 
クラス定義では、まず継承リストがあればそれを評価します。 
継承リストの各要素の値評価結果はクラスオブジェクトか、サブクラス可能なクラス型でなければなりません。 
次にクラスのスイートが新たな実行フレーム内で、新たなローカル名前空間と元々のグローバル名前空間を使って実行されます (4.1 節を参照してください)。 
(通常、スイートには関数定義のみが含まれます) クラスのスイートを実行し終えると、実行フレームは無視されますが、ローカルな名前空間は保存されます。 
次に、基底クラスの継承リストを使ってクラスオブジェクトが生成され、ローカルな名前空間を属性値辞書として保存します。 
最後に、もとのローカルな名前空間において、クラス名がこのクラスオブジェクトに束縛されます。 
プログラマのための注釈: クラス定義内で定義された変数はクラス変数です; クラス変数は全てのインスタンス間で共有されます。 
インスタンス変数を定義するには、__init__() メソッドや他のメソッド中で変数に値を与えます。 
クラス変数もインスタンス変数も``self.name'' 表記でアクセスすることができます。 
この表記でアクセスする場合、インスタンス変数は同名のクラス変数を隠蔽します。 
変更不能な値をもつクラス変数は、インスタンス変数のデフォルト値として使えます。 新形式のクラスでは、デスクリプタを使ってインスタンス変数の振舞いを変更できます。 
5 ドキュメントクラス Python ドキュメントで利用するため、2つの LaTeX ドキュメントクラスが定義されています。 
manual クラスは、章単位で区分するような大きなドキュメントのためのクラスです。 
howto クラスはより小さなドキュメントのためのクラスです。 manual ドキュメントは大規模で、ほとんどの標準ドキュメントが使うクラスです。 
このドキュメントクラスは標準 LaTeX の report クラスに基づいていて、まるで長い技術的報告書のようにフォーマットされます。 
ます。 
Python リファレンスマニュアル 
は manual ドキュメントのよい例です。 また、 
は大規模な文書の例です。 howto ドキュメントはより短く、manual ドキュメントのような大きな構造を持ちません。 
このクラスは標準 LaTeX のarticle クラスに基づいていて、Linux Documentation プロジェクトの ``HOWTO''シリーズのようにフォーマットされます。 ``HOWTO'' シリーズはもともと LinuxDocソフトウェアを使ってフォーマットを行っています。 
このドキュメントクラスの本来の目的は、 LDP の HOWTO シリーズと同様の役割を果たすことにありましたが、その後、このクラスにはより広範囲な適用性があるとわかりました。 
このクラスは ``how-to'' ドキュメント (このドキュメントがその一例です)や、小規模で、かなり強い関連性で結ばれたモジュールライブラリのリファレンスマニュアルに用います。 
後者のドキュメントクラスの例には 
があります。 
これらのドキュメントは、大きなドキュメントにおける章一つ分とだいたい同じ規模です。 
4.9.1.1 Codec オブジェクト 
4.9.1.2 StreamWriter オブジェクト 
Codec クラスは以下のメソッドを定義します。 これらのメソッドは、内部状態を持たないエンコーダ/デコーダ関数のインタフェースを定義します。 
オブジェクト input エンコードし、(出力オブジェクト, 消費した 長さ) のタプルを返します。 
codecs は Unicode 専用ではありませんが、Unicode の文脈では、エンコーディングは Unicode オブジェクトを特定の文字集合エンコーディング(たとえば cp1252 やiso-8859-1)を使って文字列オブジェクトに変換します。 
errors は適用するエラー処理を定義します。 
'strict' 処理がデフォルトです。 このメソッドは Codec に内部状態を保存してはなりません。 
オブジェクト input をデコードし、(出力オブジェクト, 消費した長さ) のタプルを返します。 
Unicode の文脈では、デコードは特定の文字集合エンコーディングでエンコードされた文字列を Unicode オブジェクトに変換します。 
input は bf_getreadbuf バッファスロットを提供するオブジェクトでなければなりません。 
バッファスロットを提供しているオブジェクトにはPython 文字列オブジェクト、バッファオブジェクト、メモリマップファイルがあります。 
'strict' がデフォルト値です。 このメソッドは、Codec インスタンスに内部状態を保存してはなりません。 
StreamWriter と StreamReader クラスは、新しいエンコーディングモジュールを、非常に簡単に実装するのに使用できる、一般的なインターフェイス提供します。 
実装例は encodings.utf_8 をご覧ください。 
本節では、型強制 (coercion) に関する規則について記述します。 
プログラム言語が進化するにつれ、型強制規則について正確に記述するのは難しくなってゆきます; 従って、あるバージョンのある実装について記述するのは望ましくありません。 
その代わりに、型強制に関する非公式的なガイドラインを示しておきます。 
Python 3.0からは、型強制がサポートされなくなる予定です。 
% 演算子の左被演算子が文字列か Unicode オブジェクトの場合、型強制は起きず、文字列としての書式化操作が呼び出されます。 
型強制演算の定義はもはや推奨されていません。 
事実上、 NotImplemented を返す演算子は、全く実装されていないものとして扱われます。 
以下の説明では、__op__() および __rop__() は、演算子に相当する一般的なメソッド名を表すために使われます; __iop__ はインプレース演算子を表します。 
例えば、演算子 `+' の場合、__add__() および __radd__() がそれぞれ左右の被演算子用の二項演算子として使われ、__iadd__ がインプレース演算用の演算子として使われる、といった具合です。 
オブジェクト x および y に対して、まず 
x.__op__(y) が試されます。 
この演算が実装されていないか、NotImplemented を返す場合、次に 
y.__rop__(x) が試されます。 
この演算も実装されていないか、NotImplemented を返すなら、 TypeError例外が送出されます。 
ただし、以下の例外があるので参照してください: 
前項に対する例外: 左被演算子が組み込み型や新形式クラスのインスタンスであり、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインスタンスである場合、左被演算子の __op__() メソッドを試す 前に 右被演算子の __rop__() が試されます。 
これは、サブクラス側で二項演算子を完全にオーバライドできるようにするためです。 
そうしなければ、常に左被演算子の __op__ メソッドが右被演算子を受理してしまいます: あるクラスのインスタンスが被演算子になるとされている場合、そのサブクラスのインスタンスもまた受理可能だからです。 
双方の被演算子が型強制を定義している場合、型強制は被演算子の型の__op__() や __rop__() メソッドが呼び出される前に呼び出され、それより早くなることはありません。 
型強制の結果、型強制を行うことになったいずれの被演算子とも異なる型が返された場合、返されたオブジェクトの新たな型を使って、この過程が部分的に再度行われます。 
(`+=' のような) インプレース型の演算子を用いる際、左被演算子が__iop__() を実装していれば、__iop__() が呼び出され、型強制は一切行われません。 
演算が __op__() かつ/または__rop__() に帰着した場合、通常の型強制規則が適用されます。 
y において、 x が結合 (concatenation) 演算を実装しているシーケンスであれば、シーケンスの結合が実行されます。 
y において、一方の演算子が繰り返し (repeat) 演算を実装しているシーケンスであり、かつ他方が整数 (int または long) である場合、シーケンスの繰り返しが実行されます。 
(__eq__() などのメソッドで実装されている) 拡張比較は、決して型強制を行いません。 
(__cmp__() で実装されている) 三値比較(three-way comparison) は、他の二項演算子で行われているのと同じ条件で型強制を受けます。 
現在の実装では、組み込み数値型 int, long およびfloat は型強制を行いません; 一方、complex は型強制を使います。 
こうした違いは、これらの型をサブクラス化する際に顕在化してきます。 
そのうち、 complex 型についても型強制を避けるよう修正されるかもしれません。 
これらの型は全て、関数 coerce() から利用するための __coerce__() メソッドを実装しています。 
コメントは文字列リテラル内に入っていないハッシュ文字 (#) から始まり、同じ物理行の末端で終わります。 
非明示的な行継続規則が適用されていない限り、コメントは論理行を終端させます。 コメントは構文上無視されます; コメントはトークンになりません。 
10.1 オブジェクトをヒープ上にメモリ確保する 
Python では、オブジェクト型を定義する上で数多くの構造体が使われます。 
PyObject 型や PyVarObject 型もまた、他の全ての Python オブジェクトを定義する上で直接的・間接的に使われているマクロを使って定義されています。 
全てのオブジェクト型はこの型を拡張したものです。 
この型には、あるオブジェクトに対するオブジェクトとしてのポインタをPython から扱う必要がある際に必要な情報が入っています。 
通常に ``リリースされている'' ビルドでは、この構造体にはオブジェクトの参照カウントと、オブジェクトに対応する型オブジェクトだけが入っています。 
PyObject_HEAD マクロ展開で定義されているフィールドに対応します。 
PyObject を拡張して、ob_size フィールドを追加したものです。 
この構造体は、長さ (length) の概念を持つオブジェクトだけに対して使います。 
この型が Python/C API で使われることはほとんどありません。 
PyObject_VAR_HEAD マクロ展開で定義されているフィールドに対応します。 
PyObject および PyVarObject の定義には以下のマクロが使われています: 
PyObject 型のフィールド宣言に展開されるマクロです; 可変でない長さを持つオブジェクトを表現する新たな型を宣言する場合に使います。 
展開によってどのフィールドが宣言されるかは、Py_TRACE_REFS の定義に依存します。 
デフォルトでは、Py_TRACE_REFS は定義されておらず、PyObject_HEAD は以下のコードに展開されます: 
Py_TRACE_REFS が定義されている場合、以下のように展開されます: 
PyObject_VAR_HEAD マクロです。 
PyVarObject 型のフィールド宣言に展開されるマクロです;インスタンスによって可変の長さを持つオブジェクトを表現する新たな型を宣言する場合に使います。 
マクロは常に以下のように展開されます: 
マクロ展開結果の一部にPyObject_HEAD が含まれており、PyObject_HEAD の展開結果はPy_TRACE_REFSの定義に依存します。 
ほとんどの Python の呼び出し可能オブジェクトを C で実装する際に用いられている関数の型です。 この型の関数は二つの PyObject* 型パラメタをとり、PyObject* 型の値を返します。 
戻り値を NULLにする場合、例外をセットしておかなければなりません。 
NULLでない値を返す場合、戻り値は Python に関数の戻り値として公開される値として解釈されます。 
この型の関数は新たな参照を返さなければなりません。 
拡張型のメソッドを記述する際に用いる構造体です。 
この構造体には4 つのフィールドがあります: 
フィールド 
C データ型 
メソッド名 
C 実装へのポインタ 
呼び出しをどのように行うかを示すフラグビット 
docstring の内容を指すポインタ 
ml_meth は C の関数ポインタです。 
関数は別の型で定義されていてもかまいませんが、常に PyObject* を返します。 
関数が PyFunction でない場合、メソッドテーブル内でキャストを行うようコンパイラが要求することになるでしょう。 
PyCFunction では最初のパラメタがPyObject* 型であると定義していますが、固有の C 型を self オブジェクトに使う実装はよく行われています。 ml_flags フィールドはビットフィールドで、以下のフラグが入ります。 
個々のフラグは呼び出し規約 (calling convention) や束縛規約(binding convention) を表します。 
呼び出し規約フラグでは、METH_VARARGS およびMETH_KEYWORDS を組み合わせられます (ただし、METH_KEYWORDS 単体の指定を行っても 
METH_VARARGS | METH_KEYWORDS と同じなので注意してください)。 
呼び出し規約フラグは束縛フラグと組み合わせられます。 
PyCFunction 型のメソッドで典型的に使われる呼び出し規約です。 
関数はPyObject* 型の引数値を二つ要求します。 
最初の引数はメソッドの self オブジェクトです; モジュール関数の場合、Py_InitModule4() に与えることになる値が入ります(NULL にするとPy_InitModule() が使われます)。 
第二のパラメタ (よく args と呼ばれます) は、全ての引数を表現するタプルオブジェクトです。 
パラメタは通常、PyArg_ParseTuple() や PyArg_UnpackTupleで処理されます。 
このフラグを持つメソッドはPyCFunctionWithKeywords型でなければなりません。 
PyCFunctionWithKeywords は三つのパラメタ:self、 args、 およびキーワード引数全てからなる辞書、を要求します。 
このフラグは通常METH_VARARGS と組み合わされ、パラメタはPyArg_ParseTupleAndKeywords() で処理されます。 
引数のないメソッドは、METH_NOARGS フラグをつけた場合、必要な引数が指定されているかをチェックしなくなります。 
こうしたメソッドは PyCFunction 型でなくてはなりません。 
オブジェクトのメソッドに使った場合、第一のパラメタは selfになり、オブジェクトインスタンスへの参照を保持することになります。 
いずれにせよ、第二のパラメタは NULLになります。 
単一のオブジェクト引数だけをとるメソッドは、PyArg_ParseTuple() を引数 "O" にして呼び出す代わりに、METH_O フラグつきで指定できます。 
メソッドはPyCFunction 型で、self パラメタと単一の引数を表現するPyObject* パラメタを伴います。 
この呼び出し規約は撤廃されました。 
メソッドはPyCFunction 型でなければなりません。 
第二引数は、引数がない場合には NULL、単一の引数の場合にはその引数オブジェクト、複数個の引数の場合には引数オブジェクトからなるタプルです。 
この呼び出し規約を使うと、複数個の引数の場合と、単一のタプルが唯一引数の場合を区別できなくなってしまいます。 
以下の二つの定数は、呼び出し規約を示すものではなく、クラスのメソッドとして使う際の束縛方式を示すものです。 
モジュールに対して定義された関数で用いてはなりません。 
メソッドに対しては、最大で一つしかこのフラグをセットできません。 
メソッドの最初の引数には、型のインスタンスではなく型オブジェクトが渡されます。 
このフラグは 組み込み関数classmethod() を使って生成するのと同じクラスメソッド (class method)を生成するために使われます。 
バージョン 2.3 で 新たに追加 された仕様です。 
メソッドの最初の引数には、型のインスタンスではなく NULL が渡されます。 
このフラグは、staticmethod() を使って生成するのと同じ静的メソッド (static method)を生成するために使われます。 
もう一つの定数は、あるメソッドを同名の別のメソッド定義と置き換えるかどうかを制御します。 
メソッドを既存の定義を置き換える形でロードします。 
METH_COEXIST を指定しなければ、デフォルトの設定にしたがって、定義が重複しないようスキップします。 
スロットラッパはメソッドテーブルよりも前にロードされるので、例えば sq_contains スロットはラップしているメソッド __contains__() を生成し、同名のPyCFunction のロードを阻止します。 
このフラグを定義すると、PyCFunction はラッパオブジェクトを置き換える形でロードされ、スロットと連立します。 
PyCFunctions の呼び出しはラッパオブジェクトの呼び出しよりも最適化されているので、こうした仕様が便利になります。 
C で実装された拡張型の束縛メソッドオブジェクトを返します。 
PyObject_GenericGetAttr() 関数を使わないtp_getattro や tp_getattr ハンドラを実装する際に便利です。 
比較演算は全てのオブジェクトでサポートされています。 
比較演算子は全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。 比較は任意の形で連鎖させることができます; 例えば、 
は 
x y および y = z 
と等価で、違うのは y が一度だけしか評価されないということです (どちらの場合でも、 
が偽となった場合には z は評価されません) 。 
以下のテーブルに比較演算をまとめます: 
より小さい 
以下 
より大きい 
以上 
等しい 
等しくない 
同一のオブジェクトである 
同一のオブジェクトでない 
および != は同じ演算子を別の書き方にしたものです。 
繰り返しますが、そのようなオブジェクトも任意の順番付けをされていますが、それは一貫したものです。 
被演算子が複素数の場合、演算子 、 = 、 および = は例外 TypeError を送出します。 
あるクラスのインスタンス間の比較は、そのクラスで __cmp__()メソッドが定義されていない限り等しくなりません。 
このメソッドを使ってオブジェクトの比較方法に影響を及ぼすための情報については 
を参照してください。 
実装に関する注釈: 数値型を除き、異なる型のオブジェクトは型の名前で順番付けされます; 適当な比較をサポートしていないある型のオブジェクトはアドレスによって順番付けされます。 同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ"in" 
および "not in" 
がサポートされています (以下を参照)。 
1.6 C から Python 
新しい拡張モジュールを使えるようになるまで、まだ二つの作業: コンパイルと、Python システムへのリンク、が残っています。 
動的読み込み (dynamic loading) を使っているのなら、作業の詳細は自分のシステムが使っている動的読み込みの形式によって変わるかもしれません; 詳しくは、拡張モジュールのビルドに関する章 (3 章) や、Windows におけるビルドに関係する追加情報の章(4 章) を参照してください。 動的読み込みを使えなかったり、モジュールを常時 Python インタプリタの一部にしておきたい場合には、インタプリタのビルド設定を変更して再ビルドしなければならなくなるでしょう。 
Unixでは、幸運なことにこの作業はとても単純です: 単に自作のモジュールファイル (例えばspammodule.c ) を展開したソース配布物の Modules/ ディレクトリに置き、 Modules/Setup.local に自分のファイルを説明する以下の一行: 
を追加して、トップレベルのディレクトリで make を実行して、インタプリタを再ビルドするだけです。 
Modules/ サブディレクトリでも make を実行できますが、前もって `make Makefile' を実行して Makefilew再ビルドしておかなければならりません。 (この作業はSetup ファイルを変更するたびに必要です。 
)モジュールが別のライブラリとリンクされている必要がある場合、ライブラリも設定ファイルに列挙できます。 例えば以下のようにします: 
Python compiler パッケージは Python のソースコードを分析したりPython バイトコードを生成するためのツールです。 
compiler はPython のソースコードから抽象的な構文木を生成し、その構文木からPython バイトコードを生成するライブラリをそなえています。 
パッケージは、Python で書かれたPython ソースコードからバイトコードへの変換プログラムです。 
これは組み込みの構文解析器をつかい、そこで得られた具体的な構文木に対して標準的な 
モジュールを使用します。 
この構文木から抽象構文木 AST (Abstract Syntax Tree) が生成され、その後 Python バイトコードが得られます。 このパッケージの機能は、Python インタプリタに内蔵されている組み込みのコンパイラがすべて含んでいるものです。 
これはその機能と正確に同じものになるよう意図してつくられています。 
なぜ同じことをするコンパイラをもうひとつ作る必要があるのでしょうか? このパッケージはいろいろな目的に使うことができるからです。 
パッケージのいろいろなコンポーネントがどのように動作するのかを説明します。 
そのため説明はリファレンスマニュアル的なものと、チュートリアル的な要素がまざったものになっています。 以下のモジュールは 
パッケージの一部です: 
Completerオブジェクトは以下のメソッドを持っています: 
textのstate番目の補完候補を返します。 もしtextがピリオド(".")を含まない場合、 
で定義されている名前か、キーワード ( 
モジュールで定義されている)から補完されます。 ピリオドを含む名前の場合、副作用を出さずに名前を最後まで評価しようとします(関数を明示的に呼び出しはしませんが、__getattr__()を呼んでしまうことはあります)そして、dir()関数でマッチする語を見つけます。 
7.2.4 浮動小数点型オブジェクト (floating point 
7.2.5.1 C 構造体としての複素数 
Python の複素数オブジェクトは、 C API 側から見ると二つの別個の型として実装されています: 一方は Python プログラムに対して公開されている Python のオブジェクトで、他方は実際の複素数値を表現する C の構造体です。 
API では、これら双方を扱う関数を提供しています。 
7.2.5.1 C 構造体としての複素数 
7.2.5.2 Python オブジェクトとしての複素数型 
7.1 if 文 
7. 複合文 (compound statement) 
複合文には、他の文 (のグループ) が入ります; 複合文は、中に入っている他の文の実行の制御に何らかのやり方で影響を及ぼします。 
関数とクラス定義もまた、構文法的には複合文です。 複合文は、一つまたはそれ以上の `節 (clause)' からなります。 
一つの節は、ヘッダと `スイート (suite)' からなります。 
特定の複合文を構成する節のヘッダ部分は、全て同じインデントレベルになります。 各々の節ヘッダ行は一意に識別されるキーワードから始まり、コロンで終わります。 
スイートは、ヘッダのコロンの後ろにセミコロンで区切られた一つまたはそれ以上の単純文を並べるか、ヘッダ行後のインデントされた文の集まりです。 
後者の形式のスイートに限り、ネストされた複合文を入れることができます; 以下の文は、else 節がどの if 節に属するかがはっきりしないという理由から不正になります: 
また、このコンテキスト中では、セミコロンはコロンよりも強い結合を表すことにも注意してください。 従って、以下の例では、printは全て実行されるか、されないかのどちらかです: 
まとめると、以下のようになります: 
文は常に NEWLINE 
か、その後にDEDENT が続いたもので終了することに注意してください。 
また、オプションの継続節は常にあるキーワードから始まり、このキーワードから複合文を開始することはできないため、曖昧さは存在しないことにも注意してください (Python では、`ぶら下がり(dangling) else' 問題を、ネストされたif 文はインデントさせること解決しています)。 
以下の節における文法規則の記述方式は、明確さのために、各節を別々の行に書くようにしています。 
Distutils の使い方は、モジュール開発者とサードパーティ製のモジュールをインストールするユーザ/管理者のどちらにとってもきわめて単純です。 
開発者側のやるべきことは (もちろん、しっかりした実装で、詳しく文書化され、よくテストされたコードを書くことは別として!) 以下の項目になります: 
setup スクリプト (setup.py という名前にするのがならわし)を書く 
(必要があれば) setup 設定ファイルを書く 
ソースコード配布物を作成する 
(必要があれば) 一つまたはそれ以上のビルド済み (バイナリ) 形式の配布物を作成する 
これらの作業については、いずれもこのドキュメントで扱っています。 全てのモジュール開発者が複数の実行プラットフォームを利用できるわけではないので、全てのプラットフォーム向けにビルド済みの配布物を提供してもらえると期待するわけにはいきません。 
ですから、仲介を行う人々、いわゆる パッケージ作成者 (packager) がこの問題を解決すべく立ち上がってくれることが望ましいでしょう。 
パッケージ作成者はモジュール開発者がリリースしたソースコード配布物を、一つまたはそれ以上のプラットフォーム上でビルドして、得られたビルド済み配布物をリリースすることになります。 
したがって、ほとんどの一般的なプラットフォームにおけるユーザは、setup スクリプト一つ実行せず、コードを一行たりともコンパイルしなくても、使っているプラットフォーム向けのきわめて普通の方法でほとんどの一般的な Python モジュール配布物をインストールできるでしょう。 
7.1 基本オブジェクト (fundamental object) 
7. 具象オブジェクト (concrete object) レイヤ 
この章ではは、特定の Python オブジェクト型固有の関数について述べています。 
これらの関数に間違った方のオブジェクトを渡すのは良い考えであありません; Python プログラムから何らかのオブジェクトを受け取ったとき、そのオブジェクトが正しい型になっているか確信をもてないのなら、まず型チェックを行わなければなりません; 例えば、あるオブジェクトが辞書型か調べるには、PyDict_Check() を使います。 
この章は Python のオブジェクト型における ``家計図'' に従って構成されています。 
警告:この章で述べている関数は、渡されたオブジェクトの型を注意深くチェックしはするものの、多くの関数は渡されたオブジェクトが有効なNULL なのか有効なオブジェクトなのかをチェックしません。 
これらの関数に NULL を渡させてしまうと、関数はメモリアクセス違反を起こして、インタプリタを即座に終了させてしまうはずです。 
7.2.5.1 C 構造体としての複素数 
7.3.2.2 メソッドおよびスロット関数 (slot function) 
条件変数(condition variable) は常にある種のロックに関連付けられています;条件変数に関連付けるロックは明示的に引き渡したり、デフォルトで生成させたりできます。 
これら三つのメソッドを呼び出せるのは、呼び出し手のスレッドがロックを獲得している時だけです。 wait()メソッドは現在のスレッドのロックを解放し、他のスレッドが同じ条件変数に対してnotify()またはnotifyAll() を呼び出して現在のスレッドを起こすまでブロックします。 
一度起こされると、再度ロックを獲得して処理を戻します。 
wait() にはタイムアウトも設定できます。 notify()メソッドは条件変数待ちのスレッドを1つ起こします。 
例えば、以下のコードは無制限のバッファ容量のときの一般的な生産者-消費者問題です: 
notify() とnotifyAll() のどちらを使うかは、その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは複数なのかで考えます。 
例えば、典型的な生産者-消費者問題では、バッファに 1 つの要素を加えた場合には消費者スレッドを 1 つしか起こさなくてかまいません。 
クラスCondition 
lock を指定して、None の値にする場合、Lock またはRLock オブジェクトでなければなりません。 
この場合、lock は根底にあるロックオブジェクトとして使われます。 それ以外の場合には新しい RLock オブジェクトを生成して使います。 
このメソッドを呼び出してよいのは、呼び出し手のスレッドがロックを獲得しているときだけです。 
このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に対してnotify()またはnotifyAll() を呼び出して現在のスレッドを起こすか、オプションのタイムアウトが発生するまでブロックします。 
その代わり、 ロックが再帰的に複数回獲得されていても確実にアンロックを行えるRLock クラスの内部インタフェースを使います。 その後ロックを再獲得する時に、もう一つの内部インタフェースを使ってロックの再帰レベルを復帰します。 
何らかの待機中スレッドがある場合、そのスレッドの一つを起こします。 
待機中のスレッドがなければ何もしません。 現在の実装では、待機中のメソッドをただ一つだけ起こします。 
とはいえ、この挙動に依存するのは安全ではありません。 
将来、実装の最適化によって、複数のスレッドを起こすようになるかもしれないからです。 注意: 起こされたスレッドは実際にロックを再獲得できるまでwait()呼出しから戻りません。 
notify()はロックを解放しないので、notify() 呼び出し手は明示的にロックを解放せねばなりません。 
この条件を待っているすべてのスレッドを起こします。 
このメソッドはnotify() のように動作しますが、1 つではなくすべての待ちスレッドを起こします。 
6 拡張モジュールのビルド: 小技と豆知識 
上で述べたように、 Distutils 設定ファイルを使えば、任意の Distutils オプションに対して個人的な設定やサイト全体の設定を記録できます。 
すなわち、任意のコマンドの任意のオプションを二つか三つ (プラットフォームによって異なります) の設定ファイルに保存でき、コマンドラインを解釈する前にオプションを問い合わせさせるようにできます。 
つまり、設定ファイルはデフォルトの値を上書きし、さらにコマンドライン上で与えた値が設定ファイルの内容を上書きするわけです。 
さらに、複数の設定ファイルが適用されると、``先に'' 適用されたファイルに指定されていた値は ``後に'' 適用されたファイル内の値で上書きされます。 
設定ファイルの名前と場所は、非常にわずかですがプラットフォーム間で異なります。 
Unixでは、三種類の設定ファイルは以下のようになります(処理される順に並んでいます): 
設定ファイルのタイプ 
場所とファイル名 
Windows では設定ファイルは以下のようになります: 
Mac OS では以下のようになります: 
厳密に言えば、システム全体向けの設定ファイルは、 Distutilsがインストールされているディレクトリになります; Unixの Python 1.6 以降では、表の通りの場所になります。 
Python 1.5.2 では、 Distutils は通常 
prefix/lib/python1.5/site-packages/distutilsにインストールされるため、 Python 1.5.2 では設定ファイルをそこに置かなければなりません。 
Unixでは、環境変数 HOME が定義されていない場合、標準モジュール 
のgetpwuid() 関数を使ってユーザのホームディレクトリを決定します。 
現在のディレクトリ (通常は setup スクリプトがある場所) です。 
(注記 (1) も参照してください) Python 1.6 およびそれ以降のバージョンでは、 Python のデフォルトの ``インストールプレフィクス''は C:Python なので、システム設定ファイルは通常C:PythonLibdistutilsdistutils.cfg になります。 
Python 1.5.2 ではデフォルトのプレフィクスは C:ProgramFilesPythonであり、Distutils は標準ライブラリの一部ではありません -- 従って、システム設定ファイルは、 Windows 用の標準の Python 1.5.2 ではC:ProgramFilesPythondistutilsdistutils.cfg になります。 
Windows では、環境変数 HOME が設定されていない場合、個人用の設定ファイルはどこにもなく、使われることもありません。 
(言い換えれば、 Windows での Distutils はホームディレクトリがどこにあるか一切推測しようとしないということです。 ) 
(注釈 (1) と (4) も参照してください) デフォルトのインストールプレフィクスは単に Python: なので、Python 1.6 以降では、通常は Python:Lib:distutils:distutils.cfgになります。 
Distutils 設定ファイルは、全て同じ構文をしています。 
設定ファイルはセクションでグループ分けされています。 
各 Distutils コマンドごとにセクションがあり、それに加えて全てのコマンドに影響するグローバルオプションを設定するためのglobal セクションがあります。 
各セクションにはoption=value の形で、一行あたり一つのオプションを指定します。 例えば、以下は全てのコマンドに対してデフォルトでメッセージを出さないよう強制するための完全な設定ファイルです: 
この内容のファイルがシステム全体用の設定ファイルとしてインストールされていれば、そのシステムの全てのユーザによる全ての Python モジュール配布物に対する処理に影響します。 
ファイルが (個人用の設定をサポートしているシステムで) 個人用の設定ファイルとしてインストールされていれば、そのユーザが処理するモジュール配布物にのみ影響します。 この内容を特定のモジュール配布物の setup.cfg として使えば、その配布物だけに影響します。 
以下のようにして、デフォルトの ``ビルドベース'' ディレクトリをオーバライドしたり、build* コマンドが常に強制的にリビルドを行うようにもできます: 
この設定は、コマンドライン引数の 
python setup.py build --build-base=blib --force に対応します。 
ただし、後者ではコマンドライン上で build コマンドを含めて、そのコマンドを実行するよう意味しているところが違います。 
特定のコマンドに対するオプションを設定ファイルに含めると、このような関連付けの必要はなくなります;あるコマンドが実行されると、そのコマンドに対するオプションが適用されます。 
(また、設定ファイル内からオプションを取得するような他のコマンドを実行した場合、それらのコマンドもまた設定ファイル内の対応するオプションの値を使います。 )あるコマンドに対するオプションの完全なリストは、例えば以下のように、--help を使って調べます: 
グローバルオプションの完全なリストを得るには、コマンドを指定せずに--help オプションを使います: 
``Python モジュールの配布'' マニュアルの、``リファレンスマニュアル'' の節も参照してください。 
6 拡張モジュールのビルド: 小技と豆知識 
1.2.5 設定を行なう MacPython 配布物には、EditPythonPrefs というアプレットがついてきます。 
このアプレットを使うと、 MacPython の環境をカスタマイズして、自分の作業方法にあわせる手助けをしてくれます。 
InteractiveConsoleクラスはInteractiveInterpreterのサブクラスです。 以下の追加メソッドだけでなく、インタプリタオブジェクトのすべてのメソッドも提供します。 
対話的なPythonコンソールをそっくりにエミュレートします。 
その行はバッファへ追加され、ソースとして連結された内容が渡されインタプリタのrunsource()メソッドが呼び出されます。 
コマンドが実行されたか、有効であることをこれが示している場合は、バッファはリセットされます。 そうでなければ、コマンドが不完全で、その行が付加された後のままバッファは残されます。 
さらに入力が必要ならば、戻り値はTrueです。 その行がある方法で処理されたならば、Falseです(これはrunsource()と同じです)。 
入力バッファから処理されていないソーステキストを取り除きます。 
プロンプトを書き込み、一行を読み込みます。 
返る行は末尾に改行を含みません。 
ユーザがEOFキーシーケンスを入力したときは、EOFErrorを発生させます。 
基本実装では、組み込み関数raw_input()を使います。 サブクラスはこれを異なる実装と置き換えるかもしれません。 
ContentHandler はアプリケーション側でサブクラス化して利用することが前提になっています。 
パーサは入力ドキュメントのイベントにより、それぞれに対応する以下のメソッドを呼び出します。 
アプリケーションにドキュメント・イベントの発生位置を通知するためにパーサから呼び出されます。 
典型的な利用方法としては、アプリケーション側でこの情報を使い独自のエラーを発生させること(文字コンテンツがアプリケーション側で決めた規則に沿っていない場合等)があげられます。 
しかしロケータが返す情報は検索エンジンなどで利用するものとしてはおそらく不充分でしょう。 ロケータが正しい情報を返すのは、インターフェースからイベントの呼出しが実行されている間だけです。 
それ以外のときは使用すべきでありません。 
ドキュメントの開始通知を受け取ります。 SAX パーサはこのインターフェースやDTDHandler のどのメソッド(setDocumentLocator()を除く)よりも先にこのメソッドを一度だけ呼び出します。 
ドキュメントの終了通知を受け取ります。 SAX パーサはこのメソッドを一度だけ、パース過程の最後に呼び出します。 
パーサは(回復不能なエラーで)パース処理を中断するか、あるいは入力の最後に到達するまでこのメソッドを呼び出しません。 
プリフィックスと URI の名前空間の関連付けを終了します。 詳しくは startPrefixMapping() を参照してください。 
このイベントは常に対応する endElement() の後で発生しますが、複数の endPrefixMapping() イベントの順序は特に保証されません。 
非名前空間モードで要素の開始を通知します。 name パラーメータには要素型の raw XML 1.0名を文字列として、attrs パラメータには要素の属性を保持する 
Attributes インターフェース オブジェクトをそれぞれ指定します。 
attrs として渡されたオブジェクトはパーサで再利用することも可能ですが、属性のコピーを保持するためにこれを参照し続けるのは確実な方法ではありません。 
属性のコピーを保持したいときは attrs オブジェクトの copy() メソッドを用いてください。 
非名前空間モードで要素の終了を通知します。 name パラメータには startElement() イベント同様の要素型名を指定します。 
名前空間モードで要素の開始を通知します。 name パラーメータには要素型を (uri,localname) のタプルとして、qname パラメータにはソース・ドキュメントで用いられている raw XML 1.0名、attrs には要素の属性を保持する 
AttributesNS インターフェース のインスタンスをそれぞれ指定します。 
要素に関連付けられた名前空間がないときは、name コンポーネントの uri が None になります。 
attrs として渡されたオブジェクトはパーサで再利用することも可能ですが、属性のコピーを保持するためにこれを参照し続けるのは確実な方法ではありません。 
属性のコピーを保持したいときは attrs オブジェクトの copy() メソッドを用いてください。 feature_namespace_prefixes 機能が有効になっていなければ、パーサで qname を None にセットすることも可能です。 
文字データの通知を受け取ります。 パーサは文字データのチャンクごとにこのメソッドを呼び出して通知します。 
SAX パーサは一連の文字データを単一のチャンクとして返す場合と複数のチャンクに分けて返す場合がありますが、ロケータの情報が正しく保たれるように、一つのイベントの文字データは常に同じ外部エンティティのものでなければなりません。 
content はユニコード文字列、バイト文字列のどちらでもかまいませんが、expat リーダ・モジュールは常にユニコード文字列を生成するようになっています。 
注意:Python XML SIG が提供していた初期 SAX 1 では、このメソッドにもっと JAVA 風のインターフェースが用いられています。 
しかし Python で採用されている大半のパーサでは古いインターフェースを有効に使うことができないため、よりシンプルなものに変更されました。 
古いコードを新しいインターフェースに変更するには、古い offset と length パラメータでスライスせずに、content を指定するようにしてください。 
スキップしたエンティティの通知を受け取ります。 
パーサはエンティティをスキップするたびにこのメソッドを呼び出します。 妥当性検査をしないプロセッサは(外部 DTD サブセットで宣言されているなどの理由で)宣言が見当たらないエンティティをスキップします。 
すべてのプロセッサは feature_external_ges およびfeature_external_pes 属性の値によっては外部エンティティをスキップすることがあります。 
Python/C API リファレンスマニュアル 
continue 文は for ループや while ループ内のネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、try 文の中には現れません。 
continue 文は、文を囲う最も内側のループの次の周期に処理を継続します。 
... 文の中には現れません。 
except 節やelse 節中に置くことはできます。 
try 文に置けないという制限は、実装側の不精によるもので、そのうち改善されることでしょう。 
コントロールウィンドウオブジェクトには Window オブジェクトのメソッドの他に次のメソッドがあります。 
コントロール control のパートコード pcode がユーザーにヒットされた場合に呼ばれます。 
トラッキングなどは任せておいてかまいません。 
以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれている場合、引数は 3 章の末尾に記載されている型強制規則に基づいて型強制されます。 
引数がいずれも標準の数値型である場合、以下の型強制が適用されます: 
片方の引数が複素数型であれば、他方は複素数型に変換されます; 
それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます; 
それ以外の場合で、片方の引数が長整数型であれば、他方は長整数型に変換されます; 
それ以外の場合で、両方の引数が通常の整数型であれば、変換の必要はありません。 
特定の演算子 (文字列を左引数とする `%' 演算子など) では、さらに別の規則が適用されます。 
拡張をおこなうことで、個々の演算子に対する型強制を定義できます。 
次の例はCookieの使い方を示したものです。 
Cookie インスタンスは、さまざまなクッキーの標準で規定されている標準的なクッキー属性とおおまかに対応する Python 属性をもっています。 
しかしデフォルト値を決める複雑なやり方が存在しており、また max-age および expires クッキー属性は同じ値をもつことになっているので、この対応は 1対 1 ではありません。 CookiePolicy メソッド内でのごくわずかな例外を除けば、これらの属性に代入する必要はないはずです。 
このクラスは内部の一貫性を保つようにはしていないため、代入するのは自分のやっていることを理解している場合のみにしてください。 
整数または None。 
Netscape クッキーは バージョン 0 であり、RFC 2965 および RFC 2109 クッキーは バージョン 1 です。 
クッキーの名前 (文字列)。 
クッキーの値 (文字列)、あるいは None。 
ポートあるいはポートの集合をあらわす文字列 (例: '80' または '80,8080')、あるいは None。 
クッキーのパス名 (文字列、例:'/acme/rocket_launchers')。 
そのクッキーを返せるのが安全な接続のみならば真を返します。 
クッキーの期限が切れる日時をあわらす整数 (エポックから経過した秒数)、あるいは None。 
is_expired() も参照してください。 
これがセッションクッキーであれば真を返します。 
このクッキーの働きを説明する、サーバからのコメント文字列、あるいは None。 
このクッキーの働きを説明する、サーバからのコメントのリンク URL、あるいは None。 
サーバがポート、あるいはポートの集合を(Set-Cookie: / Set-Cookie2: ヘッダ内で) 明示的に指定していれば真を返します。 
サーバがドメインを明示的に指定していれば真を返します。 
サーバが明示的に指定したドメインが、ドット ('.') で始まっていれば真を返します。 
クッキーは、オプションとして標準的でないクッキー属性を持つこともできます。 
これらは以下のメソッドでアクセスできます: 
そのクッキーが指定された名前のクッキー属性をもっている場合には真を返します。 
クッキーが指定された名前のクッキー属性をもっていれば、その値を返します。 
そうでない場合は default を返します。 set_nonstandard_attr 
指定された名前のクッキー属性を設定します。 
Cookie クラスは以下のメソッドも定義しています: 
サーバが指定した、クッキーの期限が切れるべき時が過ぎていれば真を返します。 
now が指定されているときは (エポックから経過した秒数です)、そのクッキーが指定された時間において期限切れになっているかどうかを判定します。 
文字列表現を値にデコードして返します。 
戻り値の型はどのようなものでも許されます。 
このメソッドはBaseCookieにおいて何も実行せず、オーバーライドされるためにだけ存在します。 
エンコードした値を返します。 
ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と同様に動作する埋め込み可能なJavaScript snippetを返します。 attrsの意味はoutput()と同じです。 
rawdataが文字列であれば、HTTP_COOKIEとして処理し、その値をMorselとして追加します。 
辞書の場合は次と同様の処理をおこないます。 
11.20.2 FileCookieJar のサブクラスと web 
CookiePolicy インターフェイスを実装するオブジェクトは以下のようなメソッドを持っています: 
クッキーがサーバから受け入れられるべきかどうかを表わす boolean 値を返します。 
cookie は cookielib.Cookie インスタンスです。 request はCookieJar.extract_cookies() の説明で定義されているインターフェイスを実装するオブジェクトです。 
クッキーがサーバに返されるべきかどうかを表わす boolean 値を返します。 
cookie は cookielib.Cookie インスタンスです。 request はCookieJar.add_cookie_header() の説明で定義されているインターフェイスを実装するオブジェクトです。 
与えられたクッキーのドメインに対して、そこにクッキーを返すべきでない場合にはfalse を返します。 このメソッドは高速化のためのものです。 
これにより、すべてのクッキーをある特定のドメインに対してチェックする (これには多数のファイル読みこみを伴なう場合があります)必要がなくなります。 
domain_return_ok() および path_return_ok() の両方から true が返された場合、すべての決定は return_ok() に委ねられます。 もし、このクッキードメインに対して domain_return_ok() が true を返すと、つぎにそのクッキーのパス名に対して path_return_ok() が呼ばれます。 
そうでない場合、そのクッキードメインに対する path_return_ok() およびreturn_ok() は決して呼ばれることはありません。 
path_return_ok() が true を返すと、return_ok() がその Cookie オブジェクト自身の全チェックのために呼ばれます。 
そうでない場合、そのクッキーパス名に対する return_ok() は決して呼ばれることはありません。 注意: domain_return_ok() は request ドメインだけではなく、すべての cookie ドメインに対して呼ばれます。 
たとえば request ドメインが"www.example.com" だった場合、この関数は ".example.com" および"www.example.com" の両方に対して呼ばれることがあります。 
同じことは path_return_ok() にもいえます。 request 引数は return_ok() で説明されているとおりです。 
与えられたクッキーのパス名に対して、そこにクッキーを返すべきでない場合にはfalse を返します。 
domain_return_ok() の説明を参照してください。 上のメソッドの実装にくわえて、CookiePolicy インターフェイスの実装では以下の属性を設定する必要があります。 
これはどのプロトコルがどのように使われるべきかを示すもので、これらの属性にはすべて代入することが許されています。 
Netscape プロトコルを実装していることを示します。 
RFC 2965 プロトコルを実装していることを示します。 
Cookie2: ヘッダをリクエストに含めないようにします(このヘッダが存在する場合、私たちは RFC 2965 クッキーを理解するということをサーバに示すことになります)。 
もっとも有用な方法は、DefaultCookiePolicy をサブクラス化したCookiePolicy クラスを定義して、いくつか (あるいはすべて) のメソッドをオーバーライドすることでしょう。 
CookiePolicy 自体はどのようなクッキーも受け入れて設定を許可する「ポリシー無し」ポリシーとして使うこともできます (これが役に立つことはあまりありませんが)。 
はじめに、もっとも一般的な cookielib の使用例をあげます: 
以下の例では、 URL を開く際に Netscape や Mozilla または Lynx のクッキーを使う方法を示しています (クッキーファイルの位置は Unix/Netscape の慣例にしたがうものと仮定しています): 
つぎの例は DefaultCookiePolicy の使用例です。 RFC 2965 クッキーをオンにし、Netscape クッキーを設定したり返したりするドメインに対してより厳密な規則を適用します。 
そしていくつかのドメインからクッキーを設定あるいは返還するのをブロックしています: import urllib2from cookielib import CookieJar, DefaultCookiePolicypolicy = DefaultCookiePolicy(rfc2965=True, strict_ns_domain=Policy.DomainStrict,blocked_domains=["ads.net", ".ads.net"])cj = CookieJar(policy)opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))r = opener.open("http://example.com/") 
2. 超高レベルレイヤ 
この節のマクロはPythonオブジェクトの参照カウントを管理するために使われます。 
オブジェクトoに対する参照カウントを一つ増やします。 
オブジェクトがNULLであってはいけません。 それがNULLではないと確信が持てないならば、Py_XINCREF()を使ってください。 
オブジェクトがNULLであってもよく、その場合マクロは何の影響も与えません。 
オブジェクトoに対する参照カウントを一つ減らします。 
オブジェクトがNULLであってはいけません。 それがNULLではないと確信が持てないならば、Py_XDECREF()を使ってください。 
参照カウントがゼロになったら、オブジェクトの型のメモリ解放関数(NULLであってはならない)が呼ばれます。 
警告:(例えば__del__()メソッドをもつクラスインスタンスがメモリ解放されたときに)メモリ解放関数は任意のPythonコードを呼び出すことができます。 
このようなコードでは例外は伝播しませんが、実行されたコードはすべてのPythonグローバル変数に自由にアクセスできます。 
これが意味するのは、Py_DECREF()が呼び出されるより前では、グローバル変数から到達可能などんなオブジェクトも一貫した状態にあるべきであるということです。 
例えば、リストからオブジェクトを削除するコードは削除するオブジェクトへの参照を一時変数にコピーし、リストデータ構造を更新し、それから一時変数に対してPy_DECREF()を呼び出すべきです。 
オブジェクトoへの参照カウントを一つ減らします。 
バージョン 2.4 で 新たに追加 された仕様です。 
以下の関数:Py_IncRef(PyObject *o), Py_DecRef(PyObject *o).は,実行時の動的な Python 埋め込みで使われる関数です.これらの関数はそれぞれPy_XINCREF() およびPy_XDECREF() をエクスポートしただけです.以下の関数やマクロ: _Py_Dealloc(), _Py_ForgetReference(),_Py_NewReference()は,インタプリタのコアの内部においてのみ使用するためのものです。 また、グローバル変数_Py_RefTotal も同様です。 
1.12 拡張モジュールに C API 
C++でも拡張モジュールは作成できます。 
ただしいくつか制限があります。 
メインプログラム (Python インタプリタ) は C コンパイラでコンパイルされリンクされているので、グローバル変数や静的オブジェクトをコンストラクタで作成できません。 
メインプログラムが C++ コンパイラでリンクされているならこれは問題ではありません。 
Python インタプリタから呼び出される関数 (特にモジュール初期化関数)は、extern "C" を使って宣言しなければなりません。 また、Python ヘッダファイルをextern "C" {...} に入れる必要はありません-- シンボル"__cplusplus" (最近の C++ コンパイラは全てこのシンボルを定義しています) が定義されているときにextern "C" {...} が行われるように、ヘッダファイル内にすでに書かれているからです。 
1 ダム形式のビルド済み配布物を作成する 
1 ダム形式のビルド済み配布物を作成する 
RPM 形式は、Red Hat, SuSE, Mandrake といった、多くの一般的な Linux ディストリビューションで使われています。 
あるいは、bdist コマンドを --format オプション付きで使います: 
前者の場合、 RPM 特有のオプションを指定できます; 後者の場合、一度の実行で複数の形式を指定できます。 
両方同時にやりたければ、それぞれの形式について各コマンドごとにオプション付きでbdist_* コマンドを並べます: 
Distutils が setup スクリプトで制御されているのとほとんど同じく、RPM パッケージの作成は、 .spec で制御されています。 
RPM の作成を簡便に解決するため、bdist_rpm コマンドでは通常、 setup スクリプトに与えた情報とコマンドライン、そして Distutils設定ファイルに基づいて .spec ファイルを作成します。 
.spec ファイルの様々なオプションやセクション情報は、以下のようにして setup スクリプトから取り出されます: 
RPM .spec ファイルのオプションまたはセクション 
Distutils setup スクリプト内のオプション 
Summary (preamble 内) 
author と author_email, または maintainer と maintainer_email 
%description (セクション) 
また、.spec ファイル内の多くのオプションは、 setup スクリプト中に対応するオプションがありません。 
これらのほとんどは、以下に示すbdist_rpm コマンドのオプションで扱えます: 
bdist_rpm オプション 
デフォルト値 
(上記参照) 
言うまでもなく、こうしたオプションをコマンドラインで指定するのは面倒だし、エラーの元になりますから、普通は setup.cfg に書いておくのがベストです --12 節を参照してください。 
沢山の Python モジュール配布物を配布したりパッケージ化したりしているのなら、配布物全部に当てはまるオプションを個人用の Distutils 設定ファイル (~/.pydistutils.cfg) に入れられます。 バイナリ形式の RPM パッケージを作成する際には三つの段階があり、Distutils はこれら全ての段階を自動的に処理します: 
RPM パッケージの内容を記述する .spec ファイルを作成します(.spec ファイルは setup スクリプトに似たファイルです; 実際、setup スクリプトのほとんどの情報が .spec ファイルから引き揚げられます) 
ソース RPM を作成します 
``バイナリ (binary)'' RPM を生成します (モジュール配布物にPython 拡張モジュールが入っているか否かで、バイナリコードが含まれることも含まれないこともあります) 
通常、RPM は最後の二つのステップをまとめて行います; Distutilsを使うと、普通は三つのステップ全てをまとめて行います。 望むなら、これらの三つのステップを分割できます。 
bdist_rpm コマンドに --spec-only を指定すれば、単に.spec を作成して終了します; この場合、.specファイルは ``配布物ディレクトリ (distribution directory)''--通常は dist/ に作成されますが、 --dist-dirオプションで変更することもできます。 
(通常、 .spec ファイルは``ビルドツリー (build tree)''、すなわち build_rpmが作成する一時ディレクトリの中から引き揚げられます。 ) 
1.2.2.2 クリエータをセットしてダブルクリックする 
1.2.2.1 ドラッグ&ドロップする 
1.2.2 Pythonスクリプトの走らせ方 
1.2.3 コマンドライン引数をシミュレートする 
スクリプトを、MacPython 配布物のMac フォルダ下の scriptsフォルダに置きます。 
修正したいスクリプトは全てひとつのフォルダに入れます。 
他のファイルは入れないようにします。 fixfiletypes.py アイコンをダブルクリックします。 
修正したいファイルの入ったフォルダを選んで``Select current folder''ボタンを押します。 
15. 暗号関連のサービス 
この章で記述されているモジュールでは、暗号の本質に関わる様々なアルゴリズムを実装しています。 
これらは必要に応じてインストールすることで使えます。 
概要を以下に示します: 
Python で実装された、メッセージ認証のための鍵付きハッシュ化 (HMAC: Keyed-Hashing for Message Authentication)アルゴリズム。 
NISTのセキュアハッシュアルゴリズム、SHA。 
あなたがハードコアなサイバーパンクなら、さらに A.M. Kuchling の書いた暗号化モジュールに興味を持つかもしれません。 このパッケージでは組み込みの DES および IDEA 暗号を追加し、PGP 暗号化されたファイルの読み込みや復号化を行うためのモジュールなどを提供します。 
これらのモジュールは Python と一緒には配布されず、別に入手できます。 
詳細は http://www.amk.ca/python/code/crypto.html を見てください。 
12.20.2 Dialect クラスと書式化パラメタ 
csv モジュールでは以下の関数を定義しています: 
与えられた csvfile 内の行を反復処理するような reader オブジェクトを返します。 csvfile はイテレータプロトコルをサポートし、next メソッドが呼ばれた際に常に文字列を返すような任意のオブジェクトにすることができます。 
csvfile がファイルオブジェクトの場合、ファイルオブジェクトの形式に違いがあるようなプラットフォームでは 'b' フラグを付けて開かなければなりません。 
オプションとして dialect パラメタを与えることができ、特定の CSV 表現形式 (dialect) 特有のパラメタの集合を定義するために使われます。 
dialect パラメタは Dialect クラスのサブクラスのインスタンスか、list_dialects 関数が返す文字列の一つにすることができます。 
別のオプションである fmtparam キーワード引数は、現在の表現形式における個々の書式パラメタを上書きするために与えることができます。 
表現形式および書式化パラメタの詳細については、12.20.2 節、 ``Dialect クラスと書式化パラメタ''を参照してください。 読み出されたデータは全て文字列として返されます。 
データ型の変換が自動的に行われることはありません。 
ユーザが与えたデータをデリミタで区切られた文字列に変換し、与えられたファイルオブジェクトにするための writer オブジェクトを返します。 csvfile は write メソッドを持つ任意のオブジェクトでかまいません。 
csvfile がファイルオブジェクトの場合、ファイルオブジェクトの形式に違いがあるようなプラットフォームでは 'b' フラグを付けて開かなければなりません。 
オプションとして dialect パラメタを与えることができ、特定の CSV 表現形式 (dialect) 特有のパラメタの集合を定義するために使われます。 
dialect パラメタは Dialect クラスのサブクラスのインスタンスか、list_dialects 関数が返す文字列の一つにすることができます。 
別のオプションである fmtparam キーワード引数は、現在の表現形式における個々の書式パラメタを上書きするために与えることができます。 
表現形式および書式化パラメタの詳細については、12.20.2 節、 ``Dialect クラスと書式化パラメタ''を参照してください。 
DB API を実装するモジュールとのインタフェースを可能な限り容易にするために、None は空文字列として書き込まれます。 
この処理は可逆な変換ではありませんが、SQL で NULL データ値をCSV にダンプする処理を、cursor.fetch*() 呼び出しによって返されたデータを前処理することなく簡単に行うことができます。 
他の非文字データは、書き出される前に str() を使って文字列に変換されます。 
dialect を name と関連付けます。 
dialect はcsv.Dialect のサブクラスでなければなりません。 name は文字列か Unicode オブジェクトでなければなりません。 
name に関連づけられた表現形式を表現形式レジストリから削除します。 
name が表現形式名でない場合には Error を送出します。 
name に関連づけられた表現形式を返します。 
name が表現形式名でない場合には Error を送出します。 
登録されている全ての表現形式を返します。 
csv モジュールでは以下のクラスを定義しています: 
クラスDictReader 
省略可能なfieldnames パラメタで与えられたキーを読み出された情報に対応付ける他は正規の reader のように動作するオブジェクトを生成します。 
fieldnamesパラメタが無い場合には、csvfileの最初の行の値がフィールド名として利用されます。 
読み出された行が fieldnames のシーケンスよりも多くのフィールドを持っていた場合、残りのフィールドデータは restkey の値をキーとするシーケンスに追加されます。 
読み出された行が fieldnames のシーケンスよりも少ないフィールドしか持たない場合、残りのキーはオプションのrestval パラメタに指定された値を取ります。 
その他の省略可能またはキーワード形式のパラメタはベースになっている reader のインスタンスに渡されます。 
クラスDictWriter 
辞書を出力行に対応付ける他は正規の writer のように動作するオブジェクトを生成します。 
fieldnames パラメタには、辞書中の writerow() メソッドに渡される値がどの順番でcsvfile に書き出されるかを指定します。 
オプションの restval パラメタは、fieldnames 内のキーが辞書中にない場合に書き出される値を指定します。 
writerow() メソッドに渡された辞書に、 fieldnames 内には存在しないキーが入っている場合、オプションの extraactionパラメタでどのような動作を行うかを指定します。 
この値が'raise' に設定されている場合 ValueError が送出されます。 
'ignore' に設定されている場合、辞書の余分の値は無視されます。 
Pythonのdictオブジェクトは整列されていないので、列がcsvfileに書かれるべき順序を推定するための十分な情報はありません。 
Dialect クラスはコンテナクラスで、基本的な用途としては、その属性を特定の reader や writer インスタンスのパラメタを定義するために用います。 
Sniffer クラスは CSV ファイルの書式を推理するために用いられるクラスです。 
Sniffer クラスではメソッドを一つ提供しています: 
与えられた sample を解析し、発見されたパラメタを反映した Dialect サブクラスを返します。 
オプションの delimiters パラメタを与えた場合、有効なデリミタ文字を含んでいるはずの文字列として解釈されます。 
(CSV 形式と仮定される) サンプルテキストを解析して、最初の行がカラムヘッダの羅列のように推察される場合 Trueを返します。 
csv モジュールでは以下の定数を定義しています: 
writer オブジェクトに対し、全てのフィールドをクオートするように指示します。 
writer オブジェクトに対し、現在の delimiter を含むか、あるいは quotechar で始まるフィールドだけをクオートするように指示します。 
writer オブジェクトに対し、全ての非数値フィールドをクオートするように指示します。 
writer オブジェクトに対し、フィールドを決してクオートしないように指示します。 
現在の delimiter が出力データ中に現れた場合、現在設定されている excapechar 文字が前に付けられます。 
QUOTE_NONE の効果下にある時には、1 文字からなる文字列escapechar が定義されていないと、たとえ書き出されるデータ中に delimiter 文字が入っていなくてもエラーになります。 
csv モジュールでは以下の例外を定義しています: 
全ての関数において、エラーが検出された際に送出される例外です。 
レコードに対する入出力形式の指定をより簡単にするために、特定の書式化パラメタは表現形式 (dialect) にまとめてグループ化されます。 
表現形式は Dialect クラスのサブクラスで、様々なクラス特有のメソッドと、validate() メソッドを一つ持っています。 
reader または writer オブジェクトを生成するとき、プログラマは文字列または Dialect クラスのサブクラスを表現形式パラメタとして渡さなければなりません。 
さらに、dialect パラメタの代りに、プログラマは上で定義されている属性と同じ名前を持つ個々の書式化パラメタを Dialect クラスに指定することができます。 Dialect は以下の属性をサポートしています: 
フィールド間を分割するのに用いられる 1 文字からなる文字列です。 
デフォルトでは ',' です。 
フィールド内に現れた quotechar のインスタンスで、クオートではないその文字自身でなければならない文字をどのようにクオートするかを制御します。 
True の場合、この文字は二重化されます。 False の場合、 escapechar は 1 文字からなる文字列でなければならず、quotechar の前に置かれます。 
デフォルトではTrue です。 
quoting が QUOTE_NONE に設定されている場合に、delimiter をエスケープするために用いられる、 1 文字からなる文字列です。 
デフォルトでは None です。 
CSV ファイルの各行を終端する際に用いられる文字列です。 
デフォルトでは 'rn' です。 
delimiter を含むか、quotechar から始まる要素をクオートする際に用いられる 1 文字からなる文字列です。 
デフォルトでは '"'です。 
writer によってクオートがいつ生成されるかを制御します。 
QUOTE_* 定数のいずれか (12.20.1 節参照) をとることができ、デフォルトではQUOTE_MINIMAL です。 
True の場合、delimiter の直後に続く空白は無視されます。 
デフォルトでは False です。 
curses モジュールでは以下の例外を定義しています: 
curses ライブラリ関数がエラーを返した際に送出される例外です。 
注意:関数やメソッドにおけるオプションの引数 x および y がある場合、標準の値は常に現在のカーソルになります。 オプションの attr がある場合、標準の値は A_NORMALです。 
curses では以下の関数を定義しています: 
端末の出力速度をビット/秒で返します。 
ソフトウェア端末エミュレータの場合、これは固定の高い値を持つことになります。 この関数は歴史的な理由で入れられています; かつては、この関数は時間遅延を生成するための出力ループを書くために用いられたり、行速度に応じてインタフェースを切り替えたりするために用いられたりしていました。 
注意を促す短い音を鳴らします。 
端末に表示される色をプログラマが変更できるか否かによって、真または偽を返します。 
cbreak モードに入ります。 
cbreak モード (``rare'' モードと呼ばれることもあります) では、通常の tty 行バッファリングはオフにされ、文字を一文字一文字読むことができます。 
ただし、raw モードとは異なり、特殊文字 (割り込み:interrupt、終了:quit、一時停止:suspend、およびフロー制御) については、tty ドライバおよび呼び出し側のプログラムに対する通常の効果をもっています。 
まず raw() を呼び出し、次いで cbreak() を呼び出すと、端末を cbreak モードにします。 
色 color_number の赤、緑、および青 (RGB) 要素の強度を返します。 
color_number は 0 から COLORS の間でなければなりません。 与えられた色の R、G、B、の値からなる三要素のタプルが返されます。 
この値は 0 (その成分はない) から 1000(その成分の最大強度) の範囲をとります。 color_pair 
指定された色の表示テキストにおける属性値を返します。 
属性値は A_STANDOUT、 A_REVERSE、およびその他の A_* 属性と組み合わせられています。 pair_number() はこの関数の逆です。 
カーソルの状態を設定します。 visibility は 0、1、または 2 に設定され、それぞれ不可視、通常、または非常に可視、を意味します。 
要求された可視属性を端末がサポートしている場合、以前のカーソル状態が返されます; そうでなければ例外が送出されます。 
多くの端末では、``可視 (通常)'' モードは下線カーソルで、``非常に可視'' モードはブロックカーソルです。 
現在の端末属性を、稼動中のプログラムが curses を使う際のモードである``プログラム'' モードとして保存します。 
(このモードの反対は、プログラムが curses を使わない ``シェル'' モードです。 
) その後reset_prog_mode() を呼ぶとこのモードを復旧します。 
現在の端末属性を、稼動中のプログラムが curses を使っていないときのモードである ``シェル'' モードとして保存します。 
(このモードの反対は、プログラムが curses 機能を利用している ``プログラム'' モードです。 
)その後 reset_shell_mode() を呼ぶとこのモードを復旧します。 delay_output 
出力に ms ミリ秒の一時停止を入れます。 
物理スクリーン (physical screen) を更新します。 
curses ライブラリは、現在の物理スクリーンの内容と、次の状態として要求されている仮想スクリーンをそれぞれ表す、2 つのデータ構造を保持しています。 
doupdate() は更新を適用し、物理スクリーンを仮想スクリーンに一致させます。 仮想スクリーンは addstr() のような書き込み操作をウィンドウに行った後に noutrefresh() を呼び出して更新することができます。 
通常の refresh() 呼び出しは、単に noutrefresh() を呼んだ後に doupdate() を呼ぶだけです; 複数のウィンドウを更新しなければならない場合、全てのウィンドウに対してnoutrefresh() を呼び出した後、一度だけ doupdate()を呼ぶことで、パフォーマンスを向上させることができ、おそらくスクリーンのちらつきも押さえることができます。 
echo モードに入ります。 
echo モードでは、各文字入力はスクリーン上に入力された通りにエコーバックされます。 
ライブラリの非初期化を行い、端末を通常の状態に戻します。 
ユーザの現在の消去文字 (erase character) 設定を返します。 
Unix オペレーティングシステムでは、この値は curses プログラムが制御している端末の属性であり、curses ライブラリ自体では設定されません。 
filter() ルーチンを使う場合、initscr() を呼ぶ前に呼び出さなくてはなりません。 
この手順のもたらす効果は以下の通りです: まず二つの関数の呼び出しの間は、LINES は 1 に設定されます;clear、cup、cud、cud1、cuu1、cuu、vpa は無効化されます; home 文字列は cr の値に設定されます。 これにより、カーソルは現在の行に制限されるので、スクリーンの更新も同様に制限されます。 
この関数は、スクリーンの他の部分に影響を及ぼさずに文字単位の行編集を行う場合に利用できます。 
スクリーンをフラッシュ(flash) します。 
すなわち、画面を色反転(reverse-video) にして、短時間でもとにもどします。 
人によっては、beep() で生成される可聴な注意音よりも、このような ``可視ベル(visible bell)'' を好みます。 
全ての入力バッファをフラッシュします。 
この関数は、ユーザによってすでに入力されているが、まだプログラムによって処理されていない全ての先行入力文字 (typeahead) を捨て去ります。 
イベントは (id, x, y, z, bstate) の5 要素のタプルで表現されています。 
仮想スクリーンにおける現在のカーソル位置を y および x の順で返します。 
leaveok が真に設定されていれば、 -1、-1 が返されます。 
以前の putwin() 呼び出しでファイルに保存されている、ウィンドウ関連データを読み出します。 
次に、このルーチンはそのデータを使って新たなウィンドウを生成し初期化して、その新規ウィンドウオブジェクトを返します。 
端末が色表示を行える場合には真を返します。 そうでない場合には偽を返します。 
端末が文字の挿入/削除機能を持つ場合に真を返します。 
この関数は、最近の端末エミュレータがどれもこの機能を持っているのと同じく、歴史的な理由だけのために含められています。 
端末が行の挿入/削除機能を持つか、領域単位のスクロールによって機能をシミュレートできる場合に真を返します。 
キー値 ch をとり、現在の端末タイプがその値のキーを認識できる場合に真を返します。 
半遅延モード、すなわち cbreak モードに似た、ユーザが打鍵した文字がすぐにプログラムで利用できるようになるモードで使われます。 しかしながら、何も入力されなかった場合、 tenths 十秒後に例外が送出されます。 
tenths の値は 1 から 255 の間でなければなりません。 
半遅延モードから抜けるには nocbreak() を使います。 
色の定義を変更します。 変更したい色番号と、その後に 3 つ組みのRGB 値 (赤、緑、青の成分の大きさ) をとります。 
color_numberの値は 0 から COLORS の間でなければなりません。 
r、g、b の値は 0 から 1000 の間でなければなりません。 
init_color() を使うと、スクリーン上でカラーが使用されている部分は全て新しい設定に即時変更されます。 
この関数はほとんどの端末で何も行いません;can_change_color() が 1 を返す場合にのみ動作します。 
色ペアの定義を変更します。 
3 つの引数: 変更したい色ペア、前景色の色番号、背景色の色番号、をとります。 
pair_number は1 から COLOR_PAIRS -1 の間でなければなりません(0 色ペアは黒色背景に白色前景となるように設定されており、変更することができません) 。 
fg および bg 引数は0 と COLORS の間でなければなりません。 
色ペアが以前に初期化されていれば、スクリーンを更新して、指定された色ペアの部分を新たな設定に変更します。 
ライブラリを初期化します。 
スクリーン全体をあらわす WindowObject を返します。 
注意:端末のオープン時にエラーが発生した場合、curses ライブラリによってインタープリタが終了される場合があります。 
endwin() がすでに呼び出されている (すなわち、curses ライブラリが非初期化されてしまっている) 場合に真を返します。 
k に番号付けされているキーの名前を返します。 
印字可能なASCII 文字を生成するキーの名前はそのキーの文字自体になります。 
コントロールキーと組み合わせたキーの名前は、キャレットの後に対応するASCII 文字が続く 2 文字の文字列になります。 
Alt キーと組み合わせたキー (128-255) の名前は、先頭に `M-' が付き、その後に対応するASCII 文字が続く文字列になります。 
ユーザの現在の行削除文字を返します。 
現在の端末について記述している terminfo の長形式 name フィールドが入った文字列を返します。 
verbose 形式記述の最大長は 128 文字です。 
この値は initscr() 呼び出しの後でのみ定義されています。 
yes が 1 の場合、8 ビット文字を入力として許します。 
yes が 0の場合、 7 ビット文字だけを許します。 
ボタンが押されてから離されるまでの時間をマウスクリック一回として認識する最大の時間間隔を設定します。 以前の内部設定値を返します。 
標準の値は 200 ミリ秒、または 5 分の 1 秒です。 
この関数が呼ばれない限り、マウスイベントは何も報告されません。 
ms ミリ秒スリープします。 
与えられた行とカラム数を持つパッド (pad) データ構造を生成し、そのポインタを返します。 
パッドはウィンドウオブジェクトとして返されます。 パッドはウィンドウと同じようなものですが、スクリーンのサイズによる制限をうけず、スクリーンの特定の部分に関連付けられていなくてもかまいません。 
大きなウィンドウが必要であり、スクリーンにはそのウィンドウの一部しか一度に表示しない場合に使えます。 
(スクロールや入力エコーなどによる) パッドに対する再描画は起こりません。 
パッドに対する refresh() および noutrefresh() メソッドは、パッド中の表示する部分と表示するために利用するスクリーン上の位置を指定する 6 つの引数が必要です。 これらの引数はpminrow、 pmincol、 sminrow、 smincol、 smaxrow、smaxcol です; p で始まる引数はパッド中の表示領域の左上位置で、s で始まる引数はパッド領域を表示するスクリーン上のクリップ矩形を指定します。 
左上の角が (begin_y, begin_x) で、高さ/幅がnlines/ncols の新規ウィンドウを返します。 
標準では、ウィンドウは指定された位置からスクリーンの右下まで広がります。 
newlime モードに入ります。 
このモードはリターンキーを入力中の改行として変換し、出力時に改行文字を復帰 (return) と改行 (line-feed) に変換します。 newline モードは初期化時にはオンになっています。 
cbreak モードから離れます。 
行バッファリングを行う通常の ``cooked'' モードに戻ります。 
echo モードから離れます。 
入力のエコーバックはオフにされます。 
newline モードから離れます。 
入力時のリターンキーから改行への変換、および出力時の改行から復帰/改行への低レベル変換を無効化します(ただし、addch('n') の振る舞いは変更せず、仮想スクリーン上では常に復帰と改行に等しくなります)。 
変換をオフにすることで、curses は水平方向の動きを少しだけ高速化できることがあります;また、入力中のリターンキーの検出ができるようになります。 
noquiflush ルーチンを使うと、通常行われている INTR、QUIT、およびSUSP 文字による入力および出力キューのフラッシュが行われなくなります。 
シグナルハンドラが終了した際、割り込みが発生しなかったかのように出力を続たい場合、ハンドラ中で noqiflush() を呼び出すことができます。 
raw モードから離れます。 
要求された色ペア中の色を含む (fg, bg) からなるタプルを返します。 
pair_number は 0 から 
COLOR_PAIRS - 1 の間でなければなりません。 
attr に対する色ペアセットの番号を返します。 color_pair() はこの関数の逆に相当します。 
tputs(str, 1, putchar) と等価です; 現在の端末における、指定された terminfo 機能の値を出力します。 
putp の出力は常に標準出力に送られるので注意して下さい。 
flag が偽なら、noqiflush() を呼ぶのとと同じ効果です。 
flag が真か、引数が与えられていない場合、制御文字が読み出された最にキューはフラッシュされます。 
raw モードに入ります。 
raw モードでは、通常の行バッファリングと割り込み (interrupt)、終了 (quit)、一時停止 (suspend)、およびフロー制御キーはオフになります; 文字は curses 入力関数に一文字づつ渡されます。 
端末を ``program'' モードに復旧し、予め def_prog_mode()で保存した内容に戻します。 
端末を ``shell'' モードに復旧し、予め def_shell_mode()で保存した内容に戻します。 
仮想スクリーンカーソルを y、x に設定します。 y および x が共に -1 の場合、leaveok が設定されます。 
端末を初期化します。 
termstr は文字列で、端末の名前を与えます;省略された場合、TERM 環境変数の値が使われます。 
fd は初期化シーケンスが送られる先のファイル記述子です; fdを与えない場合、sys.stdout のファイル記述子が使われます。 start_color 
プログラマがカラーを利用したい場合で、かつ他の何らかのカラー操作ルーチンを呼び出す前に呼び出さなくてはなりません。 
この関数は initscr() を呼んだ直後に呼ぶようにしておくとよいでしょう。 
start_color() は 8 つの基本色 (黒、赤、緑、黄、青、マゼンタ、シアン、および白) と、色数の最大値と端末がサポートする色ペアの最大数が入っている、curses モジュールにおける二つのグローバル変数、COLORS および COLOR_PAIRS を初期化します。 
この関数はまた、色設定を端末のスイッチが入れられたときの状態に戻します。 
端末がサポートする全てのビデオ属性を論理和した値を返します。 
この情報は、curses プログラムがスクリーンの見え方を完全に制御する必要がある場合に便利です。 
14 文字以下になるように切り詰められた環境変数 TERM の値を返します。 
terminfo 機能名 capname に対応する機能値をブール値で返します。 
capname がブール値で表される機能値でない場合 -1が返され、機能がキャンセルされているか、端末記述上に見つからない場合には 0 を返します。 
terminfo 機能名 capname に対応する機能値を数値で返します。 
capname が数値で表される機能値でない場合 -2が返され、機能がキャンセルされているか、端末記述上に見つからない場合には -1 を返します。 
terminfo 機能名 capname に対応する機能値を文字列値で返します。 
capname が文字列値で表される機能値でない場合や、機能がキャンセルされているか、端末記述上に見つからない場合には None を返します。 
str を与えられたパラメタを使って文字列にインスタンス化します。 
str は terminfo データベースから得られたパラメタを持つ文字列でなければなりません。 
例えば、tparm(tigetstr("cup"), 5, 3) は '033[6;4H' のようになります。 厳密には端末の形式によって異なる結果となります。 
先読みチェックに使うためのファイル記述子 fd を指定します。 
fd が -1 の場合、先読みチェックは行われません。 curses ライブラリはスクリーンを更新する間、先読み文字列を定期的に検索することで ``行はみ出し最適化 (line-breakout optimization)''を行います。 
入力が得られ、かつ入力は端末からのものである場合、現在行おうとしている更新は refresh や doupdate を再度呼び出すまで先送りにします。 
この関数は異なるファイル記述子で先読みチェックを行うように指定することができます。 
ch の印字可能な表現を文字列で返します。 
制御文字は例えば^C のようにキャレットに続く文字として表示されます。 
印字可能文字はそのままです。 
ch をプッシュして、 getch() を次に呼び出したときに返されるようにします。 
注意: getch() を呼び出すまではch は一つしかプッシュできません。 
与えられた状態データが関連付けられた KEY_MOUSE イベントを入力キューにプッシュします。 
この関数を使う場合、initscr() または newterm を呼ぶ前に呼び出さなくてはなりません。 
flag が偽の場合、環境変数LINES および COLUMNS の値 (これらは標準の設定で使われます) の値が設定されていたり、curses がウィンドウ内で動作して (この場合 LINES や COLUMNS が設定されていないとウィンドウのサイズを使います) いても、terminfo データベースに指定された lines および columns の値を使います。 
この機能をサポートしている端末上で、色の値としてデフォルト値を使う設定をします。 
あなたのアプリケーションで透過性とサポートするためにこの関数を使ってください。 
デフォルトの色は 色番号-1に割り当てられます。 この関数を呼んだ後、たとえば init_pair(x, curses.COLOR_RED, -1)は色ペアxを赤い前景色とデフォルトの背景色に初期化します。 
上記の new_panel() が返す Panel オブジェクトはスタック順の概念を持つウィンドウです。 
ウィンドウはパネルに関連付けられており、表示する内容を決定している一方、パネルのメソッドはパネルスタック中のウィンドウの深さ管理を担います。 Panel オブジェクトは以下のメソッドを持っています: 
現在のパネルの上にあるパネルを返します。 
現在のパネルの下にあるパネルを返します。 
パネルをスタックの最下層にプッシュします。 
パネルが隠れている (不可視である) 場合に真を返し、そうでない場合偽を返します。 
パネルを隠します。 
この操作ではオブジェクトは消去されず、スクリーン上のウィンドウを不可視にするだけです。 
パネルをスクリーン座標 (y, x) に移動します。 
パネルに関連付けられたウィンドウを win に変更します。 
パネルのユーザポインタを obj に設定します。 
このメソッドは任意のデータをパネルに関連付けるために使われ、任意の Python オブジェクトにすることができます。 
(隠れているはずの) パネルを表示します。 
パネルをスタックの最上層にプッシュします。 
パネルのユーザポインタを返します。 
任意の Python オブジェクトです。 
パネルに関連付けられているウィンドウオブジェクトを返します。 
6.16.1 Textbox オブジェクト 
以下のような Textbox オブジェクトをインスタンス生成することができます: 
クラスTextbox 
テキストボックスウィジェットオブジェクトを返します。 
Textbox オブジェクトは以下のメソッドを持ちます: 
普段使うことになるエントリポイントです。 
終了キーストロークの一つが入力されるまで編集キーストロークを受け付けます。 
validatorを与える場合、関数でなければなりません。 
validator はキーストロークが入力されるたびにそのキーストロークが引数となって呼び出されます; 返された値に対して、コマンドキーストロークとして解釈が行われます。 
このメソッドはウィンドウの内容を文字列として返します;ウィンドウ内の空白が含められるかどうかは stripspaces メンバで決められます。 
単一のコマンドキーストロークを処理します。 
以下にサポートされている特殊キーストロークを示します: 
キーストローク 
動作 
ウィンドウの左端に移動します。 
カーソルを左へ移動し、必要なら前の行に折り返します。 
カーソル下の文字を削除します。 
右端 (stripspaces がオフのとき) または行末 (stripspaces がオンのとき) に移動します。 
カーソルを右に移動し、必要なら次の行に折り返します。 
ウィンドウを終了し、その内容を返します。 
逆方向に文字を削除します。 
(バックスペース) Control-J 
ウィンドウが 1 行であれば終了し、そうでなければ新しい行を挿入します。 
行が空白行ならその行全体を削除し、そうでなければカーソル以降行末までを消去します。 
スクリーンを更新します。 
カーソルを下に移動します; 1 行下に移動します。 
カーソルの場所に空行を 1 行挿入します。 
カーソルを上に移動します; 1 行上に移動します。 
移動操作は、カーソルがウィンドウの縁にあって移動ができない場合には何も行いません。 
場合によっては、以下のような同義のキーストロークがサポートされています: 
定数 
他のキーストロークは、与えられた文字を挿入し、(行折り返し付きで)右に移動するコマンドとして扱われます。 
このメソッドはウィンドウの内容を文字列として返します; ウィンドウ内の空白が含められるかどうかは stripspaces メンバ変数で決められます。 
このデータメンバはウィンドウ内の空白領域の解釈方法を制御するためのフラグです。 
フラグがオンに設定されている場合、各行の末端にある空白領域は無視されます; すなわち、末端空白領域にカーソルが入ると、その場所の代わりに行の末尾にカーソルが移動します。 また、末端の空白領域はウィンドウの内容を取得する際に剥ぎ取られます。 
6.15.3 定数 
上記の initscr() や newwin() が返すウィンドウは、以下のメソッドを持ちます: 
(y, x) にある文字 ch を属性 attrで描画します。 このときその場所に以前描画された文字は上書きされます。 
標準の設定では、文字の位置および属性はウィンドウオブジェクトにおける現在の設定になります。 
文字列 str から最大で n 文字を (y, x) に属性 attr で描画します。 以前ディスプレイにあった内容はすべて上書きされます。 
(y, x) に文字列 str を属性 attr で描画します。 以前ディスプレイにあった内容はすべて上書きされます。 
現在のウィンドウに書き込まれた全ての内容に対し ``バックグラウンド'' に設定された属性 attr を除去します。 
現在のウィンドウに書き込まれた全ての内容に対し ``バックグラウンド'' に属性 attr を追加します。 
``バックグラウンド'' の属性セットを attr に設定します。 
初期値は 0 (属性なし) です。 
ウィンドウ上の背景プロパティを、 attr を属性とする文字 ch に設定します。 
変更はそのウィンドウ中の全ての文字に以下のようにして適用されます: 
ウィンドウ中の全ての文字の属性が新たな背景属性に変更されます。 
以前の背景文字が出現すると、常に新たな背景文字に変更されます。 
ウィンドウの背景を設定します。 
ウィンドウの背景は、文字と何らかの属性の組み合わせから成り立ちます。 
背景情報の属性の部分は、ウィンドウ上に描画されている空白でない全ての文字と組み合わされ(OR され) ます。 
空白文字には文字部分と属性部分の両方が組み合わされます。 
背景は文字のプロパティとなり、スクロールや行/文字の挿入/削除操作の際には文字と一緒に移動します。 
ウィンドウの縁に境界線を描画します。 
各引数には境界の特定部分を表現するために使われる文字を指定します; 詳細は以下のテーブルを参照してください。 
文字は整数または 1 文字からなる文字列で指定されます。 
注意:どの引数も、0 を指定した場合標準設定の文字が使われるようになります。 
キーワード引数は使うことが できません。 
標準の設定はテーブル中に示されています: 
引数 
記述 
標準の設定値 
左側 
右側 
上側 
下側 
左上の角 
右上の角 
左下の角 
右下の角 
border() と同様ですが、ls および rs は共に vertch で、ts および bs は共に horchです。 
この関数では、角に使われる文字は常に標準設定の値です。 
erase() に似ていますが、次に refresh() が呼び出された際に全てのウィンドウを再描画するようにします。 
yes が 1 ならば、次の refresh() はウィンドウを完全に消去します。 
カーソルの位置からウィンドウの端までを消去します: カーソル以降の全ての行が削除されるため、 clrtoeol() が実行されたのとおなじになります。 
カーソル位置から行末までを消去します。 
ウィンドウの全ての親ウィンドウについて、現在のカーソル位置を反映するよう更新します。 
(y, x) にある文字を削除します。 
カーソルの下にある行を削除します。 
後続の行はすべて 1 行上に移動します。 
``derive window (ウィンドウを導出する)'' の短縮形です。 
derwin() は subwin() と同じですが、begin_y および begin+x はスクリーン全体の原点ではなく、ウィンドウの原点からの相対位置です。 
導出されたウィンドウオブジェクトが返されます。 
文字 ch に属性 attr を付与し、即座に refresh()をウィンドウに対して呼び出します。 
与えられた文字セル座標をスクリーン原点から相対的なものとし、ウィンドウの中に含まれるかを調べて、真または偽を返します。 
スクリーン上のウィンドウの一部がマウスイベントの発生場所を含むかどうかを調べる上で便利です。 
ウィンドウをクリアします。 
左上の角の座標をあらわすタプル (y, x) を返します。 
文字を取得します。 
返される整数は ASCII の範囲の値となるわけではない ので注意してください: ファンクションキー、キーパッド上のキー等は 256 よりも大きな数字を返します。 
無遅延(no-delay) モードでは、入力がない場合 -1 が返されます。 
文字を取得し、 getch() のように整数を返す代わりに文字列を返します。 
ファンクションキー、キーバットキーなどはキー名の入った複数バイトからなる文字列を返します。 
無遅延モードでは、入力がない場合例外が送出されます。 
ウィンドウの高さおよび幅を表すタプル (y, x) を返します。 
親ウィンドウ中におけるウィンドウの開始位置を x と y の二つの整数で返します。 
ウィンドウに親ウィンドウがない場合-1,-1 を返します。 
原始的な文字編集機能つきで、ユーザの入力文字列を読み取ります。 
ウィンドウの左上角からの相対で表した現在のカーソル位置をタプル(y, x) で返します。 
(y, x) から始まり、 n の長さを持つ、文字 ch で作られる水平線を表示します。 
flag が偽の場合、curses は端末のハードウェアによる文字挿入/削除機能を使おうとしなくなります; flag が真ならば、文字挿入/削除は有効にされます。 
curses が最初に初期化された際には文字挿入/削除は標準の設定で有効になっています。 
yes が 1 であれば、curses はハードウェアの行編集機能を利用しようと試みます。 
行挿入/削除は無効化されます。 
flag が真ならば、ウィンドウイメージ内における何らかの変更があるとウィンドウを更新するようになります; すなわち、refresh()を自分で呼ばなくても良くなります。 
とはいえ、wrefresh を繰り返し呼び出すことになるため、この操作はかなりパフォーマンスを低下させます。 
標準の設定では無効になっています。 
ウィンドウの指定の位置の文字を返します。 
下位 8 ビットが常に文字となり、それより上のビットは属性を表します。 
(y, x) に文字 ch を属性 attr で描画し、行の x からの内容を 1 文字分右にずらします。 
nlines 行を指定されたウィンドウの現在の行の上に挿入します。 
その下にある nlines 行は失われます。 
負の nlines を指定すると、カーソルのある行以降の nlines を削除し、削除された行の後ろに続く内容が上に来ます。 
その下にある nlines は消去されます。 
現在のカーソル位置はそのままです。 
カーソルの下に空行を 1 行入れます。 
それ以降の行は 1 行づつ下に移動します。 
文字列をカーソルの下にある文字の前に (一行に収まるだけ) 最大 n 文字挿入します。 
n がゼロまたは負の値の場合、文字列全体が挿入されます。 カーソルの右にある全ての文字は右に移動し、行の左端にある文字は失われます。 
カーソル位置は (y、 x が指定されていた場合はそこに移動しますが、その後は) 変化しません。 
キャラクタ文字列を (行に収まるだけ) カーソルより前に挿入します。 
カーソルの右側にある文字は全て右にシフトし、行の右端の文字は失われます。 
現在のカーソル位置、または y, x が指定されている場合にはその場所から始まるキャラクタ文字列をウィンドウから抽出して返します。 
属性は文字から剥ぎ取られます。 
n が指定された場合、instr()は (末尾の NUL 文字を除いて) 最大で n 文字までの長さからなる文字列を返します。 is_linetouched 
指定した行が、最後に refresh() を呼んだ時から変更されている場合に真を返します; そうでない場合には偽を返します。 
line が現在のウィンドウ上の有効な行でない場合、curses.error 例外を送出します。 
指定したウィンドウが、最後に refresh() を呼んだ時から変更されている場合に真を返します; そうでない場合には偽を返します。 
yes が 1 の場合、ある種のキー (キーパッドやファンクションキー)によって生成されたエスケープシーケンスは curses で解釈されます。 yes が 0 の場合、エスケープシーケンスは入力ストリームにそのままの状態で残されます。 
yes が 0 の場合、カーソルは更新の際に常に ``カーソル位置''に移動します。 
カーソルを (new_y, new_x) に移動します。 
ウィンドウを親ウィンドウの中で移動します。 
ウィンドウのスクリーン相対となるパラメタ群は変化しません。 
このルーチンは親ウィンドウの一部をスクリーン上の同じ物理位置に表示する際に用いられます。 
ウィンドウの左上角が (new_y, new_x)になるように移動します。 
yes が 1 の場合、getch() は非ブロックで動作します。 
yes が 1 の場合、エスケープシーケンスはタイムアウトしなくなります。 yes が 0 の場合、数ミリ秒間の間エスケープシーケンスは解釈されず、入力ストリーム中にそのままの状態で残されます。 
更新をマークはしますが待機します。 
この関数はウィンドウのデータ構造を表現したい内容を反映するように更新しますが、物理スクリーン上に反映させるための強制更新を行いません。 
更新を行うためにはdoupdate() を呼び出します。 
ウィンドウを destwin の上に重ね書き (overlay) します。 
ウィンドウは同じサイズである必要はなく、重なっている領域だけが複写されます。 
destwin の上にウィンドウの内容を上書き (overwrite) します。 
ウィンドウは同じサイズである必要はなく、重なっている領域だけが複写されます。 
ウィンドウに関連付けられている全てのデータを与えられたファイルオブジェクトに書き込みます。 
この情報は後に getwin() 関数を使って取得することができます。 
beg 行から始まる num スクリーン行の表示内容が壊れており、次の refresh() 呼び出しで完全に再描画されなければならないことを通知します。 
ウィンドウ全体を更新 (touch) し、次の refresh() 呼び出しで完全に再描画されるようにします。 
ディスプレイを即時更新し (現実のウィンドウとこれまでの描画/削除メソッドの内容との同期をとり) ます。 6 つのオプション引数はウィンドウが newpad() で生成された場合にのみ指定することができます。 
追加の引数はパッドやスクリーンのどの部分が含まれるのかを示すために必要です。 
pminrow および pmincol にはパッドが表示されている矩形の左上角を指定します。 sminrow, smincol, smaxrow, および smaxcol には、スクリーン上に表示される矩形の縁を指定します。 
パッド内に表示される矩形の右下角はスクリーン座標から計算されるので、矩形は同じサイズでなければなりません。 
矩形は両方とも、それぞれのウィンドウ構造内に完全に含まれていなければなりません。 
pminrow, pmincol, sminrow, または smincol に負の値を指定すると、ゼロを指定したものとして扱われます。 
スクリーンまたはスクロール領域を上に lines 行スクロールします。 
ウィンドウのカーソルが、最下行で改行を行ったり最後の文字を入力したりした結果、ウィンドウやスクロール領域の縁からはみ出して移動した際の動作を制御します。 
flag が偽の場合、カーソルは最下行にそのままにしておかれます。 
flag が真の場合、ウィンドウは 1 行上にスクロールします。 
端末の物理スクロール効果を得るためにはidlok() も呼び出す必要があるので注意してください。 
スクロール領域を top から bottom に設定します。 
スクロール動作は全てこの領域で行われます。 
A_STANDOUT 属性をオフにします。 
端末によっては、この操作で全ての属性をオフにする副作用が発生します。 
A_STANDOUT 属性をオンにします。 
左上の角が (begin_y, begin_x) にあり、幅/高さがそれぞれ ncols/nlines であるようなサブウィンドウを返します。 
左上の角が (begin_y, begin_x) にあり、幅/高さがそれぞれ ncols/nlines であるようなサブウィンドウを返します。 
標準の設定では、サブウィンドウは指定された場所からウィンドウの右下角まで広がります。 
このウィンドウの上位のウィンドウのいずれかで更新(touch)された各場所をこのウィンドウ内でも更新します。 
このルーチンは refresh() から呼び出されるので、手動で呼び出す必要はほとんどないはずです。 
flag を真にして呼び出すと、ウィンドウが変更された際は常にsyncup() を自動的に呼ぶようになります。 
ウィンドウ内で更新 (touch) した場所を、上位の全てのウィンドウ内でも更新します。 
ウィンドウのブロックまたは非ブロック読み込み動作を設定します。 
delay が負の場合、ブロック読み出しが使われ、入力を無期限で待ち受けます。 
delay がゼロの場合、非ブロック読み出しが使われ、 入力待ちの文字がない場合 getch() は -1 を返します。 
delay が正の値であれば、 getch() はdelay ミリ秒間ブロックし、ブロック後の時点で入力がない場合には-1 を返します。 
start から始まる count 行が変更されたかのように振舞わせます。 
描画を最適化するために、全てのウィンドウが変更されたかのように振舞わせます。 
ウィンドウ内の全ての行を、最後に refresh() を呼んだ際から変更されていないものとしてマークします。 
(y, x) から始まり、 n の長さを持つ、文字 ch で作られる垂直線を表示します。 
curses.panel では以下の関数を定義しています: 
パネルスタックの最下層のパネルを返します。 
与えられたウィンドウ win に関連付けられたパネルオブジェクトを返します。 
パネルスタックの最上層のパネルを返します。 
仮想スクリーンをパネルスタック変更後の状態に更新します。 
この関数ではcurses.doupdate() を呼ばないので、ユーザは自分で呼び出す必要があります。 
インスタンスが生成された際に呼び出されるコンストラクタ (constructor)です。 
引数はそのクラスのコンストラクタ式に渡した引数になります。 
基底クラスが__init__() メソッドを持っている場合、導出クラスの __init__() メソッドでは、例えば "BaseClass.__init__(self, [args...])" のように、必要ならば明示的に基底クラスの__init__() メソッドを呼び出して、インスタンスの基底クラスに関わる部分が正しく初期化されるようにしなければなりません。 
コンストラクタには、値を返してはならないという特殊な制限があります; 値を返すようにすると、実行時にTypeError の送出を引き起こします。 
インスタンスが消滅させられる際に呼び出されます。 
このメソッドはデストラクタ (destructor) 
とも呼ばれます。 
基底クラスが__del__() メソッドを持っている場合、導出クラスの __del__() メソッドでは、必要ならば明示的に基底クラスの__del__() メソッドを呼び出して、インスタンスの基底クラスに関わる部分が正しく消滅処理されるようにしなければなりません。 
__del__() メソッドでインスタンスに対する新たな参照を作ることで、インスタンスの消滅を遅らせることができます (とはいえ、推奨しません!)。 
このようにすると、新たに作成された参照がその後削除された際にもう一度 __del__() メソッドが呼び出されます。 
インタプリタが終了する際に残っているオブジェクトに対して、__del__() メソッドが呼び出される保証はありません。 
注意:"del x" は直接 x.__del__() を呼び出しません -- 前者は x への参照カウント (reference count) を 1 つ減らし、後者は x への参照カウントがゼロになった際にのみ呼び出されます。 
ごみオブジェクトと化した循環参照は、オプションの循環参照検出機構 (cycle detector) が有効にされている場合 (これはデフォルトの設定です) には検出されますが、検出された循環参照を消去するのは Python レベルで__del__() メソッドが定義されていない場合だけです。 
__del__() メソッドが循環参照検出機構でどのように扱われるか、とりわけ garbage 値の記述に関しては、 
また、(例えばプログラムの実行終了による) モジュールの削除に伴って__del__() が呼び出される際には、__del__() メソッドが参照している他のグローバル変数はすでに削除されているかもしれません。 
この理由から、 __del__() メソッドでは外部の不変関係を維持する上で絶対最低限必要なことだけをすべきです。 
バージョン 1.5 からは、単一のアンダースコアで始まるようなグローバル変数は、他のグローバル変数が削除される前にモジュールから削除されるように Python 側で保証しています; これらのアンダースコア付きグローバル変数は、__del__() が呼び出された際に、import されたモジュールがまだ残っているか確認する上で役に立ちます。 
組み込み関数repr() 
や、文字列への変換 (逆クオート表記: reverse quote) の際に呼び出され、オブジェクトを表す ``公式の (official)'' 文字列を計算します。 
可能な場合には、この値は同じ値を持ったオブジェクトを(適切な環境で) 再生成するために使えるような有効な Python 式に似せるべきです。 
それが不可能なら、"...some usefuldescription..." 形式の文字列を返してください。 
戻り値は文字列オブジェクトでなければなりません。 クラスが __repr__() を定義しているが __str__()を定義していない場合、そのクラスのインスタンスに対する``非公式の (informal)'' 文字列表現が必要なときにも__repr__() が使われます。 
この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。 
組み込み関数 str() 
およびprint 
文によって呼び出され、オブジェクトを表す ``非公式の'' 文字列を計算します。 
このメソッドは、有効な Python 式を返さなくても良いという点で、__repr__() と異なります: その代わり、より便利で分かりやすい表現を返すようにしてください。 
戻り値は文字列オブジェクトでなければなりません。 
は x.__lt__(y) を呼び出します; 
は 
x.__le__(y) を呼び出します; 
は 
x.__eq__(y) を呼び出します; 
は x.__gt__(y) を呼び出します; 
x.__ge__(y) を呼び出します。 
すなわち、 x==y 
が真である場合、暗黙のうちに 
が偽になるわけではありません。 
与えられた引数ペアの間で演算が実装されていない場合、拡張比較メソッドは NotImplemented を返します。 
拡張比較 (上参照) が定義されていない場合、比較演算によって呼び出されます。 
self other である場合には負の値、self == other ならばゼロ、self other であれば正の値を返さなければなりません。 
演算 __cmp__() 、__eq__() および __ne__() がいずれも定義されていない場合、クラスインスタンスはオブジェクトのアイデンティティ (``アドレス'')で比較されます。 
自作の比較演算をサポートするオブジェクトや、辞書のキーとして使えるオブジェクトを生成するには、__hash__() に関する記述を参照してください。 (注意: __cmp__() が例外を伝播しないという制限はPython 1.5 から除去されました。 
バージョン 2.1 で 変更 された仕様:もはやサポートされていません 
辞書演算におけるハッシュ値として利用できる、32 ビットの整数を返さなければなりません。 
このメソッドに必要な性質は、比較結果が等価であるオブジェクトは同じハッシュ値をもつということです; オブジェクト間で比較を行う際には、オブジェクトの各要素に対するハッシュ値を (排他的論理和をとるなどして) 何らかの方法で混合するよう勧めます。 
クラスが __cmp__() メソッドを定義していない場合、__hash__() メソッドも定義してはなりません; クラスが__cmp__() または __eq__() を定義しているが、__hash__() を定義していない場合、インスタンスを辞書のキーとして使うことはできません。 クラスが変更可能なオブジェクトを定義しており、__cmp__() または __eq__() メソッドを実装している場合、__hash__()を定義してはなりません。 
これは、辞書の実装においてハッシュ値が変更不能であることが要求されているからです (オブジェクトのハッシュ値が変化すると、キーが誤ったハッシュバケツ: hash bucket に入っていることになってしまいます)。 
真値テストや組み込み演算 bool() を実現するために呼び出されます; False または True か、等価な整数値0 または 1 を返さなければなりません。 このメソッドが定義されていない場合、__len__() (下記参照)が定義されていれば呼び出されます。 
__len__() と__nonzero__() のどちらもクラスで定義されていない場合、そのクラスのインスタンスはすべて真の値を持つものとみなされます。 
組み込み関数 unicode() を実現するために呼び出されます。 
Unicode オブジェクトを返さなければなりません。 
このメソッドが定義されていなければ、文字列への変換が試みられ、その結果がデフォルトの文字エンコードを用いてUnicode に変換されます。 
7.3 Cygwin での作業 多くのパッケージは Cygwin 環境下でのインストールが難しいために、Cygwin 用に必要なツールの Cygwin 環境下でのインストールは少し厄介です。 
Cygwin インストーラを使って、 Cygwin のインストールによって Perl、Python、そして TeX パッケージが入っていることを確認してください。 
Perl と Python はインストーラの Interpreters セクションの下に配置されています。 TeX パッケージは Textセクションの下です; tetex-beta、texmkf、texmf-base、および texmf-extra をインストールすると、必要な全てのパッケージを利用できるようになります。 
説明に従ってインストールしてください。 
LaTeX2HTML はソースアーカイブからのインストールもできますが、配布物中のあるファイルをいじってからでないとできません。 
展開した配布物のトップレベルにある L2hos.pm を編集してください;ファイルの末尾近くにある、$^O というテキストを'unix' に変更してください。 
以下のコマンドを使ってソフトウェアをビルドしてインストールします: 
これで少なくとも DVI、HTML、PDF、および PostScript 形式版のフォーマット済みドキュメントをビルドできます。 
3.1 オブジェクト、値、および型 
3.3.2.1 新しい形式のクラスのための別の属性アクセス 
date オブジェクトは日付 (年、月、および日) を表します。 日付は理想的なカレンダー、すなわち現在のグレゴリオ暦を過去と未来の両方向に無限に延長したもので表されます。 
1 年の 1 月 1 日は日番号 1、1 年 1 月 2 日は日番号 2、となっていきます。 
この暦法は、全ての計算における基本カレンダーである、Dershowitz と Reingold の書籍 Calendrical Calculationsにおける "予期的グレゴリオ (proleptic Gregorian)" 暦の定義に一致します。 
クラスdate 
全ての引数が必要です。 
引数は整数でも長整数でもよく、以下の範囲に入らなければなりません: 
1 = day = 指定された月と年における日数 
範囲を超えた引数を与えた場合、ValueError が送出されます。 
他のコンストラクタ、および全てのクラスメソッドを以下に示します: 
現在のローカルな日付を返します。 
date.fromtimestamp(time.time()) と等価です。 
time.time() が返すような POSIX タイムスタンプに対応する、ローカルな日付を返します。 
タイムスタンプがプラットフォームにおける C 関数 localtime()でサポートされている範囲を超えている場合には ValueErrorを送出することがあります。 
この値はよく 1970 年から 2038 年に制限されていることがあります。 
うるう秒がタイムスタンプの概念に含まれている非 POSIX システムでは、fromtimestamp() はうるう秒を無視します。 
予期的グレゴリオ暦順序に対応する日付を表し、1 年 1 月 1 日が序数 1 となります。 
1 = ordinal = date.max.toordinal()でない場合、ValueError が送出されます。 
任意の日付 d に対し、date.fromordinal(d.toordinal()) == d となります。 
以下にクラス属性を示します: 
表現できる最も古い日付で、date(MINYEAR, 1, 1) です。 
表現できる最も新しい日付で、 date(MAXYEAR, 12, 31) です。 
等しくない日付オブジェクト間の最小の差で、 timedelta(days=1)です。 
以下に (読み出し専用の) インスタンス属性を示します: 
両端値を含む MINYEAR から MAXYEAR までの値です。 
両端値を含む 1 から 12 までの値です。 
1 から与えられた月と年における日数までの値です。 
サポートされている操作を以下に示します: 
date2 はから date1 から 
timedelta.days 日移動した日付です。 (1) 
date1 が時刻として date2 よりも前を表す場合に、date1 はdate2 よりも小さいと見なされます。 
date2 は timedelta.days 0 の場合進む方向に、 
timedelta.days 0 の場合戻る方向に移動します。 
演算後は、 
date2 - date1 == timedelta.daysとなります。 
timedelta.seconds および 
timedelta.microseconds は無視されます。 
date2.year が MINYEAR になってしまったり、MAXYEAR より大きくなってしまう場合にはOverflowError が送出されます。 
この操作は date1 + (-timedelta) と等価ではありません。 なぜならば、date1 - timedeltaがオーバフローしない場合でも、-timedelta 単体がオーバフローする可能性があるからです。 
timedelta.seconds および 
timedelta.microseconds は無視されます。 
この演算は厳密で、オーバフローしません。 timedelta.secondsおよび timedelta.microseconds は 0 で、演算後にはdate2 + timedelta == date1 となります。 
別の言い方をすると、 date1.toordinal() date2.toordinal()であり、かつそのときに限り date1 date2 となります。 
型混合の比較がデフォルトのオブジェクトアドレス比較となってしまうのを抑止するために、timedelta オブジェクトと異なる型のオブジェクトが比較されると TypeError が送出されます。 
しかしながら、被比較演算子のもう一方が timetuple 属性を持つ場合には NotImplemented が返されます。 
このフックにより、他種の日付オブジェクトに型混合比較を実装するチャンスを与えています。 そうでない場合、timedelta オブジェクトと異なる型のオブジェクトが比較されると、比較演算子が == または !=でないかぎり TypeError が送出されます。 
後者の場合、それぞれ False または Trueを返します。 
date オブジェクトは辞書のキーとして用いることができます。 
ブール演算コンテキストでは、全ての date オブジェクトは真であるとみなされます。 以下にインスタンスメソッドを示します: 
キーワード引数で指定されたデータメンバが置き換えられることを除き、同じ値を持つ date オブジェクトを返します。 
例えば、d == date(2002, 12, 31) とすると、d.replace(day=26) == date(2002, 12, 26) となります。 
時間、分、および秒は 0 で、DST フラグは -1 になります。 
d.timetuple() はtime.struct_time((d.year, d.month, d.day,0, 0, 0, d.weekday(), d.toordinal() - date(d.year, 1, 1).toordinal() + 1,-1))と等価です。 
予測的グレゴリオ暦における日付序数を返します。 1 年の 1 月 1 日が序数 1 となります。 
任意の date オブジェクト d について、date.fromordinal(d.toordinal()) == d 
となります。 
月曜日を 0、日曜日を 6 として、曜日を整数で返します。 
例えば、 date(2002, 12, 4).weekday() == 2であり、水曜日を示します。 
isoweekday() も参照してください。 
月曜日を 1、日曜日を 7 として、曜日を整数で返します。 
例えば、 date(2002, 12, 4).weekday() == 3であり、水曜日を示します。 
weekday()、isocalendar() も参照してください。 
細かい説明についてはhttp://www.phys.uu.nl/~vgent/calendar/isocalendar.htmを参照してください。 
ISO 年は完全な週が 52 または 53 週あり、週は月曜から始まって日曜に終わります。 ISO 年でのある年における最初の週は、その年の木曜日を含む最初の (グレゴリオ暦での) 週となります。 
この週は週番号 1 と呼ばれ、この木曜日での ISO 年はグレゴリオ暦における年と等しくなります。 
例えば、2004 年は木曜日から始まるため、ISO 年の最初の週は2003 年 12 月 29 日、月曜日から始まり、2004 年 1 月 4 日、日曜日に終わります。 
従って、date(2003, 12, 29).isocalendar() == (2004, 1, 1)であり、かつdate(2004, 1, 4).isocalendar() == (2004, 1, 7)となります。 
ISO 8601 形式、'YYYY-MM-DD' の日付を表す文字列を返します。 
例えば、date(2002, 12, 4).isoformat() == '2002-12-04'となります。 
date オブジェクト d において、str(d) は 
d.isoformat() と等価です。 
日付を表す文字列を、例えばdate(2002, 12, 4).ctime() == 'Wed Dec 4 00:00:00 2002'のようにして返します。 
ネイティブの C 関数 ctime() (time.ctime() はこの関数を呼び出しますが、date.ctime() は呼び出しません) が C 標準に準拠しているプラットフォームでは、 d.ctime() はtime.ctime(time.mktime(d.timetuple()))と等価です。 
明示的な書式化文字列で制御された、日付を表現する文字列を返します。 
時間、分、秒を表す書式化コードは値 0 になります。 strftime() のふるまいについてのセクションを参照してください。 
datetime オブジェクトは date オブジェクトおよびtime オブジェクトの全ての情報が入っている単一のオブジェクトです。 
date オブジェクトと同様に、datetime は現在のグレゴリオ暦が両方向に延長されているものと仮定します;また、time オブジェクトと同様に、datetime は毎日が厳密に 3600*24 秒であると仮定します。 
以下にコンストラクタを示します: クラスdatetime 
年、月、および日の引数は必須です。 tzinfo はNone または tzinfo クラスのサブクラスのインスタンスにすることができます。 
残りの引数は整数または長整数で、以下のような範囲に入ります: 
1 = day = 与えられた年と月における日数 
引数がこれらの範囲外にある場合、ValueError が送出されます。 
その他のコンストラクタ、およびクラスメソッドを以下に示します: 
現在のローカルな datetime を tzinfo が Noneであるものとして返します。 
これはdatetime.fromtimestamp(time.time()) と等価です。 now()、 fromtimestamp() も参照してください。 
現在のローカルな日付および時刻を返します。 
オプションの引数tz が None であるか指定されていない場合、このメソッドは today() と同様ですが、可能ならばtime.time() タイムスタンプを通じて得ることができるより高い精度で時刻を提供します (例えば、プラットフォームが C 関数 gettimeofday() をサポートする場合には可能なことがあります)。 
そうでない場合、tz はクラス tzinfo のサブクラスのインスタンスでなければならず、現在の日付および時刻はtz のタイムゾーンに変換されます。 
この場合、結果は 
tz.fromutc(datetime.utcnow().replace(tzinfo=tz))と等価になります。 
today(), utcnow() も参照してください。 
現在の UTC における日付と時刻を、 tzinfo が None であるものとして返します。 
このメソッドは now() に似ていますが、現在の UTC における日付と時刻を naive な datetime オブジェクトとして返します。 now() も参照してください。 
time.time() が返すような、POSIX タイムスタンプに対応するローカルな日付と時刻を返します。 
オプションの引数 tz が None であるか、指定されていない場合、タイムスタンプはプラットフォームのローカルな日付および時刻に変換され、返される datetime オブジェクトは naive なものになります。 そうでない場合、 tz はクラス tzinfo のサブクラスのインスタンスでなければならず、現在の日付および時刻はtz のタイムゾーンに変換されます。 
この場合、結果は 
tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz))と等価になります。 
タイムスタンプがプラットフォームの C 関数 localtime() やgmtime() でサポートされている範囲を超えた場合、fromtimestamp() は ValueError を送出することがあります。 
time.time() が返すような POSIX タイムスタンプに対応する、UTC での datetime オブジェクトを返します。 タイムスタンプがプラットフォームにおける C 関数 localtime()でサポートされている範囲を超えている場合には ValueErrorを送出することがあります。 
この値はよく 1970 年から 2038 年に制限されていることがあります。 fromtimestamp() も参照してください。 
1 年 1 月 1 日を序数 1 とする予測的グレゴリオ暦序数に対応するdatetime オブジェクトを返します。 1 = ordinal = datetime.max.toordinal() でないかぎりValueError が送出されます。 
結果として返されるオブジェクトの時間、分、秒、およびマイクロ秒はすべて 0 となり、tzinfo は None となります。 
与えられた date オブジェクトと同じデータメンバを持ち、時刻と tzinfo メンバが与えられた time オブジェクトと等しい、新たな datetime オブジェクトを返します。 
任意の datetime オブジェクト d について、 d == datetime.combine(d.date(), d.timetz())となります。 
date が datetime オブジェクトの場合、その時刻と tzinfo は無視されます。 
表現できる最も古い datetime で、datetime(MINYEAR, 1, 1, tzinfo=None) です。 
表現できる最も新しい datetime で、datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None) です。 
等しくない datetime オブジェクト間の最小の差で、 timedelta(microseconds=1)です。 
range(24) 内の値です。 
range(60) 内の値です。 
range(1000000) 内の値です。 
datetime コンストラクタに tzinfo 引数として与えられたオブジェクトになり、何も渡されなかった場合には Noneになります。 
以下にサポートされている演算を示します: 
datetime を datetime と比較します。 (4) 
datetime2 は datetime1 から時間 timedelta 移動したもので、 
timedelta.days 0 の場合進む方向に、 
timedelta.days 0 の場合戻る方向に移動します。 
datetime から datetime の減算は両方の被演算子がnaive であるか、両方とも aware である場合にのみ定義されています片方が aware でもう一方が naive の場合、 TypeError が送出されます。 
両方とも naive か、両方とも aware で同じ tzinfo メンバを持つ場合、tzinfo メンバは無視され、結果は 
datetime2 + t == datetime1 であるようなtimedelta オブジェクト t となります。 
この場合タイムゾーン修正は全く行われません。 
両方が aware で異なる tzinfo メンバを持つ場合、a-b は a および b をまず naive な UTC datetimeオブジェクトに変換したかのようにして行います。 
演算結果は決してオーバフローを起こさないことを除き、(a.replace(tzinfo=None) - a.utcoffset()) -(b.replace(tzinfo=None) - b.utcoffset())と同じになります。 
datetime1 が時刻として datetime2 よりも前を表す場合に、datetime1 はdatetime2 よりも小さいと見なされます。 被演算子の片方が naive でもう一方が aware の場合、TypeError が送出されます。 
両方の被演算子が aware で、同じ tzinfo メンバを持つ場合、共通の tzinfoメンバは無視され、基本の datetime 間の比較が行われます。 
両方の被演算子が aware で異なる tzinfo メンバを持つ場合、被演算子はまず (self.utcoffset() で得られる) UTC オフセット で修正されます。 
注意:型混合の比較がデフォルトのオブジェクトアドレス比較となってしまうのを抑止するために、被演算子のもう一方が datatime オブジェクトと異なる型のオブジェクトの場合には TypeError が送出されます。 
しかしながら、被比較演算子のもう一方が timetuple 属性を持つ場合には NotImplemented が返されます。 
このフックにより、他種の日付オブジェクトに型混合比較を実装するチャンスを与えています。 
そうでない場合、datetime オブジェクトと異なる型のオブジェクトが比較されると、比較演算子が == または !=でないかぎり TypeError が送出されます。 
後者の場合、それぞれ False または Trueを返します。 
datetime オブジェクトは辞書のキーとして用いることができます。 
ブール演算コンテキストでは、全ての datetime オブジェクトは真であるとみなされます。 インスタンスメソッドを以下に示します: 
同じ年、月、日の date オブジェクトを返します。 
同じ時、分、秒、マイクロ秒を持つ time オブジェクトを返します。 tzinfo は None です。 
timetz() も参照してください。 
同じ時、分、秒、マイクロ秒、および tzinfo メンバを持つtime オブジェクトを返します。 
time() メソッドも参照してください。 
キーワード引数で指定したメンバの値を除き、同じ値をもつ datetime オブジェクトを返します。 
メンバに対する変換を行わずに aware な datetime オブジェクトから naive な datetime オブジェクトを生成するために、tzinfo=None を指定することもできます。 
tz は tzinfo のサブクラスのインスタンスでなければならず、インスタンスの utcoffset() および dst() メソッドは None を返してはなりません。 
self はaware でなくてはなりません ( 
self.tzinfo が Noneであってはならず、かつ 
self.utcoffset() は Noneを返してはなりません)。 
self.tzinfo が tz の場合、 
self.astimezone(tz) は self に等しくなります: 日付および時刻データメンバに対する調整は行われません。 そうでない場合、結果はタイムゾーン tz におけるローカル時刻で、self と同じ UTC 時刻を表すようになります: 
astz = dt.astimezone(tz) とした後、 
astz - astz.utcoffset() は通常 dt - dt.utcoffset() と同じ日付および時刻データメンバを持ちます。 
tzinfo クラスに関する議論では、夏時間 (Daylight Saving time)の遷移境界では上の等価性が成り立たないことを説明しています(tz が標準時と夏時間の両方をモデル化している場合のみの問題です)。 単にタイムゾーンオブジェクト tz を datetime オブジェクトdt に追加したいだけで、日付や時刻データメンバへの調整を行わないのなら、 
dt.replace(tzinfo=tz) を使ってください。 
単に aware な datetime オブジェクト dt からタイムゾーンオブジェクトを除去したいだけで、日付や時刻データメンバの変換を行わないのなら、 dt.replace(tzinfo=None) を使ってください。 
デフォルトの tzinfo.fromutc() メソッドを tzinfoのサブクラスで上書きして、astimezone() が返す結果に影響を及ぼすことができます。 
エラーの場合を無視すると、astimezone() は以下のように動作します: 
tzinfo が None の場合、None を返し、そうでない場合には 
self.tzinfo.utcoffset(self)を返します。 
後者の式が None か、1 日以下の大きさを持つ経過時間を表す timedelta オブジェクトのいずれかを返さない場合には例外を送出します。 
self.tzinfo.dst(self)を返します。 
後者の式が None か、1 日以下の大きさを持つ経過時間を表す timedelta オブジェクトのいずれかを返さない場合には例外を送出します。 
self.tzinfo.tzname(self)を返します。 
後者の式が None か文字列オブジェクトのいずれかを返さない場合には例外を送出します。 
d.timetuple() はtime.struct_time((d.year, d.month, d.day,d.hour, d.minute, d.second,d.weekday(),d.toordinal() - date(d.year, 1, 1).toordinal() + 1,dst))と等価です。 
返されるタプルの tm_isdst フラグは dst() メソッドに従って設定されます: tzinfo が None かdst() が None を返す場合、tm_isdst は -1 に設定されます; そうでない場合、dst() がゼロでない値を返すと、tm_isdst は 1となります; それ以外の場合には tm_isdst は0 に設定されます。 
datetime インスタンス d が naive の場合、このメソッドは 
d.timetuple() と同じであり、d.dst() の返す内容にかかわらず tm_isdst が 0 に強制される点だけが異なります。 
DST が UTC 時刻に影響を及ぼすことは決してありません。 d が aware の場合、d から 
d.utcoffset() が差し引かれて UTC 時刻に正規化され、正規化された時刻の time.struct_timeを返します。 tm_isdst は 0 に強制されます。 
d.year が MINYEAR や MAXUEAR で、UTC への修正の結果表現可能な年の境界を越えた場合には、戻り値の tm_year メンバはMINYEAR-1 または MAXYEAR+1 になることがあります。 
予測的グレゴリオ暦における日付序数を返します。 
self.date().toordinal() と同じです。 
self.date().weekday() と同じです。 
isoweekday() も参照してください。 
self.date().isoweekday() と等価です。 
weekday()、 isocalendar() も参照してください。 
3 要素のタプル (ISO 年、ISO 週番号、ISO 曜日) を返します。 
self.date().isocalendar() と等価です。 
日付と時刻を ISO 8601 形式、すなわちYYYY-MM-DDTHH:MM:SS.mmmmmmか、microsecond が 0 の場合にはYYYY-MM-DDTHH:MM:SSで表した文字列を返します。 
utcoffset() が None を返さない場合、UTC からのオフセットを時間と分を表した (符号付きの) 6 文字からなる 文字列が追加されます: すなわち、YYYY-MM-DDTHH:MM:SS.mmmmmm+HH:MMとなるか、 microsecond が ゼロの場合にはYYYY-MM-DDTHH:MM:SS+HH:MMとなります。 オプションの引数 sep (デフォルトでは 'T' です) は 1 文字のセパレータで、結果の文字列の日付と時刻の間に置かれます。 
例えば、 
となります。 __str__ 
datetime オブジェクト d において、str(d) は 
d.isoformat(' ') と等価です。 
日付を表す文字列を、例えばdatetime(2002, 12, 4, 20, 30, 40).ctime() =='Wed Dec 4 20:30:40 2002'のようにして返します。 
ネイティブの C 関数 ctime() (time.ctime() はこの関数を呼び出しますが、datetime.ctime() は呼び出しません) が C 標準に準拠しているプラットフォームでは、 d.ctime() はtime.ctime(time.mktime(d.timetuple()))と等価です。 
明示的な書式化文字列で制御された、日付を表現する文字列を返します。 
strftime() のふるまいについてのセクションを参照してください。 
datetime モジュールでは、様々な日付オブジェクトや時刻オブジェクトを提供しています。 
以下に示す関数を使う場合には、あらかじめヘッダファイルdatetime.h をソースに include し (Python.h はこのファイルを include しません)、PyDateTime_IMPORT() マクロを起動しておく必要があります。 
このマクロは以下のマクロで使われる静的変数PyDateTimeAPI に C 構造体へのポインタを入れます。 以下は型チェックマクロです: 
ob がPyDateTime_DateType 型かPyDateTime_DateType型のサブタイプのオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_DateType 型のオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_DateTimeType 型かPyDateTime_DateTimeType 型のサブタイプのオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_DateTimeType 型のオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_TimeType 型かPyDateTime_TimeType型のサブタイプのオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_TimeType 型のオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_DeltaType 型かPyDateTime_DeltaType型のサブタイプのオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_DeltaType 型のオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_TZInfoType 型かPyDateTime_TZInfoType型のサブタイプのオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
ob がPyDateTime_TZInfoType 型のオブジェクトの場合に真を返します;ob は NULL であってはなりません。 バージョン 2.4 で 新たに追加 された仕様です。 
以下はオブジェクトを作成するためのマクロです: 
指定された年、月、日のdatetime.date オブジェクトを返します。 
バージョン 2.4 で 新たに追加 された仕様です。 
指定された年、月、日、時、分、秒、マイクロ秒のdatetime.datetime オブジェクトを返します。 
指定された時、分、秒、マイクロ秒のdatetime.time オブジェクトを返します。 
指定された日、秒、マイクロ秒のdatetime.timedelta オブジェクトを返します。 
マイクロ秒と秒が datetime.timedelta オブジェクトで定義されている範囲に入るように正規化を行います。 
バージョン 2.4 で 新たに追加 された仕様です。 
以下のマクロは date オブジェクトからフィールド値を取り出すためのものです。 
引数はPyDateTime_Date またはそのサブクラス(例えば PyDateTime_DateTime)の インスタンスでなければなりません。 
引数を NULL にしてはならず、型チェックは行いません: 
年を正の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
月を 1 から 12 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
日を 1 から 31 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
以下のマクロは datetime オブジェクトからフィールド値を取り出すためのものです。 
引数はPyDateTime_DateTime またはそのサブクラスのインスタンスでなければなりません。 引数を NULL にしてはならず、型チェックは行いません: 
時を 0 から 23 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
分を 0 から 59 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
秒を 0 から 59 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
マイクロ秒を 0 から 999999 の間の整数で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
以下のマクロは time オブジェクトからフィールド値を取り出すためのものです。 
引数はPyDateTime_Time またはそのサブクラスのインスタンスでなければなりません。 引数を NULL にしてはならず、型チェックは行いません: 
以下のマクロは DB API を実装する上での便宜用です: 
dateitme.datetime.fromtimestamp() に渡すのに適した引数タプルから新たな datetime.datetime オブジェクトを生成して返します。 
バージョン 2.4 で 新たに追加 された仕様です。 PyObject* 
dateitme.date.fromtimestamp() に渡すのに適した引数タプルから新たな datetime.date オブジェクトを生成して返します。 
バージョン 2.4 で 新たに追加 された仕様です。 
time オブジェクトは (ローカルの) 日中時刻を表現します。 
この時刻表現は特定の日の影響を受けず、tzinfo オブジェクトを介した修正の対象となります。 クラスtime 
全ての引数はオプションです。 tzinfo はNone または tzinfo クラスのサブクラスのインスタンスにすることができます。 
残りの引数は整数または長整数で、以下のような範囲に入ります: 
tzinfoのデフォルト値がNoneである以外のデフォルト値は0です。 
表現できる最も古い datetime で、time(0, 0, 0, 0) です。 The earliest representable time, time(0, 0, 0, 0). 
表現できる最も新しい datetime で、time(23, 59, 59, 999999, tzinfo=None) です。 
等しくない datetime オブジェクト間の最小の差で、 timedelta(microseconds=1)ですが、time オブジェクト間の四則演算はサポートされていないので注意してください。 
time コンストラクタに tzinfo 引数として与えられたオブジェクトになり、何も渡されなかった場合には Noneになります。 
以下にサポートされている操作を示します: 
time と time の比較では、a が時刻としてb よりも前を表す場合に a は b よりも小さいと見なされます。 
被演算子の片方が naive でもう一方が aware の場合、TypeError が送出されます。 
両方の被演算子が aware で、同じ tzinfo メンバを持つ場合、共通の tzinfoメンバは無視され、基本の datetime 間の比較が行われます。 
両方の被演算子が aware で異なる tzinfo メンバを持つ場合、被演算子はまず (self.utcoffset() で得られる) UTC オフセット で修正されます。 
型混合の比較がデフォルトのオブジェクトアドレス比較となってしまうのを抑止するために、time オブジェクトが他の型のオブジェクトと比較された場合、比較演算子が == または !=でないかぎり TypeError が送出されます。 
ハッシュ化、辞書のキーとしての利用 
効率的な pickle 化 
ブール演算コンテキストでは、time オブジェクトは、分に変換し、utfoffset() (None を返した場合には0) を差し引いて変換した後の結果がゼロでない場合、かつそのときに限って真とみなされます。 
以下にインスタンスメソッドを示します: 
キーワード引数で指定したメンバの値を除き、同じ値をもつ timeオブジェクトを返します。 
メンバに対する変換を行わずに aware な datetime オブジェクトから naive な time オブジェクトを生成するために、tzinfo=None を指定することもできます。 
日付と時刻を ISO 8601 形式、すなわちHH:MM:SS.mmmmmmか、microsecond が 0 の場合にはHH:MM:SSで表した文字列を返します。 
utcoffset() が None を返さない場合、UTC からのオフセットを時間と分を表した (符号付きの) 6 文字からなる 文字列が追加されます: すなわち、HH:MM:SS.mmmmmm+HH:MMとなるか、 microsecond が 0 の場合にはHH:MM:SS+HH:MMとなります。 
time オブジェクト t において、str(t) は 
t.isoformat() と等価です。 
明示的な書式化文字列で制御された、日付を表現する文字列を返します。 
strftime() のふるまいについてのセクションを参照してください。 
self.tzinfo.utcoffset(None)を返します。 
後者の式が None か、1 日以下の大きさを持つ経過時間を表す timedelta オブジェクトのいずれかを返さない場合には例外を送出します。 
self.tzinfo.dst(None)を返します。 
後者の式が None か、1 日以下の大きさを持つ経過時間を表す timedelta オブジェクトのいずれかを返さない場合には例外を送出します。 
self.tzinfo.tzname(None)を返します。 
後者の式が None か文字列オブジェクトのいずれかを返さない場合には例外を送出します。 
timedelta オブジェクトは経過時間、すなわち二つの日付や時刻間の差を表します。 
クラスtimedelta 
全ての引数がオプションで、デフォルト値は0です。 
引数は整数、長整数、浮動小数点数にすることができ、正でも負でもかまいません。 days、seconds および microseconds のみが内部に記憶されます。 
引数は以下のようにして変換されます: 
1 ミリ秒は 1000 マイクロ秒に変換されます。 
1 分は 60 秒に変換されます。 
1 時間は 3600 秒に変換されます。 
1 週間は 7 日に変換されます。 
その後、日、秒、マイクロ秒は値が一意に表されるように、 
0 = seconds 3600*24 (一日中の秒数) 
で正規化されます。 引数のいずれかが浮動小数点であり、小数のマイクロ秒が存在する場合、小数のマイクロ秒は全ての引数から一度取り置かれ、それらの和は最も近いマイクロ秒に丸められます。 
例えば、 d = timedelta(microseconds=-1) (d.days, d.seconds, d.microseconds)(-1, 86399, 999999) 
クラス属性を以下に示します: 
最小の値を表す timedelta オブジェクトで、timedelta(-999999999) です。 
最大の値を表す timedelta オブジェクトで、timedelta(days=999999999, hours=23, minutes=59, seconds=59,microseconds=999999) です。 
timedelta オブジェクトが等しくならない最小の時間差で、timedelta(microseconds=1) です。 
属性 
値 
両端値を含む -999999999 から 999999999 の間 
両端値を含む 0 から 86399 の間 
両端値を含む 0 から 999999 の間 
端数を切り捨てて除算され、剰余 (がある場合) は捨てられます。 (3) 
同じ値を持つtimedelta オブジェクトを返します。 (2) 
-t1 timedelta(-t1.days, -t1.seconds,-t1.microseconds)、および t1* -1 と同じです。 
t.days = 0 のときには +t 、t.days 0 のときには -t となります。 (2) 
この操作は厳密ですが、オーバフローするかもしれません。 
この操作は厳密であり、オーバフローしないはずです。 
0 による除算は ZeroDivisionError を送出します。 
-timedelta.max は timedelta オブジェクトで表現することができません。 
timedelta オブジェクトはハッシュ可能 (辞書のキーとして利用可能)であり、効率的な pickle 化をサポートします、また、ブール演算コンテキストでは、 timedelta オブジェクトは timedelta(0) に等しくない場合かつそのときに限り真となります。 
tzinfo は抽象基底クラスです。 
tzinfo の具体的なサブクラスでは、以下のメソッドを実装する必要があります。 
厳密にどのメソッドが必要なのかは、aware な datetime オブジェクトがこのサブクラスのインスタンスをどのように使うかに依存します。 
不確かならば、単に全てを実装してください。 
ローカル時間の UTC からのオフセットを、UTC から東向きを正とした分で返します。 
ローカル時間が UTC の西側にある場合、この値は負になります。 
このメソッドは UTC からのオフセットの総計を返すように意図されているので注意してください; 例えば、 tzinfo オブジェクトがタイムゾーンと DST 修正の両方を表現する場合、utcoffset()はそれらの合計を返さなければなりません。 
UTC オフセットが未知である場合、None を返してください。 
そうでない場合には、返される値は -1439 から 1439 の両端を含む値 (1440 = 24*60 ; つまり、オフセットの大きさは 1 日より短くなくてはなりません)が分で指定された timedelta オブジェクトでなければなりません。 
ほとんどの utcoffset() 実装は、おそらく以下の二つのうちの一つに似たものになるでしょう: 
utcoffset() が None を返さない場合、dst() も None を返してはなりません。 utcoffset() のデフォルトの実装はNotImplementedError を送出します。 
夏時間 (DST) 修正を、UTC から東向きを正とした分で返します。 DST 情報が未知の場合、None が返されます。 
例えば、datetime.timetuple() は tzinfo メンバの dst() メソッドを呼んで tm_isdst フラグがセットされているかどうか判断し、tzinfo.fromutc() は dst() タイムゾーンを移動する際に DST による変更があるかどうかを調べます。 
全ての datetime オブジェクトdt について常に同じ結果を返さなければならないという点で、一貫性を持っていなければなりません。 
正常に実装された tzinfo のサブクラスでは、この式はタイムゾーンにおける "標準オフセット (standard offset)" を表し、特定の日や時刻の事情ではなく地理的な位置にのみ依存していなくてはなりません。 
datetime.astimezone() の実装はこの事実に依存していますが、違反を検出することができません;正しく実装するのはプログラマの責任です。 
tzinfo のサブクラスでこれを保証することができない場合、tzinfo.fromutc() の実装をオーバライドして、astimezone() に関わらず正しく動作するようにしてもかまいません。 ほとんどの dst() 実装は、おそらく以下の二つのうちの一つに似たものになるでしょう: 
デフォルトの dst() 実装は NotImplementedErrorを送出します。 
datetime オブジェクト dt に対応するタイムゾーン名を文字列で返します。 datetime モジュールでは文字列名について何も定義しておらず、特に何かを意味するといった要求仕様もまったくありません。 
例えば、"GMT"、"UTC"、 "-500"、 "-5:00"、 "EDT"、 "US/Eastern"、"America/New York" は全て有効な応答となります。 
文字列名が未知の場合には None を返してください。 
tzinfo のサブクラスでは、特に、tzinfoクラスが夏時間について記述している場合のように、渡された dt の特定の値によって異なった名前を返したい場合があるため、文字列値ではなくメソッドとなっていることに注意してください。 デフォルトの tzname() 実装は NotImplementedErrorを送出します。 
以下のメソッドは datetime や time オブジェクトにおいて、同名のメソッドが呼び出された際に応じて呼び出されます。 
datetimeオブジェクトは自身を引数としてメソッドに渡し、time オブジェクトは引数として None をメソッドに渡します。 
従って、tzinfo のサブクラスにおけるメソッドは引数 dt が None の場合と、datetime の場合を受理するように用意しなければなりません。 None が渡された場合、最良の応答方法を決めるのはクラス設計者次第です。 
例えば、このクラスが tzinfo プロトコルと関係をもたないということを表明させたければ、None が適切です。 
その結果 tzinfo メソッドは dt がローカル時間であると解釈するので、他のタイムゾーンでのオブジェクトの振る舞いについて心配する必要がありません。 
デフォルトの datetime.astimezone() 実装で呼び出されます。 
datetime.astimezone() から呼ばれた場合、 
dt.tzinfoは self であり、 dt の日付および時刻データメンバはUTC 時刻を表しているものとして見えます。 
fromutc() の目的は、self のローカル時刻に等しい datetime オブジェクトを返すことにより日付と時刻データメンバを修正することにあります。 ほとんどの tzinfo サブクラスではデフォルトの fromutc()実装を問題なく継承できます。 
デフォルトの実装は、固定オフセットのタイムゾーンや、標準時と夏時間の両方について記述しているタイムゾーン、そしてDST 移行時刻が年によって異なる場合でさえ、扱えるくらい強力なものです。 
以下に tzinfo クラスの使用例を示します: 
具体的な例として、東部アメリカ時刻(US Eastern, UTC -5000) を考えます。 
EDT は 4 月の最初の日曜日の 1:59 (EST) 以後に開始し、10 月の最後の日曜日の 1:59 (EDT) に終了します: 
DST の開始の際 ("start" の並び) ローカルの壁時計は 1:59 から3:00 に飛びます。 
この日は 2:MM の形式をとる時刻は実際には無意味となります。 従って、astimezone(Eastern) は DST が開始する日には hour == 2 となる結果を返すことはありません。 
astimezone() がこのことを保証するようにするには、tzinfo.dst() メソッドは "失われた時間" (東部時刻における2:MM) が夏時間に存在することを考えなければなりません。 DST が終了する際 ("end" の並び) では、問題はさらに悪化します:1 時間の間、ローカルの壁時計ではっきりと時刻をいえなくなります:それは夏時間の最後の 1 時間です。 
東部時刻では、その日の UTCでの 5:MM に夏時間は終了します。 
東部時刻の例では、5:MM および 6:MM の形式をとる UTC 時刻は両方とも、東部時刻に変換された際に 1:MM に対応づけられます。 
astimezone() がこのことを保証するようにするには、tzinfo.dst() は "繰り返された時間" が標準時に存在することを考慮しなければなりません。 
このことは、例えばタイムゾーンの標準のローカルな時刻に DST への切り替え時刻を表現することで簡単に設定することができます。 このようなあいまいさを許容できないアプリケーションは、ハイブリッドな tzinfo サブクラスを使って問題を回避しなければなりません; UTC や、他のオフセットが固定された tzinfo のサブクラス (EST (-5 時間の固定オフセット) のみを表すクラスや、EDT (-4 時間の固定オフセット) のみを表すクラス) を使う限り、あいまいさは発生しません。 
open() によって返されるデータベースオブジェクトは、全ての DBM 形式データベースやマップ型オブジェクトで共通のメソッドを提供します。 
それら標準のメソッドに加え、dbhash では以下のメソッドが利用可能です。 
このメソッドと next() メソッドを使って、データベースの全てのキー/値のペアにわたってループ処理を行えます。 
探索はデータベースの内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。 
このメソッドは最初のキーを返します。 
データベース探索における最後のキー/値を返します。 
逆順探索を開始する際に使うことができます; previous() を参照してください。 
データベースの順方向探索において、次のよりも後に来るキー/値のペアを返します。 
以下のコードはデータベース db について、キー全てを含むリストをメモリ上に生成することなく全てのキーを出力します。 
データベースの逆方向探索において、手前に来るキー/値のペアを返します。 last() と併せて、逆方向の探索に用いられます。 
このメソッドはディスクにまだ書き込まれていないデータを全て書き込ませます。 
デバッガは以下のコマンドを認識します。 
ほとんどのコマンドは一文字または二文字に省略することができます。 
例えば、"h(elp)"が意味するのは、ヘルプコマンドを入力するために"h"か"help"のどちらか一方を使うことができるということです(が、"he"や"hel"は使えず、また"H"や"Help"、"HELP"も使えません)。 
コマンドの引数は空白(スペースまたはタブ)で区切られなければなりません。 
オプションの引数はコマンド構文の角括弧("[]")の中に入れなければなりません。 角括弧をタイプしてはいけません。 
コマンド構文における選択肢は垂直バー("|")で区切られます。 空行を入力すると入力された直前のコマンドを繰り返します。 
例外: 直前のコマンドが"list"コマンドならば、次の11行がリストされます。 デバッガが認識しないコマンドはPython文とみなして、デバッグしているプログラムのコンテキストおいて実行されます。 
Python文は感嘆符("!")を前に付けることもできます。 
これはデバッグ中のプログラムを調査する強力な方法です。 変数を変更したり関数を呼び出したりすることさえ可能です。 
このような文で例外が発生した場合には例外名がプリントされますが、デバッガの状態は変化しません。 複数のコマンドを";;"で区切って一行で入力することができます。 
エイリアスはパラメータを持つことができ、調査中のコンテキストに対して人がある程度柔軟に対応できます。 ファイル.pdbrc 
両方のファイルが存在する場合、ホームディレクトリのものが最初に読まれ、そこに定義されているエイリアスはローカルファイルにより上書きされることがあります。 
引数なしでは、利用できるコマンドの一覧をプリントします。 
引数としてcommandがある場合は、そのコマンドについてのヘルプをプリントします。 
"help pdb"は完全ドキュメンテーションファイルを表示します。 環境変数PAGERが定義されているならば、代わりにファイルはそのコマンドへパイプされます。 
command引数が識別子でなければならないので、"!"コマンドについてのヘルプを得るためには"help exec"と入力しなければならない。 
スタックの底にある最も新しいフレームと一緒にスタックトレースをプリントします。 
矢印はカレントフレームを指し、それがほとんどのコマンドのコンテキストを決定します。 
(より新しいフレームに向かって)スタックトレース内でカレントフレームを一レベル下げます。 
(より古いフレームに向かって)スタックトレース内でカレントフレームを一レベル上げます。 
lineno引数がある場合は、現在のファイルのその場所にブレークポイントを設定します。 
function引数がある場合は、その関数の中の最初の実行可能文にブレークポイントを設定します。 別のファイル(まだロードされていないかもしれないもの)のブレークポイントを指定するために、行番号はファイル名とコロンをともに先頭に付けられます。 
ファイルはsys.pathにそって検索されます。 
一時的なブレークポイントで、最初にそこに達したときに自動的に取り除かれます。 
引数はbreakと同じです。 
スペースで区切られたブレークポイントナンバーのリストを与えると、それらのブレークポイントを解除します。 
引数なしの場合は、すべてのブレークポイントを解除します(が、はじめに確認します)。 
スペースで区切られたブレークポイントナンバーのリストとして与えられるブレークポイントを無効にします。 
ブレークポイントを無効にすると、プログラムの実行を止めることができなくなりますが、ブレークポイントの解除と違いブレークポイントのリストに残ったままになり、(再び)有効にすることができます。 
指定したブレークポイントを有効にします。 
与えられたブレークポイントナンバーに通過カウントを設定します。 
countが省略されると、通過カウントは0に設定されます。 
通過カウントがゼロになったとき、ブレークポイントが機能する状態になります。 
ゼロでないときは、そのブレークポイントが無効にされず、どんな関連条件も真に評価されていて、ブレークポイントに来るたびにcountが減らされます。 
conditionはブレークポイントがhonored(???)する前に真に評価しなければならない式です。 
conditionがない場合は、どんな既存の条件も取り除かれます。 すなわち、ブレークポイントに条件がありません。 
現在の行を実行し、最初に実行可能なものがあらわれたときに(呼び出された関数の」中か、現在の関数の次の行で)停止します. 
現在の関数の次の行に達するか、あるいは関数が返るまで実行を継続します。 
("next"と"step"の差は"step"が呼び出された関数の内部で停止するのに対し、"next"は呼び出された関数を(ほぼ)全速力で実行し、現在の関数内の次の行で停止するだけです。 
現在の関数が返るまで実行を継続します。 
ブレークポイントに出会うまで、実行を継続します。 
次に実行する行を指定します。 
最も底のフレーム中でのみ実行可能です。 
前に戻って実行したり、不要な部分をスキップして先の処理を実行する場合に使用します。 ジャンプには制限があり、例えば forループの中には飛び込めませんし、finally節の外にも飛ぶ事ができません。 
現在のファイルのソースコードをリスト表示します。 
引数なしの場合は、現在の行の周囲を11行リストするか、または前のリストの続きを表示します。 
引数が一つある場合は、その行の周囲を11行表示します。 
引数が二つの場合は、与えられた範囲をリスト表示します。 第二引数が第一引数より小さいときは、カウントと解釈されます。 
現在の関数の引数リストをプリントします。 
現在のコンテキストにおいてexpressionを評価し、その値をプリントします。 
(注意: "print"も使うことができますが、デバッガコマンドではありません -- これはPythonのprint文を実行します。 ) 
pprintモジュールを使って例外の値が整形されることを除いて"p"コマンドと同様です。 
nameという名前のcommandを実行するエイリアスを作成します。 
コマンドは引用符で囲まれていてはいけません。 
入れ替え可能なパラメータは"%1"、"%2"などで指し示され、さらに"%*"は全パラメータに置き換えられます。 
コマンドが与えられなければ、nameに対する現在のエイリアスを表示します。 
引数が与えられなければ、すべてのエイリアスがリストされます。 エイリアスは入れ子になってもよく、pdbプロンプトで合法的にタイプできるどんなものでも含めることができます。 
内部pdbコマンドをエイリアスによって上書きすることができます。 
そのとき、このようなコマンドはエイリアスが取り除かれるまで隠されます。 
指定したエイリアスを削除します。 
現在のスタックフレームのコンテキストにおいて(一行の)statementを実行します。 文の最初の語がデバッガコマンドと共通でない場合は、感嘆符を省略することができます。 
グローバル変数を設定するために、同じ行に"global"コマンドとともに代入コマンドの前に付けることができます。 (Pdb) global list_options; list_options = ['-l'](Pdb) 
デバッガを終了します。 実行しているプログラムは中断されます。 
いくつかの変更がインタプリタへ加えられました: 
sys.settrace(func)がグローバルトレース関数を設定します 
そこで、ローカルトレース関数を使うこともできます(後ろを参照) 
'call' 関数が呼び出されます(または、他のコードブロックに入ります)。 
インタプリタがコードの新しい行を実行しようとしているところです(ときどき、一行に複数行イベントが存在します)。 ローカルトレース関数が呼び出されます。 
argはNoneです。 戻り値は新しいローカルトレース関数を指定します。 
関数(または、コードブロック)が返ろうとしているところです。 
ローカルトレース関数が呼び出されます。 argは返るであろう値です。 
トレース関数の戻り値は無視されます。 
例外が生じています。 
拡張モジュールまたは組み込みの C 関数が呼び出されようとしています。 
arg は C 関数オブジェクトです。 
'c_return' C 関数が処理を戻しました。 
arg はNone です。 
'c_exception' C 関数が例外を送出しました。 
arg はNone です。 
例外が一連の呼び出し元を伝えられて行くときに、'exception'イベントは各レベルで生成されることことに注意してください。 コードとフレームオブジェクトについてさらに情報を得るには、 
コンテキスト (context) とは、算術演算における環境設定です。 
コンテキストは計算精度を決定し、値丸めの方法を設定し、シグナルのどれが例外になるかを決め、指数の範囲を制限しています。 多重スレッドで処理を行う場合には各スレッドごとに現在のコンテキストがあり、getcontext() や setcontext() といった関数でアクセスしたり設定変更できます: 
アクティブなスレッドの現在のコンテキストを返します。 
General Decimal Arithmetic Specification で定義されている標準コンテキストの一つです。 
精度は 9 桁に設定されています。 
丸め規則は ROUND_HALF_UPです。 
すべての演算結果フラグはクリアされています。 
Inexact、Rounded、Subnormal を除く全ての演算エラートラップが有効 (例外として扱う) になっています。 多くのトラップが有効になっているので、デバッグの際に便利なコンテキストです。 
丸め規則はROUND_HALF_EVEN です。 
トラップは全て無効 (演算中に一切例外を送出しない) になっています。 トラップが無効になっているので、エラーの伴う演算結果を NaN や Infinity にし、例外を送出しないようにしたいアプリケーションに向いたコンテキストです。 
このコンテキストを使うと、他の場合にはプログラムが停止してしまうような状況があっても実行を完了させられます。 
Context コンストラクタが新たなコンテキストを作成するさいに雛形にするコンテキストです。 
このコンテキストのフィールド (精度の設定など)を変更すると、Context コンストラクタが生成する新たなコンテキストに影響を及ぼします。 このコンテキストは、主に多重スレッド環境で便利です。 
スレッドを開始する前に何らかのフィールドを変更しておくと、システム全体のデフォルト設定に効果を及ぼせます。 
スレッドを開始した後にフィールドを変更すると競合条件を抑制するためにスレッドを同期化せねばならないので推奨しません。 単一スレッドの環境では、このコンテキストを使わないよう薦めます。 
下で述べるように明示的にコンテキストを作成してください。 デフォルトの値は精度 28 桁、丸め規則 ROUND_HALF_EVEN で、トラップ Overflow、InvalidOperation、およびDivisionByZero が有効になっています。 
上に挙げた三つのコンテキストに加え、Context コンストラクタを使って新たなコンテキストを生成できます。 
クラスContext 
新たなコンテキストを生成します。 
あるフィールドが定義されていないかNone であれば、 DefaultContext からデフォルト値をコピーします。 
Context クラスでは、いくつかの汎用のメソッドの他、現在のコンテキストで算術演算を直接行うためのメソッドを数多く定義しています。 
フラグを全て 0 にセットします。 
コンテキストの複製を返します。 
self をコンテキストとする新たな Decimal インスタンスをnum から生成します。 
Decimal コンストラクタと違い、数値を変換する際にコンテキストの精度、値丸め方法、フラグ、トラップを適用します。 定数値はしばしばアプリケーションの要求よりも高い精度を持っているため、このメソッドが役に立ちます。 
また、値丸めを即座に行うため、例えば以下のように、入力値に値丸めを行わないために合計値にゼロの加算を追加するだけで結果が変わってしまうといった、現在の精度よりも細かい値の影響が紛れ込む問題を防げるという恩恵もあります。 
"Emmin - prec + 1" に等しい値を返します。 演算結果の劣化が起こる桁の最小値です。 
アンダーフローが起きた場合、指数は Etiny に設定されます。 
"Emax - prec + 1" に等しい値を返します。 
Decimal を使った処理を行う場合、通常は Decimal インスタンスを生成して、算術演算を適用するというアプローチをとります。 演算はアクティブなスレッドにおける現在のコンテキストの下で行われます。 
もう一つのアプローチは、コンテキストのメソッドを使った特定のコンテキスト下での計算です。 
コンテキストのメソッドは Decimal クラスのメソッドに似ているので、ここでは簡単な説明にとどめます。 
x の絶対値を返します。 
x と y の加算を返します。 
二つの値を数値として比較します。 __cmp__() に似ていますが、 以下のようにDecimal インスタンスを返します: 
x を y で除算した値を返します。 
二つの数値間の除算を行い、結果の整数部を返します。 
二つの値を数値として比較し、大きいほうを返します。 
数値上二つの値が等しい場合には、左側値を結果として返します。 
二つの値を数値として比較し、小さいほうを返します。 
数値上二つの値が等しい場合には、左側値を結果として返します。 
Python における単項の符号反転前置演算子 (unary prefix minus operator) に対応する演算です。 
x とy の積を返します。 
被演算子をもっとも単純な表記にします。 本質的には、plus 演算の結果から末尾のゼロを全て取り除いたものと同じです。 
Python における単項の符号非反転前置演算子 (unary prefix plus operator) に対応する演算です。 
コンテキストにおける精度や値丸めを適用するので、等値 (identity) 演算とは 違います。 
"x ** y" を計算します。 
modulo が指定されていれば使います。 右被演算子は整数部が 9 桁以下で、小数部 (のある場合) は値丸め前に全てゼロになっていなければなりません。 
x に値丸めを適用し、指数を y にした値を返します。 他の演算と違い、量子化後の係数の長さが精度よりも大きい場合にはInvalidOperation をシグナルします。 
このため、エラーが生じないかぎり、量子化後の指数は右側の被演算子の指数と等しくなることが保証されます。 また、結果が劣化していたり不正確な値であっても、Underflowをシグナルしないという点も他の演算と異なります。 
整数除算の剰余を返します。 
剰余がゼロでない場合、符号は割られる数の符号と同じになります。 remainder_near 
モジュロを計算し、正負のモジュロのうちゼロに近い値を返します。 
たとえば、"Decimal(10).remainder_near(6)" は Decimal("4") よりもゼロに近い値 Decimal("-2")を返します。 ゼロからの差が同じ場合には、 self と同じ符号を持った方を返します。 
self と other が同じ指数を持っているか、あるいは双方とも NaN である場合に真を返します。 
平方根を精度いっぱいまで求めます。 
x とy の間の差を返します。 
工学表記で文字列に変換します。 
工学表記では指数は 3 の倍数になります。 
従って、最大で 3 桁までの数字が基数の小数部に現れます。 
たとえば、Decimal('123E+1') は Decimal("1.23E+3")に変換されます。 to_integral 
Inexact や Rounded といったシグナルを出さずに最近傍の整数に値を丸めます。 
数値を科学表記で文字列に変換します。 
10 進浮動小数点数を使うと、 10 進数表現による誤差を抑制できます(0.1 を正確に表現できるようになります); しかし、ゼロでない桁が一定の精度を越えている場合には、演算によっては依然として値丸めによる誤差を引き起こします。 
Knuth は、十分でない計算精度の下で値丸めを伴う浮動小数点演算を行った結果、加算の結合則や分配則における恒等性が崩れてしまう例を二つ示しています: 
decimal モジュールでは、最下桁を失わないように十分に計算精度を広げることで、上で問題にしたような恒等性をとりもどせます: 
decimal モジュールの数体系では、NaN, sNaN, -Infinity , Infinity , および二つのゼロ、+0 と -0 といった特殊な値を提供しています。 無限大 (Infinity) は Decimal('Infinity') で直接構築できます。 
また、DivisionByZero をトラップせずにゼロで除算を行った場合にも出てきます。 
同様に、 Overflow シグナルをトラップしなければ、表現可能な最大の数値の制限を越えた値を丸めたときに出てきます。 無限大には符号があり (アフィン: affine であり)、算術演算に使用でき、非常に巨大で不確定の(indeterminate)値として扱われます。 
例えば、0/0 は NaN を返します。 
NaN は「非数値 (not a number)」を表します。 このような NaN は暗黙のうちに生成され、一度生成されるとそれを他の計算にも流れてゆき、関係する個々の演算全てが個別の NaN を返すようになります。 
この挙動は、たまに入力値が欠けるような状況で一連の計算を行う際に便利です -- 特定の計算に対しては無効な結果を示すフラグを立てつつ計算を進められるからです。 
一方、NaN の変種であるsNaN は関係する全ての演算で演算後にシグナルを送出します。 
二つの符号付きゼロが区別されているのに等価であることに加えて、異なる精度におけるゼロの表現はまちまちなのに、値は等価とみなされるということがあります。 
これに慣れるには多少時間がかかります。 
正規化浮動小数点表現に目が慣れてしまうと、以下の計算でゼロに等しい値が返っているとは即座に分かりません: 
Decimal クラスの利用を実演している例をいくつか示します。 これらはユーティリティ関数としても利用できます: 
def moneyfmt(value, places=2, curr='', sep=',', dp='.',pos='', neg='-', trailneg=''):"""Decimal を通貨表現の文字列に変換します。 
places: 小数点以下の値を表すのに必要な桁数curr: 符号の前に置く通貨記号 (オプションで、空でもかまいません)sep: 桁のグループ化に使う記号、オプションです (コンマ、ピリオド、スペース、または空)dp: 小数点 (コンマまたはピリオド)小数部がゼロの場合には空にできます。 
pos: optional sign for positive numbers: '+', space or blankneg: optional sign for negative numbers: '-', '(', space or blanktrailneg:optional trailing minus indicator: '-', ')', space or blank d = Decimal('-1234567.8901') moneyfmt(d, curr='$')'-$1,234,567.89' moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')'1.234.568-' moneyfmt(d, curr='$', neg='(', trailneg=')')'($1,234,567.89)' moneyfmt(Decimal(123456789), sep=' ')'123 456 789.00' moneyfmt(Decimal('-0.02'), neg='', trailneg='')'.02'"""q = Decimal((0, (1,), -places)) # 2 places -- '0.01'sign, digits, exp = value.quantize(q).as_tuple()assert exp == -places result = []digits = map(str, digits)build, next = result.append, digits.popif sign:build(trailneg)for i in range(places):if digits:build(next())else:build('0')build(dp)i = 0while digits:build(next())i += 1if i == 3 and digits:i = 0build(sep)build(curr)if sign:build(neg)else:build(pos)result.reverse()return ''.join(result)def pi():"""Compute Pi to the current precision. print pi()3.141592653589793238462643383"""getcontext().prec += 2 # extra digits for intermediate stepsthree = Decimal(3) # substitute "three=3.0" for regular floatslasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24while s != lasts:lasts = sn, na = n+na, na+8d, da = d+da, da+32t = (t * n) / ds += tgetcontext().prec -= 2return +s # unary plus applies the new precisiondef exp(x):"""Return e raised to the power of x. Result type matches input type. print exp(Decimal(1))2.718281828459045235360287471 print exp(Decimal(2))7.389056098930650227230427461 print exp(2.0)7.38905609893 print exp(2+0j)(7.38905609893+0j)"""getcontext().prec += 2i, lasts, s, fact, num = 0, 0, 1, 1, 1while s != lasts:lasts = s i += 1fact *= inum *= x s += num / fact getcontext().prec -= 2 return +sdef cos(x):"""x ラジアンの余弦を返します。 print cos(Decimal('0.5'))0.8775825618903727161162815826 print cos(0.5)0.87758256189 print cos(0.5+0j)(0.87758256189+0j)"""getcontext().prec += 2i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1while s != lasts:lasts = s i += 2fact *= i * (i-1)num *= x * xsign *= -1s += num / fact * sign getcontext().prec -= 2 return +sdef sin(x):"""x ラジアンの正弦を返します。 
5.5.4 シグナル シグナルは、計算中に生じた様々なエラー条件を表現します。 
例えば、DivisionByZero が設定されていると、エラー条件が生じた際に DivisionByZero 例外を送出します。 
値の表現上の制限に沿わせるために指数部が変更されたことを通知します。 通常、クランプ (clamp) は、指数部がコンテキストにおける指数桁の制限値Emin およびEmax を越えたなった場合に発生します。 
可能な場合には、係数部にゼロを加えた表現に合わせて指数部を減らします。 
他のシグナルの基底クラスで、ArithmeticError のサブクラスです。 
有限値をゼロで除算したときのシグナルです。 除算やモジュロ除算、数を負の値で累乗した場合に起きることがあります。 
このシグナルをトラップしない場合、演算結果は Infinity または-Infinity になり、その符号は演算に使った入力に基づいて決まります。 
値の丸めによって演算結果から厳密さが失われたことを通知します。 このシグナルは値丸め操作中にゼロでない桁を無視した際に生じます。 
演算結果は値丸め後の値です。 
シグナルのフラグやトラップは、演算結果の厳密さが失われたことを検出するために使えるだけです。 
このシグナルの発生原因として考えられるのは、以下のような状況です: 
数値オーバフローを示すシグナルです。 このシグナルは、値丸めを行った後の指数部が Emax より大きいことを示します。 
シグナルをトラップしない場合、演算結果は値丸めのモードにより、表現可能な最大の数値になるように内側へ引き込んで丸めを行った値か、Infinity になるように外側に丸めた値のいずれかになります。 
いずれの場合も、Inexact および Rounded が同時にシグナルされます。 
このシグナルをトラップしなければ、演算結果をそのまま返します。 
このシグナルは有効桁数の減少を検出する際に使います。 
これらのシグナルの階層構造をまとめると、以下の表のようになります: 
関数getcontext() は、スレッド毎に別々のContext オブジェクトにアクセスします。 
アプリケーションを通じて全てのスレッドに同じ値を使うようにデフォルトを設定したければ、DefaultContextオブジェクトを直接変更します。 
getcontext() を呼び出すスレッド間で競合条件が生じないようにするため、DefaultContextへの変更はいかなるスレッドを開始するよりも前に 行わねばなりません。 
以下に例を示します: 
# スレッドを立ち上げる前にアプリケーションにわたるデフォルトを設定DefaultContext.prec = 12DefaultContext.rounding = ROUND_DOWNDefaultContext.traps = ExtendedContext.traps.copy()DefaultContext.traps[InvalidOperation] = 1setcontext(DefaultContext)# その後でスレッドを開始t1.start()t2.start()t3.start(). . . 
普通、decimal を使うときには、モジュールを import し、現在の演算コンテキストを getcontext() で調べ、必要に応じて精度や丸めを設定し、演算エラーのトラップを有効にします: 
from decimal import * getcontext()Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,capitals=1, flags=[], traps=[Overflow, InvalidOperation,DivisionByZero]) getcontext().prec = 7 # 新たな精度を設定 
Decimal のインスタンスは、整数、文字列またはタプルから生成できます。 
Decimal を float から生成したければ、まず文字列型に変換せねばなりません。 
そうすることで、変換方法の詳細を(representation error も含めて) 明示的に残せます。 
Decimal は ``数値ではない (Not a Number)''を表す NaN や正負の Infinity (無限大)、-0 といった特殊な値も表現できます。 
新たな Decimal 型数値の有効桁数は入力した数の桁数だけで決まります。 
演算コンテキストにおける精度や値丸めの設定が影響するのは算術操作の中だけです。 
Decimal 型数値はほとんどの場面で Python の他の機能とうまくやりとりできます。 
Decimal 浮動小数点小劇場 (flying circus) を示しましょう: 
data = map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()) max(data)Decimal("9.25") min(data)Decimal("0.03") sorted(data)[Decimal("0.03"), Decimal("1.00"), Decimal("1.34"), Decimal("1.87"),Decimal("2.35"), Decimal("3.45"), Decimal("9.25")] sum(data)Decimal("19.29") a,b,c = data[:3] str(a)'1.34' float(a)1.3400000000000001 round(a, 1) # round() は値をまず二進の浮動小数点数に変換します1.3 int(a)1 a * 5Decimal("6.70") a * bDecimal("2.5058") c % aDecimal("0.77") 
quantize() メソッドは位を固定して数値を丸めます。 
このメソッドは、計算結果を固定の桁数で丸めることがよくある、通貨を扱うアプリケーションで便利です: 
前述のように、getcontext() 関数を使うと現在の演算コンテキストにアクセスでき、設定を変更できます。 
ほとんどのアプリケーションはこのアプローチで十分です。 より高度な作業を行う場合、Context() コンストラクタを使って別の演算コンテキストを作っておくと便利なことがあります。 
別の演算コンテキストをアクティブにしたければ、setcontext()を使います。 Decimal モジュールでは、標準仕様に従って、すぐ利用できる二つの標準コンテキスト、BasicContext およびExtendedContext を提供しています。 
後者はほとんどのトラップが有効になっており、とりわけデバッグの際に便利です: 
演算コンテキストには、演算中に遭遇した例外的状況をモニタするためのシグナルフラグがあります。 
フラグが一度セットされると、明示的にクリアするまで残り続けます。 そのため、フラグのモニタを行いたいような演算の前にはclear_flags() メソッドでフラグをクリアしておくのがベストです。 
flags エントリから、Pi の有理数による近似値が丸められた(コンテキスト内で決められた精度を超えた桁数が捨てられた) ことと、計算結果が厳密でない (無視された桁の値に非ゼロのものがあった) ことがわかります。 コンテキストの traps フィールドに入っている辞書を使うと、個々のトラップをセットできます: 
ほとんどのプログラムでは、開始時に一度だけ現在の演算コンテキストを修正します。 
また、多くのアプリケーションでは、データから Decimal への変換はループ内で一度だけキャストして行います。 
コンテキストを設定し、Decimal オブジェクトを生成できたら、ほとんどのプログラムは他の Python 数値型と全く変わらないかのようにDecimal を操作できます。 
クッキーを受けつけ、またそれを返す際の標準的なルールを実装します。 RFC 2965 クッキーと Netscape クッキーの両方に対応しています。 
デフォルトでは、RFC 2965 の処理はオフになっています。 自分のポリシーを提供するいちばん簡単な方法は、このクラスを継承して、自分用の追加チェックの前にオーバーライドした元のメソッドを呼び出すことです: 
CookiePolicy インターフェイスを実装するのに必要な機能に加えて、このクラスではクッキーを受けとったり設定したりするドメインを許可したり拒絶したりできるようになっています。 
コンストラクタの引数 blocked_domains、およびblocked_domains() と set_blocked_domains() メソッドを使ってください (allowed_domains に関しても同様の対応する引数とメソッドがあります)。 
ホワイトリストを設定した場合は、それを None にすることでホワイトリスト機能をオフにすることができます。 ブラックリストあるいはホワイトリスト中にあるドメインのうち、ドット (.) で始まっていないものは、正確にそれと一致するドメインのクッキーにしか適用されません。 
たとえばブラックリスト中のエントリ "example.com" は、"example.com" にはマッチしますが、"www.example.com" にはマッチしません。 
一方ドット (.) で始まっているドメインは、より特化されたドメインともマッチします。 たとえば、".example.com" は、"www.example.com" と"www.coyote.example.com" の両方にマッチします(が、"example.com" 自身にはマッチしません)。 
IP アドレスは例外で、つねに正確に一致する必要があります。 
たとえば、かりにblocked_domains が "192.168.1.2" と ".168.1.2" を含んでいたとして、192.168.1.2 はブロックされますが、193.168.1.2 はブロックされません。 
DefaultCookiePolicy は以下のような追加メソッドを実装しています: 
ブロックしているドメインのシーケンスを (タプルとして) 返します。 
ブロックするドメインを設定します。 
domain がクッキーを授受しないブラックリストに載っているかどうかを返します。 
None あるいは明示的に許可されているドメインを (タプルとして) 返します。 
許可するドメイン、あるいは None を設定します。 
domain がクッキーを授受するホワイトリストに載っているかどうかを返します。 
サイトに、国別コードとトップレベルドメインだけからなるドメイン名 (.co.uk, .gov.uk,.co.nz など) を設定させないようにします。 
これは完璧からはほど遠い実装であり、いつもうまくいくとは限りません! 
RFC 2965 プロトコルの厳密性に関するスイッチ: 
検証不可能なトランザクション (通常これはリダイレクトか、別のサイトがホスティングしているイメージの読み込み要求です) に関するRFC 2965 の規則に従います。 
この値が偽の場合、検証可能性を基準にしてクッキーがブロックされることは決してありません。 
Netscape プロトコルの厳密性に関するスイッチ: 
検証不可能なトランザクションに関する RFC 2965 の規則を Netscape クッキーに対しても適用します。 
Netscape クッキーに対するドメインマッチングの規則をどの程度厳しくするかを指示するフラグです。 
とりうる値については下の説明を見てください。 
Set-Cookie: ヘッダで、'$' で始まる名前のクッキーを無視します。 
要求した URI にパスがマッチしないクッキの設定を禁止します。 
strict_ns_domain はいくつかのフラグの集合です。 
これはいくつかの値を or することで構成します (たとえばDomainStrictNoDots|DomainStrictNonDomain は両方のフラグが設定されていることになります)。 
クッキーを設定するさい、ホスト名のプレフィクスにドットが含まれるのを禁止します (例: www.foo.bar.com は .bar.com のクッキーを設定することはできません、なぜなら www.foo はドットを含んでいるからです)。 
domain クッキー属性を明示的に指定していないクッキーは、そのクッキーを設定したドメインと同一のドメインだけに返されます(例: example.com からのクッキーに domain クッキー属性がない場合、そのクッキーが spam.example.com に返されることはありません)。 
クッキーを設定するさい、RFC 2965 の完全ドメインマッチングを要求します。 
以下の属性は上記のフラグのうちもっともよく使われる組み合わせで、便宜をはかるために提供されています。 
0 と同じです (つまり、上述の Netscape のドメイン厳密性フラグがすべてオフにされます)。 
DomainStrictNoDots|DomainStrictNonDomain と同じです。 
EditPythonPrefs ダイアログボックスの 「Default startupoptions...」ボタンを押すと、沢山のオプションが現れます。 オプションの中には、スクリプトの終了後に「Output」ウィンドウを開いたままにしておけるようにしたり、スクリプトの実行終了後に対話モードに入れるようにしたりできるものがあります。 
後者はスクリプト実行中に生成されたオブジェクトを調べたい場合にとても便利です。 
2.1 基本的なこと 
2. 新しい型を定義する 
注意:Python 2.2 から、新しい型を定義する方法がかなり変わって(よくなって) います。 
この文書は Python 2.2 およびそれ以降で新しい型をどうやって定義するかについて述べています。 
古いバージョンのPython をサポートする必要がある場合は、この文書の古い版を参照してください。 
2.2.3.1 総称的な属性を管理する 
2.2.3.2 特定の型に特化した属性の管理 
オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義されています。 
ここでは完全な詳細を記述するよりもいくつかのヒントを述べるにとどめます。 ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削除します。 
名前に対して削除を行うと、ローカルまたはグローバル名前空間でのその名前の束縛を解除します。 どちらの名前空間かは、名前が同じコードブロック内の global 文で宣言されているかどうかによります。 
名前が未束縛 (unbound) であるばあい、NameError 例外が送出されます。 
ネストしたブロック中で自由変数 
になっているローカル名前空間上の名前に対する削除は不正な操作になります属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクトに渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。 
以下のトークンは文法上のデリミタとして働きます: 
浮動小数点数や虚数リテラル中にピリオドがあってもかまいません。 
ピリオド三つの列はスライス表記における省略符号 (ellipsis) として特別な意味を持っています。 リスト後半の累算代入演算子 (augmentedassignment operator) は、字句的にはデリミタとして振舞いますが、演算も行います。 
以下の印字可能 ASCII 文字は、他のトークンの一部として特殊な意味を持っていたり、字句解析器にとって重要な意味を持っています: ' " # \ 
以下の印字可能 ASCII 文字は、Python では使われていません。 
これらの文字が文字列リテラルやコメントの外にある場合、無条件にエラーとなります: 
この節では deque をつかったさまざまなアプローチを紹介します。 rotate() メソッドのおかげで、 deque の一部を切り出したり削除したりできることになります。 
たとえば del d[n] の純粋な Python 実装ではpop したい要素まで rotate() します : 
このアプローチをやや変えたものとして、Forth スタイルのスタック操作、つまり dup, drop, swap, over,pick, rot, および roll を実装するのも簡単です。 ラウンドロビンのタスクサーバは deque をつかって、popleft() で現在のタスクを選択し、入力ストリームが使い果たされなければ append() でタスクリストの戻してやることができます: 
複数パスのデータ・リダクション アルゴリズムは、popleft() を複数回呼んで要素をとりだし、リダクション用の関数を適用してからappend() で deque に戻してやることにより、簡潔かつ効率的に表現することができます。 たとえば入れ子状になったリストでバランスされた二進木をつくりたい場合、2つの隣接するノードをひとつのリストにグループ化することになります: 
2 setup スクリプトを書く 
3.1 拡張モジュールの名前とパッケージ 
pure Python モジュールを書くより Python 拡張モジュールを書く方がちょっとだけ複雑なように、 Distutils での拡張モジュールに関する記述もちょっと複雑です。 
仮に、foo.c で実装された拡張モジュール foo が、配布物に一つだけ入ってるとします。 
コンパイラ/リンカに他の情報を与える必要がない場合、この拡張モジュールのための記述はきわめて単純です: 
Extension クラスは、 setup() によって、 distutils.core から import されます。 
従って、拡張モジュールが一つだけ入っていて、他には何も入っていないモジュール配布物を作成するための setup スクリプトは、以下のようになるでしょう: 
Explained クラス (実質的には、Explained クラスの根底にある build_ext コマンドで実装されている、拡張モジュールをビルドする機構) は、Python 拡張モジュールをきわめて柔軟に記述できるようなサポートを提供しています。 これについては後の節で説明します。 
Extension クラスのコンストラクタに与える最初の引数は、常に拡張モジュールの名前にします。 これにはパッケージ名も含めます。 
とすると、拡張モジュールをルートパッケージに置くことになります。 
一方、 Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c']) 
は、同じ拡張モジュールを pkg パッケージの下に置くよう記述しています。 
ソースコードファイルと、作成されるオブジェクトコードはどちらの場合でも同じです; 作成された拡張モジュールがファイルシステム上のどこに置かれるか (すなわち Python の名前空間上のどこに置かれるか) が違うにすぎません。 同じパッケージ内に (または、同じ基底パッケージ下に) いくつもの拡張モジュールがある場合、ext_package キーワード引数をsetup() に指定します。 
とすると、 foo.c をコンパイルして pkg.foo にし、bar.c をコンパイルして pkg.subpkg.bar にします。 
Extension コンストラクタの二番目の引数は、ソースファイルのリストです。 
Distutils は現在のところ、C、C++、そして Objective-Cの拡張しかサポートしていないので、引数は通常 C/C++/Objective-Cソースコードファイルになります。 
(C++ソースコードファイルを区別できるよう、正しいファイル拡張子を使ってください: .cc や.cpp にすれば、 Unix と Windows 用の双方のコンパイラで認識されるようです。 
Extension には三種類のオプション引数: include_dirs, define_macros, そして undef_macros があり、検索対象にするインクルードディレクトリを指定したり、プリプロセッサマクロを定義 (define)/定義解除 (undefine) したりする必要があるとき役立ちます。 例えば、拡張モジュールが配布物ルート下の include ディレクトリにあるヘッダファイルを必要とするときには、include_dirs オプションを使います: 
ここには絶対パスも指定できます; 例えば、自分の拡張モジュールが、/usr の下にX11R6 をインストールした Unix システムだけでビルドされると知っていれば、 
Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11']) のように書けます。 
自分のコードを配布する際には、このような可搬性のない使い方は避けるべきです: おそらく、 C のコードを 
のように書いた方がましでしょう。 他の Python 拡張モジュール由来のヘッダを include する必要があるなら、Distutils の install_header コマンドが一貫した方法でヘッダファイルをインストールするという事実を活用できます。 
例えば、 Numerical Python のヘッダファイルは、 (標準的な Unix がインストールされた環境では) /usr/local/include/python1.5/Numerical にインストールされます。 (実際の場所は、プラットフォームやどの Python をインストールしたかで異なります。 
) Python の include ディレクトリ -- 今の例では/usr/local/include/python1.5 -- は、 Python 拡張モジュールをビルドする際に常にヘッダファイル検索パスに取り込まれるので、C コードを書く上でもっともよいアプローチは、 
となります。 Numerical インクルードディレクトリ自体をヘッダ検索パスに置きたいのなら、このディレクトリを Distutils の 
モジュールを使って見つけさせられます: 
name は定義したいマクロの名前 (文字列) で、value はその値です: value は文字列か None になります。 
(マクロ FOO を None にすると、C ソースコード内で #define FOO と書いたのと同じになります: こう書くと、ほとんどのコンパイラは FOO を文字列 1 に設定します。 
は、全ての C ソースコードファイルの先頭に、以下のマクロ: 
#define NDEBUG 1#define HAVE_STRFTIME#undef HAVE_FOO#undef HAVE_BAR があるのと同じになります。 
拡張モジュールをビルドする際にリンクするライブラリや、ライブラリを検索するディレクトリも指定できます。 
非標準のパス上にあるライブラリをリンクしたいなら、その場所をlibrary_dirs に入れておかなければなりません: 
(繰り返しになりますが、この手の可搬性のない書き方は、コードを配布するのが目的なら避けるべきです。 
) 3.5 その他の操作 
他にもいくつかオプションがあり、特殊な状況を扱うために使います。 
extra_objects オプションには、リンカに渡すオブジェクトファイルのリストを指定します。 
ファイル名には拡張子をつけてはならず、コンパイラで使われているデフォルトの拡張子が使われます。 
extra_compile_args および extra_link_args には、それぞれコンパイラとリンカに渡す追加のコマンドライン引数を指定します。 
export_symbols は Windows でのみ意味があります。 
このオプションには、公開 (export) する (関数や変数の) シンボルのリストを入れられます。 
コンパイルして拡張モジュールをビルドする際には、このオプションは不要です: Distutils は公開するシンボルを自動的にinitmodule に渡すからです。 
デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: __get__(), __set__(), および __delete__()を使って、属性アクセスをオーバライドしているものです。 
これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。 属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。 
例えば、a.x による属性の検索では、まず a.__dict__['x'] 、次に type(a).__dict__['x'] 、そしてtype(a) の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。 しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを定義しているオブジェクトの属性値である場合、Python はデフォルトの動作をオーバライドして、デスクリプタメソッドの方を呼び出します。 
前後する呼び出し連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されているかと、どうやってデスクリプタメソッドが呼ばれるかに依存します。 
直接呼出し (Direct Call) 
最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: x.__get__(a) を行うというものです。 
インスタンス束縛 (Instance Binding) 
新しい形式のクラスのインスタンスに対する束縛では、a.x は呼び出し: type(a).__dict__['x'].__get__(a, type(a)) に変換されます。 
クラス束縛 (Class Binding) 
新しい形式のクラスに対する束縛では、A.x は呼び出し: A.__dict__['x'].__get__(None, A)に変換されます。 
スーパクラス束縛 (Super Binding) 
a が superのインスタンスである場合、束縛 super(B, obj).m() を行うとまず A 、続いて Bに対して obj.__class_.__mro__ を検索し、次に呼び出し: A.__dict__['m'].__get__(obj, A) でデスクリプタを呼び出します。 
インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。 
データデスクリプタでは、__get__() と __set__() を定義します。 
非データデスクリプタには __get__() メソッドしかありません。 
インスタンス辞書内で属性値が再定義されても、データデスクリプタは常にこの値をオーバライドします。 
対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバライドされます。 (staticmethod() や classmethod() を含む) Python メソッドは、非データデスクリプタとして実装されています。 
その結果、インスタンスではメソッドを再定義したりオーバライドできます。 
このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。 
property() 関数はデータデスクリプタとして実装されています。 従って、インスタンスはあるプロパティの動作をオーバライドすることができません。 
``デスクリプタ (descriptor)'' は、あるオブジェクトのいくつかの属性について記述したオブジェクトです。 デスクリプタオブジェクトは型オブジェクトの辞書内にあります。 
組み込みデスクリプタ型の型オブジェクトです。 
バージョン 2.2 で 新たに追加 された仕様です。 PyObject* 
新たな参照. 
デスクリプタオブジェクト descr がデータ属性のデスクリプタの場合には真を、メソッドデスクリプタの場合には偽を返します。 
3.3.2.3 デスクリプタを呼び出す 
3.3.2.2 デスクリプタ (descriptor) の実装 以下のメソッドは、デスクリプタメソッドを持っているクラス (いわゆる デスクリプタ (descriptor) クラス) のインスタンスが別の新たな形式のクラス、いわゆる オーナ (owner) クラスのクラス辞書に存在する場合にのみ適用されます。 
以下の例での ``属性'' とは、属性の名前がオーナクラスの __dict__ に入っているプロパティ (porperty)を検索するためのキーになっているような属性を指します。 
このメソッドは (計算された) 属性値を返すか、AttributeError 例外を送出しなければなりません。 
オーナクラスのインスタンス instance 上の属性を新たな値 valueに設定する際に呼び出されます。 
オーナクラスのインスタンス instance 上の属性を削除する際に呼び出されます。 
ダイアログウィンドウオブジェクトには、Window オブジェクトのメソッドの他に次のメソッドがあります。 
ID resid の DLOG リソースからダイアログウィンドウを作成します。 
ダイアログオブジェクトは self.wid に保存されます。 
アイテム番号 item がヒットされた時に呼ばれます。 
トグルボタンなどの再描画は自分で処理してください。 
辞書表現は、新たな辞書オブジェクトを表します。 
)重複するキー間で衝突が起きても、衝突が検出されることはありません;あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。 
この PyObject のサブタイプは Python の辞書オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python の辞書を表現します。 
このオブジェクトは、Python プログラムにはtypes.DictType および types.DictionaryType として公開されています。 
引数が PyDictObject のときに真を返します。 
p が辞書型オブジェクトであり、かつ辞書型のサブクラスのインスタンスでない場合に真を返します。 バージョン 2.4 で 新たに追加 された仕様です。 
あるマップ型オブジェクトに対して、読み出し専用に制限されたプロキシオブジェクト (proxy object) を返します。 
通常、この関数は動的でないクラス型 (non-dynamic class type) のクラス辞書を変更させないためにプロキシを作成するために使われます。 バージョン 2.2 で 新たに追加 された仕様です。 
現在辞書に入っている全てのキーと値のペアを除去して空にします。 
辞書 p に key が入っているか判定します。 
p の要素が key に一致した場合は 1 を返し、それ以外の場合には 0 を返します。 
エラーの場合 -1を返します。 
この関数は Python の式" 
"と等価です。 バージョン 2.4 で 新たに追加 された仕様です。 
p と同じキーと値のペアが入った新たな辞書を返します。 バージョン 1.6 で 新たに追加 された仕様です。 
辞書 p に、 key をキーとして値 value を挿入します。 
key はハッシュ可能でなければなりません;ハッシュ可能でない場合、 TypeError を送出します。 成功した場合には 0 を、失敗した場合には -1 を返します。 
辞書 p に、 key をキーとして値 value を挿入します。 
key は char* 型でなければなりません。 
キーオブジェクトはPyString_FromString(key) で生成されます。 
成功した場合には 0 を、失敗した場合には -1 を返します。 
辞書 p から key をキーとするエントリを除去します。 key はハッシュ可能でなければなりません; ハッシュ可能でない場合、 TypeError を送出します。 
成功した場合には 0 を、失敗した場合には -1 を返します。 
辞書 p から文字列 key をキーとするエントリを除去します。 
成功した場合には 0 を、失敗した場合には -1 を返します。 
辞書p 内で key をキーとするオブジェクトを返します。 
キー key が存在しない場合には NULL を返しますが、例外をセット しません。 
PyDict_GetItem() と同じですが、key は PyObject*ではなく char* で指定します。 
辞書オブジェクトのメソッド item() のように、辞書内の全ての要素対が入った PyListObject を返します。 (items() については 
を参照してください。 ) 
辞書オブジェクトのメソッド keys() のように、辞書内の全てのキーが入った PyListObject を返します。 (keys() については 
辞書オブジェクトのメソッド values() のように、辞書内の全ての値が入った PyListObject を返します。 (values() については 
辞書内の要素の数を返します。 
辞書に対して "len(p)" を実行するのと同じです。 
辞書 p 内の全てのキー/値のペアにわたる反復処理を行います。 
ppos が参照している int 型は、この関数で反復処理を開始する際に、最初に関数を呼び出すよりも前に 0 に初期化しておかなければなりません; この関数は辞書内の各ペアを取り上げるごとに真を返し、全てのペアを取り上げたことが分かると偽を返します。 
パラメタ pkey および pvalue には、それぞれ辞書の各々のキーと値を指すポインタか、または NULLが入ります。 
この関数から返される参照はすべて借りた参照になります。 反復処理中に ppos を変更してはなりません。 
この値は内部的な辞書構造体のオフセットを表現しており、構造体はスパースなので、オフセットの値に一貫性がないためです。 
以下に例を示します: 
PyObject *key, *value;int pos = 0;while (PyDict_Next(self-dict, pos, key, value)) {/* 取り出した値で何らかの処理を行う... */...} 
反復処理中に辞書 p を変更してはなりません。 
(Python 2.1 からは) 辞書を反復処理する際に、キーに対応する値を変更しても大丈夫になりましたが、キーの集合を変更しないことが前提です。 
PyObject *a, PyObject *b, int override) マップ型オブジェクト b の全ての要素にわたって、反復的にキー/値のペアを辞書 a に追加します。 
C で表せば PyDict_Merge(a, b, 1) と同じ、Python で表せば 
seq2 内のキー/値ペアを使って、辞書a の内容を更新したり統合したりします。 seq2 は、キー/値のペアとみなせる長さ 2 の反復可能オブジェクト(iterable object) を生成する反復可能オブジェクトでなければなりません。 
この例では2つのテキストを比較します。 
初めに、改行文字で終了する独立した1行の連続した(ファイル形式オブジェクトのreadlines()メソッドによって得られるような)テキストを用意します。 
注意:Differオブジェクトをインスタンス化するとき、``junk.''である列と文字をフィルタリングす関数を渡すことができます。 
詳細はDiffer()コンストラクタを参照してください。 
最後に、2つを比較します。 
Differオブジェクトによって抽出された差分は、最小単位の差分を見ても問題なく抽出されます。 
隣接するマッチ列の同期するポイントを制限することで、より長い差異を算出する再帰的なコストでの、局所性の概念を制限します。 Differは、以下のようなコンストラクタを持ちます。 
クラスDiffer 
オプションのパラメータlinejunkとcharjunkはfilter関数のために指定します(もしくはNoneを指定)。 
linejunk:ひとつの文字列引数を受け取れるべき関数です。 文字列がjunkのときにtrueを返します。 
デフォルトでは、Noneであり、どんな行であってもjunkとは見なされません。 
charjunk: この関数は(長さ1の)文字列を引数として受け取り、文字列がjunkであるときにtrueを返します。 デフォルトはNoneであり、どんな文字列もjunkとは見なされません。 
Differオブジェクトは、以下のひとつのメソッドによって使われます(違いを生成します)。 
文字列からなる2つのシーケンスを比較し、差異(を表す文字列からなるシーケンス)を生成します。 Each sequence must contain individual single-line strings endingwith newlines. Such sequences can be obtained from thereadlines() method of file-like objects. The delta generatedalso consists of newline-terminated strings, ready to be printed as-isvia the writelines() method of a file-like object.それぞれのシーケンスは、改行文字によって終了する、独立したひと連なりの文字列でなければなりません。 
そのようなシーケンスは、ファイル形式オブジェクトのreadline()メソッドによって得ることができます。 
(得られる)差異は改行文字で終了する文字列として得られ、ファイル形式オブジェクトのwriteline()メソッドによって出力できる形になっています。 
dircmp のインスタンスは以下のコンストラクタで生成されます: 
クラスdircmp 
dircmp クラスは以下のメソッドを提供しています: 
a および b の間の比較結果を (sys.stdout に) 出力します。 
a および b およびそれらの直下にある共通のサブディレクトリ間での比較結果を出力します。 
a および b およびそれらの共通のサブディレクトリ間での比較結果を (再帰的に比較して) 出力します。 
dircmp は、比較しているディレクトリツリーに関する様々な種類の情報を取得するために使えるような、多くの興味深い属性を提供しています。 __getattr__() フックを経由すると、全ての属性をのろのろと計算するため、速度上のペナルティを受けないのは計算処理の軽い属性を使ったときだけなので注意してください。 
a にあるファイルおよびサブディレクトリです。 hide および ignore でフィルタされています。 
b にあるファイルおよびサブディレクトリです。 hide および ignore でフィルタされています。 
a および b の両方にあるファイルおよびサブディレクトリです。 
a だけにあるファイルおよびサブディレクトリです。 
b だけにあるファイルおよびサブディレクトリです。 
a および b の両方にあるサブディレクトリです。 
a および b の両方にあるファイルです。 
a および b の両方にあり、ディレクトリ間でタイプが異なるか、os.stat() がエラーを報告するような名前です。 
a および b 両方にあり、一致するファイルです。 
a および b 両方にあるが、一致しないファイルです。 
a および b 両方にあるが、比較されなかったファイルです。 
common_dirs のファイル名を dircmp オブジェクトに対応付けた辞書です。 
2 ディレクトリ構造 標準 Python ドキュメントのソース配布物には、数多くのディレクトリが入っています。 
サードパーティ製のドキュメントは、このディレクトリ構造下や似たディレクトリ構造下におく必要はありませんが、Python ドキュメント作成ツールを利用して新たなドキュメントを開発する際に、どこで例題やツールを探せばよいか知っておけば便利でしょう。 
ファイルはREADME や Makefile を含め、ほとんどがその名の通りのファイルです。 
ディレクトリは以下の三つのカテゴリに分かれます: 
ドキュメントソース 
各ドキュメントの LaTeX ソースは、それぞれ別々のディレクトリに配置されています。 
ディレクトリには、各々のドキュメントを漠然と説明する短い名前がついています: 
ディレクトリ 
タイトル 
Macintosh モジュールリファレンス 
Python の更新情報 
出力形式ごとの出力ディレクトリ 
ほとんどの出力形式に対して、出力結果のドキュメントを格納するディレクトリがあり、その出力形式でのドキュメント生成を制御するMakefile が入っています。 
このカテゴリの例外となるのは Portable Document Format (PDF) およびPostScript 版で、これらは paper-a4/ および paper-letter/に出力されます (こうすることで、LaTeX が生成する全ての一時ファイルが用紙サイズごとに同じ場所に置かれ、目立たなくなります)。 
出力形式 
HTML 形式 
GNU info 形式 
iSiloドキュメント (Palm OS 機器用) 
paper-letter/ PDF と PostScript、US-Letter サイズ 
補助ファイル群 
その他のディレクトリは、様々な処理で用いられる補助ファイルを格納するためのものです。 
補助ファイルは、各ドキュメントで共通の LaTeX ドキュメントクラス、LaTeX2HTML のサポートファイル、ドキュメントの構成要素となる雛形ファイル、フォーマット処理の様々なステップを実行するスクリプトなどです。 
内容 
ドキュメント間で共通の文章 
LaTeX2HTML 処理のサポート 
ソースドキュメントの例 
LaTeXスタイルファイル 
独自の処理用スクリプト 
Doc-SIG にはメーリングリストのアーカイブや購読情報があり、http://www.python.org/sigs/doc-sig/ で利用できます。 SIG はドキュメンテーションに関心を持つ全ての人々に解放されています。 
標準ドキュメントに対するコメントやバグ報告はdocs@python.org に送ってください。 
これにはフォーマット、内容、文法的間違いやつづり間違い、そしてこのドキュメント自体に対するコメントも含みます。 
このドキュメントに対するコメントは作者であるfdrake@acm.org に直接送っていただいてもかまいません。 注意:和訳に対するコメントやバグ報告は、SourceForge.jp のプロジェクトページにお寄せください。 
A. 日本語訳について ご意見やご指摘をお寄せになりたい方は、 
3. distutils による C 
3. distutils による C 
4. Windows 上での C 
3.1 拡張モジュールの配布 
拡張モジュールをうまくビルドできたら、三通りの使い方があります。 エンドユーザは普通モジュールをインストールしようと考えます;これには 
を実行します。 モジュールメンテナはソースパッケージを作成します; これには 
プラットフォームに応じて、以下のコマンドのいずれかを使います。 
リリース 2.4 ,平成18年6月27日 更新 ご意見やご指摘をお寄せになりたい方は、 
4 Distutils 固有の用語以下は Distutils を使って Python モジュールを配布する際に使われる特有の用語です: 
モジュール配布物 (module distribution) 
一個のファイルとしてダウンロード可能なリソースの形をとり、一括して インストールされることになっている形態で配られる Python モジュールのコレクションです。 
よく知られたモジュール配布物には、Numeric Python、PyXML、 PIL (the Python Imaging Library)、 mxBase などがあります。 
(パッケージ (package) と呼ばれることもありますが、 Python 用語としてのパッケージとは意味が違います: 一つのモジュール配布物の中には、場合によりゼロ個、一つ、それ以上の Python パッケージが入っています。 ) 
pure モジュール配布物 (pure module distribution) 
pure Python モジュールやパッケージだけが入ったモジュール配布物です。 
``pure 配布物 (pure distribution)'' とも呼ばれます。 
非 pure モジュール配布物 (non-pure module distribution) 
少なくとも一つの拡張モジュールが入ったモジュール配布物です。 
``非 pure 配布物''とも呼びます。 
配布物ルートディレクトリ (distribution root) 
ソースコードツリー(またはソース配布物) ディレクトリの最上階層で、 setup.py のある場所です。 
一般的には、 setup.py はこのディレクトリ上で実行します。 
open()によって返されたDlオブジェクトは次のメソッドを持っています: 
メモリーを除く全てのリソースを解放します。 
nameという名前の関数が参照された共有オブジェクトに存在する場合、そのポインター(整数値)を返します。 
存在しない場合Noneを返します。 
これは次のように使えます: if a.sym('time'): ... a.call('time')... else: ... time.time() 
(0はNULLポインターであるので、この関数は0でない数を返すだろうということに注意してください) 
参照された共有オブジェクトのnameという名前の関数を呼出します。 引数は、Python整数(そのまま渡される)、Python文字列(ポインターが渡される)、None (NULLとして渡される) のどれかでなければいけません。 
Pythonはその文字列が変化させられるのを好まないので、文字列はconst char*として関数に渡されるべきであることに注意してください。 最大で10個の引数が渡すことができ、与えられない引数はNoneとして扱われます。 
関数の返り値はC long(Python整数である)です。 
2.1.1 基本のサンプルにデータとメソッドを追加する 
Python ランタイムでは、すべての Python オブジェクトはPyObject* 型の変数として扱います。 
PyObject はさほど大仰なオブジェクトではなく、単にオブジェクトに対する参照回数と、そのオブジェクトの「タイプオブジェクト (type object)」へのポインタを格納しているだけです。 
重要な役割を果たしているのはこのタイプオブジェクトです。 
この手のことは例を見たほうが早いでしょうから、ここに最小限の、しかし完全な、新しい型を定義するモジュールをあげておきます: 
さしあたって覚えておくことは以上ですが、これで前の章からすこしは説明がわかりやすくなっていることと思います。 最初に習うのは、つぎのようなものです: 
これが Noddy オブジェクトの内容です -- このケースでは、ほかの Python オブジェクトが持っているものと何ら変わりはありません。 つまり参照カウントと型オブジェクトへのポインタですね。 
これらは PyObject_HEAD マクロによって展開されるメンバです。 
マクロを使う理由は、レイアウトを標準化するためと、デバッグ用ビルド時に特別なデバッグ用のメンバを定義できるようにするためです。 
この PyObject_HEAD マクロの後にはセミコロンがないことに注意してください。 セミコロンはすでにマクロ内に含まれています。 
うっかり後にセミコロンをつけてしまわないように気をつけて。 
これはお使いの機種では何の問題も起こらないかもしれませんが、機種によっては、おそらく問題になるのです! (Windows 上では、MS Visual C がこの手のエラーを出し、コンパイルできないことが知られています)比較のため、以下に標準的な Python の整数型の定義を見てみましょう: 
typedef struct {PyObject_HEADlong ob_ival;} PyIntObject; では次にいってみます。 
かなめの部分、タイプオブジェクトです。 
object.h の中にある PyTypeObject の定義を見ると、実際にはここに挙げた以上の数のメンバがあるとわかるでしょう。 
これ以外のメンバは C コンパイラによってゼロに初期化されるので、必要な時を除いてふつうはそれらの値を明示的には指定せずにおきます。 次のものは非常に重要なので、とくに最初の最初に見ておきましょう: 
これはちょっとぶっきらぼうですね。 実際に書きたかったのはこうです: 
この場合、タイプオブジェクトの型は「type」という名前になりますが、これは厳密には C の基準に従っておらず、コンパイラによっては文句を言われます。 
幸いにも、このメンバは PyType_Ready() が埋めてくれます。 
ヘッダ中の ob_size メンバは使われていません。 これは歴史的な遺物であり、構造体中にこれが存在しているのは古いバージョンの Python 用にコンパイルされた拡張モジュールとのバイナリ上の互換性を保つためです。 
ここにはつねにゼロを指定してください。 
これは型の名前です。 
この名前はオブジェクトのデフォルトの表現形式と、いくつかのエラーメッセージ中で使われます。 
たとえば: "" + noddy.new_noddy()Traceback (most recent call last):File "stdin", line 1, in ?TypeError: cannot add type "noddy.Noddy" to string 
注意: この名前はドットで区切られた名前で、モジュール名と、そのモジュール内での型名を両方ふくんでいます。 
この場合のモジュールは noddy で、型の名前はNoddy ですから、ここでの型名としては noddy.Noddy を指定するわけです。 
これによって Python は PyObject_New() が呼ばれたときにどれくらいの量のメモリを割り当てればよいのか知ることができます。 
注意:あなたのタイプを Python でサブクラス化可能にしたい場合、そのタイプが基底タイプと同じ tp_basicsize をもっていると多重継承のときに問題が生じることがあります。 
そのタイプを Python のサブクラスにしたとき、その __bases__ リストにはあなたのタイプが最初にくるようにしなければなりません。 さもないとエラーの発生なしにあなたのタイプの __new__ メソッドを呼び出すことはできなくなります。 
この問題を回避するには、つねにあなたのタイプの tp_basicsize をその基底タイプよりも大きくしておくことです。 
ほとんどの場合、あなたのタイプは object か、そうでなければ基底タイプにデータ用のメンバを追加したものでしょうから、したがって大きさはつねに増加するためこの条件は満たされています。 
これはリストや文字列などの可変長オブジェクトのためのものです。 
すべての型はフラグにこの定数を含めておく必要があります。 
これは現在のバージョンの Python で定義されているすべてのメンバを許可します。 この型の docstring は tp_doc に入れます。 
ここからタイプメソッドに入るわけですが。 ここがあなたのオブジェクトが他と違うところです。 
オブジェクトの作成を許可するには、tp_new の実装を提供する必要があります。 
今回は、API 関数によって提供されるデフォルトの実装 PyType_GenericNew() を使うだけにしましょう。 
これを単に tp_new スロットに代入すればよいのですが、これは互換上の理由からできません。 プラットフォームやコンパイラによっては、構造体メンバの初期化に別の場所で定義されている C の関数を代入することはできないのです。 
この関数は、上で NULLに指定していた ob_type などのいくつものメンバを埋めて、Noddy 型を初期化します。 
これはこの型をモジュール中の辞書に埋め込みます。 
これで、Noddy クラスを呼べば Noddy インスタンスを作れるようになりました: 
これだけです! 残るはこれをどうやってビルドするかということです。 
上のコードを noddy.c というファイルに入れて、以下のものを setup.py というファイルに入れましょう。 
そして、シェルから以下のように入力します。 
何もデータを持ってないし、何もしてはくれません。 
継承してサブクラスを作ることさえできないのです。 
2.1.3 循環ガベージコレクションをサポートする 
たくさんのメソッドがありますね。 
型を初期化するさいに、これらのメンバを正しい順序で並べるよう、くれぐれも注意してください。 
ふつういちばん簡単なのは、必要なメンバがすべて含まれている(たとえそれらが 0 に初期化されていても) 例をとってきて、自分の型に合わせるよう変更をくわえることです。 char *tp_name; /* 表示用 */ 
これは型の名前です。 
前節で説明したように、これはいろいろな場面で現れ、ほとんどは診断用の目的で使われるものです。 なので、そのような場面で役に立つであろう名前を選んでください。 
int tp_basicsize, tp_itemsize; /* 割り当て用 */ 
これらのメンバは、この型のオブジェクトが作成されるときにどれだけのメモリを割り当てればよいのかをランタイムに指示します。 
Python には可変長の構造体(文字列やリストなどを想像してください) に対する組み込みのサポートがある程度あり、ここで tp_itemsize メンバが使われます。 
これらについてはあとでふれます。 
DocXMLRPCServer はSimpleXMLRPCServer.SimpleXMLRPCServer の派生クラスで、セルフ- ドキュメンティングの手段と XML-RPC サーバ機能を提供します。 
HTTP POST リクエストは XML-RPC メソッドの呼び出しとして扱われます。 
HTTP GET リクエストは pydoc スタイルの HTML ドキュメント生成のリクエストとして扱われます。 
これはサーバが自分自身のドキュメントを Web ベースで提供可能であることを意味します。 
生成する HTML ドキュメントのタイトルをセットします。 
このタイトルはHTML の title 要素として使われます。 
生成する HTML ドキュメントの名前をセットします。 
この名前はHTML 冒頭の h1 要素に使われます。 set_server_documentation 
生成する HTML ドキュメントの本文をセットします。 
この本文はドキュメント中の名前の下にパラグラフとして出力されます。 
5.2.9.1 DocTest オブジェクト 
5.2.9.2 Example オブジェクト 
クラスDocTest 
単一の名前空間内で実行される doctest 例題の集まりです。 
コンストラクタの引数は DocTest インスタンス中の同名のメンバ変数の初期化に使われます。 バージョン 2.4 で 新たに追加 された仕様です。 
DocTest では、以下のメンバ変数を定義しています。 
これらの変数はコンストラクタで初期化されます。 直接変更してはなりません。 
対話モードにおける例題それぞれをエンコードしていて、テストで実行される、Example オブジェクトからなるリストです。 
例題を実行する名前空間 (いわゆるグローバル変数) です。 このメンバは、名前から値への対応付けを行っている辞書です。 
例題が名前空間に対して (新たな変数をバインドするなど)何らかの変更を行った場合、globs への反映はテストの実行後に起こります。 
DocTest を識別する名前の文字列です。 
通常、この値はテストを取り出したオブジェクトかファイルの名前になります。 
DocTest を取り出したファイルの名前です;ファイル名が未知の場合や DocTest をファイルから取り出したのでない場合にはNone になります。 
filename 中でDocTest のテスト例題が始まっている行の行番号です。 
行番号は、ファイルの先頭をゼロとして数えます。 
テストを取り出した docstring 自体を現す文字列です。 docstring 文字列を得られない場合や、文字列からテスト例題を取り出したのでない場合には None になります。 
5.2.9.3 DocTestFinder オブジェクト 
5.2.9.4 DocTestParser オブジェクト 
クラスDocTestFinder 
与えられたオブジェクトについて、その docstring か、そのオブジェクトに入っているオブジェクトの docstring からDocTest を抽出する処理クラスです。 
現在のところ、モジュール、関数、クラス、メソッド、静的メソッド、クラスメソッド、プロパティからDocTest を抽出できます。 オプション引数 verbose を使うと、抽出処理の対象となるオブジェクトを表示できます。 
DocTestFinder では以下のメソッドを定義しています: 
name を指定しない場合、 
obj.__name__ を使います。 オプションのパラメタ module は、指定したオブジェクトを収めているモジュールを指定します。 
module を指定しないか、None を指定した場合には、正しいモジュールを自動的に決定しようと試みます。 
オブジェクトのモジュールは以下のような役割を果たします: 
globs を指定していない場合、オブジェクトのモジュールはデフォルトの名前空間になります。 
他のモジュールから import されたオブジェクトに対してDocTestFinder がDocTest を抽出するのを避けるために使います (module 由来でないオブジェクトを無視します)。 
オブジェクトの入っているファイル名を調べるために使います。 
オブジェクトがファイル内の何行目にあるかを調べる手助けにします。 
module が False の場合には、モジュールの検索を試みません。 
各々の DocTest に対して、グローバル変数を表す辞書の新たな浅いコピーを生成します。 
globs を指定しない場合に使われるのデフォルト値は、モジュールを指定していればそのモジュールの __dict__ になり、指定していなければ{} になります。 
extraglobs を指定しない場合、デフォルトの値は{} になります。 
5.2.9.5 DocTestRunner オブジェクト 
クラスDocTestParser 
対話モードの例題を文字列から抽出し、それを使ってDocTest オブジェクトを生成するために使われる処理クラスです。 バージョン 2.4 で 新たに追加 された仕様です。 
DocTestParser では以下のメソッドを定義しています: 
指定した文字列から全ての doctest 例題を抽出し、DocTestオブジェクト内に集めます。 
globs, name, filename, および lineno は新たに作成される DocTest オブジェクトの属性になります。 
詳しくはDocTest のドキュメントを参照してください。 
指定した文字列から全ての doctest 例題を抽出し、Example オブジェクトからなるリストにして返します。 
各Example の行番号はゼロから数えます。 
オプション引数name はこの文字列につける名前で、エラーメッセージにしか使われません。 
指定した文字列を、例題とその間のテキストに分割し、例題をExample オブジェクトに変換し、Example と文字列からなるリストにして返します。 各Example の行番号はゼロから数えます。 
オプション引数name はこの文字列につける名前で、エラーメッセージにしか使われません。 
5.2.9.6 OutputChecker オブジェクト 
クラスDocTestRunner 
DocTest 内の対話モード例題を実行し、検証する際に用いられる処理クラスです。 予想出力と実際の出力との比較は OutputChecker で行います。 
比較は様々なオプションフラグを使ってカスタマイズできます;詳しくは5.2.6 を参照してください。 
デフォルトはsys.stdout.write です。 
verbose がTrueの場合、各例題を実行するつど、その例題についての情報を出力します。 
verbose がFalse の場合、テストの失敗だけを出力します。 
verbose を指定しない場合やNone を指定した場合、コマンドラインスイッチ -v を使った場合にのみverbose 出力を適用します。 オプションのキーワード引数optionflags を使うと、テストランナが予想出力と実際の出力を比較する方法や、テストの失敗を表示する方法を制御できます。 
詳しくは5.2.6 節を参照してください。 
DocTestRunner では、以下のメソッドを定義しています: 
test は example の入っているテストです。 
out は出力用の関数で、DocTestRunner.run() に渡されます。 report_success 
与えられた例題が正しく動作したことを報告します。 
このメソッドは DocTestRunner のサブクラスで出力をカスタマイズできるようにするために提供されています;直接呼び出してはなりません。 
与えられた例題が正しく動作しなかったことを報告します。 
このメソッドは DocTestRunner のサブクラスで出力をカスタマイズできるようにするために提供されています;直接呼び出してはなりません。 
与えられた例題が予想とは違う例外を送出したことを報告します。 このメソッドは DocTestRunner のサブクラスで出力をカスタマイズできるようにするために提供されています;直接呼び出してはなりません。 
test 内の例題 (DocTest オブジェクト) を実行し、その結果を出力用の関数out を使って表示します。 
compileflags には、例題を実行する際に Python コンパイラに適用するフラグセットを指定します。 
compileflags を指定しない場合、デフォルト値はglobs で適用されている future-import フラグセットになります。 各例題の出力は DocTestRunner の出力チェッカで検査され、その結果は DocTestRunner.report_*. メソッドで書式化されます。 
この DocTestRunner が実行した全てのテストケースのサマリを出力し、タプル"(failure_count, test_count)" を返します。 オプションのverbose 引数を使うと、どのくらいサマリを詳しくするかを制御できます。 
冗長度を指定しない場合、DocTestRunner自体の冗長度を使います。 
クラスExample 
ひとつの Python 文と、それに対する予想出力からなる、単一の対話的モードの例題です。 
コンストラクタの引数は Example インスタンス中の同名のメンバ変数の初期化に使われます。 バージョン 2.4 で 新たに追加 された仕様です。 
Example では、以下のメンバ変数を定義しています。 
例題のソースコードが入った文字列です。 
ソースコードは単一のPython で、末尾は常に改行です。 コンストラクタは必要に応じて改行を追加します。 
コンストラクタは必要に応じて改行を追加します。 
例題が例外を生成すると予想される場合の例外メッセージです。 
例外を送出しない場合には None です。 この例外メッセージは、traceback.format_exception_only()の戻り値と比較されます。 
値が None でない限り、exc_msgは改行で終わっていなければなりません; コンストラクタは必要に応じて改行を追加します。 
この例題の入っている文字列中における、例題の実行文のある行のの行番号です。 
行番号は文字列の先頭をゼロとして数えます。 
例題の入っている文字列のインデント、すなわち例題の最初のプロンプトより前にある空白文字の数です。 
オプションフラグを True または False に対応付けている辞書です。 例題に対するデフォルトオプションを上書きするために用いられます。 
この辞書に入っていないオプションフラグはデフォルトの状態 (DocTestrunner の optionflags の内容) のままになります。 
クラスOutputChecker 
doctest 例題を実際に実行したときの出力が予想出力と一致するかどうかをチェックするために使われるクラスです。 
OutputChecker では、与えられた二つの出力を比較して、一致する場合には真を返すcheck_output と、二つの出力間の違いを説明する文字列を返すoutput_difference の、二つのメソッドがあります。 バージョン 2.4 で 新たに追加 された仕様です。 
OutputChecker では以下のメソッドを定義しています: 
例題から実際に得られた出力 (got) と、予想出力 (want)が一致する場合にのみTrue を返します。 
二つの文字列が全く同一の場合には常に一致するとみなしますが、テストランナの使っているオプションフラグにより、厳密には同じ内容になっていなくても一致するとみなす場合もあります。 
オプションフラグについての詳しい情報は5.2.6 節を参照してください。 
与えられた例題の予想出力 (want)と、実際に得られた出力(got) の間の差異を解説している文字列を返します。 optionflags はwant とgot を比較する際に使われるオプションフラグのセットです。 
基本 API は、 doctest を使いやすくするための簡単なラッパであり、柔軟性があってほとんどのユーザの必要を満たしています; とはいえ、もっとテストをきめ細かに制御したい場合や、 doctest の機能を拡張したい場合、拡張 API (advanced API) を使わねばなりません。 
拡張 API は、doctest ケースから抽出した対話モードでの例題を記憶するための二つのコンテナクラスを中心に構成されています: 
Example: 一つの Python 実行文と、その予想出力をペアにしたもの。 
DocTest: Example の集まり。 通常一つの docstring やテキストファイルから抽出されます。 
その他に、 doctest の例題を検索、パーズ、実行、チェックするための処理クラスが以下のように定義されています: 
DocTestFinder: 与えられたモジュールから全てのdocstring を検索し、対話モードでの例題が入った各 docstring からDocTestParser を使ってDocTest を生成します。 
DocTestParser: (オブジェクトにつけられた docstring のような)文字列からDocTest オブジェクトを生成します。 
DocTestRunner: DocTest 内の例題を実行し、OutputChecker を使って出力を検証します。 
OutputChecker: doctest 例題から実際に出力された結果を予想出力と比較し、両者が一致するか判別します。 
これらの処理クラスの関係を図にまとめると、以下のようになります: 
5.2.6.2 注意 
関数 testmod() および testfile() は、基本的なほとんどの用途に十分な doctest インタフェースを提供しています。 
これら二つの関数についてもっとくだけた説明を読みたければ、5.2.1 節および 5.2.2 節を参照してください。 
filename 以外の引数は全てオプションで、キーワード引数形式で指定せねばなりません。 filename に指定したファイル内にある例題をテストします。 
"(failure_count, test_count)" を返します。 オプション引数の module_relative は、ファイル名をどのように解釈するかを指定します: 
module_relative が True (デフォルト) の場合、filename は OS に依存しないモジュールの相対パスになります。 
デフォルトでは、このパスは関数 testfile を呼び出しているモジュールからの相対パスになります; ただし、package引数を指定した場合には、パッケージからの相対になります。 
OS への依存性を除くため、filename ではパスを分割する文字に/ を使わねばならず、絶対パスにしてはなりません(パス文字列を/ で始めてはなりません)。 
module_relative が False の場合、filenameは OS 依存のパスを示します。 
パスは絶対パスでも相対パスでもかまいません; 相対パスにした場合、現在の作業ディレクトリを基準に解決します。 
オプション引数 name には、テストの名前を指定します; デフォルトの場合や None を指定した場合、 os.path.basename(filename) になります。 オプション引数 package には、 Python パッケージを指定するか、モジュール相対のファイル名の場合には相対の基準ディレクトリとなるPython パッケージの名前を指定します。 
パッケージを指定しない倍、関数を呼び出しているモジュールのディレクトリを相対の基準ディレクトリとして使います。 
マージはdict.update() のように振舞います: globs とextraglobs との間に同じキー値がある場合、両者を合わせた辞書中にはextraglobs の方の値が入ります。 
この仕様は、パラメタ付きで doctest を実行するという、やや進んだ機能です。 
オプション引数report が真の場合、テストの最後にサマリを出力します。 
オプション引数 raise_on_error の値はデフォルトでは偽です。 
真にすると、最初のテスト失敗や予期しない例外が起きたときに例外を送出します。 
デフォルトでは通常のパーザ ( 
DocTestParser()) です。 
m.__test__ が存在し、None でない場合、この辞書から到達できる例題もテストします。 
オプション引数 exclude_empty はデフォルトでは偽になっています。 
m.__dict__ になります。 オプション引数 isprivate には、ある名前がプライベート名であるかどうかを決定する関数を指定します。 
リリース 2.4 で撤廃されました。 
isprivate を使うのは賢くありません -使わないようにしてください。 名前に基づいてテストをスキップしたければ、DocTestFinder.find() の返すリストをフィルタしてください。 
バージョン 2.3 で 変更 された仕様:optionflags パラメタを追加しました 
バージョン 2.4 で 変更 された仕様:extraglobs, raise_on_errorおよびexclude_empty パラメタを追加しました 
単一のオブジェクトに関連付けられた doctest を実行するための関数もあります。 この関数は以前のバージョンとの互換性のために提供されています。 
この関数を撤廃する予定はありませんが、役に立つことはほとんどありません: 
オブジェクト f に関連付けられた例題をテストします。 
デフォルトでは、例題のテストに失敗したときのみ出力を生成します。 オプション引数compileflags には、例題を実行するときに Python バイトコードコンパイラが使うフラグを指定します。 
デフォルトの場合やNone を指定した場合、フラグはglobs 内にある future機能セットに対応したものになります。 オプション引数 optionflags は、上で述べたtestfile()と同様の働きをします。 
5.2.11 提言 
doctest では、doctest 例題をデバッグするメカニズムをいくつか提供しています: 
doctest を実行可能な Python プログラムに変換し、 Python デバッガ 
で実行できるようにするための関数がいくつかあります。 
DocTestSuite() の生成する 
テストケースは、debug() メソッドをサポートしています。 debug() は 
.TestCase で定義されています。 
.set_trace() を doctest 例題の中で呼び出しておけば、その行が実行されたときに Python デバッガが組み込まれます。 
デバッガを組み込んだあとは、変数の現在の値などを調べられます。 
たとえば、以下のようなモジュールレベルの docstring の入ったファイルa.py があるとします: 
対話セッションは以下のようになるでしょう: 
バージョン 2.4 で 変更 された仕様: 
.set_trace() を doctest の中で有効に使えるようになりました 
以下は、doctest を Python コードに変換して、できたコードをデバッガ下で実行できるようにするための関数です: 
例題の入ったテキストをスクリプトに変換します。 引数s は doctest 例題の入った文字列です。 
この文字列は Python スクリプトに変換され、その中では s の doctest 例題が通常のコードに、それ以外は Python のコメント文になります。 
生成したスクリプトを文字列で返します。 
例えば、 import doctestprint doctest.script_from_examples(r"""Set x and y to 1 and 2. x, y = 1, 2Print their sum: print x+y3""") 
は、 
# Set x and y to 1 and 2.x, y = 1, 2## Print their sum:print x+y# Expected:## 3 になります。 
この関数は他の関数 (下記参照) から使われていまるが、対話セッションをPython スクリプトに変換したいような場合にも便利でしょう。 
あるオブジェクトの doctest をスクリプトに変換します。 引数module はモジュールオブジェクトか、対象の doctest を持つオブジェクトの入ったモジュールのドット表記名です。 
引数name は対象の doctest を持つオブジェクトの (モジュール内の)名前です。 
対象オブジェクトの docstring を上のscript_from_examples() で説明した方法で Python スクリプトに変換してできた文字列を返しますます。 
例えば、a.py モジュールのトップレベルに関数 f() がある場合、以下のコード 
を実行すると、f() の docstring から doctest をコードに変換し、それ以外をコメントにしたスクリプトを出力します。 
オブジェクトの持つ doctest をデバッグします。 module および name 引数は上の testsource()と同じです。 
指定したオブジェクトの docstring から合成された Python スクリプトは一時ファイルに書き出され、その後 Python デバッガ 
オプション引数pm は、検死デバッグを行うかどうかを指定します。 
pm が真の場合、スクリプトファイルは直接実行され、スクリプトが送出した例外が処理されないまま終了した場合にのみデバッガが立ち入ります。 
その場合、 
.post_mortem() によって検死デバッグを起動し、処理されなかった例外から得られたトレースバックオブジェクトを渡します。 
pm を指定しないか値を偽にした場合、 
.run() に適切な execfile() 呼び出しを渡して、最初からデバッガの下でスクリプトを実行します。 
バージョン 2.4 で 変更 された仕様:引数pm を追加しました 
文字列中の doctest をデバッグします。 
globs を指定しない場合やNone にした場合、空の辞書を使います。 
辞書を指定した場合、実際の実行コンテキストには浅いコピーが使われます。 
DebugRunner クラス自体やDebugRunner クラスが送出する特殊な例外は、テストフレームワークの作者にとって非常に興味のあるところでThe DebugRunner class, and the special exceptions it may raise,are of most interest to testing framework authors, and will only besketched here. 詳しくはソースコード、とりわけDebugRunner の docstring(それ自体 doctest ですよ!) を参照してください。 
クラスDebugRunner 
テストの失敗に遭遇するとすぐに例外を送出するようになっているDocTestRunner のサブクラスです。 
予期しない例外が生じると、UnexpectedException 例外を送出します。 この例外には、テスト、例題、もともと送出された例外が入っています。 
DebugRunner インスタンスの送出する例外には以下の二つがあります: 
例外DocTestFailure 
doctest 例題の実際の出力が予想出力と一致しなかったことを示すためにDocTestRunner が送出する例外です。 コンストラクタの引数は、インスタンスの同名のメンバ変数を初期化するために使われます。 
DocTestFailure では以下のメンバ変数を定義しています: 
例題が失敗した時に実行されていたDocTest オブジェクトです。 
失敗した Example オブジェクトです。 
例題の実際の出力です。 
例外UnexpectedException 
doctest 例題が予期しない例外を送出したことを示すためにDocTestRunner が送出する例外です。 
コンストラクタの引数は、インスタンスの同名のメンバ変数を初期化するために使われます。 
UnexpectedException では以下のメンバ変数を定義しています: 
予期しない例外についての情報の入ったタプルで、sys.exc_info() が返すのと同じものです。 
5.2.4 ドキュメンテーション文字列内の例をどうやって認識するのか? 
5.2.3.1 どのドキュメンテーション文字列が検証されるのか? 
5.2.5 実行コンテキストとは何か? 
5.2.4 ドキュメンテーション文字列内の例をどうやって認識するのか? 
ほとんどの場合、対話コンソールセッション上でのコピー/ペーストはうまく動作します。 とはいえ、 doctest は特定の Python シェルの振る舞いを正確にエミュレーションしようとするわけではありません。 
ハードタブは全て 8 カラムのタブストップを使ってスペースに展開されます。 
従って、タブがそのように表現されると考えておかないととまずいことになります:その場合は、ハードタブを使わないか、自前で DocTestParserクラスを書いてください。 
バージョン 2.4 で 変更 された仕様:新たにタブをスペースに展開するようになりました; 以前のバージョンはハードタブを保存しようとしていたので、混乱させるようなテスト結果になってしまっていました 
出力結果例には、全て空白の行が入っていてはなりません。 
stdout への出力は取り込まれますが、stderr は取り込まれません (例外発生時のトレースバックは別の方法で取り込まれます)。 
対話セッションにおいて、バックスラッシュを用いて次の行に続ける場合や、その他の理由でバックスラッシュを用いる場合、raw docstring を使ってバックスラッシュを入力どおりに扱わせるようにせねばなりません: 
こうしなければ、バックスラッシュは文字列の一部として解釈されてしまいますう。 例えば、上の例の "" は改行文字として認識されてしまうでしょう。 
こうする代わりに、(raw docstring を使わずに) doctest 版の中ではバックスラッシュを全て二重にしてもかまいません: 
開始カラムはどこでもかまいません: 
出力結果例の先頭部にある空白文字列は、例題の開始部分にあたる'' 行の先頭にある空白文字列と同じだけはぎとられます。 
5.2.3 doctest のからくり 
5.2.2 簡単な利用法: テキストファイル中の例題をチェックする 
この節では、doctest のからくり: どの docstring を見に行くのか、どうやって対話操作例を見つけ出すのか、どんな実行コンテキストを使うのか、例外をどう扱うか、上記の振る舞いを制御するためにどのようなオプションフラグを使うか、について詳しく吟味します。 
5.2.6.1 オプションフラグとディレクティブ 
5.2.6 例外はどう扱えばよいのですか? 
5.2.6 例外はどう扱えばよいのですか? 
doctest では、その挙動の様々な側面をたくさんのオプションフラグで制御しています。 
各フラグのシンボル名はモジュールの定数として提供されており、論理和で組み合わせて様々な関数に渡せるようになっています。 
デフォルトでは、予想出力ブロックに単に1 だけが入っており、実際の出力ブロックに 1 または True だけが入っていた場合、これらの出力は一致しているとみなされます。 
0 と False の場合も同様です。 
DONT_ACCEPT_TRUE_FOR_1 を指定すると、こうした値の読み替えを行いません。 デフォルトの挙動で読み替えを行うのは、最近の Python で多くの関数の戻り値型が整数型からブール型に変更されたことに対応するためです; 読み替えを行う場合、"通常の整数" の出力を予想出力とするような doctest も動作します。 
このオプションはそのうち無くなるでしょうが、ここ数年はそのままでしょう。 
デフォルトでは、予想出力ブロックに BLANKLINE だけの入った行がある場合、その行は実際の出力における空行に一致するようになります。 
完全な空行を入れてしまうと予想出力がそこで終わっているとみなされてしまうため、空行を予想出力に入れたい場合にはこの方法を使わねばなりません。 
DONT_ACCEPT_BLANKLINE を指定すると、BLANKLINE の読み替えを行わなくなります。 
NORMALIZE_WHITESPACE このフラグを指定すると、空白 (空白と改行文字) の列は互いに等価であるとみなします。 
このフラグを指定すると、予想出力中の省略記号マーカ (...) を実際の出力中の任意の部分文字列に一致させられます。 
部分文字列は行境界にわたるものや空文字列を含みます。 従って、このフラグを使うのは単純な内容を対象にする場合にとどめましょう。 
複雑な使い方をすると、正規表現に .* を使ったときのように"あらら、省略部分をマッチがえてる (match too much) !" と驚くことになりかねません。 
このフラグを指定すると、予想される実行結果に例外が入るような例題で、予想通りの型の例外が送出された場合に、例外の詳細情報が一致していなくてもテストをパスさせます。 
例えば、予想出力が"ValueError: 42" であるような例題は、実際に送出された例外が"ValueError: 3*14" でもパスしますが、TypeError が送出されるといった場合にはパスしません。 ELLIPSIS を使っても同様のことができ、IGNORE_EXCEPTION_DETAIL は リリース 2.4 以前の Pythonを使う人がほとんどいなくなった時期を見計らって撤廃するかもしれないので気をつけてください。 
それまでは、IGNORE_EXCEPTION_DETAIL は2.4 以前の Python で例外の詳細については気にせずテストをパスさせるようにdoctest を書くための唯一の明確な方法です。 
にすると、 Python 2.4 と Python 2.3 の両方でテストをパスさせられます。 
というのは、例外の詳細情報は 2.4 で変更され、 "doesn't" から "does not" と書くようになったからです。 
上記の比較フラグ全ての論理和をとったビットマスクです。 
二つ目のオプション群は、テストの失敗を報告する方法を制御します: 
このオプションを指定すると、複数行にわたる予想出力や実際の出力を、一元化 (unified) diff を使って表示します。 
このオプションを指定すると、複数行にわたる予想出力や実際の出力を、コンテキスト diff を使って表示します。 
このオプションを指定すると、予想出力と実際の出力との間の差分をよく知られているndiff.py ユーティリティと同じアルゴリズムを使っている difflib.Differ で分析します。 
これは、行単位の差分と同じように行内の差分にマーカをつけられるようにする唯一の手段です。 
例えば、予想出力のある行に数字の 1 が入っていて、実際の出力には l が入っている場合、不一致のおきているカラム位置を示すキャレットの入った行が一行挿入されます。 
このオプションを指定すると、各 doctest で最初にエラーの起きた例題だけを表示し、それ以後の例題の出力を抑制します。 
これにより、正しく書かれた例題が、それ以前の例題の失敗によっておかしくなってしまった場合に、doctest がそれを報告しないようになります。 とはいえ、最初に失敗を引き起こした例題とは関係なく誤って書かれた例題の報告も抑制してしまいます。 
REPORT_ONLY_FIRST_FAILURE を指定した場合、例題がどこかで失敗しても、それ以後の例題を続けて実行し、失敗したテストの総数を報告します; 出力が抑制されるだけです。 
上記のエラー報告に関するフラグ全ての論理和をとったビットマスクです。 
「doctest ディレクティブ」を使うと、個々の例題に対してオプションフラグの設定を変更できます。 
doctest ディレクティブは特殊な Python コメント文として表現され、例題のソースコードの後に続けます: 
+ や- とディレクティブオプション名の間に空白を入れてはなりません。 
ディレクティブオプション名は上で説明したオプションフラグ名のいずれかです。 ある例題の doctest ディレクティブは、その例題だけの doctest の振る舞いを変えます。 
ある特定の挙動を有効にしたければ + を、無効にしたければ - を使います。 例えば、以下のテストはパスします: 
ディレクティブがない場合、実際の出力には一桁の数字の間に二つスペースが入っていないこと、実際の出力は 1 行になることから、テストはパスしないはずです。 
別のディレクティブを使って、このテストをパスさせることもできます: 
複数のディレクティブは、一つの物理行の中にコンマで区切って指定できます: 
一つの例題中で複数のディレクティブコメントを使った場合、それらは組み合わされます: 
前の例題で示したように、"..." の後ろにディレクティブだけの入った行を例題のうしろに追加して書けます。 
この書きかたは、例題が長すぎるためにディレクティブを同じ行に入れると収まりが悪い場合に便利です: 
デフォルトでは全てのオプションが無効になっており、ディレクティブは特定の例題だけに影響を及ぼすので、通常意味があるのは有効にするためのオプション(+ のついたディレクティブ) だけです。 
とはいえ、doctest を実行する関数はオプションフラグを指定してデフォルトとは異なった挙動を実現できるので、そのような場合には - を使った無効化オプションも意味を持ちます。 
バージョン 2.4 で 変更 された仕様:Constants DONT_ACCEPT_BLANKLINE,NORMALIZE_WHITESPACE, ELLIPSIS,IGNORE_EXCEPTION_DETAIL,REPORT_UDIFF, REPORT_CDIFF,REPORT_NDIFF, REPORT_ONLY_FIRST_FAILURE,COMPARISON_FLAGS and REPORTING_FLAGSを追加しました。 
予想出力中の BLANKLINE がデフォルトで実際の出力中の空行にマッチするようになりました。 また、doctest ディレクティブが追加されました 
新たなオプションフラグ名を登録する方法もありますが、 
の内部をサブクラスで拡張しない限り、意味はないでしょう: 
名前name の新たなオプションフラグを作成し、作成されたフラグの整数値を返します。 register_optionflag() はOutputChecker や DocTestRunner をサブクラス化して、その中で新たに作成したオプションをサポートさせる際に使います。 
register_optionflag は以下のような定形文で呼び出さねばなりません: MY_FLAG = register_optionflag('MY_FLAG') 
5.2.1 簡単な利用法: docstring 中の例題をチェックする 
doctest のもう一つの簡単な用途は、テキストファイル中にある対話操作の例に対するテストです。 
これには testfile() 関数を使います: 
この短いスクリプトは、example.txt というファイルの中に入っている対話モードの Python 操作例全てを実行して、その内容を検証します。 
ファイルの内容は一つの巨大な docstring であるかのように扱われます;ファイルが Python プログラムでなくてもよいのです! 例えば、example.txt には以下のような内容が入っているかもしれません: 
doctest.testfile("example.txt") を実行すると、このドキュメント内のエラーを見つけ出します: 
testmod() と同じく、testfile() は例題が失敗しない限り何も表示しません。 
例題が失敗すると、失敗した例題とその原因が(場合によっては複数) testmod() と同じ書式で標準出力に書き出されます。 デフォルトでは、testfile() は自分自身を呼び出したモジュールのあるディレクトリを探します。 
doctest を試す簡単な方法、(とはいえ、いつもそうする必要はないのですが) は、各モジュール M の最後を、以下: 
実行を試みた全ての例について詳細に報告し、最後に各種まとめをおこなった内容が標準出力に印字されます。 verbose=True を testmod() に渡せば、詳細報告 (verbose) モードを強制できます。 
5.2.12 進んだ使い方 
冒頭でも触れたように、 
は、 
docstring 内の例題をチェックする、 
回帰テストを行う、 
実行可能なドキュメント/読めるテストの実現、 
という三つの主な用途を持つようになりました。 これらの用途にはそれぞれ違った要求があるので、区別して考えるのが重要です。 
例題は、ドキュメントに紛れ無しの価値を与えます。 
よい例がたくさんの言葉に値することは多々あります。 注意深くやれば、例はユーザにとってはあまり意味のないものになるかもしれませんが、歳を経るにつれて、あるいは "状況が変わった" 際に何度も何度も正しく動作させるためにかかることになる時間を節約するという形で、きっと見返りを得るでしょう。 
は回帰テストの優れたツールにもなり得ます。 
説明文と例題を交互に記述していけば、実際に何をどうしてテストしているのかもっと簡単に把握できるようになるでしょう。 
もちろん、コードベースのテストに詳しくコメントを入れるのも手ですが、そんなことをするプログラマはほとんどいません。 多くの人々が、 
doctest のアプローチをとった方がきれいにテストを書けると気づいています。 
おそらく、これは単にコード中にコメントを書くのが少し面倒だからという理由でしょう。 
私はもう少しうがった見方もしています: doctest ベースのテストを書くときの自然な態度は、自分のソフトウェアのよい点を説明しようとして、例題を使って説明しようとするときの態度そのものだからだ、という理由です。 
それゆえに、テストファイルは自然と単純な機能の解説から始め、論理的により複雑で境界条件的なケースに進むような形になります。 
結果的に、一見ランダムに見えるような個別の機能をテストしている個別の関数の集まりではなく、首尾一貫した説明ができるようになるのです。 
回帰テストの組み方にはいくつか選択肢があります: 
テストケースを対話モードの例題にして入れたテキストファイルを書き、testifle() や DocFileSuite() を使ってそのファイルをテストします。 
という名前の関数を定義します。 
この関数には、あるトピックに対応するテストケースの入った docstringが一つだけ入っています。 
この関数はモジュールと同じファイルの中にも置けますし、別のテストファイルに分けてもかまいません。 
回帰テストのトピックをテストケースの入った docstring に対応付けた辞書__test__ 辞書を定義します。 
doctest 化したモジュールのコレクションが増えるにつれ、全ての doctest をシステマティックに実行したいと思うようになるはずです。 
Python 2.4 以前の 
には Tester というほとんどドキュメント化されていないクラスがあり、複数のモジュールのdoctest を統合する初歩的な手段を提供していました。 
Tester は非力であり、実際のところ、もっときちんとした Python のテストフレームワークが 
モジュールで構築されており、複数のソースコードからのテストを統合する柔軟な方法を提供しています。 
そこで Python 2.4 では 
こうしたテストスイートは、 
のテストランナを使って実行できます: 
doctest の入ったテキストファイルやモジュールから 
.TestSuite インスタンスを生成するための主な関数は二つあります: 
単一または複数のテキストファイルに入っている doctest 形式のテストを、 
.TestSuite インスタンスに変換します。 この関数の返す 
.TestSuite インスタンスは、unittest フレームワークで動作させ、各ファイルの例題を対話的に実行するためのものです。 
module_relative が True (デフォルト) の場合、filename は OS に依存しないモジュールの相対パスになります。 
OS への依存性を除くため、filename ではパスを分割する文字に/ を使わねばならず、絶対パスにしてはなりません(パス文字列を/ で始めてはなりません)。 
module_relative が False の場合、filenameは OS 依存のパスを示します。 
オプション引数 package には、 Python パッケージを指定するか、モジュール相対のファイル名の場合には相対の基準ディレクトリとなるPython パッケージの名前を指定します。 
パッケージを指定しない倍、関数を呼び出しているモジュールのディレクトリを相対の基準ディレクトリとして使います。 
module_relative をFalseに指定している場合、package を指定するとエラーになります。 オプション引数 setUp には、テストスイートのセットアップに使う関数を指定します。 
この関数は、各ファイルのテストを実行する前に呼び出されます。 
setUp 関数は DocTest オブジェクトに引き渡されます。 
setUp はglobs 属性を介してテストのグローバル変数にアクセスできます。 オプション引数 tearDown には、テストを解体 (tear-down) するための関数を指定します。 
この関数は、各ファイルのテストの実行を終了するたびに呼び出されます。 
tearDown関数は DocTest オブジェクトに引き渡されます。 
tearDown ははglobs 属性を介してテストのグローバル変数にアクセスできます。 オプション引数 globs は辞書で、テストのグローバル変数の初期値が入ります。 
この辞書は各テストごとに新たにコピーして使われます。 
デフォルトではglob は空の新たな辞書です。 オプション引数 optionflags には、テストを実行する際にデフォルトで適用される doctest オプションを OR で結合して指定します。 
デフォルトは通常のパーザ ( 
doctest のテストを 
.TestSuite に変換します。 この関数の返す 
.TestSuite インスタンスは、unittest フレームワークで動作させ、モジュール内の各 doctest を実行するためのものです。 
何らかの doctest の実行に失敗すると、この関数で生成した単位テストは失敗し、該当するテストの入っているファイルの名前と、(場合によりだいたいの) 行番号の入ったfailureException 例外を送出します。 オプション引数 module には、テストしたいモジュールの名前を指定します。 
module にはモジュールオブジェクトまたは (ドット表記の) モジュール名を指定できます。 
module を指定しない場合、この関数を呼び出しているモジュールになります。 オプション引数 globs は辞書で、テストのグローバル変数の初期値が入ります。 
デフォルトではglob は空の新たな辞書です。 オプション引数 extraglobs には追加のグローバル変数セットを指定します。 
バージョン 2.4 で 変更 された仕様:globs, extraglobs,test_finder, setUp, tearDown, およびoptionflags パラメタを追加しました。 また、この関数はdoctest の検索にtestmod() と同じテクニックを使うようになりました 
DocTestSuite() は水面下ではdoctest.DocTestCaseインスタンスから 
.TestSuite を作成しており、DocTestCase は 
.TestCase のサブクラスになっています。 
DocTestCase についてはここでは説明しません(これは内部実装上の詳細だからです) が、そのコードを調べてみれば、 
の組み込みの詳細に関する疑問を解決できるはずです。 同様に、DocFileSuite() はdoctest.DocFileCaseインスタンスから 
これにははっきりとした訳があります: 
関数を自分で実行する場合、オプションフラグを 
関数に渡すことで、 
のオプションを直接操作できます。 
しかしながら、 
フレームワークを書いている場合には、いつどのようにテストを動作させるかを 
が完全に制御してしまいます。 
フレームワークの作者はたいてい、 
のレポートオプションを (コマンドラインオプションで指定するなどして) 操作したいと考えますが、 
を介して 
のテストランナにオプションを渡す方法は存在しないのです。 
このため、 
では、以下の関数を使って、 
サポートに特化したレポートフラグ表記方法もサポートしています: 
のレポートフラグをセットします。 
引数flags にはオプションフラグを OR で結合して渡します。 5.2.6 節を参照してください。 
「レポートフラグ」しか使えません。 この関数で設定した内容はモジュール全体にわたる物であり、関数呼び出し以後に 
モジュールから実行される全ての doctestに影響します: DocTestCase のrunTest() メソッドは、DocTestCase インスタンスが作成された際に、現在のテストケースに指定されたオプションフラグを見に行きます。 
レポートフラグが指定されていない場合 (通常の場合で、望ましいケースです)、 
の 
レポートフラグが OR で結合され、doctest を実行するために作成されるDocTestRunner インスタンスに渡されます。 
DocTestCase インスタンスを構築する際に何らかのレポートフラグが指定されていた場合、 
レポートフラグは無視されます。 この関数は、関数を呼び出す前に有効になっていた 
レポートフラグの値を返します。 
5.2.6.1 オプションフラグとディレクティブ 
doctest では、予想出力に対する厳密な一致を厳しく求めています。 
一致しない文字が一文字でもあると、テストは失敗してしまいます。 
このため、Python が出力に関して何を保証していて、何を保証していないかを正確に知っていないと幾度か混乱させられることでしょう。 
例えば、辞書を出力する際、Python はキーと値のペアが常に特定の順番で並ぶよう保証してはいません。 従って、以下のようなテスト 
は失敗するかもしれないのです! 回避するには 
とするのが一つのやり方です。 
別のやり方は、 
d = foo().items() d.sort() d[('Harry', 'broomstick'), ('Hermione', 'hippogryph')] です。 
他にもありますが、自分で考えてみてください。 以下のように、オブジェクトアドレスを埋め込むような結果をprint するのもよくありません: 
ELLIPSIS ディレクティブを使うと、上のような例をうまく解決できます: 
浮動小数点数もまた、プラットフォーム間での微妙な出力の違いの原因となります。 というのも、Python は浮動小数点の書式化をプラットフォームの C ライブラリにゆだねており、この点では、C ライブラリはプラットフォーム間で非常に大きく異なっているからです。 
I/2.**J の形式になる数値はどのプラットフォームでもうまく動作するので、私はこの形式の数値を生成するように doctest の例題を工夫しています: 
このように、単分数 (simple fraction) を使えば、人間にとっても理解しやすくよいドキュメントになります。 
5.2.3.1 どのドキュメンテーション文字列が検証されるのか? 
5.2.4 ドキュメンテーション文字列内の例をどうやって認識するのか? 
モジュールのドキュメンテーション文字列、全ての関数、クラスおよびメソッドのドキュメンテーション文字列が検索されます。 
モジュールに import されたオブジェクトは検索されません。 加えて、 M.__test__ が存在し、 "真の値を持つ" 場合、この値は辞書で、辞書の各エントリは (文字列の) 名前を関数オブジェクト、クラスオブジェクト、または文字列に対応付けていなくてはなりません。 
M.__test__ から得られた関数およびクラスオブジェクトのドキュメンテーション文字列は、その名前がプライベートなものでも検索され、文字列の場合にはそれがドキュメンテーション文字列であるかのように直接検索を行います。 
出力においては、M.__test__ におけるキー Kは、 
name of M.__test__.K のように表示されます。 
検索中に見つかったクラスも同様に再帰的に検索が行われ、クラスに含まれているメソッドおよびネストされたクラスについてドキュメンテーション文字列のテストが行われます。 
バージョン 2.4 で 変更 された仕様:"プライベート名" の概念は撤廃されたため、今後はドキュメントにしません 
13.6.3.2 アクセサメソッド 
13.6.3.1 型の対応付け 
OMG IDL から Python への対応付けは、 IDL attribute 宣言へのアクセサ関数の定義を、Java による対応付けが行うのとほとんど同じように行います。 
IDL 宣言の対応付け 
は、三つのアクセサ関数: someValue に対する ``get'' メソッド(_get_someValue())、そしてanotherValue に対する``get'' および ``set'' メソッド (_get_anotherValue() および_set_anotherValue()) を生み出します。 
とりわけ、対応付けでは、IDL 属性が通常の Python 属性としてアクセス可能であることは必須ではありません: object.someValue が動作することは必須 ではなく 、AttributeErrorを送出してもかまいません。 
しかしながら、Python DOM API では、通常の属性アクセスが動作することが必須です。 
これは、Python IDL コンパイラによって生成された典型的なサロゲーションはまず動作することはなく、DOM オブジェクトがCORBA を解してアクセスされる場合には、クライアント上でラッパオブジェクトが必要であることを意味します。 CORBA DOM クライアントでは他にもいくつか考慮すべきことがある一方で、CORBA を介して DOM を使った経験を持つ実装者はこのことを問題視していません。 
readonly であると宣言された属性は、全てのDOM 実装で書き込みアクセスを制限しているとは限りません。 さらに、アクセサ関数は必須ではありません。 
アクセサ関数が提供された場合、Python IDL 対応付けによって定義された形式をとらなければなりませんが、属性は Python から直接アクセスすることができるので、それらのメソッドは必須ではないと考えられます。 
readonly であると宣言された属性に対しては、 ``set'' アクセサを提供してはなりません。 
13.6.2.7 Attr オブジェクト 
13.6.2.6 Element オブジェクト 
13.6.2 DOM 内のオブジェクト 
Attr は Node を継承しており、全ての属性を受け継いでいます。 
名前にコロンがあればコロン以降の部分に、なければ名前全体になります。 
名前にコロンがあればコロン以前の部分に、なければ空文字列になります。 
13.6.2.9 Comment オブジェクト 
NamedNodeMap は Node を継承して いません 。 
属性リストの長さです。 
特定のインデクスを持つ属性を返します。 
属性の並び方は任意ですが、DOM 文書が生成されている間は一定になります。 
各要素は属性ノードです。 
属性値はノードの value 属性で取得してください。 
このクラスをよりマップ型的な動作ができるようにする実験的なメソッドもあります。 
そうしたメソッドを使うこともできますし、Element オブジェクトに対して、標準化されたgetAttribute*() ファミリのメソッドを使うこともできます。 
13.6.2.10 Text オブジェクトおよび CDATASection 
Comment は XML 文書中のコメントを表現します。 
Comment は Node のサブクラスですが、子ノードを持つことはありません。 
文字列によるコメントの内容です。 
- と- 
- 自体は含みません。 
13.6.2.12 例外 
13.6.2.5 Document オブジェクト 
13.6.2.4 DocumentType オブジェクト 
Document は XML ドキュメント全体を表現し、その構成要素である要素、属性、処理命令、コメント等が入っています。 
Document は Node からプロパティを継承していることを思い出してください。 
ドキュメントの唯一無二のルート要素です。 
新たな要素ノードを生成して返します。 
要素は、生成された時点ではドキュメント内に挿入されません。 
insertBefore() やappendChild() のような他のメソッドの一つを使って明示的に挿入を行う必要があります。 
名前空間を伴う新たな要素ノードを生成して返します。 
tagNameにはプレフィクス (prefix) があってもかまいません。 
要素は、生成された時点では文書内に挿入されません。 
insertBefore() やappendChild() のような他のメソッドの一つを使って明示的に挿入を行う必要があります。 appendChild(). 
パラメタで渡されたデータの入ったテキストノードを生成して返します。 
他の生成 (create) メソッドと同じく、このメソッドは生成されたノードをツリーに挿入しません。 
パラメタで渡されたデータの入ったコメントノードを生成して返します。 
パラメタで渡された target および data の入った処理命令ノードを生成して返します。 
他の生成 (create) メソッドと同じく、このメソッドは生成されたノードをツリーに挿入しません。 
属性ノードを生成して返します。 
このメソッドは属性ノードを特定の要素に関連づけることはしません。 
新たに生成された属性インスタンスを使うには、適切な Element オブジェクトの setAttributeNode() を使わなければなりません。 
名前空間を伴う新たな属性ノードを生成して返します。 
このメソッドは属性ノードを特定の要素に関連づけることはしません。 
全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の要素型名を持つものを検索します。 
全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の名前空間 URI とローカル名 (local name) を持つものを検索します。 
ローカル名は名前空間におけるプレフィクス以降の部分です。 
13.6.2.3 NodeList オブジェクト 
文書で宣言されている記法 (notation) やエンティティ (entity) に関する (外部サブセット(external subset) がパーザから利用でき、情報を提供できる場合にはそれも含めた) 情報は、 DocumentType オブジェクトから手に入れることができます。 
文書の DocumentType は、Document オブジェクトの doctype 属性で入手することができます; 文書の DOCTYPE 宣言がない場合、文書の doctype 属性は、このインタフェースを持つインスタンスの代わりに None に設定されます。 
DocumentType は Node を特殊化したもので、以下の属性を加えています: 
文書型定義 (document type definition) の外部サブセットに対する公開識別子 (public identifier) です。 
文字列または Noneになります。 
文書型定義 (document type definition) の外部サブセットに対するシステム識別子 (system identifier) です。 
文字列の URI またはNone になります。 
ドキュメントの完全な内部サブセットを与える文字列です。 サブセットを囲むブラケットは含みません。 
ドキュメントが内部サブセットを持たない場合、この値は None です。 
DOCTYPE 宣言でルート要素の名前が与えられている場合、その値になります。 
外部エンティティの定義を与える NamedNodeMap です。 
複数回定義されているエンティティに対しては、最初の定義だけが提供されます (その他は XML 勧告での要求仕様によって無視されます)。 
パーザによって情報が提供されないか、エンティティが定義されていない場合には、この値は None になることがあります。 
記法の定義を与える NamedNodeMap です。 複数回定義されている記法名に対しては、最初の定義だけが提供されます (その他は XML 勧告での要求仕様によって無視されます)。 
パーザによって情報が提供されないか、エンティティが定義されていない場合には、この値は None になることがあります。 
Element は Node のサブクラスです。 このためNode クラスの全ての属性を継承します。 
要素型名です。 
名前空間使用の文書では、要素型名中にコロンがあるかもしれません。 
値は文字列です。 
Document クラス内における同名のメソッドと同じです。 
属性値を文字列で返します。 
attrname で指定された属性の Attr ノードを返します。 
指定した namespaceURI および localName を持つ属性値を文字列として返します。 
指定した namespaceURI および localName を持つ属性値をノードとして返します。 
名前で指定された属性を削除します。 
該当する属性がなくても例外は送出されません。 
oldAttr が属性リストにある場合、削除して返します。 oldAttr が存在しない場合、NotFoundErr が送出されます。 
このメソッドは qname ではなく localName を使うので注意してください。 
該当する属性がなくても例外は送出されません。 
文字列を使って属性値を設定します。 
新たな属性ノードを要素に追加します。 name 属性が既存の属性に一致した場合、必要に応じて属性を置き換えます。 
置換が生じると、古い属性ノードが返されます。 
newAttr がすでに使われていれば、InuseAttributeErr が送出されます。 
新たな属性ノードを要素に追加します。 namespaceURI およびlocalName 属性が既存の属性に一致した場合、必要に応じて属性を置き換えます。 
置換が生じると、古い属性ノードが返されます。 
newAttr がすでに使われていれば、InuseAttributeErr が送出されます。 
指定された namespaceURI および qname で与えられた属性の値を文字列で設定します。 
qname は属性の完全な名前であり、この点が上記のメソッドと違うので注意してください。 
13.7.3 minidom と DOM 
以下のプログラム例は、かなり現実的な単純なプログラムの例です。 
特にこの例に関しては、DOM の柔軟性をあまり活用してはいません。 
13.6.2.11 ProcessingInstruction オブジェクト 
バージョン 2.1 で 新たに追加 された仕様です。 
DOM の実装では、適切な特定の例外を送出しなければならず、各例外は code 属性に対応する適切な値を伴わなければなりません。 
全ての特定の DOM 例外で使われている基底例外クラスです。 
この例外クラスは直接インスタンス化することができません。 
指定された範囲のテキストが文字列に収まらない場合に送出されます。 この例外は Python の DOM 実装で使われるかどうかは判っていませんが、Python で書かれていない DOM 実装から送出される場合があります。 
挿入できない型のノードを挿入しようと試みたときに送出されます。 
メソッドに与えたインデクスやサイズパラメタが負の値や許容範囲の値を超えた際に送出されます。 
文書中にすでに存在する Attr ノードを挿入しようと試みた際に送出されます。 
パラメタまたは操作が根底にあるオブジェクトでサポートされていない場合に送出されます。 
この例外は、文字列パラメタが、現在使われているコンテキストでXML 1.0 勧告によって許可されていない場合に送出されます。 
例えば、要素型に空白の入った Element ノードを生成しようとすると、このエラーが送出されます。 
ノードの型を変更しようと試みた際に送出されます。 
定義されていないオブジェクトや、もはや利用できなくなったオブジェクトを使おうと試みた際に送出されます。 
に照らして許可されていない方法でオブジェクトを変更しようと試みた場合、この例外が送出されます。 
参照しているコンテキスト中に目的のノードが存在しない場合に送出される例外です。 
例えば、NamedNodeMap.removeNamedItem() は渡されたノードがノードマップ中に存在しない場合にこの例外を送出します。 
要求された方のオブジェクトや操作が実装でサポートされていない場合に送出されます。 
データ属性をサポートしないノードにデータを指定した際に送出されます。 
オブジェクトに対して (読み出し専用ノードに対する修正のように) 許可されていない修正を行おうと試みた際に送出されます。 
無効または不正な文字列が指定された際に送出されます。 
ノードが現在属している文書と異なる文書に挿入され、かつある文書から別の文書へのノードの移行が実装でサポートされていない場合に送出されます。 
DOM 勧告で定義されている例外コードは、以下のテーブルに従って上記の例外と対応付けられます: 
例外 
13.6.2.1 DOMImplementation オブジェクト 
13.6.2.2 Node オブジェクト 
DOMImplementation インタフェースは、利用している DOM 実装において特定の機能が利用可能かどうかを決定するための方法をアプリケーションに提供します。 
DOM レベル2 では、DOMImplementation を使って新たなDocument オブジェクトや DocumentType オブジェクトを生成する機能も追加しています。 
Python の DOM API 定義は 
モジュールドキュメントの一部として与えられています。 
との違いについて列挙します。 
DOM との内部的な参照を破壊して、循環参照ガベージコレクションを持たないバージョンの Python でもガベージコレクションされるようにします。 
循環参照ガベージコレクションが利用できても、このメソッドを使えば、大量のメモリをすぐに使えるようにできるため、必要なくなったらすぐにこのメソッドを DOM オブジェクトに対して呼ぶのが良い習慣です。 
このメソッドは Document オブジェクトに対してだけ呼び出せばよいのですが、あるノードの子ノードを放棄するために子ノードに対して呼び出してもかまいません。 
XML を writer オブジェクトに書き込みます。 
writerは、ファイルオブジェクトインタフェースの write() に該当するメソッドを持たなければなりません。 
indent パラメタには現在のノードのインデントを指定します。 
addindent パラメタには現在のノードの下にサブノードを追加する際のインデント増分を指定します。 
newl には、改行時に行末を終端する文字列を指定します。 
バージョン 2.1 で 変更 された仕様:美しい出力をサポートするため、新たなキーワード引数indent、addindent、および newl が追加されました 
バージョン 2.3 で 変更 された仕様:Document ノードに対して、追加のキーワード引数encoding を使って、XML ヘッダの encoding フィールドを指定できるようになりました 
DOM が表現している XML を文字列にして返します。 引数がなければ、 XML ヘッダは encoding を指定せず、文書内の全ての文字をデフォルトエンコード方式で表示できない場合、結果は Unicode 文字列となります。 
この文字列を UTF-8 以外のエンコード方式でエンコードするのは不正であり、なぜなら UTF-8 がXML のデフォルトエンコード方式だからです。 明示的な encoding 引数があると、結果は指定されたエンコード方式によるバイト文字列となります。 
引数を常に指定するよう推奨します。 
表現不可能なテキストデータの場合に UnicodeError が送出されるのを避けるため、encoding 引数は "utf-8" に指定するべきです。 
バージョン 2.3 で 変更 された仕様:encoding が追加されました 
美しく出力されたバージョンの文書を返します。 indent はインデントを行うための文字で、デフォルトはタブです; newl には行末で出力される文字列を指定し、デフォルトは n です。 
バージョン 2.3 で 変更 された仕様:encoding 引数の追加; toxml を参照 
以下の標準 DOM メソッドは、 
では特別な注意をする必要があります: 
このメソッドは Python 2.0 にパッケージされているバージョンの 
にはありましたが、これには深刻な障害があります。 
以降のリリースでは修正されています。 
XML 文書内の処理命令を表現します; Node インタフェースを継承していますが、子ノードを持つことはできません。 
最初の空白文字までの処理命令の内容です。 
読み出し専用の属性です。 
最初の空白文字以降の処理命令の内容です。 
13.6.2.10 Text オブジェクトおよび CDATASection オブジェクト 
Text インタフェースは XML 文書内のテキストを表現します。 
パーザおよび DOM 実装が DOM の XML 拡張をサポートしている場合、CDATA でマークされた区域 (section) に入れられている部分テキストは CDATASection オブジェクトに記憶されます。 
これら二つのインタフェースは同一のものですが、nodeType属性が異なります。 これらのインタフェースは Node インタフェースを拡張したものです。 
しかし子ノードを持つことはできません。 
文字列によるテキストノードの内容です。 
注意: CDATASection ノードの利用は、ノードが完全な CDATA マーク区域を表現するという意味ではなく、ノードの内容が CDATA 区域の一部であるということを意味するだけです。 
単一の CDATA セクションは文書ツリー内で複数のノードとして表現されることがあります。 
二つの隣接する CDATASectionノードが、異なる CDATA マーク区域かどうかを決定する方法はありません。 
DOM 仕様で使われている基本的な IDL 型は、以下のテーブルに従ってPython の型に対応付けられています。 
IDL 型 
Python 型 
IntegerType (値 0 または 1) による 
さらに、勧告で定義されている DOMString は、Python 文字列または Unicode 文字列に対応付けられます。 
アプリケーションでは、DOM から文字列が返される際には常に Unicode を扱えなければなりません。 IDL の null 値は None に対応付けられており、API で null の使用が許されている場所では常に受理されるか、あるいは実装によって提供されるはずです。 
DTDHandler インスタンスは以下のメソッドを提供します。 
表記法宣言イベントの通知を捕捉します。 
未構文解析エンティティ宣言イベントの通知を受け取りますHandle an unparsed entity declaration event. 
UserDict.DictMixin クラスで提供されているメソッドに加え、dumbdbm オブジェクトでは以下のメソッドを提供しています。 
ディスク上の辞書とデータファイルを同期します。 
このメソッドはShelve オブジェクトの sync メソッドから呼び出されます。 
4.1 名前づけと束縛 (naming and 
自由変数の入った入れ子スコープ (nested scope) を併用すると、Python の文が不正な文になる場合がいくつかあります。 ある変数がスコープの外側から参照された場合、その名前に対する削除操作は不正になります。 
この場合、コンパイル時にエラーが報告されることになります。 ワイルドカード形式の import 文 -- "import *" -- を関数内で使った場合や、関数が自由変数を含んでいたり、自由変数を伴う入れ子ブロックである場合、コンパイラは SyntaxError を送出します。 
exec が関数内で使われており、関数が自由変数を含んでいたり、自由変数を伴う入れ子ブロックである場合、exec に明示的にローカル名前空間を指定しないかぎりコンパイラは SyntaxError を送出します。 
名前が呼び出し側のローカル名前空間やグローバル名前空間から解決されることはあります。 
自由変数は最内名前空間ではなく、グローバル名前空間から解決されます。 
exec 文と、関数 eval() およびexecfile() にはオプションの引数があり、グローバルおよびローカル名前空間をオーバライドできます。 
名前空間を一つしか指定しなければ、両方の名前空間として使われます。 
...自由変数は最内名前空間ではなく、グローバル名前空間から解決されます。 
この制限は、上記の操作によって実行されるコードが、モジュールをコンパイルしたときには利用できないために起こります。 
4. Windows 上での C 
Unix と Windows では、コードの実行時読み込みに全く異なるパラダイムを用いています。 
動的ロードされるようなモジュールをビルドしようとする前に、自分のシステムがどのように動作するか知っておいてください。 Unix では、共有オブジェクト (.so) ファイルにプログラムが使うコード、そしてプログラム内で使う関数名やデータが入っています。 
ファイルがプログラムに結合されると、これらの関数やデータに対するファイルのコード内の全ての参照は、メモリ内で関数やデータが配置されている、プログラム中の実際の場所を指すように変更されます。 
これは基本的にはリンク操作にあたります。 Windows では、動的リンクライブラリ (.dll) ファイルにはぶら下がり参照 (dangling reference) はありません。 
その代わり、関数やデータへのアクセスはルックアップテーブルを介します。 
共有オブジェクトファイル (.so) を作成するリンク処理の段階中に、リンカは定義場所の不明な識別子に遭遇することがあります。 
このときリンカはライブラリ内のオブジェクトファイルを検索します; もし識別子が見つかると、リンカはそのオブジェクトファイルから全てのコードを取り込みます。 Windows では、二つの形式のライブラリ、静的ライブラリとインポートライブラリがあります (どちらも.lib と呼ばれています)。 
静的ライブラリは Unix における .a ファイルに似ています;このファイルには、必要に応じて取り込まれるようなコードが入っています。 インポートライブラリは、基本的には特定の識別子が不正ではなく、DLL がロードされた時点で存在することを保証するためにだけ使われます。 
リンカはインポートライブラリからの情報を使ってルックアップテーブルを作成し、DLL に入っていない識別子を使えるようにします。 
Windows では、A.dll をビルドするとA.lib もビルドされます。 
B や C のリンクにはA.lib を渡します。 
A.lib にはコードは入っていません; 単に A のコードにアクセスするするために実行時に用いられる情報が入っているだけです。 
Windows ではインポートライブラリの使用は "import spam"とするようなものです; この操作によって spam の名前にアクセスできますが、コードのコピーを個別に作成したりはしません。 
Unix では、ライブラリとのリンクはむしろ "from spam import *" に似ています; この操作では個別にコードのコピーを生成します。 
6.27.1 ロケールの背景、詳細、ヒント、助言および補足説明 
6.27.3 メッセージカタログへのアクセス 
拡張モジュールは、現在のロケールを調べる以外は、決してsetlocale() を呼び出してはなりません。 
しかし、返される値もロケールの復帰のために使えるだけなので、さほど便利とはいえません (例外はおそらくロケールが "C" かどうか調べることでしょう)。 ロケールを変更するために Python コードで locale モジュールを使った場合、Python を埋め込んでいるアプリケーションにも影響を及ぼします。 
Python を埋め込んでいるアプリケーションに影響が及ぶことを望まない場合、config.c ファイル内の組み込みモジュールのテーブルから _locale 拡張モジュール (ここで全てを行っています) を削除し、共有ライブラリから _locate モジュールにアクセスできないようにしてください。 
Python インタプリタの埋め込みを行う人 (いわば拡張モジュールの書き手の対極) が気にかけなければならない重要なタスクは、Python インタプリタの初期化処理 (initialization)、そしておそらくは終了処理 (finalization) です。 
この関数はロード済みのモジュールからなるテーブルを作成し、土台となるモジュール __builtin__ 
, およびexceptions 
を作成します。 また、モジュール検索パス (sys.path) 
の初期化も行います。 Py_Initialize() の中では、 ``スクリプトへの引数リスト''(script argument list, sys.argv のこと) を設定しません。 
この変数が後に実行される Python コード中で必要なら、Py_Initialize() に続いてPySys_SetArgv(argc, argv) 
を呼び出して明示的に設定しなければなりません。 ほとんどのシステムでは (特に Unix と Windows は、詳細がわずかに異なりはしますが)、 Py_Initialize() は標準の Python インタプリタ実行形式の場所に対する推定結果に基づいて、Python のライブラリが Python インタプリタ実行形式からの相対パスで見つかるという仮定の下にモジュール検索パスを計算します。 
)ユーザは PYTHONHOME を設定することでこの動作をオーバライドしたり、PYTHONPATH を設定して追加のディレクトリを標準モジュール検索パスの前に挿入したりできます。 埋め込みを行うアプリケーションでは、Py_Initialize() を呼び出す 前に Py_SetProgramName(file) 
を呼び出すことで、上記の検索を操作できます。 
この埋め込みアプリケーションでの設定は依然として PYTHONHOME でオーバライドでき、標準のモジュール検索パスの前には以前としてPYTHONPATH が挿入されるので注意してください。 
アプリケーションでモジュール検索パスを完全に制御したいのなら、独自にPy_GetPath() 
, およびPy_GetProgramFullPath() 
の実装を提供しなければなりません (これらは全てModules/getpath.c で定義されています)。 たまに、 Python を ``初期化しない'' ようにしたいことがあります。 
Py_Finalize() を使うと、こうした処理を実現できます。 また、関数Py_IsInitialized() 
は、Python が現在初期化済みの状態にある場合に真を返します。 
これらの関数についてのさらなる情報は、後の章で説明します。 
5. 他のアプリケーションへの Python の埋め込み 
C++ プログラム中にも Python を埋め込めます; 厳密に言うと、どうやって埋め込むかは使っているC++ 処理系の詳細に依存します;一般的には、メインプログラムをC++で書き、C++ コンパイラを使ってプログラムをコンパイル・リンクする必要があるでしょう。 
Python 自体を C++でコンパイルしなおす必要はありません。 
Python スクリプト中の最初の行か、二行目にあるコメントが正規表現coding[=:]s*([-w.]+) にマッチする場合、コメントはエンコード宣言 (encoding declaration) として処理されます;表現に対する最初のマッチグループがソースコードファイルのエンコードを指定します。 
エンコード宣言式として推奨する形式は、GNU Emacs が認識できる形式 
または、Bram Moolenar による VIM が認識できる形式 
宣言されたエンコードは全ての字句解析、特に文字列の終端を検出する際やUnicode リテラルの内容を翻訳する上で用いられます。 文字列リテラルは文法的な解析を行うために Unicode に変換され、解釈が行われる前に元のエンコードに戻されます。 
エンコード宣言は宣言全体が一行に収まっていなければなりません。 
エンティティのシステム識別子を解決し、文字列として読み込んだシステム識別子あるいは InputSource オブジェクトのいずれかを返します。 
デフォルトの実装では systemId を返します。 
1.3 例に戻る 
Python インタプリタ全体を通して、一つの重要な取り決めがあります:それは、関数が処理に失敗した場合、例外状態をセットして、エラーを示す値 (通常は NULL ポインタ) を返さねばならない、ということです。 
例外はインタプリタ内の静的なグローバル変数に保存されます;この値が NULL の場合、例外は何も起きていないことになります。 
第二のグローバル変数には、例外の ``付属値 (associated value)''(raise 文の第二引数) が入ります。 
第三の値には、エラーの発生源が Python コード内だった場合にスタックトレースバック (stack traceback) が入ります。 
これらの三つの変数は、それぞれ Python の変数sys.exc_type、 sys.exc_value およびsys.exc_traceback と等価な C の変数です( 
のsys モジュールに関する節を参照してください。 
引数は例外オブジェクトと C 文字列です。 
例外オブジェクトは通常、PyExc_ZeroDivisionError のような定義済みのオブジェクトです。 
もっとも汎用的な関数はPyErr_SetObject() で、二つのオブジェクト、例外と付属値を引数にとります。 
これら関数に渡すオブジェクトにはPy_INCREF() を使う必要はありません。 例外がセットされているかどうかは、PyErr_Occurred() を使って非破壊的に調べられます。 
この関数は現在の例外オブジェクトを返します。 例外が発生していない場合には NULL を返します。 
以下同様に続きます -- エラーの最も詳しい原因は、最初にエラーを検出した関数がすでに報告しているからです。 
エラーが Python インタプリタのメインループに到達すると、現在実行中の Python コードは一時停止し、 Python プログラマが指定した例外ハンドラを探し出そうとします。 (モジュールがPyErr_*() 関数をもう一度呼び出して、より詳細なエラーメッセージを提供するような状況があります。 
このような状況ではそうすべきです。 とはいえ、一般的な規則としては、PyErr_*() を何度も呼び出す必要はなく、ともすればエラーの原因に関する情報を失う結果になりがちです: これにより、ほとんどの操作が様々な理由から失敗するかもしれません)ある関数呼び出しでの処理の失敗によってセットされた例外を無視するには、PyErr_Clear() を呼び出して例外状態を明示的に消去しなくてはなりません。 
エラーをインタプリタには渡したくなく、自前で (何か他の作業を行ったり、何も起こらなかったかのように見せかけるような) エラー処理を完全に行う場合にのみ、PyErr_Clear() を呼び出すようにすべきです。 malloc() の呼び出し失敗は、常に例外にしなくてはなりません -- malloc() (または realloc())を直接呼び出しているコードは、PyErr_NoMemory() を呼び出して、失敗を示す値を返さねばなりません。 
PyExc_ZeroDivisionError のように、全ての組み込みの Python 例外には対応する宣言済みの C オブジェクトがあり、直接利用できます。 もちろん、例外の選択は賢く行わねばなりません -- ファイルが開けなかったことを表すのにPyExc_TypeError を使ったりはしないでください (この場合はおそらくPyExc_IOError の方にすべきでしょう)。 
引数リストに問題がある場合には、PyArg_ParseTuple() はたいてい PyExc_TypeError を送出します。 引数の値が特定の範囲を超えていたり、その他の満たすべき条件を満たさなかった場合には、PyExc_ValueError が適切です。 
モジュール固有の新たな例外も定義できます。 定義するには、通常はファイルの先頭部分に静的なオブジェクト変数の宣言を行います: 
そして、モジュールの初期化関数 (initspam())の中で、例外オブジェクトを使って初期化します (ここではエラーチェックを省略しています): 
Python レベルでの例外オブジェクトの名前は spam.errorになることに注意してください。 
PyErr_NewException() 関数は、 
の ``組み込み例外'' の節に述べられているException クラスを基底クラスに持つ例外クラスも作成できます (NULLの代わりに他のクラスを渡した場合は別です)。 SpamError 変数は、新たに生成された例外クラスへの参照を維持することにも注意してください; これは意図的な仕様です!外部のコードが例外オブジェクトをモジュールから除去できるため、モジュールから新たに作成した例外クラスが見えなくなり、SpamError がぶら下がりポインタ (dangling pointer)になってしまわないようにするために、クラスに対する参照を所有しておかねばなりません。 
もしSpamError がぶら下がりポインタになってしまうと、C コードが例外を送出しようとしたときにコアダンプや意図しない副作用を引き起こすことがあります。 この例にある、関数の戻り値型に PyMODINIT_FUNC の使う方法については後で議論します。 
Python は、式を左から右へと順に評価してゆきます。 
ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも先に評価されるので注意してください。 
以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります: expr1, expr2, expr3, expr4(expr1, expr2, expr3, expr4){expr1: expr2, expr3: expr4}expr1 + expr2 * (expr3 - expr4)func(expr1, expr2, *expr3, **expr4)expr3, expr4 = expr1, expr2 
7.5.4.1 Semaphore の例 
wait()メソッドはフラグがTrueになるまでブロックします。 
クラスEvent 
内部フラグの初期値は偽です。 
内部フラグの値が真である場合かつその場合にのみ真を返します。 
フラグの値が真になるのを待っている全てのスレッドを起こします。 
一旦フラグが真になると、スレッドがwait() を呼び出しても全くブロックしなくなります。 
内部フラグの値を偽にリセットします。 
以降は、set() を呼び出して再び内部フラグの値を真にセットするまで、wait() を呼出したスレッドはブロックするようになります。 
内部フラグの値が真になるまでブロックします。 
wait() 処理に入った時点で内部フラグの値が真であれば、直ちに処理を戻します。 
そうでない場合、他のスレッドがset()を呼び出してフラグの値を真にセットするか、オプションのタイムアウトが発生するまでブロックします。 timeout引数を指定して、None以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。 
次の関数はPython 1.4までの標準import文(階層的なモジュール名がない)をエミュレートします。 
(この実装はそのバージョンでは動作しないでしょう。 なぜなら、find_module()は拡張されており、またload_module()が1.4で追加されているからです。 
階層的なモジュール名を実装し、reload() 
関数を含むより完全な例はモジュールknee 
にあります。 
kneeモジュールはPythonのソースディストリビューションの中のDemo/imputil/にあります。 
6 パッケージインデクスに登録する 
1 pure Python 配布物 
この章で説明する関数を使うと、Pythonの例外の処理や送出ができるようになります。 
Pythonの例外処理の基本をいくらか理解することが大切です。 
例外はUnix errno変数にやや似た機能を果たします: 発生した中で最も新しいエラーの(スレッド毎の)グローバルなインジケータがあります。 
実行に成功した場合にはほとんどの関数がこれをクリアしませんが、失敗したときにはエラーの原因を示すために設定します。 
エラーを処理して例外をクリアするか、あるいは(オブジェクト参照またはメモリ割り当てのような)それが持つどんなリソースも取り除いた後に戻るかのどちらか一方を行う責任があります。 エラーを処理する準備をしていなければ、普通に続けるべきではありません。 
エラーのために戻る場合は、エラーが設定されていると呼び出し元に知らせることが大切です。 
エラーが処理されていない場合または丁寧に伝えられている場合には、Python/C APIのさらなる呼び出しは意図した通りには動かない可能性があり、不可解な形で失敗するかもしれません。 エラーインジケータは 
Python変数sys.exc_type, sys.exc_value およびsys.exc_tracebackに対応する三つのPythonオブジェクトからからなります。 
いろいろな方法でエラーインジケータとやりとりするためにAPI関数が存在します。 
各スレッドに別々のエラーインジケータがあります。 
sys.stderrへ標準トレースバックをプリントし、エラーインジケータをクリアします。 
エラーインジケータが設定されているときにだけ、この関数を呼び出してください。 
(それ以外の場合、致命的なエラーを引き起こすでしょう!) 
エラーインジケータが設定されているかテストします。 
設定されている場合は、例外の型(PyErr_Set*()関数の一つあるいはPyErr_Restore()への最も新しい呼び出しに対する第一引数)を返します。 
設定されていない場合はNULLを返します。 
あなたは戻り値への参照を持っていませんので、それにPy_DECREF()する必要はありません。 
注意:戻り値を特定の例外と比較しないでください。 
"PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)"と同じ。 
例外が実際に設定されたときにだけ、これを呼び出だすべきです。 例外が発生していないならば、メモリアクセス違反が起きるでしょう。 
given例外がexcの例外と一致するなら真を返します。 
これはexcがクラスオブジェクトである場合も真を返します。 これはgivenがサブクラスのインスタンスであるときも真を返します。 
excがタプルならば、タプル内(と再帰的にサブタプル内)のすべての例外が一致するか調べられます。 
givenがNULLならば、メモリアクセス違反が起きるでしょう。 
ある状況では、以下のPyErr_Fetch()が返す値は``正規化されていない''可能性があります。 つまり、*exc 
はクラスオブジェクトだが*val 
は同じクラスのインスタンスではないという意味です。 
この関数はそのような場合にそのクラスをインスタンス化するために使われます。 
その値がすでに正規化されている場合は何も起きません。 
遅延正規化はパフォーマンスを改善するために実装されています。 
エラーインジケータをクリアします。 
エラーインジケータが設定されていないならば、効果はありません。 
エラーインジケータをアドレスを渡す三つの変数の中へ取り出します。 
エラーインジケータが設定されていない場合は、三つすべての変数をNULLに設定します。 
エラーインジケータが設定されている場合はクリアされ、あなたは取り出されたそれぞれのオブジェクトへの参照を持つことになります。 
型オブジェクトがNULLでないときでさえ、その値とトレースバックオブジェクトはNULLかもしれません。 
注意:通常、この関数は例外を扱う必要のあるコードあるいはエラーインジケータを一時的に保存して元に戻す必要のあるコードによってのみ使用されます。 
三つのオブジェクトからエラーインジケータを設定します。 
エラーインジケータがすでに設定されている場合は、最初にクリアされます。 
オブジェクトがNULLならば、エラーインジケータがクリアされます。 
NULLのtypeと非NULLのvalueあるいはtracebackを渡してはいけません。 
例外の型(type)はクラスであるべきです。 
無効な例外の型(type)あるいは値(value)を渡してはいけません。 (これらの規則を破ると後で気付きにくい問題の原因となるでしょう。 
)この呼び出しはそれぞれのオブジェクトへの参照を取り除きます: あなたは呼び出しの前にそれぞれのオブジェクトへの参照を持たなければならないのであり、また呼び出しの後にはもはやこれらの参照を持っていません。 
(これを理解していない場合は、この関数を使ってはいけません。 
注意しておきます。 
これはエラーインジケータを設定するための最も一般的な方法です。 
第一引数は例外の型を指定します。 
通常は標準例外の一つ、例えばPyExc_RuntimeErrorです。 
その参照カウントを増加させる必要はありません。 
第二引数はエラーメッセージで、文字列オブジェクトへ変換されます。 
この関数はPyErr_SetString()に似ていますが、例外の``値(value)''として任意のPythonオブジェクトを指定することができます。 
常に NULL. 
書式化コードの前の幅.精度(width.precision)は解析されますが、幅の部分は無視されます。 
文字 
文字、int引数として 
10進数、int引数として 
16進数、int引数として 
文字列、char *引数として 
16進法のポインタ、void *引数として 
認識できない書式化文字があると書式化文字列の残りすべてがそのまま結果の文字列へコピーされ、余分の引数はどれも捨てられます。 
これは"PyErr_SetObject(type, Py_None)"を省略したものです。 
これは"PyErr_SetString(PyExc_TypeError, message)"を省略したもので、ここでmessageは組み込み操作が不正な引数で呼び出されたということを表しています。 
主に内部で使用するためのものです。 
これは"PyErr_SetNone(PyExc_MemoryError)"を省略したもので、NULLを返します。 したがって、メモリ不足になったとき、オブジェクト割り当て関数は"return PyErr_NoMemory();"と書くことができます。 
Cライブラリ関数がエラーを返してC変数errnoを設定したときに、これは例外を発生させるために便利な関数です。 
第一要素が整数errno値で、第二要素が(strerror() から得られる)対応するエラーメッセージであるタプルオブジェクトを構成します。 
それから、"PyErr_SetObject(type, object)"を呼び出します。 
Unixでは、errno値がEINTRであるとき、すなわち割り込まれたシステムコールを表しているとき、これはPyErr_CheckSignals()を呼び出し、それがエラーインジケータを設定した場合は設定されたままにしておきます。 
関数は常にNULLを返します。 
したがって、システムコールがエラーを返したとき、システムコールのラッパー関数は"return PyErr_SetFromErrno(type);"と書くことができます。 PyObject* 
PyErr_SetFromErrno()に似ていて、filenameがNULLでない場合に、それがtypeのコンストラクタに第三引数として渡されるというふるまいが追加されています。 
IOErrorとOSErrorのような例外の場合では、これが例外インスタンスのfilename属性を定義するために使われます。 
これはWindowsErrorを発生させるために便利な関数です。 0のierrとともに呼び出された場合、GetLastError()が返すエラーコードが代りに使われます。 
利用可能範囲: Windows。 PyObject* 
PyErr_SetFromWindowsErr()に似ていて、送出する例外の型を指定する引数が追加されています。 
PyErr_SetFromWindowsErr()に似ていて、filenameがNULLでない場合にはWindowsErrorのコンストラクタへ第三引数として渡されるという振る舞いが追加されています。 利用可能範囲: Windows。 
"PyErr_SetString(PyExc_TypeError, message)"を省略したものです。 
ここでmessageは内部操作(例えば、Python/C API関数)が不正な引数とともに呼び出されたということを示しています。 
主に内部で使用するためのものです。 
警告メッセージを出します。 
警告機構がもつ問題のためにその関数が例外を発生させるということも可能です。 (実装ではその厄介な仕事を行うためにwarningsモジュールをインポートします)。 
例外が発生させられなければ、戻り値は0です。 
警告コントロールのためのC APIはありません。 
すべての警告の属性を明示的に制御した警告メッセージを出します。 
これはPython関数warnings.warn_explicit()の直接的なラッパで、さらに情報を得るにはそちらを参照してください。 
そこに説明されているデフォルトの効果を得るために、moduleとregistry引数はNULLに設定することができます。 
この関数はPythonのシグナル処理とやりとりすることができます。 
シグナルがそのプロセスへ送られたかどうかチェックし、そうならば対応するシグナルハンドラを呼び出します。 
モジュールがサポートされている場合は、これはPythonで書かれたシグナルハンドラを呼び出せます。 
KeyboardInterrupt例外を発生させることです。 
例外が発生した場合、エラーインジケータが設定され、関数は1を返します。 そうでなければ、関数は0を返します。 
エラーインジケータが以前に設定されている場合は、それがクリアされるかどうかわからない。 
この関数は廃止されています。 
SIGINT シグナルが到達した影響をシミュレートします -- 次にPyErr_CheckSignals()が呼ばれるとき、 
KeyboardInterruptは送出されるでしょう。 
インタプリタロックを保持することなく呼び出すことができます。 
このユーティリティ関数は新しい例外オブジェクトを作成して返します。 name引数は新しい例外の名前、module.class形式のC文字列でなければならない。 
baseとdict引数は通常NULLです。 
これはすべての例外のためのルート、組み込み名Exception(CではPyExc_Exceptionとしてアクセス可能)から導出されたクラスオブジェクトを作成します。 新しいクラスの__module__属性はname引数の前半部分(最後のドットまで)に設定され、クラス名は後半部分(最後のドットの後)に設定されます。 
base引数は代わりのベースクラスを指定するために使えます。 dict引数はクラス変数とメソッドの辞書を指定するために使えます。 
例外が設定されているがインタプリタが実際に例外を発生させることができないときに、このユーティリティ関数は警告メッセージをsys.stderrへプリントします。 
例えば、例外が__del__()メソッドで発生したときに使われます。 発生させられない例外が生じたコンテキストを特定するための一つの引数objとともに関数が呼び出されます。 
objのreprが警告メッセージにプリントされるでしょう。 
Python/C API の全ての関数は、関数のドキュメントで明確に説明がない限り例外を発行する可能性があります。 
一般的な話として、ある関数が何らかのエラーに遭遇すると、関数は例外を送出して、関数内における参照の所有権を全て放棄し、エラー指標 (error indicator) -- 通常は NULL または -1を返します。 
いくつかの関数ではブール型で真/偽を返し、偽はエラーを示します。 きわめて少数の関数では明確なエラー指標を返さなかったり、あいまいな戻り値を返したりするので、PyErr_Occurred() 
で明示的にエラーテストを行う必要があります。 例外時の状態情報 (exception state)は、スレッド単位に用意された記憶領域 (per-thread storage) 内で管理されます (この記憶領域は、スレッドを使わないアプリケーションではグローバルな記憶領域と同じです)。 
一つのスレッドは二つの状態のどちらか: 例外が発生したか、まだ発生していないか、をとります。 関数 PyErr_Occurred() を使うと、この状態を調べられます:この関数は例外が発生した際にはその例外型オブジェクトに対する借用参照 (borrowed reference) を返し、そうでないときには NULLを返します。 
例外状態を設定する関数は数多くあります:PyErr_SetString() 
はもっともよく知られている (が、もっとも汎用性のない) 例外を設定するための関数で、PyErr_Clear() 
は例外状態情報を消し去る関数です。 完全な例外状態情報は、3 つのオブジェクト: 例外の型、例外の値、そしてトレースバック、からなります (どのオブジェクトもNULLを取り得ます)。 
これらの情報は、 Python オブジェクトの 
この関数は Python コードの実行されているスレッドにおける例外状態情報を返します。 
また、これらの例外状態情報に対するアクセス手段は、両方とも意味づけ (semantics) が変更され、ある関数が例外を捕捉すると、その関数を実行しているスレッドの例外状態情報を保存して、呼び出し側の呼び出し側の例外状態情報を維持するようになりました。 
この変更によって、無害そうに見える関数が現在扱っている例外を上書きすることで引き起こされる、例外処理コードでよくおきていたバグを抑止しています; また、トレースバック内のスタックフレームで参照されているオブジェクトがしばしば不必要に寿命を永らえていたのをなくしています。 一般的な原理として、ある関数が別の関数を呼び出して何らかの作業をさせるとき、呼び出し先の関数が例外を送出していないか調べなくてはならず、もし送出していれば、その例外状態情報は呼び出し側に渡されなければなりません。 
呼び出し元の関数はオブジェクト参照の所有権をすべて放棄し、エラー指標を返さなくてはなりませんが、余計に例外を設定する必要は ありません -- そんなことをすれば、たった今送出されたばかりの例外を上書きしてしまい、エラーの原因そのものに関する重要な情報を失うことになります。 
例外を検出して渡す例は、上のsum_sequence() で示しています。 
偶然にも、この例ではエラーを検出した際に何ら参照を放棄する必要がありません。 
以下の関数の例では、エラーに対する後始末について示しています。 
まず、どうして Python で書くのが好きか思い出してもらうために、等価な Python コードを示します: 
以下は対応するコードを C で完璧に書いたものです: 
intincr_item(PyObject *dict, PyObject *key){/* Py_XDECREF 用に全てのオブジェクトを NULL で初期化 */PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;int rv = -1; /* 戻り値の初期値を -1 (失敗) に設定しておく */item = PyObject_GetItem(dict, key);if (item == NULL) {/* KeyError だけを処理: */if (!PyErr_ExceptionMatches(PyExc_KeyError))goto error;/* エラーを無かったことに (clear) してゼロを使う: */PyErr_Clear();item = PyInt_FromLong(0L);if (item == NULL)goto error;}const_one = PyInt_FromLong(1L);if (const_one == NULL)goto error;incremented_item = PyNumber_Add(item, const_one);if (incremented_item == NULL)goto error;if (PyObject_SetItem(dict, key, incremented_item) 0)goto error;rv = 0; /* うまくいった場合 *//* 後始末コードに続く */error:/* 成功しても失敗しても使われる後始末コード *//* NULL を参照している場合は無視するために Py_XDECREF() を使う */Py_XDECREF(item);Py_XDECREF(const_one);Py_XDECREF(incremented_item);return rv; /* エラーなら -1 、 成功なら 0 */} 
なんとこの例は C で goto 文を使うお勧めの方法まで示していますね!この例では、特定の例外を処理するためにPyErr_ExceptionMatches() 
および PyErr_Clear() 
をどう使うかを示しています。 
また、所有権を持っている参照で、値が NULL になるかもしれないものを捨てるために Py_XDECREF() をどう使うかも示しています (関数名に "X" が付いていることに注意してください; Py_DECREF() は NULL 参照に出くわすとクラッシュします)。 
正しく動作させるためには、所有権を持つ参照を保持するための変数を NULL で初期化することが重要です; 同様に、あらかじめ戻り値を定義する際には値を -1 (失敗) で初期化しておいて、最後の関数呼び出しまでうまくいった場合にのみ 0 (成功)に設定します。 
7. 複合文 (compound statement) 
6.14 exec 文 
この文は、Python コードの動的な実行をサポートします。 
最初の式の値評価結果は文字列か、開かれたファイルオブジェクトか、コードオブジェクトでなければなりません。 
文字列の場合、一連の Python 実行文として解析し、(構文エラーが生じない限り)実行します。 
開かれたファイルであれば、ファイルを EOFまで読んで解析し、実行します。 
コードオブジェクトなら、単にオブジェクトを実行します。 いずれの場合でも、オプションの部分が省略されると、コードは現在のスコープ内で実行されます。 
in の後ろに一つだけ式を指定する場合、その式は辞書でなくてはならず、グローバル変数とローカル変数の両方に使われます。 
これらはそれぞれグローバル変数とローカル変数として使われます。 locals を指定する場合は何らかのマップ型オブジェクトにせねばなりません.バージョン 2.4 で 変更 された仕様:以前はlocals は辞書でなければなりませんでした 
exec の副作用として実行されるコードで設定された変数名に対応する名前の他に、追加のキーを辞書に追加することがあります。 
例えば、現在の実装では、組み込みモジュール __builtin__ の辞書に対する参照を、__builtins__ (!) というキーで追加することがあります。 
プログラマのためのヒント:式の動的な評価は、組み込み関数 eval() でサポートされています組み込み関数 globals() および locals() は、それぞれ現在のグローバル辞書とローカル辞書を返すので、exec に渡して使うと便利です。 
4.1 名前づけと束縛 (naming and binding) 
内容モデルは入れ子になったタプルを使って記述されています。 
各タプルには 4 つの値: 型、限定詞 (quantifier)、名前、そして子のタプル、が収められています。 
子のタプルは単に内容モデルを記述したものです。 最初の二つのフィールドの値は xml.parsers.expat モジュールのmodel オブジェクトで定義されている定数です。 
これらの定数は二つのグループ: モデル型 (model type) グループと限定子 (quantifier)グループ、に取りまとめられます。 
以下にモデル型グループにおける定数を示します: XML_CTYPE_ANY 
モデル名で指定された要素は ANY の内容モデルを持つと宣言されます。 
指定されたエレメントはいくつかのオプションから選択できるようになっています; (A | B | C) のような内容モデルで用いられます。 
EMPTY であると宣言されている要素はこのモデル型を持ちます。 
順々に続くようなモデルの系列を表すモデルがこのモデル型で表されます。 
(A, B, C) のようなモデルで用いられます。 
限定子グループにおける定数を以下に示します: 
XML_CQUANT_NONE 修飾子 (modifier) が指定されていません。 
従って A のように、厳密に一つだけです。 
このモデルはオプションです: A? のように、一つか全くないかです。 
このモデルは (A+ のように) 一つかそれ以上あります。 
このモデルは A* のようにゼロ回以上あります。 
以下の定数は 
モジュールにおけるerrors オブジェクトで提供されています。 
これらの定数は、エラーが発生した際に送出される ExpatError例外オブジェクトのいくつかの属性を解釈する上で便利です。 
errors オブジェクトは以下の属性を持ちます: XML_ERROR_ASYNC_ENTITY 
属性値中のエンティティ参照が、内部エンティティではなく外部エンティティを参照しました。 
文字参照が、XML では正しくない (illegal) 文字を参照しました(例えば 0 や `#0;')。 
エンティティ参照が、記法 (notation) つきで宣言されているエンティティを参照したため、解析できません。 
一つの属性が一つの開始タグ内に一度より多く使われています。 
入力されたバイトが文字に適切に関連付けできない際に送出されます;例えば、UTF-8 入力ストリームにおける NUL バイト (値 0) などです。 
空白以外の何かがドキュメント要素の後にあります。 
入力データの先頭以外の場所に XML 定義が見つかりました。 
このドキュメントには要素が入っていません (XML では全てのドキュメントは確実にトップレベルの要素を一つ持つよう要求しています)。 
Expat が内部メモリを確保できませんでした。 
パラメタエンティティが許可されていない場所で見つかりました。 
エンティティ参照中に、同じエンティティへの別の参照が入っていました;おそらく違う名前で参照しているか、間接的に参照しています。 
何らかの仕様化されていない構文エラーに遭遇しました。 
終了タグが最も内側で開かれている開始タグに一致しません。 
何らかの (開始タグのような) トークン が閉じられないまま、ストリームの終端や次のトークンに遭遇しました。 
定義されていないエンティティへの参照が行われました。 
ドキュメントのエンコードが Expat でサポートされていません。 
CDATAセクションが閉じられていません。 
XML文書が``standalone''だと宣言されておりNotStandaloneHandler が設定され 0が返されているにもかかわらず、パーサは``standalone''ではないと判別しました。 
その操作を完了するにはDTDのサポートが必要ですが、ExpatがDTDのサポートをしない設定になっています。 
これは xml.parsers.expatモジュールの標準的なビルドでは報告されません。 
パースが始まったあとで動作の変更が要求されました。 これはパースが開始される前にのみ変更可能です。 
(現在のところ) UseForeignDTD()によってのみ送出されます。 
名前空間の処理を有効すると宣言されていないプレフィックスが見つかります。 
XML文書はプレフィックスに対応した名前空間宣言を削除しようとしました。 
パラメータエンティティは不完全なマークアップを含んでいます。 
XML文書中に要素がありません。 
外部エンティティ中のテキスト宣言にエラーがあります。 
パブリックID中に許可されていない文字があります。 
要求された操作は一時停止されたパーサで行われていますが、許可されていない操作です。 
Pythonアプリケーションには通知されません。 
要求された操作で、パース対象となる入力が完了したと判断しましたが、入力は受理されませんでした。 
このエラーは追加の入力を行なおうとしている場合、もしくはパーサが停止しようとしている場合に送出されます。 
以下のプログラムでは、与えられた引数を出力するだけの三つのハンドラを定義しています。 
このプログラムの出力は以下のようになります: 
ExpatError 例外はいくつかの興味深い属性を備えています: 
特定のエラーにおける Expat の内部エラー番号です。 
この値はこのモジュールのerrors オブジェクトで定義されている定数のいずれかに一致します。 バージョン 2.1 で 新たに追加 された仕様です。 
エラーが検出された場所の行番号です。 
最初の行の番号は 1 です。 バージョン 2.1 で 新たに追加 された仕様です。 
エラーが発生した場所の行内でのオフセットです。 
最初のカラムの番号は0 です。 バージョン 2.1 で 新たに追加 された仕様です。 
二つまたはそれ以上の物理行を論理行としてつなげるためには、バックスラッシュ文字 () を使って以下のようにします:物理行が文字列リテラルやコメント中の文字でないバックスラッシュで終わっている場合、後続する行とつなげて一つの論理行を構成し、バックスラッシュおよびバックスラッシュの後ろにある行末文字を削除します。 
例えば: 
if 1900 year 2100 and 1 = month = 12 \and 1 = day = 31 and 0 = hour 24 \and 0 = minute 60 and 0 = second 60: # Looks like a valid datereturn 1 となります。 
バックスラッシュで終わる行にはコメントを入れることはできません。 
また、バックスラッシュを使ってコメントを継続することはできません。 
バックスラッシュが文字列リテラル中にある場合を除き、バックスラッシュの後ろにトークンを継続することはできません (すなわち、物理行内の文字列リテラル以外のトークンをバックスラッシュを使って分断することはできません)。 
上記以外の場所では、文字列リテラル外にあるバックスラッシュはどこにあっても不正となります。 
8.4 式入力 
A. 歴史とライセンス 
式入力には二つの形式があります。 
双方とも、先頭の空白を無視します。 eval() に対する文字列引数は、以下の形式をとらなければなりません: 
input() で読み込まれる入力行は、以下の形式をとらなければなりません: 
注意: 文としての解釈を行わない `生の (raw)' 入力行を読み出すためには、組み込み関数 raw_input() や、ファイルオブジェクトのreadline() メソッドを使うことができます。 
この章では、Python の式における個々の要素の意味について解説します。 
表記法に関する注意: この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。 
ある構文規則 (のある表現方法) が、以下の形式 
で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、name の形式をとる構文の意味付けは、othernameの意味付けと同じになります。 
少なくとも一つのカンマを含む式のリストは、タプルになります。 
タプルの長さは、リスト中の式の数に等しくなります。 
リスト中の式は左から右へと順に評価されます。 
単一要素のタプル (別名単集合 (singleton)) を作りたければ、末尾にカンマが必要です。 
単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: () を使います。 ) 
式文は、 (主に対話的な使い方では) 値を計算して出力するために使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、プロシジャは値 None を返します)を呼び出すために使います。 
その他の使い方でも式文を使うことができますし、有用なこともあります。 
式文の構文は以下の通りです: 
式文は式のリスト (単一の式のこともあります) を値評価します。 
対話モードでは、値が None でない場合、値を組み込み関数repr() 
で文字列に変換して、その結果のみからなる一行を標準出力に書き出します (6.6 節参照)。 
(None になる式文の値は書き出されないので、プロシジャ呼び出しを行っても出力は得られません。 ) 
5.5 C++による Python の埋め込み 
ここまでは、埋め込み Python インタプリタはアプリケーション本体の機能にアクセスする手段がありませんでした。 
Python API を使うと、埋め込みインタプリタを拡張することでアプリケーション本体へのアクセスを可能にします。 
つまり、アプリケーションで提供されているルーチンを使って、埋め込みインタプリタを拡張するのです。 複雑なことのように思えますが、それほどひどいわけではありません。 
さしあたって、アプリケーションが Python インタプリタを起動したということをちょっと忘れてみてください。 
その代わり、アプリケーションがサブルーチンの集まりで、あたかも普通の Python 拡張モジュールを書くかのように、Python から各ルーチンにアクセスできるようにするグルー(glue, 糊) コードを書くと考えてください。 
例えば以下のようにです: 
static int numargs=0;/* アプリケーションのコマンドライン引数の個数を返す */static PyObject*emb_numargs(PyObject *self, PyObject *args){if(!PyArg_ParseTuple(args, ":numargs"))return NULL;return Py_BuildValue("i", numargs);}static PyMethodDef EmbMethods[] = {{"numargs", emb_numargs, METH_VARARGS,"Return the number of arguments received by the process."},{NULL, NULL, 0, NULL}}; 
上のコードを main() 関数のすぐ上に挿入します。 また、以下の二つの文をPy_Initialize() の直後に挿入します: 
これら二つの行はnumargs 変数を初期化し、埋め込み Python インタプリタからemb.numargs() 関数にアクセスできるようにします。 
これらの拡張モジュール関数を使うと、Python スクリプトは 
import embprint "Number of arguments", emb.numargs() のようなことができます。 
実際のアプリケーションでは、こうしたメソッドでアプリケーション内のAPI を Python に公開することになります。 
Distutilsは様々な方法で拡張できます。 
ほとんどの拡張は存在するコマンドを新しいコマンドで置換する形でおこなわれます。 
新しいコマンドはたとえば存在するコマンドを置換して、そのコマンドでパッケージをどう処理するかの細部を変更することでプラットフォーム特有のパッケージ形式をサポートするために書かれているかもしれませんほとんどのdistutilsの拡張は存在するコマンドを変更したいsetup.pyスクリプト中で行われます。 ほとんどはパッケージにコピーされるファイル拡張子を.pyの他に、いくつか追加するものです。 
ほとんどのdistutilsのコマンド実装は distutils.cmd 
のCommandクラスのサブクラスとして実装されています。 
新しいコマンドはCommandを直接継承し、置換するコマンドでは置換対象のコマンドのサブクラスにすることでCommandを間接的に継承します。 
コマンドはCommandから派生したものである必要があります。 
Faultオブジェクトは、XML-RPCのfaultタグの内容をカプセル化しており、以下のメンバを持ちます: 
失敗のタイプを示す文字列。 
失敗の診断メッセージを含む文字列。 
11.20.1 CookieJar および FileCookieJar 
クッキーの読み書きのために、以下の CookieJar サブクラスが提供されています。 
これ以外の CookieJar サブクラスは、Microsoft Internet Explorerブラウザのクッキーを読みこむものも含め、http://wwwsearch.sf.net/ClientCookie/ から使用可能です。 
クラスMozillaCookieJar 
Mozilla の cookies.txt ファイル形式 (この形式はまた Lynx とNetscape ブラウザによっても使われています) でディスクにクッキーを読み書きするためのFileCookieJar です。 
注意:このクラスは RFC 2965 クッキーに関する情報を失います。 また、より新しいか、標準でない port などのクッキー属性についての情報も失います。 
警告:もしクッキーの損失や欠損が望ましくない場合は、クッキーを保存する前にバックアップを取っておくようにしてください (ファイルへの読み込み / 保存をくり返すと微妙な変化が生じる場合があります)。 
また、 Mozilla の起動中にクッキーを保存すると、Mozilla によって内容が破壊されてしまうことにも注意してください。 
クラスLWPCookieJar 
libwww-perl のライブラリである Set-Cookie3 ファイル形式でディスクにクッキーを読み書きするための FileCookieJar です。 
これはクッキーを人間に可読な形式で保存するのに向いています。 
ホスト名がない場合、またはホスト名が 'localhost' の場合にファイルをローカルでオープンします。 
そうでない場合、プロトコルをftp に切り替え、parent を使って再度オープンを試みます。 
非対話的なファイルから読み出された入力は、全て同じ形式: 
Download entire grammar as text. をとります。 
この構文法は、以下の状況で用いられます: 
(ファイルや文字列内の) 完全な Python プログラムを構文解析するとき; 
モジュールを構文解析するとき; 
exec で渡された文字列を構文解析するとき; 
Python の組み込みファイルオブジェクトは、全て標準 C ライブラリのFILE* サポートの上に実装されています。 
以下の詳細説明は一実装に関するもので、将来の Python のリリースで変更されるかもしれません。 
この PyObject のサブタイプは Python のファイル型オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python のファイル型を表現します。 このオブジェクトは types.FileType として 
Python プログラムで公開されています。 
引数が PyFileObject か PyFileObject のサブタイプのときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
引数が PyFileObject 型で、かつ PyFileObject 型のサブタイプでないときに真を返します。 
成功すると、filename に指定した名前のファイルを mode に指定したファイルモードで開いて得た新たなファイルオブジェクトを返します。 mode のセマンティクスは標準 C ルーチンfopen() 
と同じです。 
失敗するとNULL を返します。 
すでに開かれている標準 C ファイルポインタ fp から新たな PyFileObject を生成します。 
この関数で生成したファイルオブジェクトは、閉じる際にclose に指定した関数を呼び出します。 
失敗するとNULLを返します。 
p に関連付けられたファイルオブジェクトを FILE*で返します。 
n が 0 の場合、行の長さに関係なく正確に 1 行だけ読み出します。 
nが 0 より大きければ、n バイト以上のデータは読み出しません; 従って、行の一部だけが返される場合があります。 
どちらの場合でも、読み出し後すぐにファイルの終端に到達した場合には空文字列を返します。 
n が 0 より小さければ、長さに関わらず 1 行だけを読み出しますが、すぐにファイルの終端に到達した場合には EOFError を送出します。 
p に指定したファイルの名前を文字列オブジェクトで返します。 
setvbuf() があるシステムでのみ利用できます。 
この関数を呼び出してよいのはファイルオブジェクトの生成直後のみです。 
Unicode オブジェクトをファイルに出力するときにのエンコード方式をenc にします。 
成功すると 1 を、失敗すると 0を返します。 バージョン 2.3 で 新たに追加 された仕様です。 
この関数はインタプリタの内部的な利用のために存在します。 
この関数はp の softspace 
属性を newflag に設定し、以前の設定値を返します。 
この関数を正しく動作させるために、p がファイルオブジェクトである必然性はありません; 任意のオブジェクトをサポートします (softspace 属性が設定されているかどうかのみが問題だと思ってください)。 
この関数は全てのエラーを解消し、属性値が存在しない場合や属性値を取得する際にエラーが生じると、0 を以前の値として返します。 
この関数からはエラーを検出できませんが、そもそもそういう必要はありません。 
オブジェクト obj をファイルオブジェクト p に書き込みます。 
flag がサポートするフラグはPy_PRINT_RAW 
だけです; このフラグを指定すると、 オブジェクトにrepr() ではなくstr() を適用した結果をファイルに書き出します。 
成功した場合には 0 を返し、失敗すると -1 を返して適切な例外をセットします。 
文字列 s をファイルオブジェクト p に書き出します。 
成功した場合には 0 を返し、失敗すると -1 を返して適切な例外をセットします。 
各フィールドの詳しい説明はInside Macintosh: Filesを参照してください。 
ファイルの4文字のクリエータコードです。 
ファイルの4文字のタイプコードです。 
ファイルのファインダフラグで、 16ビットの整数で表現されています。 
Flagsのビット値は、標準モジュールMACFSで定義されています。 
フォルダ内でファイルのアイコンが配置されている場所を示す Point 値です。 
ファイルが入っているフォルダ (を整数で表したもの) です。 
7.2.5 浮動小数点オブジェクト (complex number 
この PyObject のサブタイプは Python 浮動小数点型オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python 浮動小数点型を表現します。 
これは types.FloatType と同じオブジェクトです。 
引数が PyFloatObject か PyFloatObject のサブタイプのときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
引数が PyFloatObject 型で、かつ PyFloatObject 型のサブタイプでないときに真を返します。 
str の文字列値をもとに PyFloatObject オブジェクトを生成します。 失敗すると NULL を返します。 
引数 pend は無視されます。 
この引数は後方互換性のためだけに残されています。 
v から PyFloatObject オブジェクトを生成して返します。 失敗すると NULL を返します。 
pyfloat の指す値を、 C の double 型表現で返します。 
pyfloat の指す値を、 C の double 型表現で返しますが、エラーチェックを行いません。 
2.4.4 整数および長整数リテラル 
浮動小数点数リテラルは以下の字句定義で記述されます: 
浮動小数点数における整数部と指数部は 8 進数のように見えることもありますが、10 を基数として解釈されるので注意してください。 
例えば、"077e010" は正しい表記であり、"77e10" と同じ数を表します。 浮動小数点数リテラルの取りうる値の範囲は実装に依存します。 
浮動小数点数リテラルの例をいくつか示します: 3.14 10. .001 1e100 3.14e-10 0e0 
数値リテラルには符号が含まれていないことに注意してください; -1のような句は、実際には単項演算子 (unary operator) `-' とリテラル1 を組み合わせたものです。 
for 文は、シーケンス (文字列、タプルまたはリスト) や、その他の反復可能なオブジェクト (iterable object) 内の要素に渡って反復処理を行うために使われます: 
式リストは一度だけ評価されます; 結果はイテレーション可能オブジェクトにならねばなりません。 
expression_list の結果に対してイテレータを生成し、その後、シーケンスの各要素についてインデクスの小さい順に一度だけスイートを実行します。 
このときシーケンス内の要素が通常の代入規則を使ってターゲットリストに代入され、その後スイートが実行されます。 
全ての要素を使い切ると(シーケンスが空の場合にはすぐに)、 else 節があればそれが実行され、ループを終了します。 
最初のスイート内で break 文が実行されると、else 節のスイートを実行することなくループを終了します。 
continue 文が最初のスイート内で実行されると、スイート内にある残りの文の実行をスキップして、式の真偽評価に戻ります。 
スイートの中では、ターゲットリスト内の変数に代入を行えます; この代入によって、次に代入される要素に影響を及ぼすことはありません。 ループが終了してもターゲットリストは削除されませんが、シーケンスが空の場合には、ループでの代入は全く行われません。 
ヒント: 組み込み関数 range() は、Pascal 言語における for i := a to b do の効果をエミュレートするのに適した数列を返します;すなわち、 range(3) はリスト [0, 1, 2] を返します。 
警告:ループ中のシーケンスの変更には微妙な問題があります (これは変更可能なシーケンス、すなわちリストで起こります)。 どの要素が次に使われるかを追跡するために、内部的なカウンタが使われており、このカウンタは反復処理を行うごとに加算されます。 
このカウンタがシーケンスの長さに達すると、ループは終了します。 
このことは、スイート中でシーケンスから現在の (または以前の) 要素を除去すると、(次の要素のインデクスは、すでに取り扱った要素のインデクスになるために) 次の要素が飛ばされることを意味します。 
20.4.1 flモジュールに定義されている関数 
フォームオブジェクト(上で述べたmake_form()で返されます)には下記のメソッドがあります。 
各メソッドは名前の接頭辞に"fl_"を付けたCの関数に対応します;また、最初の引数はフォームのポインタです;説明はFORMSの公式文書を参照してください。 全てのadd_*()メソッドは、FORMSオブジェクトを示すPythonオブジェクトを返します。 
FORMSオブジェクトのメソッドを以下に記載します。 
ほとんどのFORMSオブジェクトは、そのオブジェクトの種類ごとに特有のメソッドもいくつか持っています。 
フォームを表示します。 
フォームを隠します。 
フォームを再描画します。 
フォームの位置を設定します。 
フォームを固定します。 
固定したフォームの固定を解除します。 
フォームをアクティベートします。 
新しいオブジェクトのグループを作ります;グループオブジェクトを返します。 
現在のオブジェクトのグループを終了します。 
フォームの中の最初のオブジェクトを見つけます。 
フォームの中の最後のオブジェクトを見つけます。 
フォームにボックスオブジェクトを加えます。 特別な追加のメソッドはありません。 
フォームにテキストオブジェクトを加えます。 特別な追加のメソッドはありません。 
フォームにクロックオブジェクトを加えます。 
メソッド:get_clock()。 
フォームにボタンオブジェクトを加えます。 
メソッド:get_button()、set_button()。 
フォームにライトボタンオブジェクトを加えます。 
フォームにラウンドボタンオブジェクトを加えます。 
フォームにスライダーオブジェクトを加えます。 
メソッド:set_slider_value()、get_slider_value()、set_slider_bounds()、get_slider_bounds()、set_slider_return()、set_slider_size()、set_slider_precision()、set_slider_step()。 
フォームにバリュースライダーオブジェクトを加えます。 
フォームにダイアルオブジェクトを加えます。 
メソッド:set_dial_value()、get_dial_value()、set_dial_bounds()、get_dial_bounds()。 
フォームに2次元ポジショナーオブジェクトを加えます。 
メソッド:set_positioner_xvalue()、set_positioner_yvalue()、set_positioner_xbounds()、set_positioner_ybounds()、get_positioner_xvalue()、get_positioner_yvalue()、get_positioner_xbounds()、get_positioner_ybounds()。 
フォームにカウンタオブジェクトを加えます。 
メソッド:set_counter_value()、get_counter_value()、set_counter_bounds()、set_counter_step(),set_counter_precision()、set_counter_return()。 
フォームにインプットオブジェクトを加えます。 
メソッド:set_input()、get_input()、set_input_color()、set_input_return()。 
フォームにメニューオブジェクトを加えます。 
メソッド:set_menu()、get_menu()、addto_menu()。 
フォームにチョイスオブジェクトを加えます。 
メソッド:set_choice()、get_choice()、clear_choice()、addto_choice()、replace_choice()、delete_choice()、get_choice_text()、set_choice_fontsize()、set_choice_fontstyle()。 
フォームにブラウザオブジェクトを加えます。 
メソッド:set_browser_topline()、clear_browser()、add_browser_line()、addto_browser()、insert_browser_line()、delete_browser_line()、replace_browser_line()、get_browser_line()、load_browser()、get_browser_maxline()、select_browser_line()、deselect_browser_line()、deselect_browser()、isselected_browser_line()、get_browser()、set_browser_fontsize()、set_browser_fontstyle()、set_browser_specialkey()。 
フォームにタイマーオブジェクトを加えます。 
メソッド:set_timer()、get_timer()。 
フォームオブジェクトには以下のデータ属性があります;FORMSドキュメントを参照してください: 
名称 
Cの型 
GLウィンドウのid 
フォームの幅 
フォームの高さ 
フォーム左肩のx座標 
フォーム左肩のy座標 
フォームがディアクティベートされているなら非ゼロ 
フォームが可視なら非ゼロ 
フォームが固定されているなら非ゼロ 
ダブルバッファリングがオンなら非ゼロ 
このモジュールでは、formatter オブジェクトに関して二つの実装を提供しています。 ほとんどのアプリケーションではこれらのクラスを変更したりサブクラス化することなく使うことができます。 
クラスNullFormatter 
何も行わない formatter です。 
writer を省略すると、NullWriter インスタンスが生成されます。 
NullFormatter インスタンスは、writer のメソッドを全く呼び出しません。 
writer へのインタフェースを実装する場合にはこのクラスのインタフェースを継承する必要がありますが、実装を継承する必要は全くありません。 
クラスAbstractFormatter 
標準の formatter です。 
この formatter 実装は広範な writerで適用できることが実証されており、ほとんどの状況で直接使うことができます。 
高機能の WWW ブラウザを実装するために使われたこともあります。 
formatter を作成するためのインタフェースは、インスタンス化しようとする個々の formatter クラスに依存します。 
以下で解説するのは、インスタンス化された全ての formatter がサポートしなければならないインタフェースです。 モジュールレベルではデータ要素を一つ定義しています: 
後に述べる push_font() メソッドでフォント指定をする時に使える値です。 また、その他の push_property() メソッドの新しい値として使うことができます。 
AS_IS の値をスタックに置くと、どのプロパティが変更されたかの追跡を行わずに、対応する pop_property() メソッドが呼び出されるようになります。 
formatter インスタンスオブジェクトには以下の属性が定義されています: 
formatter とやり取りを行う writer インスタンスです。 
開かれている段落があれば閉じ、次の段落との間に少なくともblanklines が挿入されるようにします。 
強制改行挿入します。 
既に強制改行がある場合は挿入しません。 
論理的な段落は中断しません。 
出力に水平罫線を挿入します。 
現在の段落に何らかのデータがある場合、強制改行が挿入されますが、論理的な段落は中断しません。 
引数とキーワードは writer の send_line_break() メソッドに渡されます。 
空白を折りたたんで書式化しなければならないデータを提供します。 空白の折りたたみでは、直前や直後の add_flowing_data 呼び出しに入っている空白も考慮されます。 
このメソッドに渡されたデータは出力デバイスで行末の折り返し (word-wrap) されるものと想定されています。 
出力デバイスでの要求やフォント情報に応じて、writer オブジェクトでも何らかの行末折り返しが行われなければならないので注意してください。 
変更を加えずに writer に渡さなければならないデータを提供します。 改行およびタブを含む空白を data の値にしても問題ありません。 
現在の左マージン位置の左側に配置されるラベルを挿入します。 
このラベルは箇条書き、数字つき箇条書きの書式を構築する際に使われます。 
書式化指定は文字列からなり、 counter の値と合わせてラベルの値を算出するために使われます。 
書式文字列の各文字はラベル値にコピーされます。 このときいくつかの文字は counter 値を変換を指すものとして認識されます。 
特に、文字 "1" はアラビア数字の counter 値を表し、"A" と "a" はそれぞれ大文字および小文字のアルファベットによる counter 値を表し、"I" と "i" はそれぞれ大文字および小文字のローマ数字による counter 値を表します。 
アルファベットおよびローマ字数字への変換の際には、counter の値はゼロ以上である必要があるので注意してください。 
以前の add_flowing_data() 呼び出しでバッファされている出力待ちの空白を、関連付けられている writer オブジェクトに送信します。 
このメソッドは writer オブジェクトに対するあらゆる直接操作の前に呼び出さなければなりません。 
新たな字揃え (alignment) 設定を字揃えスタックの上にプッシュします。 
変更を行いたくない場合には AS_IS にすることができます。 
字揃え設定値が以前の設定から変更された場合、writer の new_alignment() メソッドが align の値と共に呼び出されます。 
以前の字揃え設定を復元します。 
writer オブジェクトのフォントプロパティのうち、一部または全てを変更します。 
AS_IS に設定されていないプロパティは引数で渡された値に設定され、その他の値は現在の設定を維持します。 
writer のnew_font() メソッドは完全に設定解決されたフォント指定で呼び出されます。 
以前のフォント設定を復元します。 
左マージンのインデント数を一つ増やし、論理タグ margin を新たなインデントに関連付けます。 
マージンレベルの初期値は 0です。 
変更された論理タグの値は真値とならなければなりません; AS_IS 以外の偽の値はマージンの変更としては不適切です。 
以前のマージン設定を復元します。 
任意のスタイル指定をスタックにプッシュします。 
全てのスタイルはスタイルスタックに順番にプッシュされます。 
AS_IS 値を含み、スタック全体を表すタプルは writer の new_styles() メソッドに渡されます。 
push_style() に渡された最新 n 個のスタイル指定をポップします。 
AS_IS 値を含み、変更されたスタックを表すタプルは writer の new_styles() メソッドに渡されます。 
writer の割り付けスタイル (spacing style) を設定します。 
現在の段落にデータが予期せず追加されたことを formatter に知らせます。 
このメソッドは writer を直接操作した際に使わなければなりません。 
writer 操作の結果、出力の末尾が強制改行となった場合、オプションのflag 引数を偽に設定することができます。 
FORMSオブジェクトの種類ごとに特有のメソッドの他に、全てのFORMSオブジェクトは以下のメソッドも持っています: 
オブジェクトのコールバック関数と引数を設定します。 
オブジェクトがユーザからの応答を必要とするときには、コールバック関数は2つの引数、オブジェクトとコールバックの引数とともに呼び出されます。 
(コールバック関数のないFORMSオブジェクトは、ユーザからの応答を必要とするときにはfl.do_forms()あるいはfl.check_forms()によって返されます。 
)引数なしにこのメソッドを呼び出すと、コールバック関数を削除します。 
オブジェクトを削除します。 
オブジェクトを表示します。 
オブジェクトを隠します。 
オブジェクトを再描画します。 
固定したオブジェクトの固定を解除します。 
FORMSオブジェクトには以下のデータ属性があります;FORMSドキュメントを参照してください。 
オブジェクトクラス 
オブジェクトタイプ 
ボックスタイプ 
左肩のx座標 
左肩のy座標 
幅 
高さ 
第1の色 
第2の色 
配置 
ラベルの色 
ラベルのフォントサイズ 
ラベルの文字列 
ラベルのスタイル 
(FORMSドキュメント参照) 
3.4.2 制限と他に考慮すべきこと 
以下の例はfpectlモジュールの使用を開始する方法とモジュールのテスト演算について示しています。 
このマニュアルでは、拡張モジュールを書いたり Python インタプリタをアプリケーションに埋め込んだりしたい C および C++ プログラマが利用できる API について述べています。 
は拡張モジュールを書く際の一般的な決まりごとについて記述していますが、API の詳細までは記述していないので、このドキュメントが手引きになります。 
警告:このドキュメントの現在のバージョンはまだ不完全です。 
とはいえ、役に立つだろうと思います。 
引き続きドキュメントの整備を継続して、 Python ソースコードのリリースとは別に、その時々で新たなバージョンをリリースするつもりです。 
FSSpecオブジェクトの生データです。 他のアプリケーションに渡すといった場合に適した形式です。 
FSSpec オブジェクトの表すファイルのフルパス名を返します。 
FSSpecオブジェクトで記述されたファイルの情報を、(wdRefNum, parID, name) のタプルで返します。 
このFSSpecで記述されたファイルのエイリアスオブジェクトを作成します。 
省略可能なfileパラメータを渡すと、エイリアスはそのファイルに対する相対指定で作成され、その他の場合は絶対指定となります。 
このファイルを指す最小限のエイリアス情報を作成します。 
このファイルの4文字のクリエータとタイプを返します。 
このファイルに4文字のクリエータとタイプを設定します。 
ファイルのファインダ情報を示すFInfo オブジェクトを返します。 
ファイルのファインダ情報をfinfo(FInfo オブジェクト)で与えた値に設定します。 
作成日、修正日、バックアップ日を意味する3つの浮動小数点数からなるタプルを返します。 
ファイルの作成日、修正日、バックアップ日を設定します。 
各々の値は Python が時刻の表現に使っている標準の浮動小数点型です。 
req で表されるファイルを FTP 越しにオープンします。 ログインは常に空のユーザネームおよびパスワードで行われます。 
いくつかのコマンドは2つのタイプについて実行します:1つはテキストファイルで、もう1つはバイナリファイルを扱います。 
これらのメソッドのテキストバージョンでは"lines"、バイナリバージョンでは"binary"の語がメソッド名の終わりについています。 
FTPインスタンスには以下のメソッドがあります: 
インスタンスのデバッグレベルを設定します。 
この設定によってデバッグ時に出力される量を調節します。 
デフォルトは0で、何も出力されません。 
1なら、一般的に1つのコマンドあたり1行の適当な量のデバッグ出力を行います。 
2以上なら、コントロール接続で受信した各行を出力して、最大のデバッグ出力をします。 
指定されたホストとポートに接続します。 
ポート番号のデフォルト値はFTPプロトコルの仕様で定められた21です。 
他のポート番号を指定する必要はめったにありません。 
この関数はひとつのインスタンスに対して一度だけ実行すべきです;インスタンスが作られた時にホスト名が与えられていたら、呼び出すべきではありません。 
これ以外の他の全てのメソッドは接続された後で実行可能となります。 
接続して最初にサーバから送られてくるウェルカムメッセージを返します。 
(このメッセージには、ユーザにとって適切な注意書きやヘルプ情報が含まれることがあります。 ) 
与えられたuserでログインします。 
passwdとacctのパラメータは省略可能で、デフォルトでは空文字列です。 
もしuserが指定されないなら、デフォルトで'anonymous'になります。 
もしuserが'anonymous'なら、デフォルトのpasswdは'anonymous@'になります。 
このfunctionは各インスタンスについて一度だけ、接続が確立した後に呼び出さなければなりません;インスタンスが作られた時にホスト名とユーザ名が与えられていたら、このメソッドを実行すべきではありません。 
ほとんどのFTPコマンドはクライアントがログインした後に実行可能になります。 
実行中のファイル転送を中止します。 
これはいつも機能するわけではありませんが、やってみる価値はあります。 
シンプルなコマンド文字列をサーバに送信して、受信した文字列を返します。 
バイナリ転送モードでファイルを受信します。 
commandは適切な"RETR"コマンド:'RETR filename'でなければなりません。 
関数callbackは、受信したデータブロックのそれぞれに対して、データブロックを1つの文字列の引数として呼び出されます。 省略可能な引数maxblocksizeは、実際の転送を行うのに作られた低レベルのソケットオブジェクトから読み込む最大のチャンクサイズを指定します(これはcallbackに与えられるデータブロックの最大サイズにもなります)。 
妥当なデフォルト値が設定されます。 restは、transfercmd()メソッドと同じものです。 
ASCII転送モードでファイルとディレクトリのリストを受信します。 commandは、適切な"RETR"コマンド(retrbinary()を参照)あるいは"LIST"コマンド(通常は文字列'LIST')でなければなりません。 
関数callbackは末尾のCRLFを取り除いた各行に対して実行されます。 
デフォルトではcallbackはsys.stdoutに各行を印字します。 
booleanがtrueなら``パッシブモード''をオンにし、そうでないならパッシブモードをオフにします。 
(Python 2.0以前ではデフォルトでパッシブモードはオフにされていましたが、Python 2.1以後ではデフォルトでオンになっています。 ) 
バイナリ転送モードでファイルを転送します。 
commandは適切な"STOR"コマンド:"STOR filename"でなければなりません。 fileは開かれたファイルオブジェクトで、read()メソッドでEOFまで読み込まれ、ブロックサイズblocksizeでデータが転送されます。 
引数blocksizeのデフォルト値は8192です。 バージョン 2.1 で 変更 された仕様:blocksizeのデフォルト値が追加されました 
ASCII転送モードでファイルを転送します。 commandは適切な"STOR"コマンドでなければなりません(storbinary()を参照)。 
fileは開かれたファイルオブジェクトで、readline()メソッドでEOFまで読み込まれ、各行がデータが転送されます。 
データ接続中に転送を初期化します。 
もし転送中なら、"EPRT"あるいは"PORT"コマンドと、cmdで指定したコマンドを送信し、接続を続けます。 
サーバがパッシブなら、"EPSV"あるいは"PASV"コマンドを送信して接続し、転送コマンドを開始します。 
しかし、RFC 959ではrestが印字可能なASCIIコード33から126の範囲の文字列からなることを要求していることに注意して下さい。 
したがって、transfercmd()メソッドはrestを文字列に変換しますが、文字列の内容についてチェックしません。 
もし"REST"コマンドをサーバが認識しないなら、例外error_replyが発生します。 
この例外が発生したら、引数restなしにtransfercmd()を実行します。 
transfercmd()と同様ですが、データと予想されるサイズとのタプルを返します。 
もしサイズが計算できないなら、サイズの代わりにNoneが返されます。 cmdとrestはtransfercmd()のものと同じです。 
"NLST"コマンドで返されるファイルのリストを返します。 
省略可能なargumentは、リストアップするディレクトリです(デフォルトではサーバのカレントディレクトリです)。 
"NLST"コマンドに非標準である複数の引数を渡すことができます。 
"LIST"コマンドで返されるディレクトリ内のリストを作り、標準出力へ出力します。 
省略可能なargumentは、リストアップするディレクトリです(デフォルトではサーバのカレントディレクトリです)。 
"LIST"コマンドに非標準である複数の引数を渡すことができます。 
もし最後の引数が関数なら、retrlines()のようにcallbackとして使われます;デフォルトではsys.stdoutに印字します。 
このメソッドはNoneを返します。 
サーバ上のファイルのファイル名fromnameをtonameへ変更します。 
サーバからファイルfilenameを削除します。 
成功したら応答のテキストを返し、そうでないならパーミッションエラーではerror_permを、他のエラーではerror_replyを返します。 
サーバのカレントディレクトリを設定します。 
サーバ上に新たにディレクトリを作ります。 
サーバ上のカレントディレクトリのパスを返します。 
サーバ上のディレクトリdirnameを削除します。 
サーバ上のファイルfilenameのサイズを尋ねます。 
成功したらファイルサイズが整数で返され、そうでないならNoneが返されます。 
"SIZE"コマンドは標準化されていませんが、多くの普通のサーバで実装されていることに注意して下さい。 
サーバに"QUIT"コマンドを送信し、接続を閉じます。 
これは接続を閉じるのに``礼儀正しい''方法ですが、"QUIT"コマンドに反応してサーバの例外が発生するかもしれません。 
この例外は、close()メソッドによってFTPインスタンスに対するその後のコマンド使用が不可になっていることを示しています(下記参照)。 
接続を一方的に閉じます。 
既に閉じた接続に対して実行すべきではありません(例えばquit()を呼び出して成功した後など)。 
この実行の後、FTPインスタンスはもう使用すべきではありません(close()あるいはquit()を呼び出した後で、login()メソッドをもう一度実行して再び接続を開くことはできません)。 
関数定義は、ユーザ定義関数オブジェクトを定義します (3.2 節参照): 
関数定義は実行可能な文です。 
関数定義を実行すると、現在のローカルな名前空間内で関数名を関数オブジェクト (関数の実行可能コードをくるむラッパ) に束縛します。 
この関数オブジェクトには、関数が呼び出された際に使われるグローバルな名前空間として、現在のグローバルな名前空間への参照が入っています。 
デコレータの返す値は関数オブジェクトではなく、関数名にバインドされます。 
複数のデコレータを入れ子にして適用してもかまいません。 例えば、以下のようなコード: 
と同じです。 
デフォルト値を伴うパラメタに対しては、関数呼び出しの際に対応するパラメタが省略されると、パラメタの値はデフォルト値で置き換えられます。 
あるパラメタがデフォルト値を持つ場合、それ以後のパラメタは全てデフォルト値を持たなければなりません -- これは文法的には表現されていない構文上の制限です。 
デフォルトパラメタ値は関数定義を実行する際に値評価されます。 
これは、デフォルトパラメタの式は関数を定義するときにただ一度だけ評価され、同じ ``計算済みの'' 値が全ての呼び出しで使われることを意味します。 
デフォルトパラメタ値がリストや辞書のような変更可能なオブジェクトである場合、この使用を理解しておくことは特に重要です: 関数でこのオブジェクトを (例えばリストに要素を追加して) 変更する と、実際のデフォルト値が変更されてしまいます。 
一般には、これは意図しない動作です。 
このような動作を避けるには、デフォルト値に None を使い、この値を関数本体の中で明示的にテストします。 例えば以下のようにします: 
この変数のデフォルト値は空のタプルです。 
無名関数の作成には、5.11 節で記述されているラムダ形式 (lambda form) を使います。 
ラムダ形式は、単純化された関数定義を行うための略記法にすぎません; ``def'' 文で定義された関数は、ラムダ形式で定義された関数と全く同様に引渡したり、他の名前に代入したりできます。 
実際には、``def'' 形式は複数の式を実行できるという点でより強力です。 
プログラマのための注釈: 関数は一級の (first-class) オブジェクトです。 
関数定義内で``def'' 形式を実行すると、戻り値として返したり引き渡したりできるローカルな関数を定義します。 
ネストされた関数内で自由変数を使うと、def 文の入っている関数のローカル変数にアクセスすることができます。 
詳細は4.1 節を参照してください。 
この節では、Python の型オブジェクトと単量子 (singleton) オブジェクト None について述べます。 
7.1.1 型オブジェクト (type object) 
future 文 
は、将来の特定の Python のリリースで利用可能になるような構文や意味付けを使って、特定のモジュールをコンパイルさせるための、コンパイラに対する指示句 (directive) です。 
future 文は、言語仕様に非互換性がもたらされるような、将来の Python のバージョンに容易に移行できるよう意図されています。 
future 文によって、新たな機能が標準化されたリリースが出される前に、その機能をモジュール単位で使えるようにします。 
future 文は、モジュールの先頭周辺に書かなければなりません。 
future 文の前に書いてよい内容は: 
です。 Python 2.3 が feature 文で新たに認識するようになった機能は、"generators"、"division"、および "nested_scopes"です。 
"generators" および "nested_scopes" はPython 2.3 では常に有効になっているので、冗長な機能名といえます。 
future 文は、コンパイル時に特別なやり方で認識され、扱われます:言語の中核をなす構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばしば異なるコードを生成することで実現されています。 
以下の文: import __future__ [as name] 
Python 2.2 からは、この仕様を compile() のオプション引数で制御できるようになりました -- 詳細はライブラリリファレンスのcompile() に関するドキュメントを参照してください。 
対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプリタセッション中で有効になります。 
インタプリタを -i オプションで起動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、新たな機能はスクリプトが実行された後に開始する対話セッションで有効になります。 
9 将来の方向性 Python ドキュメントは変更に次ぐ変更の歴史を重ねてきており、そのほとんどはやや小規模の漸進的なものでした。 
マークアップ言語やドキュメントの処理に使われるツールに関して非常に多くの話し合いが行われてきました。 
この節では、変更のさまと、将来の開発において最もありえそうな道筋について議論します。 
7.5.11 ジェネレータオブジェクト ジェネレータ (generator) オブジェクトは、 Python がジェネレータ型イテレータを実装するために使っているオブジェクトです。 
ジェネレータオブジェクトは、通常、PyGen_New で明示的に生成されることはなく、値を逐次生成するような関数に対してイテレーションを行うときに生成されます。 
ジェネレータオブジェクトに使われている C 構造体です。 
ジェネレータオブジェクトに対応する型オブジェクトです。 
ob がジェネレータオブジェクトの場合に真を返します。 obが NULL であってはなりません。 
ob の型がPyGen_Typeの場合に真を返します。 
obが NULL であってはなりません。 PyObject* 
frame オブジェクトに基づいて新たなジェネレータオブジェクトを生成して返します。 パラメタが NULL であってはなりません。 
ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です: 
ジェネレータ式は新たなジェネレータオブジェクトを生み出します。 
ジェネレータ式は単一の式の後ろに少なくとも一つの for節と、場合によりさらに複数のfor または if 節を続けたものです。 
新たなジェネレータが繰り返す値は、各forおよび if 節をブロックとして、左から右へとネストし、その最内ブロックの中で式を評価した結果を出力しているものとみなせます。 ジェネレータ式の使う変数の評価は、ジェネレータオブジェクトに対してnext() メソッドを呼び出すまで遅延されます。 
C.2 翻訳者一覧 (敬称略) 
エ 
__builtin__ (チネ、゜ケ モジュール),[Link],[Link] 
_ob_next (PyObject のメンバ) 
_ob_prev (PyObject のメンバ) 
apply() (組み込み関数),[Link],[Link] 
classmethod() (組み込み関数) 
cmp() (組み込み関数),[Link],[Link] 
coerce() (組み込み関数) 
exceptions (組み込み モジュール) 
exec_prefix (環境変数),[Link],[Link] 
hash() (組み込み関数),[Link] 
ihooks (標準 モジュール) 
len() (組み込み関数),[Link],[Link],[Link],[Link] 
ob_refcnt (PyObject のメンバ) 
ob_size (PyVarObject のメンバ) 
ob_type (PyObject のメンバ) 
PATH (環境変数),[Link] 
pow() (組み込み関数),[Link] 
prefix (環境変数),[Link],[Link],[Link],[Link] 
PYTHONDUMPREFS (環境変数) 
PYTHONHOME (環境変数),[Link] 
PYTHONPATH (環境変数),[Link] 
reload() (組み込み関数) 
repr() (組み込み関数),[Link] 
rexec (標準 モジュール) 
signal (組み込み モジュール) 
staticmethod() (組み込み関数) 
str() (組み込み関数) 
sys (組み込み モジュール),[Link],[Link] 
thread (組み込み モジュール) 
tp_alloc (PyTypeObject のメンバ) 
tp_allocs (PyTypeObject のメンバ) 
tp_as_buffer (PyTypeObject のメンバ) 
tp_base (PyTypeObject のメンバ) 
tp_bases (PyTypeObject のメンバ) 
tp_basicsize (PyTypeObject のメンバ) 
tp_cache (PyTypeObject のメンバ) 
tp_call (PyTypeObject のメンバ) 
tp_clear (PyTypeObject のメンバ) 
tp_compare (PyTypeObject のメンバ) 
tp_dealloc (PyTypeObject のメンバ) 
tp_descr_get (PyTypeObject のメンバ) 
tp_descr_set (PyTypeObject のメンバ) 
tp_dict (PyTypeObject のメンバ) 
tp_dictoffset (PyTypeObject のメンバ) 
tp_doc (PyTypeObject のメンバ) 
tp_flags (PyTypeObject のメンバ) 
tp_free (PyTypeObject のメンバ) 
tp_frees (PyTypeObject のメンバ) 
tp_getattr (PyTypeObject のメンバ) 
tp_getattro (PyTypeObject のメンバ) 
tp_getset (PyTypeObject のメンバ) 
tp_hash (PyTypeObject のメンバ) 
tp_init (PyTypeObject のメンバ) 
tp_is_gc (PyTypeObject のメンバ) 
tp_itemsize (PyTypeObject のメンバ) 
tp_iter (PyTypeObject のメンバ) 
tp_iternext (PyTypeObject のメンバ) 
tp_maxalloc (PyTypeObject のメンバ) 
tp_members (PyTypeObject のメンバ) 
tp_methods (PyTypeObject のメンバ) 
tp_mro (PyTypeObject のメンバ) 
tp_name (PyTypeObject のメンバ) 
tp_new (PyTypeObject のメンバ) 
tp_next (PyTypeObject のメンバ) 
tp_print (PyTypeObject のメンバ) 
tp_repr (PyTypeObject のメンバ) 
tp_richcompare (PyTypeObject のメンバ) 
tp_setattr (PyTypeObject のメンバ) 
tp_setattro (PyTypeObject のメンバ) 
tp_str (PyTypeObject のメンバ) 
tp_subclasses (PyTypeObject のメンバ) 
tp_traverse (PyTypeObject のメンバ) 
tp_weaklist (PyTypeObject のメンバ) 
tp_weaklistoffset (PyTypeObject のメンバ) 
tuple() (組み込み関数),[Link] 
unicode() (組み込み関数) V 
1.1.1 Python スクリプトの実行方法 
Python 2.3a2 の時点では、自分のマシンに MacPython-OSX をインストールするにはソース配布物を取得し、いわゆる "framework Python" をビルドするのが唯一の正しい方法です。 ビルド方法の詳細は Mac/OSX/README にあります。 
このフォルダの中には、 PythonIDE 統合開発環境、ファインダからダブルクリックして Python スクリプトを起動するための PythonLauncher、Package Manager が入っています。 
フレームワーク /Library/Frameworks/Python.framework 。 実際の処理にかかわる部分ですが、たいていの場合それを気にする必要はありません。 
1.2.1 対話型インタプリタを使う 
1.2 MacPython-OS9 の取得とインストール 最新のリリースバージョンや実験的な最新版は、Jack Jansen が運営しているMacPython のページ:http://homepages.cwi.nl/~jack/macpython.html で探すとよいでしょう。 
最新版の説明は配布物中の README を参照してください。 MacPython-OS9 は Mac OS X 上で正常に動作し、クラシック環境ではなくネイティブモードで動きます。 
とはいえ、 CFM ベースの Python を使いたいという特別な理由がない限り、Mac OS X 上では MacPython-OSX を使いましょう。 
1.2.4.1 エディタで作成する 
1.2.4.2 Pythonモード付きのエディタ 
6.12.1 future 文 (future 
global 文は、現在のコードブロック全体で維持される宣言文です。 
global 文は、列挙した識別子をグローバル変数として解釈するよう指定することを意味します。 
global を使わずにグローバル変数に代入を行うことは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグローバル変数を参照することができます。 
プログラマのための注意点: global はパーザに対する指示句 (directive) です。 
この指示句は、global 文と同時に読み込まれたコードに対してのみ適用されます。 
特に、exec 文内に入っているglobal 文は、exec 文を 含んでいるコードブロック内に効果を及ぼすことはなく、exec 文内に含まれているコードは、exec 文を含むコード内でのglobal 文に影響を受けません。 
同様のことが、関数eval()、 execfile() 、およびcompile() にも当てはまります。 
req で表される gopher 上のリソースをオープンします。 
6.12 文法における導出の表示 形式文法における導出 (producution) を表示するために、特殊なマークアップを使えます。 
マークアップは単純なもので、 BNF (やその派生形) の全ての側面をモデル化しようとはしていませんが、シンボルを記述するとそのシンボルの定義へのハイパーリンクになるような表示を文脈自由文法に対して実現しています。 
環境が一つと、二つのマクロがあります: 
この環境は、ひとまとまりの導出規則を囲むために使います。 
この環境ではマクロを二つだけ定義しています。 
ドキュメントで二つ以上の言語について説明する場合、オプションのパラメタ languageを使って、言語間で導出規則を区別せねばなりません。 
パラメタの値はファイル名の一部に使えるような短い名前にせねばなりません; コロンや、複数のプラットフォーム間で同時にファイル名に使えないような文字は含めてはなりません。 
文法における導出規則です。 
導出規則は、name をdefinitionであると定義します。 name にはマークアップを入れてはならず、ハイフンを使った一つ以上の文法のサポートは定義されていません。 
一つの production には単一のシンボルだけを定義できます --複数シンボルの定義を行ってはなりません。 
production マクロが定義しているシンボルの名前で、シンボルのdefinition の中で使います。 
シンボルname は可能な場合にはシンボル定義へのハイパーリンクになります。 
必ずしも文法全体を単一のproductionlist 環境に定義する必要はないので注意してください; 任意の数のグループを作って文法を記述してかまいません。 
token を使う場合には常にproduction と対応付けせねばなりません。 以下は 
からとった例です: 
Python の標準ドキュメントは、図や画像を全く使っていません; これは意図的にそうしているのです。 
ドキュメントのフォーマットを行う際に利用する外部ツールが、まだ画像をうまく扱えるほどではなかったからです。 
ツールの進歩やメンテナによる改善にともなって、画像に対するサポートも改善されてきました。 mkhowto スクリプトから起動される内部ツールは、画像を直接サポートしているわけではありませんが、mkhowto が外部ツールによるグラフィクスのサポートを妨げることはありません。 
こうしたツールと howto やmanual ドキュメントクラスを使ったグラフィクスの利用はまだ広く行われてはいませんが、うまく動作することは知られています。 
基本的には、以下のようにアプローチします: 
好きなアプリケーションで、画像や図版を作成します。 
出力したい形式に合わせて、画像の形式を変換します。 
HTML または PostScript を生成したければ、画像や図版はencapsulated PostScript (EPS, .eps ファイル) 形式に変換します;LaTeX2HTML は EPS ファイルを .gif ファイルに変換できます;.gif ファイルを直接指定してもかまいません。 
PDF を (pdflatex で) 生成したいなら、 ``カプセル化 (encapsulated)''PDF ファイルが必要です。 
Linux や Unix向けに配布されているteTeX についてくるepstopdf を使えば、EPS ファイルから変換できます。 
ドキュメント内で、グラフィクスをサポートするためのパッケージgraphicx を ``import'' するための行を以下のようにして追加します: 
図版や画像を取り込みたい場所で、以下のようなマークアップを行います: 
\begin{figure}\centering\includegraphics[width=5in]{myimage}\caption{myimage の説明}\end{figure} 
includegraphics マクロにはファイルの拡張子を指定しないので注意してください。 
もし特定の形式のドキュメントしか生成したくないのなら、拡張子をつけてもかまいませんが、複数の形式をサポートしたければ拡張子を省略しておいたほうが楽です。 
mkhowto を通常通りに走らせます。 
make の機能をサポートするようなシステムで作業を行っているなら、画像の変換の際に生じる中間ファイルを最新に保つようにできます。 
下の例では、 dia で作成した図を取り込んでいるようなドキュメントをフォーマットするための Makefile を示しています: 
6.13 グラフィカルインタフェースの構成要素 グラフィカルインタフェースの構成要素についてマークアップを割り当てることになっていますが、その詳細はまだほとんど決まっていません。 
対話型ユーザインタフェース上のラベルは guilabel でマークしなければなりません。 
curses などのテキストベースのライブラリを使って作成したテキストベースインタフェース上のラベルも含みます。 
ボタン、ラベル、ウィンドウのタイトル、フィールドの名前、メニューやメニューの選択肢、選択肢リスト中の値に至るまで、インタフェース上のラベルを参照する時には、常にこのマクロを使います。 
メニューの選択肢は menuselection と sub を組み合わせてマークします。 
このマクロは、サブメニューを選択して特定の操作を選択するといった完全な形のメニュー選択手順や、任意の部分的な手順をマークするために使います。 
個々の選択肢の名前は sub を入れて分割せねばなりません。 例えば、``スタート プログラム'' をマークするには、以下のコードを使います: 
\menuselection{スタート \sub プログラム} 
選択肢がダイアログを開くようなコマンドであることを示すためにオペレーティングシステムが使う省略記号のように、選択肢の末尾に末尾に識別記号が入っている場合、選択肢名からは識別記号を省いてください。 menuselection 中の個々の選択肢名は適切にマークアップされるので、guilabel でマークする必要はありません。 
複数の階層からなるメニュー選択肢を分割するための記号です。 
このマクロは menuselection マクロのコンテキスト下でしか定義されていません。 
このオブジェクトは Windows の HKEY オブジェクトをラップし、オブジェクトが破壊されたときに自動的にハンドルを閉じます。 
この場合、背後のWindows ハンドル値が返されます、また、 Detach() メソッドを使って整数のハンドル値を返させると同時に、ハンドルオブジェクトから Windows ハンドルを切り離すこともできます。 
背後の Windows ハンドルを閉じます。 ハンドルがすでに閉じられていてもエラーは送出されません。 
ハンドルオブジェクトから Windows ハンドルを切り離します。 
切り離される以前にそのハンドルを保持していた整数 (または 64 ビット Windows の場合には長整数) オブジェクトが返されます。 
ハンドルがすでに切り離されていたり閉じられていたりした場合、ゼロが返されます。 この関数を呼び出した後、ハンドルは確実に無効化されますが、閉じられるわけではありません。 
背後の Win32 ハンドルがハンドルオブジェクトよりも長く維持される必要がある場合にはこの関数を呼び出すとよいでしょう。 
5.2 超高水準の埋め込みから踏み出す: 概要 
Python の埋め込みの最も簡単な形式は、超高水準インタフェースの利用です。 
このインタフェースは、アプリケーションとやり取りする必要がないPython スクリプトを実行するためのものです。 
例えばこれは、一つのファイル上で何らかの操作を実現するのに利用できます。 
上のコードでは、まず Python インタプリタをPy_Initialize() で起動し、続いてハードコードされたPython スクリプトで日付と時間の出力を実行します。 
その後、Py_Finalize() の呼び出しでインタプリタを終了し, プログラムの終了に続きます。 
実際のプログラムでは、Python スクリプトを他のソース、おそらくテキストエディタルーチンやファイル、データベースから取り出したいと考えるかもしれません。 
Python コードをファイルから取り出すには、PyRun_SimpleFile() 関数を使うのがよいでしょう。 この関数はメモリを確保して、ファイルの内容をロードする手間を省いてくれます。 
これは Python の``ベンチマーク'' pystone を使った例です。 
プロファイル・オブジェクトは以下のメソッドを持っています。 
プロファイル出力の際、任意のラベル名を追加します。 
ログファイルを閉じ、プロファイラを終了します。 
プロファイラのログファイルのファイル・ディスクリプタを返します。 
スクリプト環境で exec 互換文字列のプロファイルをおこないます。 
モジュールのグローバル変数は、スクリプトのグローバル変数、ローカル変数の両方に使われます。 
指定した環境で exec 互換文字列の評価をおこないます。 文字列のコンパイルはプロファイルを開始する前におこなわれます。 
プロファイラを開始します。 
プロファイラを停止します。 
タグメソッドに加えて、HTMLParser クラスではタグメソッドで利用するためのいくつかのメソッドとインスタンス変数を提供しています。 
パーザに関連付けられているフォーマッタインスタンスです。 
ブール値のフラグで、空白文字を縮約したくないときには真、縮約するときには偽にします。 
一般的には、この値を真にするのは、PRE 要素の中のテキストのように、文字列データが ``書式化済みの (preformatted)'' 場合だけです。 
標準の値は偽です。 
この値は handle_data() および save_end() の操作に影響します。 
このメソッドはアンカー領域の先頭で呼び出されます。 
引数は A タグの属性で同じ名前を持つものに対応します。 
標準の実装では、ドキュメント内のハイパーリンク (A タグの HREF 属性) を列挙したリストを維持しています。 
ハイパーリンクのリストはデータ属性anchorlist で手に入れることができます。 
このメソッドはアンカー領域の末尾で呼び出されます。 
標準の実装では、テキストの注釈マーカを追加します。 マーカは anchor_bgn() で作られたハイパーリンクリストのインデクス値です。 
このメソッドは画像を扱うために呼び出されます。 
標準の実装では、単に handle_data() に alt の値を渡すだけです。 
文字列データをフォーマッタオブジェクトに送らずにバッファに保存する操作を開始します。 
保存されたデータは save_end()で取得してください。 save_bgn() / save_end() のペアを入れ子構造にすることはできません。 
文字列データのバッファリングを終了し、以前 save_bgn() を呼び出した時点から保存されている全てのデータを返します。 
nofill フラグが偽の場合、空白文字は全てスペース文字一文字に置き換えられます。 
予め save_bgn() を呼ばないでこのメソッドを呼び出すと TypeError 例外が送出されます。 
基礎的な例として、HTMLParser クラスを使い、発見したタグを出力する、非常に基礎的な HTML パーザを以下に示します。 
認証情報がある場合、認証情報付きで再度リクエストを試みます。 
HTTPCookieProcessor インスタンスは属性をひとつだけ持ちます: 
クッキーの入っているcookielib.CookieJar オブジェクトです。 
HTTP エラーレスポンスを処理します。 エラーコード 200 の場合、レスポンスオブジェクトを即座に返します。 
200 以外のエラーコードの場合、OpenerDirector.error()を介して protocol_error_code() メソッドに仕事を引き渡します。 
最終的にどのハンドラもエラーを処理しなかった場合、urllib2.HTTPDefaultErrorHandler がHTTPError を送出します。 
HTTP リクエストを送ります。 
req.has_data() に応じて、GET または POST のどちらでも送ることができます。 
以下のメソッドは HTTPPasswordMgr およびHTTPPasswordMgrWithDefaultRealm オブジェクトで利用できます。 
uri は単一の URI でも複数の URI からなるシーケンスでもかまいません。 realm 、user および passwd は文字列でなくてはなりません。 
このメソッドによって、realm と与えられた URI の上位 URI に対して(user, passwd) が認証トークンとして使われるようになります。 
与えられたレルムおよび URI に対するユーザ名またはパスワードがあればそれを取得します。 
該当するユーザ名/パスワードが存在しない場合、このメソッドは (None, None) を返します。 HTTPPasswordMgrWithDefaultRealm オブジェクトでは、与えられたrealm に対して該当するユーザ名/パスワードが存在しない場合、レルム None が検索されます。 
注意:HTTP リダイレクトによっては、このモジュールのクライアントコード側での処理を必要とします。 
その場合、 HTTPError が送出されます。 
様々なリダイレクトコードの厳密な意味に関する詳細は RFC 2616 を参照してください。 
リダイレクトの通知に応じて、 Request または Noneを返します。 このメソッドは http_error_30*() メソッドにおいて、リダイレクトの通知をサーバから受信した際に、デフォルトの実装として呼び出されます。 
リダイレクトを起こす場合、新たな Request を生成して、http_error_30*() がリダイレクトを実行できるようにします。 
そうでない場合、他のどのハンドラにもこの URL を処理させたくなければ HTTPError を送出し、リダイレクト処理を行うことはできないが他のハンドラなら可能かもしれない場合には None を返します。 
注意:このメソッドのデフォルトの実装は、RFC 2616 に厳密に従ったものではありません。 RFC 2616 では、POST リクエストに対する 301 および 302 応答が、ユーザの承認なく自動的にリダイレクトされてはならないと述べています。 
現実には、ブラウザは POST を GET に変更することで、これらの応答に対して自動的にリダイレクトを行えるようにしています。 デフォルトの実装でも、この挙動を再現しています。 
Location: URL にリダイレクトします。 
このメソッドは HTTP における `moved permanently' レスポンスを取得した際に親オブジェクトとなる OpenerDirector によって呼び出されます。 
http_error_301() と同じですが、`found' レスポンスに対して呼び出されます。 
http_error_301() と同じですが、`see other' レスポンスに対して呼び出されます。 
http_error_301() と同じですが、`temporary redirect' レスポンスに対して呼び出されます。 
HTTPConnection インスタンスには以下のメソッドがあります: 
このメソッドは、 HTTP 要求メソッド method およびセレクタ urlを使って、要求をサーバに送ります。 
デバッグレベル (印字されるデバッグ出力の量) を設定します。 標準のデバッグレベルは 0 で、デバッグ出力を全く印字しません。 
オブジェクトを生成するときに指定したサーバに接続します。 
サーバへの接続を閉じます。 
サーバにデータを送ります。 
このメソッドは endheaders() が呼び出された直後で、かつ getreply() が呼び出される前に使わなければなりません。 
サーバへの接続が確立したら、最初にこのメソッドを呼び出さなくてはなりません。 
このメソッドは request 文字列、selector 文字列、そして HTTP バージョン (HTTP/1.1) からなる一行を送信します。 
Host: やAccept-Encoding: ヘッダの自動送信を無効にしたい場合 (例えば別のコンテンツエンコーディングを受け入れたい場合) には、skip_host や skip_accept_encoding を偽でない値に設定してください。 
RFC 822 形式のヘッダをサーバに送ります。 
この処理では、header、コロンとスペース、そして最初の引数からなる 1 行をサーバに送ります。 
追加の引数を指定した場合、継続して各行にタブ一つと引数の入った引数行が送信されます。 
サーバに空行を送り、ヘッダ部が終了したことを通知します。 
以下は"GET" リクエストの送信方法を示した例です: 
以下は "POST" リクエストの送信方法を示した例です: 
HTTPResponse インスタンスは以下のメソッドと属性を持ちます: 
応答の本体全体か、amt バイトまで読み出して返します。 
ヘッダ name の内容を取得して返すか、該当するヘッダがない場合にはdefault を返します。 
(header, value) のタプルからなるリストを返します。 
応答ヘッダを含む mimetools.Message インスタンスです。 
サーバが使用した HTTP プロトコルバージョンです。 
10 は HTTP/1.0 を、11 は HTTP/1.1 を表します。 
サーバから返される状態コードです。 
サーバから返される応答の理由文です。 
HTTPS リクエストを送ります。 
2.3 識別子 (identifier) およびキーワード 
ある種の (キーワードを除く) 識別子には、特殊な意味があります。 
これらの識別子種は、先頭や末尾にあるアンダースコア文字のパターンで区別されます: 
この識別子は "from module import *" で import されません。 
対話インタプリタでは、最も最近行われた値評価の結果を記憶するために特殊な識別子 "_" が使われます; この識別子は __builtin__ モジュール内に記憶されます。 
対話モードでない場合、"_" には特殊な意味はなく、定義されていません。 6.12 節、``import 文'' を参照してください。 
注意:名前 "_" は、しばしば国際化 (internationalization) と共に用いられます; この慣習についての詳しい情報は、 
gettext module を参照してください。 
システムで定義された (system-defined) 名前です。 
これらの名前はインタプリタと (標準ライブラリを含む) 実装上で定義されています;アプリケーション側では、この名前規約を使って別の名前を定義しようとすべきではありません。 
この種の名前のうち、Python で定義されている名前のセットは、将来のバージョンで拡張される可能性があります。 
3.3 節、``特殊なメソッド名'' を参照してください。 __* 
クラスプライベート (class-private) な名前です。 
このカテゴリに属する名前は、クラス定義のコンテキスト上で用いられた場合、基底クラスと導出クラスの ``プライベートな'' 属性間で名前衝突が起こるのを防ぐために書き直されます。 5.2.1 節、``識別子 (名前)'' を参照してください。 
識別子 (または 名前 (name)) は、以下の字句定義で記述されます: 
識別子の長さには制限がありません。 
大小文字は区別されます。 
2.3.1 キーワード (keyword) 
16.4.1 PenとRawPenオブジェクト 
16. Tkを用いたグラフィカルユーザインターフェイス 
Idleは 
GUIツールキットをつかって作られた Python IDEです。 
IDLEは次のような特徴があります: 
GUIツールキットを使って、100% ピュア Python でコーディングされています 
クロス-プラットホーム: WindowsとUnixで動作します (Mac OSでは、現在Tcl/Tkに問題があります) 
多段Undo、 Python 対応の色づけや他にもたくさんの機能(例えば、自動的な字下げや呼び出し情報の表示)をもつマルチ-ウィンドウ・テキストエディタ 
Python シェルウィンドウ(別名、対話インタープリタ) 
デバッガ(完全ではりませんが、ブレークポイントの設定や値の表示、ステップ実行ができます) 
16.5.1.1 Fileメニュー 
16.5.1.2 Editメニュー 
16.5.1.3 Windowsメニュー 
16.5.1.4 Debugメニュー( Python シェルウィンドウ内のみ) 
16.5.2.1 自動的な字下げ 
16.5.2.2 Python Shellウィンドウ 
16.5.3.1 コマンドラインの使い方 
if 文は、条件分岐を実行するために使われます: 
if 文は、式を一つ一つ評価してゆき、真になるまで続けて、真になった節のスイートだけを選択します (真: true と偽: false の定義については、5.10 節を参照してください); 次に、選択したスイートを実行します (または、 if 文の他の部分を実行したり、評価したりします)全ての式が偽になった場合、 else 節があれば、そのスイートが実行されます。 
虚数リテラルは以下のような字句定義で記述されます: 
虚数リテラルは、実数部が 0.0 の複素数を表します。 
複素数は二つ組の浮動小数点型の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の範囲を持ちます。 
実数部がゼロでない浮動小数点を生成するには、(3+4j)のように虚数リテラルに浮動小数点数を加算します。 
以下に虚数リテラルの例をいくつか示します: 
以下にメイルボックスを開き、全てのメッセージを取得して印刷する最小の (エラーチェックをしない) 使用例を示します: 
必要に応じて (IMAP4 プロトコルが感知対象としている文字が文字列に入っており、かつ丸括弧か二重引用符で囲われていなかった場合) 文字列はクオートされます。 
各 data は文字列かタプルとなります。 
指定された名前のメイルボックスに message を追加します。 
認証命令です -- 応答の処理が必要です。 
mechanismは利用する認証メカニズムを与えます。 認証メカニズムはインスタンス変数capabilities の中にAUTH=mechanismという形式で現れる必要があります。 
authobjectは呼び出し可能なオブジェクトである必要があります。 
サーバ上のメイルボックスにチェックポイントを設定します。 
現在選択されているメイルボックスを閉じます。 
削除されたメッセージは書き込み可能メイルボックスから除去されます。 
"LOGOUT" 前に実行することを勧めます。 
message_set で指定したメッセージ群を new_mailbox の末尾にコピーします。 
mailbox と名づけられた新たなメイルボックスを生成します。 
mailbox と名づけられた古いメイルボックスを削除します。 
mailbox における who についてのACLを削除(権限を削除)します。 バージョン 2.4 で 新たに追加 された仕様です。 
選択されたメイルボックスから削除された要素を永久に除去します。 
各々の削除されたメッセージに対して、"EXPUNGE" 応答を生成します。 
返されるデータには "EXPUNGE" メッセージ番号を受信した順番に並べたリストが入っています。 
メッセージ (の一部) を取りよせます。 
message_partsはメッセージパートの名前を表す文字列を丸括弧で囲ったもので、例えば: ""(UID BODY[TEXT])"" のようになります。 
返されるデータはメッセージパートのエンベロープ情報とデータからなるタプルです。 
mailbox に対する "ACL" を取得します。 このメソッドは非標準ですが、 "Cyrus" サーバでサポートされています。 
pattern にマッチする directoryメイルボックス名を列挙します。 directory の標準の設定値は最上レベルのメイルフォルダで、pattern は標準の設定では全てにマッチします。 
返されるデータには"LIST" 応答のリストが入っています。 
平文パスワードを使ってクライアントを照合します。 
password はクオートされます。 login_cram_md5 
パスワードの保護のため、クライアント認証時に"CRAM-MD5"だけを使用します。 
これは、"CAPABILITY"レスポンスに "AUTH=CRAM-MD5" が含まれる場合のみ有効です。 バージョン 2.3 で 新たに追加 された仕様です。 
サーバへの接続を遮断します。 
サーバからの "BYE" 応答を返します。 
RFC2342で定義されるIMAP名前空間を返します。 バージョン 2.3 で 新たに追加 された仕様です。 
サーバに "NOOP" を送信します。 
メッセージの後略された部分を取り寄せます。 
返されるデータはメッセージパートエンベロープ情報とデータからなるタプルです。 
userとして認証されたものとします。 
遠隔のサーバから size バイト読み出します。 このメソッドはオーバライドすることができます。 
遠隔のサーバから一行読み出します。 このメソッドはオーバライドすることができます。 
サーバに更新を促します。 
新たなメッセージがない場合応答は Noneになり、そうでない場合 "RECENT" 応答の値になります。 
oldmailbox という名前のメイルボックスを newmailboxに名称変更します。 
応答 code を受信していれば、そのデータを返し、そうでなければNone を返します。 
通常の形式 (usual type) ではなく指定したコードを返します。 
条件に合致するメッセージをメイルボックスから検索します。 
返されるデータには合致したメッセージ番号をスペースで分割したリストが入っています。 charset は None でもよく、この場合にはサーバへの要求内に "CHARSET" は指定されません。 
IMAP プロトコルは少なくとも一つの条件 (criterion) が指定されるよう要求しています;サーバがエラーを返した場合、例外が送出されます。 
例: # M is a connected IMAP4 instance...msgnums = M.search(None, 'FROM', '"LDJ"')# or:msgnums = M.search(None, '(FROM "LDJ")') 
メイルボックスを選択します。 
返されるデータは mailbox 内のメッセージ数 ("EXISTS" 応答) です。 
標準の設定ではmailbox は 'INBOX' です。 
readonly が設定された場合、メイルボックスに対する変更はできません。 
遠隔のサーバに data を送信します。 このメソッドはオーバライドすることができます。 
"ACL" を mailbox に設定します。 このメソッドは非標準ですが、 "Cyrus" サーバでサポートされています。 
open で確立された接続を閉じます。 このメソッドはオーバライドすることができます。 
サーバへの接続に使われているソケットインスタンスを返します。 
sort 命令は search に結果の並べ替え (sort) 機能をつけた変種です。 
返されるデータには、条件に合致するメッセージ番号をスペースで分割したリストが入っています。 sort 命令は search_criterium の前に二つの引数を持ちます; sort_criteria のリストを丸括弧で囲ったものと、検索時のcharset です。 
search と違って、検索時の charset は必須です。 
uid sort 命令もあり、search に対する uid searchと同じように sort 命令に対応します。 
sort 命令はまず、charset 引数の指定に従って searching criteria の文字列を解釈し、メイルボックスから与えられた検索条件に合致するメッセージを探します。 
次に、合致したメッセージの数を返します。 "IMAP4rev1" 拡張命令です。 
mailbox の指定ステータス名の状態情報を要求します。 
メイルボックス内のメッセージ群のフラグ設定を変更します。 
新たなメイルボックスを購読 (subscribe) します。 
threadコマンドはsearchにスレッドの概念を加えた変形版でス。 
返されるデータは空白で区切られたスレッドメンバのリストを含んでいます。 各スレッドメンバは0以上のメッセージ番号からなり、空白で区切られて おり、親子関係を示しています。 
threadコマンドはsearch_criterion引数の前に2つの引数を持っています。 threading_algorithmとcharsetです。 
searchコマンドとは違い、charsetは必須です。 searchに対する uid searchと同様に、 threadにもuid threadがあります。 
threadコマンドはまずメールボックス中のメッセージを、charsetを用いた検索条件で検索します。 
その後マッチしたメッセージを指定されたスレッドアルゴリズムでスレッド化して返します.これは "IMAP4rev1" の拡張コマンドです。 
command args を、メッセージ番号ではなく UID で指定されたメッセージ群に対して実行します。 
命令内容に応じた応答を返します。 
少なくとも一つの引数を与えなくてはなりません; 何も与えない場合、サーバはエラーを返し、例外が送出されます。 
古いメイルボックスの購読を解除 (unsubscribe) します。 
サーバから "CAPABILITY" 応答で通知された単純な拡張命令を許容 (allow) します。 
IMAP4_SSL のインスタンスは追加のメソッドを一つだけ持ちます: 
サーバへの安全な接続に使われる SSLObject インスタンスを返します。 
以下の属性が IMAP4 のインスタンス上で定義されています: 
サーバから返された "CAPABILITY" 応答にある、サポートされている最新のプロトコルです。 
デバッグ出力を制御するための整数値です。 
初期値はモジュール変数Debug から取られます。 
3 以上の値にすると各命令をトレースします。 
集合は変更不可能な要素だけを含むことできます。 
もし出来なければ-__hash__(),__eq__(),__ne__()のための一時的なメソッドを備えたクラスによってラップされた要素を返すメソッド-__as_temporarily_immutable__()メソッドをチェックします。 代理メカニズムは、オリジナルの可変オブジェクトから分かれたコピーを組み上げる手間を助けてくれます。 
言いかえれば、変更可能な集合の集合はスレッドセーフではありません。 
丸括弧 (parentheses)、角括弧 (square bracket) 、および波括弧 (curly brace) 内の式は、バックスラッシュを使わずに一行以上の物理行に分割することができます。 
例えば: month_names = ['Januari', 'Februari', 'Maart', # These are the'April', 'Mei', 'Juni', # Dutch names'Juli', 'Augustus', 'September', # for the months'Oktober', 'November', 'December'] # of the year 
非明示的に継続された行にはコメントを含めることができます。 
継続行のインデントは重要ではありません。 
空の継続行を書くことができます。 
非明示的な継続行中には、NEWLINE トークンは存在しません。 
非明示的な行の継続は、三重クオートされた文字列 (下記参照)でも発生します; この場合には、コメントを含めることができません。 
import 文は、(1) モジュールを探し、必要なら初期化 (initialize) する;(import 文のあるスコープにおける) ローカルな名前空間で名前を定義する、の二つの段階を踏んで初期化されます。 第一形式 (from のない形式) は、上記の段階をリスト中にある各識別子に対して繰り返し実行していきます。 
このテーブルは sys.modules からアクセスできます。 
モジュール名がこのテーブル内にあるなら、段階 (1) は完了しています。 
そうでなければ、処理系はモジュール定義の検索を開始します。 
モジュールが見つかった場合、モジュールを読み込み (load) ます。 
モジュール検索や読み込みプロセスの詳細は、実装やプラットフォームに依存します。 
一般的には、ある名前のモジュールを検索する際、まず同名の``組み込み (built-in)'' モジュールを探し、次に sys.pathで列挙されている場所を探します。 
組み込みモジュールが見つかった場合 
、組み込みの初期化コードが実行され、段階 (1) を完結します。 
合致するファイルが見つからなかった場合、ImportError 
が送出されます。 
ファイルが見つかった場合、ファイルを構文解析して実行可能なコードブロックにします。 
構文エラーが起きた場合、SyntaxError 
が送出されます。 それ以外の場合、まず指定された名前をもつ空のモジュールを作成し、モジュールテーブルに挿入します。 
次に、このモジュールの実行コンテキスト下でコードブロックを実行します。 
モジュール名の後ろにas がある場合、as の後ろの名前はモジュールのローカルな名前として使われます。 
from 形式は、モジュール名の束縛を行いません:from 形式では、段階 (1) で見つかったモジュール内から、識別子リストの各名前を順に検索し、見つかったオブジェクトを識別子の名前でローカルな名前空間において束縛します。 
import の第一形式と同じように、"as localname"で別名を与えることができます。 
指定された名前が見つからない場合、ImportError が送出されます。 
識別子のリストを星印("*") で置き換えると、モジュールで公開されている名前(public name) 全てを import 文のある場所のローカルな名前空間に束縛します。 
__all__ 内にある名前は、全て公開された名前であり、実在するものとみなされます。 
__all__ が定義されていない場合、モジュールの名前空間に見つかった名前で、アンダースコア文字 ("_") で始まっていない全ての名前が公開された名前になります。 __all__ には、公開されている API 全てを入れなければなりません。 
__all__ には、(モジュール内で import されて使われているライブラリモジュールのように) API を構成しない要素を意に反して公開してしまうのを避けるという意図があります。 
"*" を使った from 形式は、モジュールのスコープ内だけに作用します。 
関数内でワイルドカードの import 文 --"import *" -- を使い、関数が自由変数を伴うネストされたブロックであったり、ブロックを含んでいる場合、コンパイラはSyntaxError を送出します。 
階層的なモジュール名: 
モジュール名に一つまたはそれ以上のドットが入っている場合、モジュール検索パスは違った扱われ方をします。 
最後のドットまでの各識別子からなる列は、``パッケージ (package)'' 
を見つけるために使われます; 次に、パッケージ内から各識別子が検索されます。 
パッケージとは、一般には sys.path 上のディレクトリのサブディレクトリで、__init__.py. 
ファイルを持つものです。 [XXX この説明については、ここでは今のところこれ以上詳しく書けません;詳細や、パッケージ内モジュールの検索がどのように行われるかは、http://www.python.org/doc/essays/packages.html を参照してください]どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、組み込み関数 __import__() が提供されています;詳細は、 
の組み込み関数 を参照してください。 
この関数は下で述べる PyImport_ImportModuleEx() を単純化したインタフェースで、 globals および locals 引数を NULLのままにしたものです。 
name 引数にドットが含まれる場合 (あるパッケージのサブモジュールを指定している場合)、fromlist 引数がリスト ['*'] に追加され、戻り値がモジュールを含むトップレベルパッケージではなく名前つきモジュール (named module) になるようにします。 
(残念ながらこのやり方には、name が実際にはサブモジュールでなくサブパッケージを指定している場合、パッケージの __all__ 
変数に指定されているサブモジュールがロードされてしまうという副作用があります。 
)import されたモジュールへの新たな参照を返します。 失敗した場合には例外をセットし、NULL を返します。 
Python 2.4 以前では、失敗した場合でもモジュールは生成されていることがあります -- sys.modules を使って調べてください。 
Python 2.4 以降では、 import に失敗したモジュールは sys.modules に残りません。 バージョン 2.4 で 変更 された仕様:import に失敗した場合、不完全なモジュールを除去するようになりました 
モジュールを import します。 
モジュールの import については組み込みの Python 関数__import__() を読むとよく分かります。 
というのも、標準の __import__() はこの関数を直接呼び出しているからです。 戻り値は import されたモジュールかトップレベルパッケージへの新たな参照になります。 
失敗した場合には例外をセットし、NULL を返します(Python 2.4 よりも前のバージョンでは、モジュールは生成されている場合があります)__import__() と同じく、パッケージに対してサブモジュールを要求した場合の戻り値は通常、空でない fromlist を指定しない限りトップレベルパッケージになります。 
バージョン 2.4 で 変更 された仕様:import に失敗した場合、不完全なモジュールを除去するようになりました PyObject* 
現在の ``import フック関数'' を呼び出すための高水準のインタフェースです。 
この関数は現在のグローバル変数辞書内の __builtins__から __import__() 関数を呼び出します。 
すなわち、現在の環境にインストールされている import フック、例えば rexec 
やihooks 
を使ってimport を行います。 
モジュールを再ロード (reload) します。 
モジュールの再ロードについては組み込みの Python 関数reload() を読むとよく分かります。 
というのも、標準の reload はこの関数を直接呼び出しているからです。 
戻り値は再ロードしたモジュールかトップレベルパッケージへの新たな参照になります。 
失敗した場合には例外をセットし、NULL を返します(その場合でも、モジュールは生成されている場合があります) PyObject* 
モジュール名に対応するモジュールオブジェクトを返します。 
注意:この関数はモジュールの import やロードを行いません;モジュールがまだロードされていなければ、空のモジュールオブジェクトを得ることになります。 PyImport_ImportModule() やその別形式を使ってモジュールを import してください。 
ドット名表記で指定したname が存在しない場合、パッケージ構造は作成されません。 
モジュール名 (package.module 形式でもかまいません) およびPython のバイトコードファイルや組み込み関数 compile() 
で得られたコードオブジェクトを元にモジュールをロードします。 
モジュールオブジェクトへの新たな参照を返します。 失敗した場合には例外をセットし、NULL を返します。 
Python 2.4 以前では、失敗した場合でもモジュールは生成されていることがありました。 
Python 2.4 以降では、たとえPyImport_ExecCodeModule() の処理に入った時にname が sys.modules に入っていたとしても、import に失敗したモジュールは sys.modules に残りません。 
初期化の不完全なモジュールを sys.modules に残すのは危険であり、そのようなモジュールを import するコードにとっては、モジュールの状態がわからない (モジュール作者の意図から外れた壊れた状態かもしれない)からです。 この関数は、すでに import されているモジュールの場合には再ロードを行います。 
意図的にモジュールの再ロードを行う方法はPyImport_ReloadModule() を参照してください。 name がpackage.module 形式のドット名表記であった場合、まだ作成されていないパッケージ構造はその作成されないままになります。 
バージョン 2.4 で 変更 された仕様:エラーが発生した場合にname をsys.modules から除去するようになりました 
Python バイトコードファイル (いわゆる .pyc および .pyoファイル) のマジックナンバを返します。 
マジックナンバはバイトコードファイルの先頭 4 バイトにリトルエンディアン整列で配置されています。 
モジュール管理のための辞書 (いわゆる sys.modules )を返します。 
この辞書はインタプリタごとに一つだけある変数なので注意してください。 
import 機構を初期化します。 
内部使用だけのための関数です。 
モジュールテーブルを空にします。 
import 機構を終了処理します。 
name という名前のフリーズ (freeze) されたモジュールをロードします。 
成功すると 1 を、モジュールが見つからなかった場合には0 を、初期化が失敗した場合には例外をセットして-1 を返します。 
ロードに成功したモジュールにアクセスするにはPyImport_ImportModule() を使ってください。 
(Note この関数名はいささか誤称めいています -- この関数はすでに import 済みのモジュールをリロードしてしまいます。 ) 
freeze ユーティリティが生成するようなフリーズ化モジュールデスクリプタの構造体型定義です。 
(Python ソース配布物の Tools/freeze/ を参照してください)この構造体の定義は Include/import.h にあり、以下のようになっています: 
このポインタは struct _frozen のレコードからなり、終端の要素のメンバが NULL かゼロになっているような配列を指すよう初期化されます。 
フリーズされたモジュールを import するとき、このテーブルを検索します。 
サードパーティ製のコードからこのポインタに仕掛けを講じて、動的に生成されたフリーズ化モジュールの集合を提供するようにできます。 
既存の組み込みモジュールテーブルに単一のモジュールを追加します。 
この関数は利便性を目的とした PyImport_ExtendInittab() のラッパ関数で、テーブルが拡張できないときには -1 を返します。 
新たなモジュールは name で import でき、最初に import を試みた際に呼び出される関数として initfunc を使います。 
Py_Initialize() よりも前に呼び出さねばなりません。 
組み込みモジュールリスト内の一つのエントリを記述している構造体です。 
リスト内の各構造体には、インタプリタ内に組み込まれているモジュールの名前と初期化関数が指定されています。 
Python を埋め込むようなプログラムは、この構造体の配列とPyImport_ExtendInittab() を組み合わせて、追加の組み込みモジュールを提供できます。 
構造体はInclude/import.h で以下のように定義されています: 
組み込みモジュールのテーブルに一群のモジュールを追加します。 
配列 newtab は name フィールドが NULL になっているセンチネル (sentinel) エントリで終端されていなければなりません;センチネル値を与えられなかった場合にはメモリ違反になるかもしれません。 
成功すると 0 を、内部テーブルを拡張するのに十分なメモリを確保できなかった場合には -1 を返します。 
操作が失敗した場合、モジュールは一切内部テーブルに追加されません。 
Py_Initialize() よりも前に呼び出さねばなりません。 
1.1 インクルードファイル 
1.2 オブジェクト、型および参照カウント 
Python/C API を使うために必要な、関数、型およびマクロの全ての定義をインクルードするには、以下の行: 
をソースコードに記述します。 この行を記述すると、標準ヘッダ:stdio.h, string.h, errno.h,limits.h, and stdlib.h を (あれば) インクルードします。 
システムによっては、Python の定義しているプリプロセッサ定義が標準ヘッダに影響をおよぼす可能性があるので、Python.hは他の標準ヘッダファイルよりも前にインクルードしてください。 
Python.h で定義されている、ユーザから見える名前全て (Python.hがインクルードしている標準ヘッダの名前は除きます) には、接頭文字列"Py" または "_Py" が付きます。 
"_Py" で始まる名前はPython 実装で内部使用するための名前で、拡張モジュールの作者は使ってはなりません。 構造体のメンバには予約済みの接頭文字列はありません。 
重要: API のユーザは、"Py" や "_Py" で始まる名前を定義するようなコードを絶対に書いてはなりません。 
後からコードを読む人を混乱させたり、将来の Python のバージョンで同じ名前が定義されて、ユーザの書いたコードの可搬性を危うくする可能性があります。 ヘッダファイル群は通常 Python と共にインストールされます。 
Unixでは 
prefix/include/pythonversion/ および 
exec_prefix/include/pythonversion/ に置かれます。 prefix と exec_prefix は Python をビルドする際の configure スクリプトに与えたパラメタに対応し、version は sys.version[:3] に対応します。 
Windows では、ヘッダは 
親ディレクトリをサーチパスに入れて、"#include python2.4/Python.h" のようにしてはなりません; prefix 内のプラットフォームに依存しないヘッダは、exec_prefix からプラットフォーム依存のヘッダをインクルードしているので、このような操作を行うと複数のプラットフォームでのビルドができなくなります。 API はすべて C 言語を使って定義していますが、ヘッダファイルはエントリポイントを extern "C" で適切に宣言しているので、C++ ユーザは、なんの問題もなく C++から API を利用できることに気づくはずです。 
6.11 索引生成のためのマークアップ 技術文書における索引の効果的な作成は、とりわけ作者がある事柄には詳しくても索引の生成には不慣れな場合には非常に困難です。 
ドキュメントの困難さのほとんどは技術用語の範囲からきています: ある概念を説明する際に、熟練者が使うような用語を入れるだけでは不十分です。 
ドキュメントの作者は普通、自分の書いているドキュメントの領域においては熟練者であり、初心者が立ち止まってしまうような用語を見つけ出すのはかなり難しいのです。 索引生成の本当に困難な側面は、ドキュメント作成ツールで補助できるような領域のことがらではありません。 
とはいえ、ひとたび用語の内容を決めたら、索引の作成を簡単にするのはツールの役割です。 
様々な種類の索引を最小限の努力で生成できるようにするためにドキュメント生成ソフトウェアが利用できるようなマークアップが提供されています。 
ドキュメントで多くのモジュールに対する参照が入った ``モジュール索引'' が必要な場合、プリアンブル内で使います。 
このマクロは一連のdeclaremodule マクロからデータファイルlibjobname.idx を生成します。 
このファイルはmakeindex プログラムで使われ、モジュール索引を入れたい場所にinput を使って取り込めるようなファイルを生成します。 
様々な概念について索引エントリを追加する上で便利なマクロがあります。 これらの多くはプログラミング言語や、Python に特有の概念です。 
name という名前の組み込み関数に対する索引エントリを追加します;name の後ろに丸括弧を入れてはなりません。 
exception という名前の例外に対する索引エントリを追加します。 
例外はクラスベースの例外でなければなりません。 
言語における予約語 (keyword、関数やメソッド呼び出しにおけるキーワード引数とは違います) に対する索引エントリを追加します。 
組み込みオブジェクト型に対する索引エントリを追加します。 
"+" のような演算子に対する索引エントリを追加します。 
モジュール module に対する索引エントリを追加します; module にアンダースコアが入っている場合、オプションのパラメタkey には、module からアンダースコアを除去した名前を指定せねばなりません。 
索引エントリ ``module (module)'' を生成します。 
Python で書かれた非標準モジュールで使うためのものです。 
refmodindex のようなものですが、索引エントリは``module (extension module)'' になります。 このマクロは Python 以外で書かれた非標準モジュールで使うためのものです。 
refmodindex のようなものですが、索引エントリは``module (built-in module)'' になります。 このマクロは Python 以外で書かれた標準モジュールで使うためのものです。 
refmodindex のようなものですが、索引エントリは``module (standard module)'' になります。 このマクロは Python で書かれた標準モジュールで使うためのものです。 
print やtry/finally のような、構文型に対する索引エントリを追加します。 
総合索引を簡単に作成する上で便利なマクロが提供されています。 索引エントリは、索引の様々な場所で語順を入れ替えて表示しなければなりません。 
これらのマクロは単に index を使って複数の索引エントリを作成するような単純なマクロです。 
こうしたマクロを使って構築された索引エントリには、一次および二次の索引テキストが入ります。 
二つの索引語からなる索引エントリを構築します。 
index{word1!word2} とindex{word2!word1} を組み合わせて使うのと同じです。 
三つの索引語からなる索引エントリを構築します。 
index{word1!word2 word3}、index{word2!word3, word1}、およびindex{word3!word1 word2} を組み合わせて使うのと同じです。 
四つの索引語からなる索引エントリを構築します。 
index{word1!word2 word3 word4}、index{word2!word3 word4, word1}、index{word3!word4, word1 word2}、およびindex{word4!word1 word2 word3} を組み合わせて使うのと同じです。 
6.3 情報単位 モジュールが提供している特定の機能を説明するために使うマクロが数多くあります。 
これらの各環境には、環境を使って何を説明しようとしているかを表す基本的な情報をパラメタに指定する必要があります。 
説明内容自体は環境の中に書きます。 こうした環境のほとんどは (ドキュメントが総合索引を生成する際に)総合索引上のエントリになります; 索引エントリが必要ない場合、それぞれ索引を生成しない変化形の環境があります。 
環境は 
featuredesc という形式の名前になり、索引を生成しない変化形は 
featuredescni という形式の名前になります。 
該当する機能がクラスインスタンスの属性である場合、type nameを与える必要があるのは、クラスがそのモジュールの説明で最後に説明したクラスでない場合だけです; それ以外の場合、最後に説明したclassdescの name を適用します。 組み込み型や拡張型の機能については、type name を常に与えねばなりません。 
もう一つ特殊なケースとして、formatter モジュールにおける formatter や writer のような、汎用の ``プロトコル'' のメソッドやメンバがあります: これらは特定の実装クラスなしにドキュメントを書くことがあり、常に type name パラメタを指定する必要があります。 
C 関数を解説するときに使う環境です。 
type は typedef されている型名か、 struct tag 
か、基本型の名前でなければなりません。 
ポインタ型の場合、後続するアスタリスクの前にスペースを入れてはなりません。 name は関数 (または関数に似た形式をとるプリプロセッサマクロ) の名前でなくてはならず、args にはパラメタの型と名前を与えねばなりません。 
名前は説明文内でも使える形式で書かねばなりません。 
構造体メンバを説明するときに使う環境です。 container には、typedef されている名前ならそれを使い、そうでなければ"struct tag 
" と指定せねばなりません。 
メンバの型は type に指定し、メンバ名は name に指定します。 
説明文中には変数の許容範囲、値がどのように解釈されるか、そして値が変更可能かを記述せねばなりません。 
本文中で構造体メンバを参照する場合には、 member マクロを使います。 
``単純'' マクロを説明するときに使う環境です。 
単純マクロは、引数を取らないため関数で記述できないようなコードを展開する際に使います。 
この環境は単純な定数定義には用いません。 
Python ドキュメント内でのこのマクロの用例としては、PyObject_HEAD やPy_BEGIN_ALLOW_THREADS があります。 
C の型を説明するときに使う環境です。 
name パラメタはtypedef された名前でなければなりません。 
typedef がなく、 struct で定義されている型の場合、 name は struct tag 
グローバルな C の変数を説明するときに使う環境です。 type は typedef されている型名か、 struct tag 
か、基本型の名前でなければなりません。 
ポインタ型の場合、後続するアスタリスクの前にスペースを入れてはなりません。 
datadesc に似ていますが、索引エントリを作成しません。 
クラスとして定義されている例外を説明するために使います。 constructor parameters には、self やコンストラクタ呼び出し構文で使う丸括弧を含めてはなりません。 
コンストラクタに与えるパラメタの説明がないような例外クラスを説明する場合には、excdesc 環境を使用してください。 
例外を説明するための環境です。 
クラス例外の場合には、コンストラクタのパラメタが記述されません: 例外クラスとコンストラクタを説明する場合には、excclassdesc を使ってください。 
モジュールレベルの関数を説明するための環境です。 parameters には、呼び出しの際に使う丸括弧を含めてはなりません。 
オブジェクトメソッドの説明にはこの環境を使いません。 
モジュールの公開インタフェースの一部としてモジュールの名前空間内に置かれている束縛されたオブジェクトメソッド (bound object method) は、ほとんどの用途でモジュールレベル関数と同じなので、この環境を使います。 説明には、必要なパラメタと、パラメタがどう処理されるか (とりわけ、パラメタとして渡した変更可能なオブジェクトが変更されるか否か) 、副作用、送出されうる例外についての情報を含めねばなりません。 
小さな例題を提供してかまいません。 
funcdesc に似ていますが、索引エントリを作成しません。 
クラスとそのコンストラクタを説明するための環境です。 constructor parameters には、self やコンストラクタ呼び出し構文で使う丸括弧を含めてはなりません。 
コンストラクタの説明を伴わないクラスを説明するための環境です。 
属性をコンテナ化することがほとんどなかったり、ユーザコードからインスタンス化やサブクラス化を行わないようなクラスを記述する際に利用できます。 
オブジェクトのデータ属性を説明するための環境です。 
説明には、想定されているデータ型や、データが直接変更可能かについての情報がなければなりません。 
memberdesc に似ていますが、索引エントリを作成しません。 
オブジェクトメソッドを説明するための環境です。 parameters には、self パラメタや呼び出し構文で使う丸括弧を含めてはなりません。 
説明には、funcdesc 内で説明するのと同じような情報が入っていなければなりません。 
methoddesc に似ていますが、索引エントリを作成しません。 
6.4 コードの例示 ご意見やご指摘をお寄せになりたい方は、 
6.5 インラインマークアップ この節で説明するマクロは、単にドキュメントテキスト中の興味深い内容をマークするために使われます。 
これらのマクロは、本文だけではなく、表題に利用してもかまいません (とはいえ、ハイパーリンクを含むものは除かねばなりません)。 
code に似ていますが、ボールド書体にします。 
C言語における変数の名前です。 
} C言語における関数の名前です。 
name には関数名とその後ろの丸括弧を含めねばなりません。 
1 バイトの文字列値ではなく、単一の文字について議論する場合の文字です。 
文字は samp と同じようにタイプセットされます。 
参照している出版物のタイトルです。 
url を指定すると、タイトル部分は HTML 形式にフォーマットした際にハイパーリンクになります。 
クラス名です; ドット名表記を使用できます。 
短いコード断片や定数リテラル。 
引用符で囲わないので、スペースを入れてはなりません。 
``定義済みの'' 定数名です。 
C 言語における #define や、変更されないことになっている Python の変数の場合があります。 
``単純'' マクロの名前です。 
単純マクロは、引数を取らないため関数で記述できないようなコードの展開に使われます。 
C の typedef や構造体の名前です。 
型がtypedef を伴わずに定義されている構造体の場合は、ctype{struct struct_tag} を使って、structが必須であることを明示してください。 
説明している内容がリリース version 以降で撤廃されていることを宣言します。 
what to do に指定したテキストでは、撤廃されたものの代わりに利用すべきものを推奨せねばなりません。 
テキストは完全な文にせねばなりません。 
文章全体に対して撤廃を注釈する場合、別個の段落にして表示せねばなりません; この場合、撤廃される機能の説明の前か後ろのどちらかに置きます。 
テキストにおけるterm のインスタンスの定義をマークします。 
(索引エントリを生成しません。 
バックスラッシュを生成します。 
code 、file や類似のマクロ、および alltt 環境の内容を記述する場合に便利で、そうしたマークアップ内だけ定義されています。 
(citetitle マクロの中身のような) 通常の文章でバックスラッシュを生成する場合には、標準の textbackslash マクロを使ってください。 
電子メールアドレスです。 
出力形式が何であれ、ハイパーリンクは行われない ので注意してください。 
アドレスのドメインネーム部分は小文字でなければなりません。 
強調テキストです。 イタリックフォントで表示されます。 
環境変数です。 
索引エントリを生成します。 
例外の名前です。 
ドット名表記を使えます。 
ファイルやディレクトリの名前です。 
PDF と PostScript 形式の出力ではファイル名を表現するのに単引用符で囲ってフォントを変更しますが、HTML 出力では引用符囲いを行いません。 
警告:処理上の制約により、file マクロはセクションタイトル内の内容には使えません。 
file に似ていますが、単引用符を使いません。 
テーブルと組み合わせる際に、カラムにファイルやディレクトリ名だけが入るような場合に使えます。 
警告:処理上の制約により、filenq マクロはセクションタイトル内の内容には使えません。 
Python 関数の名前です; ドット名表記を使えます。 
数学的な無限大を表すシンボル: です。 
このシンボルのHTML 表現を適切に描画できないブラウザもありますが、サポートは拡大しています。 
キーシーケンスをマークします。 
key sequence がどんな形式になるかはプラットフォームやアプリケーション固有の取り決めに依存します。 
適当な取り決めがない場合には、初心者や別のシステムを利用している人たちが分かりやすいように、モディファイアキー名を書き下さねばなりません。 
例えば、xemacs のキーシーケンスはkbd{C-x C-f} のようにマークできますが、特定のアプリケーションやプラットフォームに対する参照を行わない場合には、kbd{Control-x Control-f} とマークせねばなりません。 
プログラミング言語における予約語 (keyword) の名前です。 
RFC 822 形式のメイルヘッダ名です。 
このマークアップは、そのヘッダが電子メイルメッセージ中で使われていることを示すのではなく、同じ ``スタイル'' のヘッダを表すのに使える名前であることを示します。 様々な MIME 仕様が定義しているヘッダに対しても使います。 
ヘッダ名の表現方法は、実際に通常使われているのと同じ方法で入力しなくてはなりません。 また、複数の用法があり、いずれも広く使われている場合には、キャメル形式 (camel-casting) を優先します。 
ヘッダ名の後ろに続くコロンは含めてはなりません。 例: mailheader{Content-Type}。 
make における変数名です。 
Unix マニュアルページへの参照です。 
オブジェクトのデータ属性名です。 
} オブジェクトのメソッド名です。 
name にはメソッド名とその後ろに続く丸括弧を入れねばなりません。 
ドット名表記を使えます。 
MIME タイプの名前か、 MIME タイプの要素(メジャータイプはマイナータイプのいずれか) の名前です。 
モジュールの名前です: ドット名表記を使えます。 
パッケージ名にもこれを使います。 
Usenet のニュースグループ名です。 
ある API について、ユーザがその API を一部でも利用する場合には知っておかねばならないような特に重要な情報です。 
このマクロは注釈が終了する場所を視覚的にマークしないので、段落の末尾の内容にせねばなりません。 
text の内容は完全な文で書き、適切な区切りを入れねばなりません。 
Python Enhancement Proposal への参照です。 
このマクロは索引エントリを生成します。 
" という出力を生成します;HTML 出力の場合、テキストは指定された PEP のオンラインコピーに対するハイパーリンクになります。 
ある値が、指定した量に対して正負の値をとることを示すシンボルで、通常はマイナス記号の上にプラス記号を置いて表します。 
例:plusminus 3% 
実行可能形式のプログラム名です。 
プラットフォームによっては、実行可能形式のファイル名とは異なる場合があります。 
特に、Windows プログラムでは .exe (やその他の) 拡張子を省略します。 
実行可能プログラムのコマンドラインオプションです。 
``短い'' オプションだけに使い、先頭にハイフンを入れてください。 
実行可能プログラムの長いコマンドラインオプションです。 
このマクロは二つのハイフンから始まる長いオプション名だけに使います;ハイフンを option に入れてはなりません。 
module に似ていますが、指定したモジュールに対するハイパーリンクを生成します。 
このマクロに対応するdeclaremoduleは同じドキュメント内に入っていなければなりません。 
declaremodule がモジュール名とは異なるモジュールキーを定義している場合、refmodule マクロ内でも key として指定せねばなりません。 
正規表現をマークします。 
Internet Request for Commments への参照です。 
適切な索引エントリを生成します。 
テキスト "RFC number 
" を生成します; HTML 出力では、テキストは指定した RFC のオンラインコピーに対するハイパーリンクになります。 
短いコード例で、code で指定するには長すぎる場合に使います。 
引用符記号を追加するので、テキストにスペースを入れてもかまいません。 
プリアンブルのsetshortversion マクロに指定されているような、ドキュメントの対象となっているソフトウェアの ``短い'' バージョン番号です。 
Python の場合、あるリリースに対する短いバージョン番号とは。 sys.version 値の最初の三文字です。 
例えば、バージョン 2.0b1と 2.0.1 の短いバージョン番号はいずれも 2.0 になります。 
全てのパッケージにこれが当てはまるわけではありません; setshortversion を使わなければ、このマクロは空文字に展開されます。 
version マクロも参照してください。 
強く強調されたテキストです; ボールドフォントで表現されます。 
URL で指定したターゲットを指すハイパーテキストリンクになりますが、リンクテキストをドキュメントリソース中のタイトルにしてはなりません。 
名前を使ってリソースを参照する場合には、citetitle マクロを使ってください。 
全ての形式の出力が任意のハイパーテキストリンクをサポートしているわけではありません。 
LaTeX 特有の多くの文字や、このマクロ特有の文字を使った場合、たいてい正しい出力になりません。 
特に、チルダ文字 ("~") は誤って処理されます; hex 形式の配列にエンコードすればうまくいくので、チルダの代わりには"%7e" を使ってください。 
URL (または URN) です。 
URL はテキストで与えます。 
HTML や PDF の出力形式では、URL 文字列自体もハイパーリンクになります。 このマクロは、特定のタイトルを持たない外部リソースを参照する際に利用できます; タイトルのあるリソースへの参照は citetitleマクロを使ってマークしてください。 
特殊文字に関する特別な扱いについては、ulink マクロの記述中のコメントを参照してください。 
テキスト中で変数や仮引数の名前です。 
プリアンブルのrelease マクロに指定されているような、ドキュメントの対象となっているソフトウェアのバージョン番号です。 
shortversion マクロも参照してください。 
ある API について、ユーザがその API を一部でも利用する場合には警告しておかねばならないような重要な情報です。 
このマクロは注釈が終了する場所を視覚的にマークしないので、段落の末尾の内容にせねばなりません。 
text の内容は完全な文で書き、適切な区切りを入れねばなりません。 
note との違いは、セキュリティに関する情報の場合いは、warning の方が推奨されているという点です。 
以下の二つのマクロは、あるリリースから別のリリースへの変更点に関する情報を説明するときに使います。 
段落一つ程度で説明されているような内容に対して注釈を入れる場合には、その段落の末尾に一行空けて記述します。 
複数の段落からなる場合には、説明全体の末尾に一行空けて記述します。 
versionadded とversionchanged の両方を書かねばならない場合には、 versionadded を先にしてください。 バージョン番号は、リリースされた順番に並んでいなければなりません。 
また、これらのマクロは利用できる環境についての説明よりも前に置かねばなりません。 
実際にマクロを書く場所は、説明としてわかりやすいようにしなければなりませんから、必要に応じて調整してもかまいません。 
文章中で説明している機能が変更された (新たなパラメタの追加、副作用の変化、など) 時の Python のバージョン番号を示すために使います。 explanation は変更内容の短い 説明で、大文字から始まる短い文章にします; 末尾のピリオドはフォーマット処理時に追加されます。 
通常、このマクロをモジュール全体に適用することはありません。 
IncrementalParser のインスタンスは次の追加メソッドを提供します。 : 
data のチャンクを処理します。 
ドキュメントの終わりを決定します。 
終わりに達した時点でドキュメントが整形式であるかどうかを判別、ハンドラを起動後、パース時に使用した資源を解放します。 
このメソッドは close が呼び出された後、次のドキュメントをパース可能にするため、パーサのリセットするのに呼び出されます。 
close 後、reset を呼び出さずに parse や feed を呼び出した場合の戻り値は未定義です。 
論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、その行のインデントレベルを計算するために使われます。 インデントレベルは、実行文のグループ化方法を決定するために用いられます。 
まず、タブは (左から右の方向に) 1 つから 8 つのスペースで置き換えられ、置き換え後の文字列の終わりの位置までの文字数が 8 の倍数になるように調整されます (Unixで使われている規則と同じになるよう意図されています)。 
次に、空白文字でない最初の文字までのスペースの総数から、その行のインデントを決定します。 
バックスラッシュを使ってインデントを複数の物理行に分割することはできません; 最初のバックスラッシュまでの空白がインデントを決定します。 
プラットフォーム間の互換性に関する注意: 非 UNIX プラットフォームにおけるテキストエディタの性質上、一つのソースファイル内でタブとインデントを混在させて使うのは賢明ではありません。 
また、プラットフォームによっては、最大インデントレベルを明示的に制限しているかもしれません。 フォームフィード文字が行の先頭にあっても構いません; フォームフィード文字は上のインデントレベル計算時には無視されます。 
スタックの先頭に積まれてゆく数字は、常にスタックの末尾から先頭にかけて厳密に増加するようになっています。 
各論理行の開始位置において、その行のインデントレベル値がスタックの先頭の値と比較されます。 
値が等しければ何もしません。 インデントレベル値がスタック上の値よりも大きければ、インデントレベル値はスタックに積まれ、INDENT トークンが一つ生成されます。 
インデントレベル値がスタック上の値よりも小さい場合、その値はスタック内のいずれかの値と等しくなければなりません ;スタック上のインデントレベル値よりも大きい値はすべて除去され、値が一つ除去されるごとに DEDENT トークンが一つ生成されます。 
ファイルの末尾では、スタックに残っているゼロより大きい値は全て除去され、値が一つ除去されるごとに DEDENT トークンが一つ生成されます。 以下の例に正しく (しかし当惑させるように) インデントされた Pythonコードの一部を示します: 
以下の例は、様々なインデントエラーになります: 
(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後のエラーのみが字句解析器で見つかります -- return r のインデントは、スタックから逐次除去されていくどのインデントレベル値とも一致しません) 
8.1 スレッド状態 (thread state) 
8. 初期化 (initialization)、終了処理 (finalization)、スレッド 
Python インタプリタを初期化します。 
Python の埋め込みを行うアプリケーションでは、他のあらゆる Python/C API を使用するよりも前にこの関数を呼び出さねばなりません; ただし、Py_SetProgramName() 
,および PyEval_AcquireLock() 
は例外です。 
を生成します。 
(sys.path) も初期化します。 
sys.argv の設定は行いません; 設定するには、PySys_SetArgv() 
を使ってください。 
この関数を (Py_Finalize() 
を呼ばずに) 再度呼び出しても何も行いません。 
戻り値はありません; 初期化が失敗すれば、それは致命的なエラーです。 
initsigsに1を指定すればPy_Initialize()と同じ処理を実行しますが、Python埋め込みアプリケーションではinitsigsを0として初期化時にシグナルハンドラの登録をスキップすることができます。 
Python インタプリタがすでに初期化済みの場合に真 (非ゼロ) を返し、そうでない場合には偽 (ゼロ) を返します。 
Py_Finalize()を呼び出すと、次にPy_Initialize() を呼び出すまでこの関数は偽を返します。 
Py_Initialize() とそれ以後の Python/C API 関数で行った全ての初期化処理を取り消し、最後の Py_Initialize() 呼び出し以後に Python インタプリタが生成した全てのサブインタプリタ (sub-interpreter, 下記の Py_NewInterpreter() を参照) を消去します。 
理想的な状況では、この関数によって Python インタプリタが確保したメモリは全て解放されます。 
この関数を (Py_Initialize() を呼ばずに) 再度呼び出しても何も行いません。 
戻り値はありません; 終了処理中のエラーは無視されます。 この関数が提供されている理由はいくつかあります。 
Python の埋め込みを行っているアプリケーションでは、アプリケーションを再起動することなくPython を再起動したいことがあります。 
また、動的ロード可能イブラリ(あるいは DLL) から Python インタプリタをロードするアプリケーションでは、DLL をアンロードする前に Python が確保したメモリを解放したいと考えるかもしれません。 
アプリケーション内で起きているメモリリークを追跡する際に、開発者は Python が確保したメモリをアプリケーションの終了前に解放させたいと思う場合もあります。 
バグおよび注意事項: モジュールやモジュール内のオブジェクトはランダムな順番で削除されます; このため、他のオブジェクト(関数オブジェクトも含みます) やモジュールに依存するデストラクタ (__del__() メソッド) が失敗してしまうことがあります。 
動的にロードされるようになっている拡張モジュールが Python によってロードされていた場合、アンロードされません。 
Python が確保したメモリがわずかながら解放されないかもしれません (メモリリークを発見したら、どうか報告してください)。 
オブジェクト間の循環参照に捕捉されているメモリは解放されないことがあります。 
拡張モジュールが確保したメモリは解放されないことがあります。 
拡張モジュールによっては、初期化ルーチンを 2 度以上呼び出すと正しく動作しないことがあります; こうした状況は、Py_Initialize() やPy_Finalize() を 2 度以上呼び出すと起こり得ます。 
新しいサブインタプリタ (sub-interpreter) を生成します。 
サブインタプリタとは、(ほぼ完全に) 個別に分割されたPython コードの実行環境です。 
特に、新しいサブインタプリタは、import されるモジュール全てについて個別のバージョンを持ち、これには基盤となるモジュール__builtin__ 
およびsys 
も含まれます。 
ロード済みのモジュールからなるテーブル (sys.modules) およびモジュール検索パス (sys.path) もサブインタプリタ毎に別個のものになります。 
新たなサブインタプリタ環境にはsys.argv 変数がありません。 
また、サブインタプリタは新たな標準 I/O ストリーム sys.stdin, sys.stdout およびsys.stderr を持ちます (とはいえ、これらのストリームは根底にある C ライブラリの同じ FILE 構造体を参照しています)。 
戻り値は、新たなサブインタプリタが生成したスレッド状態 (thread state)オブジェクトのうち、最初のものを指しています。 
このスレッド状態が現在のスレッド状態 (current thread state) になります。 
実際のスレッドが生成されるわけではないので注意してください;下記のスレッド状態に関する議論を参照してください。 
新たなインタプリタの生成に失敗すると、NULL を返します;例外状態はセットされませんが、これは例外状態が現在のスレッド状態に保存されることになっていて、現在のスレッド状態なるものが存在しないことがあるからです。 
(他の Python/C API 関数のように、この関数を呼び出す前にはグローバルインタプリタロック(global interpreter lock) が保持されていなければならず、関数が処理を戻した際にも保持されたままになります; しかし、他の Python/C API 関数とは違い、関数から戻ったときの現在のスレッド状態が関数に入るときと同じとは限らないので注意してください)。 拡張モジュールは以下のような形で (サブ) インタプリタ間で共有されます: ある特定の拡張モジュールを最初に import すると、モジュールを通常通りに初期化し、そのモジュールの辞書の(浅い) コピーをしまい込んでおきます。 
は再度呼び出され ます。 
バグと注意事項: サブインタプリタ (とメインインタプリタ)は同じプロセスの一部分なので、インタプリタ間の絶縁性は完璧ではありません -- 例えば、 
os.close() のような低レベルのファイル操作を使うと、(偶然なり故意なりに) 互いのインタプリタ下にある開かれたファイルに影響を及ぼせてしまいます。 
拡張モジュールを (サブ) インタプリタ間で共有する方法のために、拡張モジュールによっては正しく動作しないかもしれません; 拡張モジュールが (静的な) グローバル変数を利用している場合や、拡張モジュールが初期化後に自身のモジュール辞書を操作する場合には特にそうです。 
一つのサブインタプリタで生成されたオブジェクトは他のサブインタプリタの名前空間への挿入が可能です; ユーザ定義関数、メソッド、インスタンスおよびクラスをサブインタプリタをサブインタプリタ間で共有しないように十分注意してください。 
というのは、これらの共有オブジェクトが実行した import 文は間違った (サブ) インタプリタのロード済みモジュール辞書に影響を及ぼす場合があるからです (XXX この問題は修正が難しいバグで、将来のリリースで解決される予定です) 
指定されたスレッド状態 tstate で表現される (サブ) インタプリタを抹消します。 tstate は現在のスレッド状態でなければなりません。 
下記のスレッド状態に関する議論を参照してください。 
関数呼び出しが戻ったとき、現在のスレッド状態は NULLになっています。 
このインタプリタに関連付けられた全てのスレッド状態は抹消されます。 
(この関数を呼び出す前にはグローバルインタプリタロックを保持しておかねばならず、ロックは関数が戻ったときも保持されています。 
は、その時点で明示的に抹消されていない全てのサブインタプリタを抹消します。 
この関数を呼び出すなら、最初にPy_Initialize() 
を呼び出すよりも前に呼び出さねばなりません。 
この引数値は、Py_GetPath() 
や、以下に示すその他の関数が、インタプリタの実行可能形式からPython ランタイムライブラリへの相対パスを取得するために使われます。 
デフォルトの値は'python' です。 
引数はゼロ終端されたキャラクタ文字列で、静的な記憶領域に入っていなければならず、その内容はプログラムの実行中に変更してはなりません。 
Python インタプリタ内のコードで、この記憶領域の内容を変更するものは一切ありません。 
で設定されたプログラム名か、デフォルトのプログラム名を返します。 
関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
プラットフォーム非依存のファイル群がインストールされている場所であるprefix を返します。 
この値はPy_SetProgramName() でセットされたプログラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます;例えば、プログラム名が'/usr/local/bin/python'の場合、prefix は '/usr/local' になります。 関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
この値はトップレベルの Makefile に指定されている変数prefix や、ビルド値に configure スクリプトに指定した --prefix 引数に対応しています。 
この値は Python コードからは sys.prefix として利用できます。 
Unixでも有用です。 
次に説明する関数も参照してください。 
プラットフォーム依存 のファイルがインストールされている場所であるexec-prefix を返します。 
この値はPy_SetProgramName() でセットされたプログラム名やいくつかの環境変数をもとに、数々の複雑な規則から導出されます;例えば、プログラム名が'/usr/local/bin/python'の場合、exec-prefix は '/usr/local' になります。 
関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
この値はトップレベルの Makefile に指定されている変数exec_prefix や、ビルド値に configure スクリプトに指定した --exec-prefix 引数に対応しています。 
この値は Python コードからは sys.exec_prefix として利用できます。 
Unixのみで有用です。 背景: プラットフォーム依存のファイル (実行形式や共有ライブラリ) が、別個のディレクトリツリー内にインストールされている場合、exec-prefix は prefix と異なります。 
典型的なインストール形態では、プラットフォーム非依存のファイルが/usr/local に収められる一方、プラットフォーム依存のファイルは/usr/local/plat サブツリーに収められます。 概して、プラットフォームとは、ハードウェアとソフトウェアファミリの組み合わせを指します。 
例えば、 Solaris 2.x を動作させている Sparc マシンは全て同じプラットフォームであるとみなしますが、Solaris 2.xを動作させている Intel マシンは違うプラットフォームになりますし、同じ Intel マシンでも Linux を動作させているならまた別のプラットフォームです。 
一般的には、同じオペレーティングシステムでも、メジャーリビジョンの違うものは異なるプラットフォームです。 
Python 実行可能形式の完全なプログラム名を返します; この値はデフォルトのモジュール検索パスを (前述のPy_SetProgramName() で設定された) プログラム名から導出する際に副作用的に計算されます。 
関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
この値は Python コードからは sys.executable として利用できます。 
Unixのみで有用です。 char* 
デフォルトモジュール検索パスを返します; パスは (上のPy_SetProgramName() で設定された) プログラム名と、いくつかの環境変数から計算されます。 
戻り値となる文字列は、プラットフォーム依存のパスデリミタ文字で分割された一連のディレクトリ名からなります。 
デリミタ文字は Unixでは":"、Windows では";" 、Macintosh では "n" (ASCII改行文字) です。 
この値は Python コードからはリストsys.path として利用できます。 
このリストは、値を修正して将来モジュールをロードする際に使う検索パスを変更できます。 
Python インタプリタのバージョンを返します。 
バージョンは、 
"1.5 (#67, Dec 31 1997, 22:34:28) [GCC 2.7.2.2]" ような形式の文字列です。 
第一ワード (最初のスペース文字まで) は、現在の Python のバージョンです; 最初の三文字は、メジャーバージョンとマイナーバージョン、そしてそれを分割しているピリオドです。 
この値は Python コードからはsys.versionとして利用できます。 
現在のプラットフォームのプラットフォーム識別文字列を返します。 
Unixでは、オペレーティングシステムの ``公式の'' 名前を小文字に変換し、後ろにメジャーリビジョン番号を付けた構成になっています;例えば Solaris 2.x は、SunOS 5.x, としても知られていますが、'sunos5' になります。 
Macintosh では 'mac' です。 
Windows では'win' です。 
関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
この値は Python コードからはsys.platformとして利用できます。 
現在の Python バージョンに対する公式の著作権表示文字列、例えば'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'を返します。 
関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
この値は Python コードからはsys.copyrightとして利用できます。 
現在使っているバージョンの Python をビルドする際に用いたコンパイラを示す文字列を、各括弧で囲った文字列を返します。 例えば: 
"[GCC 2.7.2.2]" になります。 
この値は Python コードからはsys.version の一部として取り出せます。 
現在使っている Python インタプリタインスタンスの、シーケンス番号とビルド日時に関する情報を返します。 例えば 
になります。 関数が返す文字列ポインタは静的な記憶領域を返します; 関数の呼び出し側はこの値を変更できません。 
argc および argv に基づいて sys.argv を設定します。 
このパラメタはプログラムの main() 
に渡したパラメタに似ていますが、最初の要素が Python インタプリタの宿主となっている実行形式の名前ではなく、実行されるスクリプト名を参照しなければならない点が違います。 
実行するスクリプトがない場合、argv の最初の要素は空文字列にしてもかまいません。 
8.1 スレッド状態 (thread state) とグローバルインタプリタロック (global interpreter lock) 
8.1 スレッド状態 (thread state) 
この InputSource の公開識別子をセットします。 
この InputSource の公開識別子を返します。 
この InputSource のシステム識別子をセットします。 
この InputSource のシステム識別子を返します。 
この InputSource の文字エンコーディングを取得します。 
この入力ソースのバイトストリームを取得します。 
getEncoding メソッドは、このバイト・ストリームの文字エンコーディングを返します。 認識できないときは None を返します。 
この入力ソースの文字ストリームをセットします(ストリームは Python 1.6 の Unicode-wrapped なファイル風オブジェクトで、ユニコード文字列への変換をサポートしていなければなりません)。 
なお、文字ストリームが指定されても SAX パーサは無視、システム識別子とみなし、バイト・ストリームを使って URI に接続しようとします。 
この入力ソースの文字ストリームを取得します。 
リストで指定したクラスの継承関係から、ネストしたリストを作成します。 
ネストしたリストには、直前の要素から派生したクラスが格納されます。 
各要素は長さ2のタプルで、クラスと基底クラスのタプルを格納しています。 
unique が真の場合、各クラスは戻り値のリスト内に一つだけしか格納されません。 
真でなければ、多重継承を利用したクラスとその派生クラスは複数回格納される場合があります。 
func) 関数の引数名とデフォルト値を取得します。 
getargspec()で取得した4つの値を読みやすく整形します。 
残りの4つの引数はオプションで、名前と値を文字列に変換する整形関数を指定する事ができます。 
getargvalues()で取得した4つの値を読みやすく整形します。 
clsクラスの基底クラス(cls自身も含む)を、メソッドの優先順位順に並べたタプルを返します。 結果のリスト内で各クラスは一度だけ格納されます。 
メソッドの優先順位はクラスの型によって異なります。 
非常に特殊なユーザ定義のメタクラスを使用していない限り、clsが戻り値の先頭要素となります。 
オブジェクトのドキュメンテーション文字列を取得します。 タブはスペースに展開されます。 
コードブロックに合わせてインデントされているdocstringを整形するため、2行目以降では行頭の空白は削除されます。 
オブジェクトがクラス・関数・メソッドの何れかの場合は、オブジェクトのソースコードの直後にあるコメント行(複数行)を、単一の文字列として返します。 オブジェクトがモジュールの場合、ソースファイルの先頭にあるコメントを返します。 
オブジェクトを定義している(テキストまたはバイナリの)ファイルの名前を返します。 
オブジェクトが組み込みモジュール・クラス・関数の場合はTypeError例外が発生します。 
オブジェクトを定義しているモジュールを推測します。 
オブジェクトを定義しているPythonソースファイルの名前を返します。 
オブジェクトが組み込みのモジュール、クラス、関数の場合には、TypeError例外が発生します。 
オブジェクトのソース行のリストと開始行番号を返します。 引数にはモジュール・クラス・メソッド・関数・トレースバック・フレーム・コードオブジェクトを指定する事ができます。 
戻り値は指定したオブジェクトに対応するソースコードのソース行リストと元のソースファイル上での開始行となります。 
ソースコードを取得できない場合はIOErrorが発生します。 
オブジェクトのソースコードを返します。 引数にはモジュール・クラス・メソッド・関数・トレースバック・フレーム・コードオブジェクトを指定する事ができます。 
ソースコードは単一の文字列で返します。 
以下の関数には、戻り値として``フレームレコード''を返す関数があります。 ``フレームレコード''は長さ6のタプルで、以下の値を格納しています:フレームオブジェクト・ファイル名・実行中の行番号・関数名・コンテキストのソース行のリスト・ソース行リストの実行中行のインデックス。 
警告: フレームレコードの最初の要素などのフレームオブジェクトへの参照を保存すると、循環参照になってしまう場合があります。 
循環参照ができると、Pythonの循環参照検出機能を有効にしていたとしても関連するオブジェクトが参照しているすべてのオブジェクトが解放されにくくなり、明示的に参照を削除しないとメモリ消費量が増大する恐れがあります。 
参照の削除をPythonの循環参照検出機能にまかせる事もできますが、finally節で循環参照を解除すれば確実にフレーム(とそのローカル変数)は削除されます。 
また、循環参照検出機能はPythonのコンパイルオプションや 
. disable()で無効とされている場合がありますので注意が必要です。 
例: 
以下の関数でオプション引数contextには、戻り値のソース行リストに何行分のソースを含めるかを指定します。 ソース行リストには、実行中の行を中心として指定された行数分のリストを返します。 
フレーム又はトレースバックオブジェクトの情報を取得します。 
フレームレコードの先頭要素を除いた、長さ5のタプルを返します。 
指定したフレームと、その外側の全フレームのフレームレコードを返します。 
外側のフレームとはframeが生成されるまでのすべての関数呼び出しを示します。 戻り値のリストの先頭はframeのフレームレコードで、末尾の要素はframeのスタックにあるもっとも外側のフレームのフレームレコードとなります。 
指定したフレームと、その内側の全フレームのフレームレコードを返します。 
内のフレームとはframeから続く一連の関数呼び出しを示します。 
戻り値のリストの先頭はtracebackのフレームレコードで、末尾の要素は例外が発生した位置を示します。 
呼び出し元のフレームオブジェクトを返します。 
呼び出し元スタックのフレームレコードのリストを返します。 
最初の要素は呼び出し元のフレームレコードで、末尾の要素はスタックにあるもっとも外側のフレームのフレームレコードとなります。 
実行中のフレームと処理中の例外が発生したフレームの間のフレームレコードのリストを返します。 
最初の要素は呼び出し元のフレームレコードで、末尾の要素は例外が発生した位置を示します。 
install コマンドは最初にビルドコマンドを実行済みにしておいてから、サブコマンド install_lib を実行します。 
このコマンドは配布物中に提供されている全てのデータファイルをインストールします。 
このコマンドは配布物中の全ての (Python) スクリプトをインストールします。 
インスタンスオブジェクト固有の関数はきわめてわずかです。 
クラスインスタンスの型オブジェクトです。 
obj がインスタンスの場合に真を返します。 
特定クラスの新たなインスタンスを生成します。 
パラメタ arg および kw はそれぞれオブジェクトのコンストラクタに渡す実引数およびキーワードパラメタとして使われます。 
特定クラスの新たなインスタンスを生成します。 class は新たに作成するオブジェクトのクラスです。 
dict パラメタはオブジェクトの __dict__ に使われます; dict がNULL なら、インスタンス用に新たな辞書が作成されます。 
この PyObject のサブタイプは Python の整数型オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python の (長整数でない) 整数型を表現します。 
これは types.IntType と同じオブジェクトです。 
o が PyInt_Type 型か PyInt_Type 型のサブタイプであるときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
o が PyInt_Type 型で、かつ PyInt_Type 型のサブタイプでないときに真を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
str の文字列値に基づいて、新たな PyIntObject または PyLongObject を返します。 このとき base を基数として文字列を解釈します。 
pend が NULL でなければ、 *pend 
は str 中で数が表現されている部分以後の先頭の文字のアドレスを指しています。 
base が 0 ならば、str の先頭の文字列に基づいて基数を決定します: もし str が '0x' または '0X'で始まっていれば、基数に 16 を使います; str が '0'で始まっていれば、基数に 8 を使います; その他の場合には基数に 10 を使います。 
base が 0 でなければ、base は 2以上 36 以下の数でなければなりません。 
先頭に空白がある場合は無視されます。 
数字が全くない場合、ValueError が送出されます。 
使用しているマシンの long int 型で表現し切れないくらい大きな数が文字列に入っており、オーバフロー警告が抑制されていれば、PyLongObject を返します。 
オーバフロー警告が抑制されていなければ、NULL を返します。 
ival の値を使って新たな整数オブジェクトを生成します。 現在の実装では、-1 から 100 までの全ての整数に対する整数オブジェクトの配列を保持するようにしており、この範囲の数を生成すると、実際には既存のオブジェクトに対する参照が返るようになっています。 
従って、 1 の値を変えることすら可能です。 
変えてしまった場合の Python の挙動は未定義です :-) 
オブジェクトがまだ PyIntObject でなければまず型キャストを試み、次にその値を返します。 
オブジェクト io の値を返します。 
エラーチェックを行いません。 
オブジェクトがまだ PyIntObject または PyLongObject でなければまず型キャストを試み、次にその値をunsigned long 型で返します。 
この関数はオーバフローをチェックしません。 バージョン 2.3 で 新たに追加 された仕様です。 
整数および長整数リテラルは以下の字句定義で記述されます: 
長整数を表す末尾の文字は小文字の "l" でも大文字の "L" でもかまいませんが、"l" は "1" に良く似ているので、常に "L" を使うよう強く勧めます。 整数で表現できる最大の値よりも大きい整数のリテラル (例えば 32-bit 整数を使っている場合には 2147483647) は、長整数として表現できる値であれば受理されます。 
2.1 値がメモリ上に収まるかどうかという問題を除けば、長整数リテラルには値域の制限がありません。 
整数リテラル (最初の行) と長整数リテラル (二行目および三行目) の例を以下に示します: 
...長整数として表現できる値であれば受理されます。 
バージョン 2.4 以前の Python では, 8 進および 16 進のリテラルのうち,通常の整数型として表現可能な値より大きく,かつ符号無しの 32-bit(32-bit 演算を使う計算機の場合) 整数で表現できる最大値,すなわち 4294967296 よりも小さな数は,リテラルを符号無し整数として表現した値から4294967296 を引いて得られる負の整数として扱っていました. 
対話モードでの入力は、以下の文法の下に構文解析されます: interactive_input 
対話モードでは、(トップレベルの) 複合文の最後に空白行を入れなくてはならないことに注意してください; これは、複合文の終端をパーザが検出するための手がかりとして必要です。 
11. インターネットプロトコルとその支援 
この章で記述されるモジュールは、インターネットプロトコルと関連技術の支援を実装します。 
それらは全てPythonで実装されています。 これらのモジュールの大部分は、システム依存のモジュール 
が存在することが必要ですが、これは現在ではほとんどの一般的なプラットフォーム上でサポートされています。 
ここに概観を示します。 
ウェウブブラウザーのための使い易いコントローラー 
サーバ側で動作するスクリプトがフォームの内容を解釈するために使うゲートウェイインタフェース規格のサポート。 
設定可能な、CGI スクリプトのトレースバック処理機構です。 
URL による任意のネットワークリソースへのアクセス (socket が必要です)。 
様々なプロトコルで URL を開くための拡張可能なライブラリ 
HTTP および HTTPS プロトコルのクライアント (ソケットを必要とします) 。 
FTPプロトコルクライアント(ソケットを必要とします)。 
gopher プロトコルのクライアント (ソケットを必要とします)。 
POP3 プロトコルクライアント (socketsを必要とする) 
NNTP プロトコルクライアント (ソケットを必要とします)。 
SMTP プロトコル クライアント (ソケットが必要です)。 
柔軟性のある SMTP サーバの実装 
Telnet クライアントクラス 
URL を解析して構成要素にします。 
ネットワークサーバ構築のためのフレームワーク。 
基本的な機能を持つ HTTP サーバ (SimpleHTTPServer および CGIHTTPServer の基底クラス)。 
このモジュールは HTTP サーバに基本的なリクエストハンドラを提供します。 
CGI スクリプトの実行機能を持つ HTTP サーバのためのリクエスト処理機構を提供します。 
HTTP クライアント用の Cookie 処理 
HTTP状態管理(cookies)のサポート。 
基本的なXML-RPCサーバーの実装。 
セルフ-ドキュメンティング XML-RPC サーバの実装。 
非同期なソケット制御サービスのためのベースクラス 
非同期コマンド/レスポンスプロトコルの開発サポート 
あるいくつかのことが起きる可能性があります: 
入力はが正しくない。 compile_command()が例外(SyntaxErrorかOverflowError)を起こした場合。 
showsyntaxerror()メソッドの呼び出によって、構文トレースバックが表示されるでしょう。 runsource()はFalseを返します。 
入力が完全。 
compile_command()がコードオブジェクトを返した場合。 (SystemExitを除く実行時例外も処理する)runcode()を呼び出すことによって、コードは実行されます。 
runsource()はFalseを返します。 
次の行を要求するためにsys.ps1かsys.ps2のどちらを使うかを決定するために、戻り値を利用できます。 
コードオブジェクトを実行します。 例外が生じたときは、トレースバックを表示するためにshowtraceback()が呼び出されます。 
呼び出し側はそれを処理するために準備しておくべきです。 
起きたばかりの構文エラーを表示します。 
起きたばかりの例外を表示します。 
文字列を標準エラーストリーム(sys.stderr)へ書き込みます。 必要に応じて適切な出力処理を提供するために、導出クラスはこれをオーバーライドすべきです。 
起動すると、バージョン情報と "" プロンプトが表示されます。 
標準ドキュメントに書かれているインタプリタとまったく同じように使えます。 
Python/C API リファレンスマニュアル 
Python のアプリケーションプログラマ用インタフェース (Application Programmer's Interface, API) は、Python インタプリタに対する様々なレベルでのアクセス手段をC や C++ のプログラマに提供しています。 
この API は通常C++ からも全く同じように利用できるのですが、簡潔な呼び名にするために Python/C API と名づけられています。 
根本的に異なる二つの目的から、 Python/C API が用いられます。 
第一は、特定用途の 拡張モジュール (extention module)、すなわち Python インタプリタを拡張する C で書かれたモジュールを記述する、という目的です。 
第二は、より大規模なアプリケーション内で Python を構成要素 (component) として利用するという目的です;このテクニックは、一般的にはアプリケーションへの Python の埋め込み (embedding) と呼びます。 
拡張モジュールの作成は比較的わかりやすいプロセスで、``手引書 (cookbook)'' 的なアプローチでうまく実現できます。 
作業をある程度まで自動化してくれるツールもいくつかあります。 
一方、他のアプリケーションへの Python の埋め込みは、Python ができてから早い時期から行われてきましたが、拡張モジュールの作成に比べるとやや難解です。 
多くの API 関数は、Python の埋め込みであるか拡張であるかに関わらず役立ちます; とはいえ、 Python を埋め込んでいるほとんどのアプリケーションは、同時に自作の拡張モジュールも提供する必要が生じることになるでしょうから、Python を実際にアプリケーションに埋め込んでみる前に拡張モジュールの書き方に詳しくなっておくのはよい考えだと思います。 
1.2.1.1 参照カウントの詳細 
1. 導入 このリファレンスマニュアルは、Python プログラミング言語自体に関する記述です。 
チュートリアルとして書かれたものではありません。 
私は本マニュアルをできるだけ正確に書こうとする一方で、文法や字句解析以外の全てについて、形式化された仕様記述ではなく英語を使うことにしました。 
一方、広く使われているPython 実装は現在のところ唯一 (今や第二の実装が存在しますが!) なので、特定のクセについては、特に実装によって何らかの制限が加えられている場合には、触れておく価値があります。 
従って、このテキスト全体にわたって短い ``実装に関する注釈 (imprementation notes)'' がちりばめられています。 Python 実装はいずれも、数々の組み込みモジュールと標準モジュールが付属します。 
これらはここではドキュメント化されていませんが、 
でドキュメント化されています。 
いくつかの組み込みモジュールについては、言語定義と重要なかかわりをもっているときについて触れています。 
1.1 本マニュアルにおける表記法 
Python では二種類のイテレータオブジェクトを提供しています。 
一つ目はシーケンスイテレータで、__getitem__() メソッドをサポートする任意のシーケンスを取り扱います。 
二つ目は呼び出し可能オブジェクトとセンチネル値 (sentinel value) を扱い、シーケンス内の要素ごとに呼び出し可能オブジェクトを呼び出して、センチネル値が返されたときに反復処理を終了します。 
PySeqIter_New() や、組み込みシーケンス型に対して1 引数形式の組み込み関数iter() を呼び出したときに返される、イテレータオブジェクトの型オブジェクトです。 バージョン 2.2 で 新たに追加 された仕様です。 
PySeqIter_Type の型が op のときに真を返します。 
一般的なシーケンスオブジェクト seq を扱うイテレータを返します。 
反復処理は、シーケンスが添字指定操作の際に IndexError を返したときに終了します。 バージョン 2.2 で 新たに追加 された仕様です。 
PyCallIter_New() や、組み込み関数 iter()の 2 引数形式が返すイテレータオブジェクトの型オブジェクトです。 iter() built-in function.バージョン 2.2 で 新たに追加 された仕様です。 
PyCallIter_Type の型が op のときに真を返します。 
新たなイテレータを返します。 
最初のパラメタ callable は引数なしで呼び出せる Python の呼び出し可能オブジェクトならなんでもかまいません; callableは、呼び出されるたびに次の反復処理対象オブジェクトを返さなければなりません。 
生成されたイテレータは、 callableが sentinel に等しい値を返すと反復処理を終了します。 バージョン 2.2 で 新たに追加 された仕様です。 
イテレータを扱うための固有の関数は二つしかありません。 
o がイテレータプロトコルをサポートする場合に真を返します。 
反復処理 o における次の値を返します。 
オブジェクトがイテレータの場合、この関数は反復処理における次の値を取り出します。 要素が何も残っていない場合には例外がセットされていない状態で NULL を返します。 
オブジェクトがイテレータでない場合には TypeErrorを送出します。 要素を取り出す際にエラーが生じると NULL を返し、発生した例外を送出します。 
イテレータの返す要素にわたって反復処理を行うループを書くと、C のコードは以下のようになるはずです: 
PyObject *iterator = PyObject_GetIter(obj);PyObject *item;if (iterator == NULL) {/* エラーの伝播処理をここに書く */}while (item = PyIter_Next(iterator)) {/* 取り出した要素で何らかの処理を行う */.../* 終わったら参照を放棄する */Py_DECREF(item);}Py_DECREF(iterator);if (PyErr_Occurred()) {/* エラーの伝播処理をここに書く */}else {/* 別の処理を続ける */} 
以下に各ツールの一般的な使い方と、ツールの組み合わせの例を示します。 
以下の関数は全て、イテレータを作成して返します。 無限長のストリームのイテレータを返す関数もあり、この場合にはストリームを中断するような関数かループ処理から使用しなければなりません。 
先頭のiterableの全要素を返し、次に2番目のiterableの全要素…と全iterableの要素を返すイテレータを作成します。 
連続したシーケンスを、一つのシーケンスとして扱う場合に使用します。 
この関数は以下のスクリプトと同等です: 
nで始まる、連続した整数を返すイテレータを作成します。 n を指定しなかった場合、デフォルト値はゼロです。 
現在、Pythonの長整数はサポートしていません。 
imap()で連続したデータを生成する場合やizip()でシーケンスに番号を追加する場合などに引数として使用することができます。 
count()はオーバーフローのチェックを行いません。 このため、sys.maxintを超えると負の値を返します。 
この動作は将来変更されます。 
iterableから要素を取得し、同時にそのコピーを保存するイテレータを作成します。 
iterableの全要素を返すと、セーブされたコピーから要素を返し、これを無限に繰り返します。 
predicateが真である限りは要素を無視し、その後は全ての要素を返すイテレータを作成します。 
このイテレータは、predicateが真の間は全く要素を返さないため、最初の要素を返すまでに長い時間がかかる場合があります。 
同じキーをもつような要素からなるiterable 中のグループに対して、キーとグループを返すようなイテレータを作成します。 
key は各要素に対するキー値を計算する関数です。 
キーを指定しない場合や None にした場合、デフォルトはオブジェクトのアイデンティティ関数をになり、要素をそのまま返します。 
通常、iterable は同じキー関数で並べ替え済みでなければなりません。 
返されるグループはそれ自体がイテレータで、groupby()と iterable を共有しています。 
predicateがTrueとなる要素だけを返すイテレータを作成します。 predicateがNoneの場合、値が真であるアイテムだけを返します。 
この関数は以下のスクリプトと同等です: def ifilter(predicate, iterable):if predicate is None:predicate = boolfor x in iterable:if predicate(x):yield x 
predicateがFalseとなる要素だけを返すイテレータを作成します。 predicateがNoneの場合、値が偽であるアイテムだけを返します。 
この関数は以下のスクリプトと同等です: def ifilterfalse(predicate, iterable):if predicate is None:predicate = boolfor x in iterable:if not predicate(x):yield x 
iterablesの要素を引数としてfuntionを呼び出すイテレータを作成します。 
functionがNoneの場合、引数のタプルを返します。 
map()と似ていますが、最短のiterableの末尾まで到達した後はNoneを補って処理を続行するのではなく、終了します。 
これは、map()に無限長のイテレータを指定するのは多くの場合誤りですが(全出力が評価されてしまうため)、imap()の場合には一般的で役に立つ方法であるためです。 
この関数は以下のスクリプトと同等です: def imap(function, *iterables):iterables = map(iter, iterables)while True:args = [i.next() for i in iterables]if function is None:yield tuple(args)else:yield function(*args) 
iterableから要素を選択して返すイテレータを作成します。 startが0以外であれば、iterableの先頭要素はstartに達するまでスキップします。 
以降、stepが1以下なら連続した要素を返し、1以上なら指定された値分の要素をスキップします。 
stopがNoneであれば、無限に、もしくはiterableの全要素を返すまで値を返します。 None以外ならイテレータは指定された要素位置で停止します。 
通常のスライスと異なり、start、stop、stepに負の値を指定する事はできません。 
シーケンス化されたデータから関連するデータを取得する場合(複数行からなるレポートで、三行ごとに名前が指定されている場合など)に使用します。 
各iterableの要素をまとめるイテレータを作成します。 zip()に似ていますが、リストではなくイテレータを返します。 
複数のイテレート可能オブジェクトに対して、同じ繰り返し処理を同時に行う場合に使用します。 
バージョン 2.4 で 変更 された仕様:イテレート可能オブジェクトを指定しない場合、TypeError 例外を送出する代わりに長さゼロのイテレータを返します。 
timesを指定しない場合、無限に値を返し続けます。 
imap()で常に同じオブジェクトを関数の引数として指定する場合に使用します。 
また、izip()で作成するタプルの全要素に常に同じオブジェクトを指定する場合にも使用することもできます。 
iterablesの要素を引数としてfuntionを呼び出すイテレータを作成します。 
functionの引数が単一のiterableにタプルとして格納されている場合(``zip済み'')、imap()の代わりに使用します。 
imap()とstarmap()ではfunctionの呼び出し方法が異なり、imap()はfunction(a,b)、starmap()ではfunction(*c)のように呼び出します。 この関数は以下のスクリプトと同等です: 
predicateが真である限りiterableから要素を返すイテレータを作成します。 
一つのiterable からn 個の独立したイテレータを生成して返します。 
n==2 の場合は、以下のコードと等価になります: def tee(iterable):def gen(next, data={}, cnt=[0]):for i in count():if i == cnt[0]:item = data[i] = next()cnt[0] += 1else:item = data.pop(i)yield itemit = iter(iterable)return (gen(it.next), gen(it.next)) 
この節では、既存の itertools をビルディングブロックとしてツールセットを拡張するためのレシピを示します。 
iterable 全体をを一度にメモリ上に置くよりも、要素を一つづつ処理する方がメモリ効率上の有利さを保てます。 関数形式のままツールをリンクしてゆくと、コードのサイズを減らし、一時変数を減らす助けになります。 
インタプリタのオーバヘッドをもたらす for ループやジェネレータを使わずに、``ベクトル化された'' ビルディングブロックを使うと、高速な処理を実現できます。 
2.3.2 予約済みの識別子種 (reserved classes 
以下の識別子は、予約語、または Python 言語におけるキーワード (keyword) として使われ、通常の識別子として使うことはできません。 
キーワードは厳密に下記の通りに綴らなければなりません: 
識別子 as は import 文における構文の一部として使われることがありますが、現在のところ予約語ではありません。 将来の Python のバージョンでは、識別子 as と Noneはともにキーワードになる予定です。 
ラムダ形式 (lambda form, ラムダ式 (lambda expression)) は、構文法的には式と同じ位置付けになります。 
ラムダは、無名関数を作成できる省略記法です; 式 lambda arguments: expression 
は、関数オブジェクトになります。 
ラムダが表す無名オブジェクトは、以下のコード 
で定義された関数と同様に動作します。 引数リストの構文法については、7.5 節を参照してください。 
ラムダ形式で作成された関数は、実行文 (statement) を含むことができないので注意してください。 
18. Python言語サービス 
PythonにはPython言語を使って作業するときに役に立つモジュールがたくさん提供されています。 
これらのモジュールはトークンの切り出し、パース、構文解析、バイトコードのディスアセンブリおよびその他のさまざまな機能をサポートしています。 これらのモジュールには、次のものが含まれています: 
Pythonソースコードに対する解析木へのアクセス。 
文字列がPythonのキーワードか否かを調べます。 
Pythonソースコードのための字句解析器。 
ディレクトリツリー内のPythonのソースファイルで問題となる空白を検出するツール。 
Pythonクラスデスクリプタの情報抽出サポート 
Pythonソースファイルをバイトコードファイルへコンパイル。 
ディレクトリに含まれるPythonソースファイルを、一括してバイトコンパイルします。 
現在インストールされている Python に追加するためのモジュール構築、および実際のインストールを支援する。 
LaTeX は、次の節で紹介する Python 固有のドキュメントクラスで提供しているマークアップの他にも、様々な環境を提供しています。 
以下に挙げる環境は、 Python の標準ドキュメント内で使っている標準の LaTeX の環境の一部です; 詳しい説明は今後追加してゆく予定です。 
4 LaTeX 入門 この節では、LaTeX の概念と構文法について簡単に紹介し、ドキュメントの作者が ``TeXnician'' にならなくてもドキュメントを十分生産的に書けるような情報を提供します。 
この節を読んだからといって、LaTeX でドキュメントを書く上で必要な全ては学べません; LaTeX が提供している標準の ``環境 (environment)''については、ここでは説明しません。 おそらく、Python ドキュメントのマークアップにおいて心に留めておくべき最も重要な概念は、TeX が非体系的なのに対して、LaTeX は TeXの上のレイヤとして設計されていて、本質的には構造化マークアップをサポートしているということです。 
Python 特有のマークアップは、標準の LaTeX ドキュメントクラスで提供されている構造を拡張し、Python 特有の情報を書けるようサポートするためのものです。 
LaTeX ドキュメントには、二つの構成要素: プリアンブルと本体が入っています。 プリアンブルは、タイトル、著者のリスト、日付、ドキュメントが属する クラス といった、ドキュメント自体に関するメタデータを指定するために使います。 
その他の情報で、インデクスの生成や参考文献データベースの使用を制御するものもプリアンブル内に置けます。 
ほとんどの著者にとっては、既存のドキュメントからプリアンブルをコピーし、いくつかの情報を修正するだけで、簡単にプリアンブルを作成できます。 ドキュメントのクラス は、ドキュメントをある広範なカテゴリに分類し、そのカテゴリで共通の基本的なフォーマットプロパティを設定するために使います。 
Python ドキュメントの場合、二つのクラス:manual クラスと howto クラスを使います。 
これらのクラスではまた、Python における概念やデータ構造を説明する際に使うマークアップも定義しています。 
これらのクラスに関する詳しい説明は、後述の 5 節、 ``ドキュメントクラス''にあります。 
ドキュメントクラスの宣言はプリアンブルの先頭にあります。 クラス宣言の後ろには数多くのマクロ があり、ドキュメントに関する詳細情報を宣言したり、追加のマークアップを設定しています。 
プリアンブルからは何も出力生成されません; 自由文 (free text)は出力生成につながるため、プリアンブルに自由文をおくとエラーになります。 ドキュメント本体はプリアンブルの後に続けます。 
本体には、出力すべきドキュメントの構成要素を構造的にマークアップして入れます。 
一般的なLaTeX の構造には、階層化された章節、番号付けリストや箇条書きリスト、そしてドキュメントの概要や索引といった特殊な構造があります。 
LaTeX は、章、セクション、サブセクション、付録などといった、伝統的な階層化によるドキュメントの整理を想定しています。 
これらの各階層は環境ではなくマクロでマークしますが、おそらくこれはある章構造とレベルが同じかより高い章構造が続くと、その章がそこで終わったと考えて差し支えないからでしょう。 Python ドキュメントが使っているクラスには 6 段階の章節分けの ``レベル'' があり、そのうち最も深い 2 レベル 
は使いません。 
レベル 
マクロ名 
5 節、``ドキュメントクラス'' で述べたように、manual ドキュメントだけで使います。 
テキストの段落とは違います; このレベルは誰も使っていないようです。 
... レベル 
表中では、深いレベルほど番号が大きくなります。 
4.1 構文法 Python ドキュメントの作者は、LaTeX の構文法についていくつか知っておかねばならないことがあります。 
コメント は、``パーセント'' 文字 ("%")から始まり、行末まで、または次の行の先頭にある空白文字まで続きます。 
これは著者の知っているどのプログラミング言語とも少し違っています。 そこで、順序立てて例を挙げます: 
最初の行のコメントの以降で、コメントでないとみなされる最初の文字は、二行目の"T" になります; 二行目の先頭にある空白文字は、最初の行のコメントの一部として消費してしまいます。 
グループは入れ子構造にして階層化できます。 
フォーマット処理のコンテキストは、フォントや、追加のマクロ定義 (またはグループ外部で定義されているマクロに対するオーバライド) を含みます。 
構文法的には、グループは波括弧で囲います: 
マクロや環境におけるパラメタをマークする場合を除き、Python ドキュメントではグループ自体は控えめに使います。 マクロ は通常は単純な構成要素で、マクロ名で識別され、いくつかのパラメタを取ることがあります。 
通常の LaTeX の使用法では、パラメタのうちの一つがオプションになっていることがあります。 
マークアップはバックスラッシュ文字 ("") から始め、マクロ名はアルファベット文字 (数字、ハイフン、アンダースコア以外)で与えます。 
必須パラメタはグループとしてマークし、オプションのパラメタはグループの代用構文でマークせねばなりません。 例えば、 単一のパラメタをとるマクロは以下のようになります: 
オプションのパラメタをとるマクロで、パラメタを指定するときには以下のように入力します: 
オプションと必須パラメタの両方が必要な場合には、以下のようになります: 
マクロ名の後ろには空白や改行を入れてもかまいません; この場合、マクロ名とパラメタ間の空白は取り去られてしまいます。 しかし、Python ドキュメントではこうした使い方を実践しません。 
空白はマクロにパラメタがない場合にも取り去られますが、この場合には空のグループ ({}) や、空白の明示的表現 (" ") をマクロ名の直後に続けると、マクロ展開が後続の文字に及ぶのを避ける手助けになります。 
パラメタを取らないが、後ろに空白を続けたくないマクロの場合には、ドキュメントソース中で名前の後ろに名前に使わない文字 (区切り文字など) が入っていれば、特別扱いする必要はありません。 例題中の各行は、パラメタをとらないマクロが入った文章を書くための適切な方法を示しています。 
環境 はマクロよりも大きな構文要素です。 環境は、マクロの引数に入れるには内容がやや大きすぎて便利さを欠く場合に使えます。 
主に、本文の大きな断片の前後でフォーマットパラメタを変更する必要があり、かつ本文を十分柔軟に書きたい場合に使います。 
これらのマクロはいずれも環境の名前をパラメタにとります。 
以下の例は、ドキュメントの概要をマークするために使う環境です: 
環境は、環境自体の必須パラメタやオプションパラメタを持つこともあります。 
これらのパラメタは begin マクロのパラメタの後ろに続けます。 以下に単一の必須パラメタをとる環境の例を示します: 
ASCII に含まれない文字、特殊文字とされている文字、TeX やLaTeXで アクティブ (active) な文字を入力するための、あまり使われないマークアップがあります。 
これらのマークアップはよく他の文字に隣接して使われるので、適切な文字を生成するためには、マークアップの後ろにスペースや空のグループを置く必要があるかもしれません。 あるいは、マークアップをグループ内に囲ってもかまいません。 
Python ドキュメントで使われるようなマークアップを以下にいくつか示します: 
キャラクタ文字 
マークアップ 
以下のテストコードがあった場合: 
テストケースインスタンスは次のように作成します: 
初期設定、終了処理が必要な場合は、次のように指定します: 
注意:PyUnitはAssertionErrorによるテストの失敗検出もサポートしていますが、推奨されません。 
将来のバージョンでは、AssertionErrorは別の目的に使用される可能性が有ります。 
Python で書かれたプログラムは パーザ (parser) に読み込まれます。 
パーザへの入力は、字句解析器 (lexical analyzer) によって生成された一連の トークン (token) からなります。 
将来のバージョンとの互換性に関する注意: 8-bit 文字に対する文字セットを ISO Latin-1 (ラテン語系アルファベットを用いるほとんどの西欧言語をカバーするASCII の上位セット) とみなしたい気にもなるかもしれません。 しかし、おそらく Unicode を編集できるテキストエディタが将来一般的になるはずです。 
こうしたエディタでは一般的に UTF-8 エンコードを使いますが、UTF-8 エンコードは ASCIIの上位セットではあるものの、文字序数 (ordinal) 128-255 の扱いが非常に異なります。 
この問題に関してはまだ合意が得られていませんが、Latin-1 と UTF-8 のどちらかとみなすのは、たとえ現在の実装が Latin-1びいきのように思えたとしても賢明とはいえません。 
これはソースコード文字セットと実行時の文字セットのどちらにも該当します。 
6.8 ライブラリレベルのマークアップ このマークアップは、一そろいのモジュールについて説明する際に使います。 
例えば、 
Macintosh ライブラリモジュール 
ドキュメントでは、モジュールの集まりを概観できるようにするためにこのマクロを役立てています。 また、 
も同様の目的にこのマクロを利用しています。 
現在の章 (howto ドキュメントの場合はドキュメント全体) に対して.syn ファイルが存在する場合には、.syn ファイルから読み出した内容でsynopsistable を作成します。 
Python プログラムは多数の 論理行 (logical lines) に分割されます。 
2.1.1 論理行 (logical line) 
Python ソースと一緒についてくるconfigure スクリプトは動的にリンクされる拡張モジュールが必要とするシンボルを公開するようただしく Python をビルドしますが、この機能はPython ライブラリを静的に埋め込むようなアプリケーションには継承されません。 少なくとも Unix ではそうです。 
これは、アプリケーションが静的な実行時ライブラリ (libpython.a)にリンクされていて、かつ (.so ファイルとして実装されている) 動的ロードされるような拡張モジュールをロードする必要がある場合に起きる問題です。 問題になるのは、拡張モジュールが使うあるエントリポイントがPython ランタイムだけで定義されているという状況です。 
埋め込みを行うアプリケーション側がこうしたエントリポイントを全く使わない場合、リンカによってはエントリポイントを最終的に生成される実行可能形式のシンボルテーブル内に含めません。 
こうした場合、リンカに追加のオプションを与えて、これらのシンボルを除去しないよう教える必要があります。 プラットフォームごとに正しいオプションを決めるのはかなり困難です、とはいえ、幸運なことに、オプションは Python のビルド設定内にすでにあります。 
インストール済みの Python インタプリタからオプションを取り出すには、対話インタプリタを起動して、以下のような短いセッションを実行します: 
表示された文字列の内容が、ビルド時に使うべきオプションです。 
文字列が空であれば、特に追加すべきオプションはありません。 
LINKFORSHARED の定義内容は、 Python のトップレベルMakefile 内の同名の変数に対応しています。 
この PyObject のサブタイプは Python のリストオブジェクトを表現します。 
この PyTypeObject のインスタンスは Python のタプル型を表現します。 
これは Python レイヤにおけるtypes.ListType と同じオブジェクトです。 
サイズが len 新たなリストオブジェクトを返します。 失敗すると NULL を返します。 
リストオブジェクトlist の長さを返します; リストオブジェクトにおける "len(list)" と同じです。 
マクロ形式でできた PyList_Size() で、エラーチェックをしません。 
p の指すリストオブジェクト内の、位置 pos にあるオブジェクトを返します。 
pos が範囲を超えている場合、 NULL を返してIndexError 例外をセットします。 
マクロ形式でできた PyList_GetItem() で、エラーチェックをしません。 
リストオブジェクト内の位置 index に、オブジェクト item を挿入します。 
成功した場合には0 を返し、失敗すると -1を返します。 
注意:この関数は item への参照を ``盗み取り'' ます。 また、変更先のインデクスにすでに別の要素が入っている場合、その要素に対する参照を放棄します。 
PyList_SetItem() をマクロによる実装で、エラーチェックを行いません。 この関数は、新たなリストのまだ要素を入れたことのない位置に要素を入れるときにのみ使います。 
注意:この関数は item への参照を ``盗み取り'' ます。 また、PyList_SetItem() と違って、要素の置き換えが生じても置き換えられるオブジェクトへの参照を放棄 しません;その結果、 list 中の位置 i で参照されていたオブジェクトがメモリリークを引き起こします。 
要素 item をインデクス index の前に挿入します。 
成功すると 0 を返します。 失敗すると -1 を返し、例外を送出します。 
list.insert(index, item) に類似した機能です。 
オブジェクト item を list の末尾に追加します。 成功すると 0 を返します; 失敗すると -1 を返し、例外をセットします。 
list.append(item) に類似した機能です。 
list 内の、low から high の 間の オブジェクトからなるリストを返します。 
失敗すると NULL を返し、例外をセットします。 
list[low:high] に類似した機能です。 
list 内の、low から high の間のオブジェクトを、itemlist の内容にします。 
itemlist は NULL でもよく、空リストの代入 (指定スライスの削除) になります。 成功した場合には 0 を、失敗した場合には -1 を返します。 
list の内容をインプレースでソートします。 
成功した場合には0 を、失敗した場合には -1 を返します。 
list の要素をインプレースで反転します。 
" list.reverse()" と同じです。 
list の内容が入った新たなタプルオブジェクトを返します;"tuple(list)". と同じです。 
小さなモジュール配布物の場合、パッケージを列挙するよりも、全てのモジュールを列挙するほうがよいと思うかもしれません --特に、単一のモジュールが ``ルートパッケージ'' にインストールされる (すなわち、パッケージは全くない) ような場合がそうです。 
この最も単純なケースは2 で示しました; ここではもうちょっと入り組んだ例を示します: 
ここでは二つのモジュールについて述べていて、一方は ``ルート''パッケージに入り、他方は pkg パッケージに入ります。 
ここでも、デフォルトのパッケージ/ディレクトリのレイアウトは、二つのモジュールが mod1.py と pkg/mod2.py にあり、pkg/__init__.py が存在することを暗示しています。 また、パッケージ/ディレクトリの対応関係はpackage_dir オプションでも上書きできます。 
packages オプションは、 packages リスト中で指定されている各々のパッケージについて、パッケージ内に見つかった全ての pure Python モジュールを処理 (ビルド、配布、インストール、等) するよう Distutils に指示します。 
このオプションを指定するためには、当然のことながら各パッケージ名はファイルシステム上のディレクトリ名と何らかの対応付けができなければなりません。 
デフォルトで使われる対応関係はきわめてはっきりしたものです。 すなわち、パッケージdistutils が配布物ルートディレクトリからの相対パスdistutils で表されるディレクトリ中にあるというものです。 
つまり、setup スクリプト中で packages = ['foo'] と指定したら、スクリプトの置かれたディレクトリからの相対パスでfoo/__init__.py を探し出せると Distutils に確約したことになります。 
この約束を裏切ると Distutils は警告を出しますが、そのまま壊れたパッケージの処理を継続します。 ソースコードディレクトリの配置について違った規約を使っていても、まったく問題はありません: 単に package_dir オプションを指定して、 Distutils に自分の規約を教えればよいのです。 
例えば、全ての Python ソースコードを lib 下に置いて、``ルートパッケージ'' 内のモジュール (つまり、どのパッケージにも入っていないモジュール) を lib 内に入れ、foo パッケージを lib/foo に入れる、といった具合にしたいのなら、 
を setup スクリプト内に入れます。 
辞書内のキーはパッケージ名で、空のパッケージ名はルートパッケージを表します。 
キーに対応する値はルートパッケージからの相対ディレクトリ名です、この場合、packages = ['foo'] を指定すれば、lib/foo/__init__.py が存在すると Distutils に確約したことになります。 
もう一つの規約のあり方は foo パッケージを lib に置き換え、foo.bar パッケージが lib/bar にある、などとするものです。 
このような規約は、 setup スクリプトでは 
のように書きます。 package_dir 辞書に 
のようなエントリがあると、package の下にある全てのパッケージに対してこの規則が暗黙のうちに適用され、その結果 foo.bar の場合が自動的に処理されます。 
この例では、 packages = ['foo', 'foo.bar'] は、Distutils に lib/__init__.py と lib/bar/__init__.py を探すように指示します。 
(package_dir は再帰的に適用されますが、この場合packages の下にある全てのパッケージを明示的に指定しなければならないことを心に留めておいてください:Distutils は __init__.py を持つディレクトリをソースツリーから再帰的にさがしたりは しません 。 ) 
リスト表現は、角括弧で囲われた式の系列です。 系列は空の系列であってもかまいません: 
リスト表現は、新に作成されたリストオブジェクトを表します。 
新たなリストの内容は、式のリストを与えるか、リストの内包表記(list comprehension) で指定します。 
カンマで区切られた式のリストを与えた場合、リストの各要素は左から右へと順に評価され、評価された順番にリスト内に配置されます。 
リストの内包表記を与える場合、内包表記はまず単一の式、続いて少なくとも一つの for 節、続いてゼロ個以上の for 節か、if 節になります。 
この場合、新たに作成されるリストの各要素は、各々の forや if 節を左から右の順にネストしたブロックとみなして実行し、ネストの最内ブロックに到達する度に式を評価した値となります。 
...ネストの最内ブロックに到達する度に式を評価した値となります。 
Python 2.3 では、リスト内包が "for" の中で使う制御変数を内包表記を書いたスコープに「漏らして」しまう仕様になっていました。 
この挙動は撤廃されたので、将来のバージョンでバグが修正されれば、この挙動に依存したコードは動作しなくなります。 
リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。 
2.4.1 文字列リテラル 
6.27.2 Python 拡張の作者と、Python を埋め込むようなプログラムに関して 
C ライブラリの gettext インタフェースが提供されているシステムでは、locake モジュールでそのインタフェースを公開しています。 
このインタフェースは関数 gettext()、 dgettext()、dcgettext()、textdomain()、bindtextdomain()、およびbind_textdomain_codeset() からなります。 
これらは 
モジュールの同名の関数に似ていますが、メッセージカタログとして C ライブラリのバイナリフォーマットを使い、メッセージカタログを探すために C ライブラリのサーチアルゴリズムを使います。 
Python アプリケーションでは、通常これらの関数を呼び出す必要はないはずで、代わりに 
こうしたアプリケーションでは、ライブラリが正しいメッセージカタログを探せるようにテキストドメイン名を指定する必要があります。 
Locator のインスタンスは次のメソッドを提供します。 : 
現在のイベントが終了する列番号を返します。 
現在のイベントが終了する行番号を返します。 
現在の文書イベントの公開識別子を返します。 
現在のイベントのシステム識別子を返します。 
7.5.1 Lock オブジェクト プリミティブロックとは、ロックが生じた際に特定のスレッドによって所有されない同期プリミティブです。 
Python では現在のところ拡張モジュール 
ロックには基本となる二つのメソッド、acquire()とrelease() があります。 
ロックの状態がアンロックである場合、acquire() は状態をロックに変更して即座に処理を戻します。 
状態がロックの場合、acquire()は他のスレッドがrelease() を呼出してロックの状態をアンロックに変更するまでブロックします。 
その後、状態をロックに再度設定してから処理を戻します。 release() メソッドを呼び出すのはロック状態のときでなければなりません; このメソッドはロックの状態をアンロックに変更し、即座に処理を戻します。 
引数blocking の値を真にして呼び出した場合、引数なしで呼び出したときと同じことを行ない、Trueを返します。 
引数blocking の値を偽にして呼び出すとブロックしません。 
引数なしで呼び出した場合にブロックするような状況であった場合には直ちに偽を返します。 
それ以外の場合には、引数なしで呼び出したときと同じ処理を行い真を返します。 
ロックを解放します。 ロックの状態がロックのとき、状態をアンロックにリセットして処理を戻します。 
6.29.10 環境設定 
6.29.10.1 環境設定のための関数 
6.29.9 スレッド安全性 
6.29.10.1 環境設定のための関数 
6.29.10.2 環境設定ファイルの書式 
6.29.10.1 環境設定のための関数 
fileConfig() が解釈できる環境設定ファイルの形式は、ConfigParser の機能に基づいています。 
ファイルには、[loggers]、 [handlers]、および[formatters] といったセクションが入っていなければならず、各セクションではファイル中で定義されている各タイプのエンティティを名前で指定しています。 
こうしたエンティティの各々について、そのエンティティをどう設定するかを示した個別のセクションがあります。 
すなわち、log01 という名前の [loggers] セクションにあるロガーに対しては、対応する詳細設定がセクション [logger_log01]に収められています。 
同様に、 hand01 という名前の[handlers] セクションにあるハンドラは [handler_hand01]と呼ばれるセクションに設定をもつことになり、[formatters] セクションにある form01 は [formatter_form01]というセクションで設定が指定されています。 
ルートロガーの設定は [logger_root] と呼ばれるセクションで指定されていなければなりません。 ファイルにおけるこれらのセクションの例を以下に示します。 
ルートロガーでは、レベルとハンドラのリストを指定しなければなりません。 
ルートロガーのセクションの例を以下に示します。 
level エントリは DEBUG, INFO, WARNING, ERROR, CRITICALのうちの一つか、NOTSET になります。 
ルートロガーの場合にのみ、NOTSET は全てのメッセージがログ記録されることを意味します。 
レベル値は logging パッケージの名前空間のコンテキストにおいて eval() されます。 handlers エントリはコンマで区切られたハンドラ名からなるリストで、[handlers] セクションになくてはなりません。 
また、これらの各ハンドラの名前に対応するセクションが設定ファイルに存在しなければなりません。 ルートロガー以外のロガーでは、いくつか追加の情報が必要になります。 
これは以下の例のように表されます。 
level および handlers エントリはルートロガーのエントリと同様に解釈されますが、非ルートロガーのレベルが NOTSETに指定された場合、ログ記録システムはロガー階層のより上位のロガーにロガーの実効レベルを問い合わせるところが違います。 
propagate エントリは、メッセージをロガー階層におけるこのロガーの上位のハンドラに伝播させることを示す 1 に設定されるか、メッセージを階層の上位に伝播しない ことを示す 0 に設定されます。 
qualname エントリはロガーのチャネル名を階層的に表したもの、すなわちアプリケーションがこのロガーを取得する際に使う名前になります。 ハンドラの環境設定を指定しているセクションは以下の例のようになります。 
class エントリはハンドラのクラス (logging パッケージの名前空間において eval() で決定されます) を示します。 
level はロガーの場合と同じように解釈され、NOTSET は "全てを記録する (log everything)" と解釈されます。 formatter エントリはこのハンドラのフォーマッタに対するキー名を表します。 
空文字列の場合、デフォルトのフォーマッタ(logging._defaultFormatter) が使われます。 
名前が指定されている場合、その名前は [formatters] セクションになくてはならず、対応するセクションが設定ファイル中になければなりません。 args エントリは、logging パッケージの名前空間のコンテキストで eval() される際、ハンドラクラスのコンストラクタに対する引数からなるリストになります。 
典型的なエントリがどうやって作成されるかについては、対応するハンドラのコンストラクタか、以下の例を参照してください。 
フォーマッタの環境設定を指定しているセクションは以下のような形式です。 
format エントリは全体を書式化する文字列で、datefmt エントリは strftime() 互換の日付/時刻書式化文字列です。 
空文字列の場合、パッケージによって ISO8601 形式の 日付/時刻に置き換えられ、日付書式化文字列 "ISO8601 形式ではミリ秒も指定しており、上の書式化文字列の結果にカンマで区切って追加されます。 
ISO8601 形式の時刻の例は2003-01-23 00:29:50,411 です。 
論理行の終端は、トークン NEWLINE で表されます。 
構文上許されている場合(複合文: compound statement 中の実行文: statement) を除いて、実行文は論理行間にまたがることはできません。 論理行は一行またはそれ以上の 物理行(physical line) からなり、物理行の末尾には明示的または非明示的な 行連結(line joining) 規則が続きます。 
この PyObject のサブタイプは長整数型を表現します。 
この PyTypeObject のインスタンスは Python 長整数型を表現します。 
これは types.LongType と同じオブジェクトです。 
引数が PyLongObject か PyLongObject のサブタイプのときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
引数が PyLongObject 型で、かつ PyLongObject 型のサブタイプでないときに真を返します。 
v から新たな PyLongObject オブジェクトを生成して返します。 失敗のときには NULL を返します。 
C の unsigned long 型から新たな PyLongObject オブジェクトを生成して返します。 失敗のときには NULL を返します。 
C の long long 型から新たな PyLongObject オブジェクトを生成して返します。 失敗のときには NULL を返します。 
C の unsigned long long 型から新たな PyLongObjectオブジェクトを生成して返します。 失敗のときには NULL を返します。 
v の整数部から新たな PyLongObject オブジェクトを生成して返します。 失敗のときには NULL を返します。 
str の文字列値に基づいて、新たな PyLongObject を返します。 このとき base を基数として文字列を解釈します。 
は str 中で数が表現されている部分以後の先頭の文字のアドレスを指しています。 
base が 0 ならば、str の先頭の文字列に基づいて基数を決定します: もし str が '0x' または '0X'で始まっていれば、基数に 16 を使います; str が '0'で始まっていれば、基数に 8 を使います; その他の場合には基数に 10 を使います。 
base が 0 でなければ、base は 2以上 36 以下の数でなければなりません。 
先頭に空白がある場合は無視されます。 
数字が全くない場合、ValueError が送出されます。 
Unicode の数字配列を Python の長整数型に変換します。 
最初のパラメタu は、 Unicode 文字列の最初の文字を指し、length には文字数を指定し、base には変換時の基数を指定します。 
基数は範囲 [2, 36] になければなりません; 範囲外の基数を指定すると、ValueError を送出します。 
バージョン 1.6 で 新たに追加 された仕様です。 PyObject* 
pylong の指す長整数値を、 C の long 型表現で返します。 
pylong の指す長整数値を、 C の unsigned long 型表現で返します。 
pylong の指す長整数値を、 C の long long 型表現で返します。 
pylong が long long で表せない場合、OverflowError を送出します。 バージョン 2.2 で 新たに追加 された仕様です。 
Python 長整数値を、 オーバフローチェックを行わずにC の unsigned long 型表現で返します。 バージョン 2.3 で 新たに追加 された仕様です。 
Python 長整数値を、 オーバフローチェックを行わずにC の unsigned long long 型表現で返します。 バージョン 2.3 で 新たに追加 された仕様です。 
pylong の指す値を、 C の double 型表現で返します。 
pylong が double を使って近似表現できない場合、OverflowError 例外を送出して -1.0 を返します。 
Python の整数型か長整数型を指す pylong を、 C のvoid ポインタに変換します。 
pylong を変換できなければ、OverflowError を送出します。 
この関数はPyLong_FromVoidPtr() で値を生成するときに使うようなvoid ポインタ型を生成できるだけです。 バージョン 1.5.2 で 新たに追加 された仕様です。 
高水準インタフェースは、断片的な Python コードをアプリケーションから実行できるようにしてくれますが、アプリケーションと Python コードの間でのデータのやり取りは、控えめに言っても煩わしいものです。 
データのやり取りをしたいなら、より低水準のインタフェース呼び出しを利用しなくてはなりません。 
より多く C コードを書かねばならない代わりに、ほぼ何でもできるようになります。 Python の拡張と埋め込みは、趣旨こそ違え、同じ作業であるということに注意せねばなりません。 
これまでの章で議論してきたトピックのほとんどが埋め込みでもあてはまります。 
これを示すために、Python から C への拡張を行うコードが実際には何をするか考えてみましょう: 
データ値を Python から C に変換する。 
変換された値を使って C ルーチンの関数呼び出しを行い、 
呼び出しで得られたデータ値 C から Python に変換する。 
Python を埋め込む場合には、インタフェースコードが行う作業は以下のようになります: 
データ値を C から Python に変換する。 
変換された値を使って Python インタフェースルーチンの関数呼び出しを行い、 
呼び出しで得られたデータ値 Python から C に変換する。 
一見して分かるように、データ変換のステップは、言語間でデータを転送する方向が変わったのに合わせて単に入れ替えただけです。 唯一の相違点は、データ変換の間にあるルーチンです。 
拡張を行う際には C ルーチンを呼び出しますが、埋め込みの際には Python ルーチンを呼び出します。 この章では、Python から C へ、そしてその逆へとデータを変換する方法については議論しません。 
また、正しい参照の使い方やエラーの扱い方についてすでに理解しているものと仮定します。 
これらの側面についてはインタプリタの拡張と何ら変わるところがないので、必要な情報については以前の章を参照できます。 
このドキュメントで記述されている次のモジュールは、いずれもMacintoshでのみ利用可能です。 
os モジュールの実装 
MacOS のパス操作関数 
FSSpec、エイリアスマネージャ、finderエイリアス、標準ファイルパッケージのサポート。 
インターネット設定へのアクセス。 
Mac OS 固有のインタープリタ機能へのアクセス。 
ファイル操作を便利にするルーチン集。 
finderのApple Eventsインターフェースのラッパ。 
基本的な Macintosh ダイアログ。 
対話型アプリケーション・フレームワーク 
イベントループ中のグローバルインタープリタの取り扱い 
メイルボックスオブジェクトの実装はすべて反復可能なオブジェクトであり、外部に公開されているメソッドを一つもっています。 
このメソッドはメイルボックスオブジェクトから生成されるイテレータによって使われ、直接利用することもできます。 
メイルボックスオブジェクトのコンストラクタに渡された、オプションのfactory 引数を使って、メイルボックス中の次のメッセージを生成して返します。 
標準の設定では、factory は rfc822.Messageオブジェクトです ( rfc822 
モジュールを参照してください)。 
メイルボックスの実装により、このオブジェクトの fp 属性は真のファイルオブジェクトかもしれないし、複数のメイルメッセージが単一のファイルに収められているなどの場合に、メッセージ間の境界を注意深く扱うためにファイルオブジェクトをシミュレートするクラスのインスタンスであるかもしれません。 
次のメッセージがない場合、このメソッドは None を返します。 
1 配布するファイルを指定する 
4 ソースコード配布物を作成する 
2 マニフェスト (manifest) 関連のオプション 
sdist コマンドが通常行う処理の流れは、以下のようになっています: 
マニフェストファイル MANIFEST が存在しなければ、MANIFEST.in を読み込んでマニフェストファイルを作成します 
MANIFEST も MANIFEST.in もなければ、デフォルトのファイルセットだけでできたマニフェストファイルを作成します 
MANIFEST.in または (setup.py) がMANIFEST より新しければ、MANIFEST.in を読み込んでMANIFEST を生成します 
(生成されたか、読み出された) MANIFEST 内にあるファイルのリストを使ってソース配布物アーカイブを作成します 
上の動作は二種類のオプションを使って修正できます。 
まず、標準の ``include'' および ``exclude'' セットを無効化するには--no-defaults および --no-prune を使います第二に、マニフェストファイルの再生成を強制できます -- 例えば、現在マニフェストテンプレート内に指定しているパターンにマッチするファイルやディレクトリを追加したり削除したりすると、マニフェストを再生成しなくてはなりません: 
また、単にマニフェストを (再) 生成したいだけで、ソース配布物は作成したくない場合があるかもしれません: 
--manifest-only を行うと、 --force-manifestを呼び出します。 -o は --manifest-only のショートカット、-f は --force-manifest のショートカットです。 
リリース 2.4 ,平成18年6月27日 更新 ご意見やご指摘をお寄せになりたい方は、 
7.4.1 辞書オブジェクト (dictionary object) 
10.5 数値オブジェクト構造体 (number object 
拡張型でマップ型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。 
オブジェクトがマップ型プロトコルを提供している場合に 1 を返し、そうでないときには 0 を返します。 
この関数呼び出しは常に成功します。 
成功するとオブジェクト o 中のキーの数を返し、失敗すると -1 を返します。 
マップ型プロトコルを提供していないオブジェクトに対しては、Python の式 "len(o)" と同じになります。 
オブジェクト o から key に関する対応付けを削除します。 失敗すると -1 を返します。 
Python の文 "del o[key]" と同じです。 
オブジェクト o から key に対する対応付けを削除します。 失敗すると -1 を返します。 
成功すると、マップ型オブジェクトがキー key を持つ場合に1 を返し、そうでないときには 0 を返します。 
この関数呼び出しは常に成功します。 
マップ型オブジェクトがキー key を持つ場合に 1 を返し、そうでないときには 0 を返します。 
Python の式 " 
o.has_key(key)" と同じです。 
成功するとオブジェクト o のキーからなるリストを返します。 
失敗すると NULLを返します。 
o.keys()" と同じです。 
成功するとオブジェクト o のキーに対応する値からなるリストを返します。 
o.values()" と同じです。 
成功するとオブジェクト o の要素対、すなわちキーと値のペアが入ったタプルからなるリストを返します。 
失敗すると NULLを返します。 
o.items()" と同じです。 
オブジェクト key に対応するo の要素を返します。 失敗すると NULLを返します。 
Python の式 " 
o[key]" と同じです。 
オブジェクトo で key を値 v に対応付けます。 失敗すると -1 を返します。 
Python の文 " 
" と同じです。 
13. 構造化マークアップツール 
Python は様々な構造化データマークアップ形式を扱うための、様々なモジュールをサポートしています。 
HTML と XHTML を扱えるシンプルなパーザ。 
HTML を解析するのに必要な機能だけを備えた SGML パーザ。 
HTML 文書の解析器。 
HTML 一般エンティティの定義。 
Expat による、検証を行わない XML パーザへのインタフェース 
Python のための文書オブジェクトモデル API。 
軽量な文書オブジェクトモデルの実装。 
SAX イベントからの部分的な DOM ツリー構築のサポート。 
SAX2 基底クラスと有用な関数のパッケージ 
SAX イベント・ハンドラの基底クラス 
SAX とともに使う有用な関数とクラスです。 
SAX 準拠の XML パーサが実装すべきインターフェースです。 
XML ドキュメントのパーサ。 
Python/XML ライブラリ 
Python にバンドルされてくる xml パッケージへの拡張である PyXML パッケージのホームページです。 
以下のルーチン群は、marshal モジュールと同じ形式を使った整列化オブジェクトを C コードから使えるようにします。 
整列化形式でデータを書き出す関数に加えて、データを読み戻す関数もあります。 
PY_MARSHAL_VERSION は現在のバージョン(バージョン 1) を示します。 
long 型の整数値 value を file へ整列化します。 
この関数は value の下桁 32 ビットを書き込むだけです;ネイティブの long 型サイズには関知しません。 
バージョン 2.4 で 変更 された仕様:ファイル形式を示すversion が追加されました 
Python オブジェクトvalue を file へ整列化します。 
value の整列化表現が入った文字列オブジェクトを返します。 
読み出し用に開かれた FILE* 内のデータストリームから、C の long 型データを読み出して返します。 
この関数は、ネイティブの long のサイズに関係なく、32 ビットの値だけを読み出せます。 
読み出し用に開かれた FILE* 内のデータストリームから、C の short 型データを読み出して返します。 
この関数は、ネイティブの short のサイズに関係なく、16 ビットの値だけを読み出せます。 
読み出し用に開かれた FILE* 内のデータストリームから、Python オブジェクトを読み出して返します。 
エラーが生じた場合、適切な例外 (EOFError またはTypeError) を送出して NULLを返します。 
PyMarshal_ReadObjectFromFile() と違い、この関数はファイル中に後続のオブジェクトが存在しないと仮定し、ファイルからメモリ上にファイルデータを一気にメモリにロードして、逆整列化機構がファイルから一バイトづつ読み出す代わりにメモリ上のデータを操作できるようにします。 
対象のファイルから他に何も読み出さないと分かっている場合にのみ、この関数を使ってください。 
エラーが生じた場合、適切な例外 (EOFError またはTypeError) を送出して NULLを返します。 
string が指しているlen バイトの文字列バッファに納められたデータストリームから Python オブジェクトを読み出して返します。 
エラーが生じた場合、適切な例外 (EOFError またはTypeError) を送出して NULLを返します。 
MatchObject インスタンスは以下のメソッドと属性をサポートします: 
テンプレート文字列 template に、sub() メソッドがするようなバックスラッシュ置換をして得られる文字列を返します。 "n"のようなエスケープは適当な文字に変換され、数値の後方参照("1"、 "2") と名前付きの後方参照("g1"、 "gname") は、対応するグループの内容で置き換えられます。 
マッチした1個以上のサブグループを返します。 
もし引数で一つであれば、その結果は一つの文字列です;複数の引数があれば、その結果は、引数ごとに一項目を持つタプルです。 引数がなければ、group1 はデフォールトでゼロです(マッチしたものすべてが返されます)。 
もし groupN 引数がゼロであれば、対応する戻り値は、マッチする文字列全体です;もしそれが範囲 [1..99] 内であれば、それは、対応する丸括弧つきグループとマッチする文字列です。 
もしグループ番号が負であるか、あるいはパターンで定義されたグループの数より大きければ、IndexError 例外が発生します。 もしグループがマッチしなかったパターンの一部に含まれていれば、対応する結果は None です。 
もしグループが、複数回マッチしたパターンの一部に含まれていれば、最後のマッチが返されます。 もし正規表現が (?Pname...) シンタクスを使うならば、groupN引数は、それらのグループ名によってグループを識別する文字列であっても構いません。 
もし文字列引数がパターンのグループ名として使われていないものであれば、IndexError 例外が発生します。 適度に複雑な例題: 
このマッチを実行したあとでは、m.group(1) はm.group('int') と同じく、'3' であり、そしてm.group(2) は '14' です。 
1からどれだけ多くであろうがパターン内にあるグループ数までの、マッチの、すべてのサブグループを含むタプルを返します。 
default 引数は、マッチに加わらなかったグループ用に使われます;それはデフォールトでは None です。 
(非互換性ノート:オリジナルの Python 1.5 リリースでは、たとえタプルが一要素長であっても、その代わりに文字列を返すことはありません。 
(1.5.1 以降の)後のバージョンでは、そのような場合には、シングルトンタプルが返されます。 ) 
すべての 名前つきのサブグループを含む、マッチの、サブグループ名でキー付けされた辞書を返します。 
default 引数はマッチに加わらなかったグループ用に使われます;それはデフォールトでは Noneです。 
groupとマッチしたサブ文字列の先頭と末尾のインデックスを返します;group は、デフォールトでは (マッチしたサブ文字列全体を意味する)ゼロです。 
group が存在してもマッチに寄与しなかった場合は、-1 を返します。 
です。 
もし groupがヌル文字列とマッチすれば、m.start(group)が m.end(group) と等しくなろことに注意して下さい。 
例えば、 
m = re.search('b(c?)', 'cba')の後では、 
m.start(0)は 1 で、 
m.end(0) は 2 であり、 
m.start(1) と 
m.end(1) はともに 2 であり、 
m.start(2) は IndexError例外を発生します。 
MatchObject m については、 2-タプル(m.start(group)、 m.end(group))を返します。 もし group がマッチに寄与しなかったら、これは(-1, -1) です。 
また group はデフォールトでゼロです。 
RegexObject の search() あるいは match() メソッドに渡された posの値です。 
これは RE エンジンがマッチを探し始める位置の文字列のインデックスです。 
RegexObject の search() あるいは match() メソッドに渡された endposの値です。 
これは RE エンジンがそれ以上は進まない位置の文字列のインデックスです。 
最後にマッチした取り込みグループの整数インデックスです。 
もしどのグループも全くマッチしなければ None です。 
最後にマッチした取り込みグループの名前です。 もしグループに名前がないか、あるいはどのグループも全くマッチしなければ None です。 
その match()あるいは search() メソッドが、このMatchObject インスタンスを生成した正規表現オブジェクトです。 
match() あるいは search()に渡された文字列です。 
Python は、正規表現に基づく、2つの異なるプリミティブな操作を提供しています:マッチと検索です。 
もしあなたが Perl の記号に慣れているのであれば、検索操作があなたの求めるものです。 
search() 関数と、コンパイルされた正規表現オブジェクトでの対応するメソッドを見て下さい。 マッチは、"^"で始まる正規表現を使うと、検索とは異なるかもしれないことに注意して下さい:"^" は文字列の先頭でのみ、あるいはMULTILINE モードでは改行の直後ともマッチします。 
``マッチ'' 操作は 、もしそのパターンが、モードに拘らず文字列の先頭とマッチするか、あるいは改行がその前にあるかどうかに拘らず、省略可能なpos 引数によって与えられる先頭位置でマッチする場合のみ成功します。 
re.compile("a").match("ba", 1) # 成功re.compile("^a").search("ba", 1) # 失敗; 'a' は先頭にないre.compile("^a").search("\na", 1) # 失敗; 'a' は先頭にないre.compile("^a", re.M).search("\na", 1) # 成功re.compile("^a", re.M).search("ba", 1) # 失敗; \n が前にない 
8.3 高度なデバッガサポート (advanced debugger 
9.1 概要 
9. メモリ管理 
9.1 概要 
最初に述べた関数セットを使って、9.1 節の例を Python ヒープに I/O バッファをメモリ確保するように書き換えたものを以下に示します: 
同じコードを型対象の関数セットで書いたものを以下に示します: 
上の二つの例では、バッファを常に同じ関数セットに属する関数で操作していることに注意してください。 
実際、あるメモリブロックに対する操作は、異なるメモリ操作機構を混用する危険を減らすために、同じメモリ API ファミリを使って行うことが必要です。 
以下のコードには二つのエラーがあり、そのうちの一つには異なるヒープを操作する別のメモリ操作関数を混用しているので致命的 (Fatal) とラベルづけをしています。 
素のメモリブロックを Python ヒープ上で操作する関数に加え、PyObject_New()、 PyObject_NewVar()、およびPyObject_Del() を使うと、 Python におけるオブジェクトをメモリ確保したり解放したりできます。 
またこれらの関数にはマクロPyObject_NEW()、 PyObject_NEW_VAR()、 およびPyObject_DEL() が対応します。 
これらの関数については、次章の C による新しいオブジェクト型の定義や実装に関する記述の中で説明します。 
Python ヒープに対してメモリを確保したり解放したりするために、以下の関数セットが利用できます。 これらの関数は ANSI C 標準に従ってモデル化されていますが、0 バイトの領域を要求した際の動作についても定義しています: 
n バイトをメモリ確保し、確保されたメモリを指す void* 型のポインタを返します。 
確保要求に失敗した場合には NULL を返します。 
0 バイトをリクエストすると、可能ならば独立した非NULL のポインタを返します。 このポインタは PyMem_Malloc(1) を代わりに呼んだときのようなメモリ領域を指しています。 
p が NULLならば、この関数はPyMem_Malloc(n) と等価になります; それ以外の場合で、n がゼロに等しければ、メモリブロックはサイズ変更されますが、解放されず、非 NULLのポインタを返します。 
p の値をNULLにしないのなら、以前呼び出した PyMem_Malloc() や PyMem_Realloc() の返した値でなければなりません。 
p が指すメモリブロックを解放します。 p は以前呼び出した PyMem_Malloc() や PyMem_Realloc() の返した値でなければなりません。 
それ以外の場合や、すでに PyMem_Free(p) を呼び出した後だった場合、未定義の動作になります。 
p が NULLなら、何も行いません。 
以下に挙げる型対象のマクロは利便性のために提供されているものです。 
TYPE* に型キャストされたポインタを返します。 
メモリには何の初期化も行われていません。 
PyMem_Realloc() と同じですが、(n * sizeof(TYPE)) バイトにサイズ変更されたメモリを確保します。 
TYPE* に型キャストされたポインタを返します。 
PyMem_Free() と同じです。 
上記に加えて、C API 関数を介することなく Python メモリ操作関数を直接呼び出すための以下のマクロセットが提供されています。 
ただし、これらのマクロは Python バージョン間でのバイナリ互換性を保てず、それゆえに拡張モジュールでは撤廃されているので注意してください。 
PyMem_MALLOC()、PyMem_REALLOC()、PyMem_FREE()。 
PyMem_NEW()、PyMem_RESIZE()、PyMem_DEL()。 
Python におけるメモリ管理には、全ての Python オブジェクトとデータ構造が入ったプライベートヒープ (private heap) が必須です。 
プライベートヒープの管理は、内部的にはPython メモリマネージャ (Python memory manager)が確実に行います。 
これらは同じヒープを操作し、各オブジェクト型固有の事情に合ったメモリ管理ポリシを実装しています。 
例えば、整数オブジェクトは文字列やタプル、辞書とは違ったやり方でヒープ内で管理されます。 というのも、整数には値を記憶する上で特別な要件があり、速度/容量のトレードオフが存在するからです。 
このように、 Python メモリマネジャは作業のいくつかをオブジェクト固有のメモリ操作関数に委譲しますが、これらの関数がプライベートヒープからはみ出してメモリ管理を行わないようにしています。 重要なのは、たとえユーザがいつもヒープ内のメモリブロックを指すようなオブジェクトポインタを操作しているとしても、Python 用ヒープの管理はインタプリタ自体が行うもので、ユーザがそれを制御する余地はないと理解することです。 
Python オブジェクトや内部使用されるバッファを入れるためのヒープ空間のメモリ確保は、必要に応じて、Python メモリマネージャがこのドキュメント内で列挙しているPython/C API 関数群を介して行います。 メモリ管理の崩壊を避けるため、拡張モジュールの作者は決して Python オブジェクトを C ライブラリが公開している関数: malloc() 
、calloc() 
、realloc() 
およびfree() で操作しようとしてはなりません。 
こうした関数を使うと、C のメモリ操作関数とPython メモリマネージャとの間で関数呼び出しが交錯します。 
C のメモリ操作関数とPython メモリマネージャは異なるアルゴリズムで実装されていて、異なるヒープを操作するため、呼び出しの交錯は致命的な結果を招きます。 
とはいえ、個別の目的のためなら、 C ライブラリのメモリ操作関数を使って安全にメモリを確保したり解放したりできます。 例えば、以下がそのような例です: 
この例では、I/O バッファに対するメモリ要求は C ライブラリのメモリ操作関数を使っています。 
その結果、特定の状況では、Python メモリマネージャがガベージコレクションやメモリのコンパクト化、その他何らかの予防措置といった、適切な動作をトリガできることがあります。 
上の例で示したように C ライブラリのメモリ操作関数を使うと、 I/O バッファ用に確保したメモリは Python メモリマネージャの管理から完全に外れることに注意してください。 
Message インスタンスは以下のメソッドを持っています: 
メッセージ本体の先頭を seek します。 
このメソッドはファイルオブジェクトが seek 可能である場合にのみ動作します。 
ある行が正しい RFC 2822 ヘッダである場合、その行の正規化されたフィールド名 (インデクス指定の際に使われる辞書キー) を返します;そうでない場合 None を返します (解析をここで一度中断し、行データを入力ストリームに押し戻すことを意味します)。 
このメソッドをサブクラスで上書きすると便利なことがあります。 
与えられた line が Message の区切りとなるデリミタであった場合に真を返します。 
このデリミタ行は消費され、ファイルオブジェクトの読み位置はその直後になります。 
標準ではこのメソッドは単にその行が空行かどうかをチェックしますが、サブクラスで上書きすることもできます。 
与えられた行全体を無視し、単に読み飛ばすときに真を返します。 標準では、これは控えメソッド (stub) であり、常に False を返しますが、サブクラスで上書きすることもできます。 
name に一致するヘッダからなる行のリストがあれば、それらを全て返します。 
各物理行は連続した行内容であるか否かに関わらず別々のリスト要素になります。 
name に一致するヘッダがない場合、空のリストを返します。 
name に一致する最初のヘッダと、その行に連続する (複数)行からなる行データのリストを返します。 
name に一致するヘッダがない場合 None を返します。 
name に一致する最初のヘッダにおけるコロン以降のテキストが入った単一の文字列を返します。 
このテキストには、先頭の空白、末尾の改行、また後続の行がある場合には途中の改行と空白が含まれます。 
name に一致するヘッダが存在しない場合には None を返します。 
getrawheader(name) に似ていますが、先頭および末尾の空白を剥ぎ取ります。 
途中にある空白は剥ぎ取られません。 
オプションの default 引数は、name に一致するヘッダが存在しない場合に、別のデフォルト値を返すように指定するために使われます。 
正規の辞書との互換性をより高めるための getheader()の別名 (alias) です。 
getheader(name) が返した文字列を解析して、(full name, email address) からなるペアを返します。 
getaddr(list) に似ていますが、複数のメイルアドレスからなるリストが入ったヘッダ (例えば To: ヘッダ) を解析し、 (full name, email address) のペアからなるリストを (たとえヘッダには一つしかアドレスが入っていなかったとしても) 返します。 
getheader() を使ってヘッダを取得して解析し、time.mktime() と互換な 9 要素のタプルにします; フィールド 6、7、および 8 は有用な値ではないので注意して下さい。 
name に一致するヘッダが存在しなかったり、ヘッダが解析不能であった場合、None を返します。 日付の解析は妖術のようなものであり、全てのヘッダが標準に従っているとは限りません。 
このメソッドは多くの発信源から集められた膨大な数の電子メールでテストされており、正しく動作することが分かっていますが、間違った結果を出力してしまう可能性はまだあります。 
getheader() を使ってヘッダを取得して解析し、10 要素のタプルにします; 最初の 9 要素は time.mktime() と互換性のあるタプルを形成し、10 番目の要素はその日におけるタイムゾーンの UTC からのオフセットを与える数字になります。 
getdate()と同様に、name に一致するヘッダがなかったり、解析不能であった場合、None を返します。 
Message インスタンスはまた、限定的なマップ型のインタフェースを持っています。 すなわち: 
m[name] は 
m.getheader(name) に似ていますが、一致するヘッダがない場合 KeyError を送出します;len(m)、 
])、 
m.keys()、 
m.items()、および 
]) は期待通りに動作します。 ただし setdefault() は標準の設定値として空文字列をとります。 
Message インスタンスはまた、マップ型への書き込みを行えるインタフェース 
m[name] =value および del m[name] をサポートしています。 
Message オブジェクトでは、 clear()、 copy()、popitem()、あるいは update() といったマップ型インタフェースのメソッドはサポートしていません。 
(get() および setdefault() のサポートは Python2.2 でしか追加されていません。 )最後に、Message インスタンスはいくつかの public なインスタンス変数を持っています: 
ヘッダ行のセット全体が、(setitem を呼び出して変更されない限り) 読み出された順番に入れられたリストです。 
各行は末尾の改行を含んでいます。 
ヘッダを終端する空行はリストに含まれません。 
インスタンス化の際に渡されたファイルまたはファイル類似オブジェクトです。 
この値はメッセージ本体を読み出すために使うことができます。 
メッセージに Unix "From" 行がある場合はその行、そうでなければ空文字列になります。 
この値は例えば mbox 形式のメイルボックスファイルのような、あるコンテキスト中のメッセージを再生成するために必要です。 
8 setup スクリプトをデバッグする 
setup スクリプトには、名前やバージョンにとどまらず、その他のメタデータを含められます。 
以下のような情報を含められます: 
メタデータ 
パッケージの名前 
短い文字列 
リリースのバージョン 
パッケージ作者の名前 
パッケージ作者の電子メールアドレス 
電子メールアドレス 
パッケージメンテナンス担当者の名前 
パッケージメンテナンス担当者の電子メールアドレス 
パッケージのホームページ 
パッケージについての簡潔な概要説明 
パッケージについての詳細な説明 
長い文字列 
パッケージをダウンロードできる場所 
Trove 分類語 
文字列からなるリスト 
必須のフィールドです。 
バージョン番号はmajor.minor[.patch[.sub] 
の形式をとるよう奨めます。 
作者かメンテナのどちらかは必ず区別してください。 
これらのフィールドは、2.2.3 および 2.3 より以前のバージョンの Python でも互換性を持たせたい場合には指定してはなりません。 
リストは PyPI ウェブサイトにあります。 
「短い文字列」 
200 文字以内の一行のテキスト。 
「長い文字列」 
複数行からなり、ReStructuredText 形式で書かれたプレーンテキスト (http://docutils.sf.net/ を参照してください)。 
「文字列のリスト」 
下記を参照してください。 
これらの文字列はいずれも Unicode であってはなりません。 バージョン情報のコード化は、それ自体が一つのアートです。 
Python のパッケージは一般的に、major.minor[.patch] 
というバージョン表記に従います。 
メジャー (major) 番号は最初は 0 で、これはソフトウェアが実験的リリースにあることを示します。 
メジャー番号は、パッケージが主要な開発目標を達成したとき、それを示すために加算されてゆきます。 
マイナー (minor)番号は、パッケージに重要な新機能が追加されたときに加算されてゆきます。 
パッチ (patch) 番号は、バグフィクス版のリリースが作成されたときに加算されます。 
末尾にバージョン情報が追加され、サブリリースを示すこともあります。 
これは "a1,a2,...,aN" (アルファリリースの場合で、機能や API が変更されているとき)、 "b1,b2,...,bN" (ベータリリースの場合で、バグフィクスのみのとき) 、そして "pr1,pr2,...,prN" (プレリリースの最終段階で、リリーステストのとき) になります。 
以下に例を示します: 
パッケージの最初の実験的なリリース 
1.0 の最初のパッチバージョンに対する、2 回目のアルファリリース 
classifiers は、 Python のリスト型で指定します: 
setup.py に classifiers を入れておき、なおかつ2.2.3 よりも以前のバージョンの Python と後方互換性を保ちたいなら、setup.py 中で setup() を呼び出す前に、以下のコードを入れます。 
6.1 プリアンブル用のマークアップ 
アドレスのドメインネーム部分は小文字にしなければなりません。 このマークアップを行っても著者紹介は生成されませんが、だれがドキュメントに貢献したかを追跡する上での補助として用います。 
クラスが生成される前にクラス辞書を変更する 
他のクラスのインスタンスを返す - 本質的にはファクトリ関数の役割を果たす 
といった、クラス生成のプロセスを監視したり置き換えたりするクラスや関数を書くことができます。 __metaclass__ 
この変数は name、bases、および dict を引数として取るような任意の呼び出し可能オブジェクトにできます。 
クラス生成の際、組み込みの type() の代わりに、指定された呼び出しオブジェクトが呼び出されます。 バージョン 2.2 で 新たに追加 された仕様です。 
以下に優先順で並んだ規則によって、適切なメタクラスが決定されます: 
dict['__metaclass__'] があればそれを使います。 
それ以外の場合で、最低でも一つ基底クラスを持っているなら、基底クラスのメタクラス (__class__ 属性を探し、なければ基底クラスの型) を使います。 
それ以外の場合で、__metaclass__ という名前のグローバル変数があれば、それをつかいます。 
それ以外の場合には、旧形式のメタクラス (types.ClassType) を使います。 
メタクラスは限りない潜在的利用価値を持っています。 
これまで試されてきたアイデアには、ログ記録、インタフェースのチェック、自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック/同期といったものがあります。 
メソッドオブジェクトを操作する上で便利な関数がいくつかあります。 
この PyTypeObject のインスタンスは Python のメソッドオブジェクト型を表現します。 このオブジェクトは、types.MethodType 
として Python プログラムに公開されています。 
o がメソッドオブジェクト (PyMethod_Type 型である)場合に真を返します。 
パラメタは NULL にできません。 
任意の呼び出し可能オブジェクトfunc を使った新たなメソッドオブジェクトを返します; 関数 func は、メソッドが呼び出された時に呼び出されるオブジェクトです。 
このメソッドをインスタンスに束縛 (bind) したい場合、 self をインスタンス自体にして、class をself のクラスにしなければなりません。 
それ以外の場合は self を NULL に、 class を非束縛メソッドを提供しているクラスにしなければなりません。 PyObject* 
メソッドオブジェクト meth を生成したクラスオブジェクトを返します;インスタンスがメソッドオブジェクトを生成した場合、戻り値はインスタンスのクラスになります。 
PyMethod_Class() をマクロで実装したバージョンで、エラーチェックを行いません。 
meth に関連付けられている関数オブジェクトを返します。 
PyMethod_Function() のマクロ版で、エラーチェックを行いません。 
meth が束縛メソッドの場合には、メソッドに関連付けられているインスタンスを返します。 それ以外の場合には NULL を返します。 
PyMethod_Self() のマクロ版で、エラーチェックを行いません。 
さて、前に約束したように、spam_system() Python プログラムからどうやって呼び出すかをこれから示します。 
まずは、関数名とアドレスを``メソッドテーブル (method table)'' に列挙する必要があります: 
リスト要素の三つ目のエントリ ("METH_VARARGS") に注意してください。 
このエントリは、C 関数が使う呼び出し規約をインタプリタに教えるためのフラグです。 
この場合、C 関数は第三引数に "PyObject *" を受理するようにせねばなりません。 このオブジェクトは、キーワード引数の辞書になります。 
こうした関数で引数を解釈するには、PyArg_ParseTupleAndKeywords() を使ってください。 メソッドテーブルは、モジュールの初期化関数内でインタプリタに渡さねばなりません。 
初期化関数はモジュールの名前を nameとしたときに initname() という名前でなければならず、モジュールファイル内で定義されているもののうち、唯一の非static 要素でなければなりません: 
PyMODINIT_FUNC は関数の戻り値を void になるように宣言し、プラットフォーム毎に必要とされる、特有のリンク宣言 (linkage declaration)を定義すること、さらに C++ の場合には関数を extern "C" に宣言することに注意してください。 Python プログラムがモジュール spam を初めて importするとき、initspam() が呼び出されます。 
(Python の埋め込みに関するコメントは下記を参照してください。 
)initspam() は Py_InitModule() を呼び出して``モジュールオブジェクト'' を生成し (オブジェクトは"spam" をキーとして辞書 sys.modules に挿入されます)、第二引数として与えたメソッドテーブル (PyMethodDef 構造体の配列) の情報に基づいて、組み込み関数オブジェクトを新たなモジュールに挿入していきます。 Py_InitModule() は、自らが生成した (この段階ではまだ未使用の) モジュールオブジェクトへのポインタを返します。 
Py_InitModule() は、モジュールを満足に初期化できなかった場合、致命的エラーで中断するため、この関数の呼び出し側がエラーをチェックする必要はありません。 Python を埋め込む場合には、_PyImport_Inittab テーブルのエントリ内に initspam() がない限り、initspam()は自動的には呼び出されません。 
この問題を解決する最も簡単な方法は、Py_Initialize() や PyMac_Initialize() を呼び出した後に initspam() を直接呼び出し、静的にリンクしておいたモジュールを静的に初期化してしまうというものです: 
intmain(int argc, char *argv[]){/* Python インタプリタに argv[0] を渡す */Py_SetProgramName(argv[0]);/* Python インタプリタを初期化する。 
必ず必要。 
*/Py_Initialize();/* 静的モジュールを追加する */initspam(); 
Python ソース配布物中の Demo/embed/demo.c ファイル内に例があります。 
より実質的なモジュール例は、Python ソース配布物にModules/xxmodule.c という名前で入っています。 
このファイルはテンプレートとしても利用できますし、単に例としても読めます。 
ソース配布物や Windows にインストールされた Python に入っているmodulator.py では、拡張モジュールで実装しなければならない関数やオブジェクトを宣言し、実装部分を埋めて作成するためのテンプレートを生成できるような、簡単なグラフィカルユーザインタフェースを提供しています。 
このスクリプトはTools/modulator/ ディレクトリにあります;詳しくはディレクトリ内の README ファイルを参照してください。 
Folder インスタンスは開かれたフォルダを表現し、以下のメソッドを持っています: 
エラーメッセージを出力します - 上書きすることができます。 
フォルダの完全なパス名を返します。 
フォルダ内のシーケンスファイルの完全なパス名を返します。 
フォルダ内のメッセージ n の完全なパス名を返します。 
フォルダ内のメッセージの (番号の) リストを返します。 
現在のメッセージ番号を返します。 
現在のメッセージ番号を n に設定します。 
msgs 文を解釈して、メッセージのリストにします。 
最新のメッセージを取得します。 メッセージがフォルダにない場合には0 を返します。 
最新のメッセージを設定します (内部使用のみ)。 
フォルダ内のシーケンスからなる辞書を返します。 
シーケンス名がキーとして使われ、値はシーケンスに含まれるメッセージ番号のリストになります。 
フォルダ内のシーケンスからなる辞書 name: list を返します。 
リスト中のメッセージをフォルダから削除します。 
リスト中のメッセージを他のフォルダに移動します。 
一つのメッセージを他のフォルダの指定先に移動します。 
一つのメッセージを他のフォルダの指定先にコピーします。 
Message クラスは mimetools.Message のメソッドに加え、一つメソッドを持っています: 
新たな開かれたメッセージオブジェクトを返します (ファイル記述子を一つ消費します)。 
MH インスタンスは以下のメソッドを持っています: 
プロファイルエントリ (設定されていなければ None) を返します。 
メイルボックスのパス名を返します。 
現在のフォルダ名を返します。 
現在のフォルダ名を設定します。 
トップレベルフォルダのリストを返します。 
全てのフォルダを列挙します。 
指定したフォルダの直下にあるサブフォルダのリストを返します。 
指定したフォルダの下にある全てのサブフォルダのリストを返します。 
新しいフォルダを生成します。 
フォルダを削除します - サブフォルダが入っていてはいけません。 
新たな開かれたフォルダオブジェクトを返します。 
Message クラスは、rfc822.Message メソッドに加えて、以下のメソッドを定義しています: 
Content-Type: ヘッダのパラメータリストを返します。 
これは文字列のリストです。 
"の形のパラメータに対しては、key は小文字に変換されますが、 value は変換されません。 
たとえば、もしメッセージに、ヘッダ"Content-type: text/html; spam=1; Spam=2; Spam" が含まれていれば、getplist() は、Python リスト ['spam=1','spam=2', 'Spam']を返すでしょう。 
Content-Transfer-Encoding: メッセージヘッダで指定された符号化方式を返します。 
もしそのようなヘッダが存在しなければ、'7bit'を返します。 
符号化方式文字列は小文字に変換されます。 
Content-Type: ヘッダで指定された(" 
"の形での)メッセージ型を返します。 
もしそのようなヘッダが存在しなければ、 'text/plain'を返します。 
型文字列は小文字に変換されます。 
Content-Type: ヘッダで指定された主要型を返します。 
もしそのようなヘッダが存在しなければ、 'text'を返します。 
主要型文字列は小文字に変換されます。 
Content-Type:ヘッダで指定された下位型を返します。 
もしそのようなヘッダが存在しなければ、 'plain'を返します。 
下位型文字列は小文字に変換されます。 
MimeTypes インスタンスは、 
モジュールのそれと非常によく似たインターフェースを提供します。 
サフィックスをサフィックスにマップする辞書。 
これは、符号化方式と型が同一拡張子で示されるような符号化ファイルが認識できるように使用されます。 
例えば、.tgz 拡張子は、符号化方式と型が別個に認識できるように .tar.gzに対応づけられます。 
これは、最初はモジュールで定義されたグローバルな suffix_map のコピーです。 
ファイル名拡張子を符号化型にマッピングする辞書。 
これは、最初はモジュールで定義されたグローバルな encodings_map のコピーです。 
ファイル名拡張子をMIME型にマッピングするる辞書。 
これは、最初はモジュールで定義されたグローバルな types_map のコピーです。 
ファイル名拡張子を非標準ではあるが、一般に使われているMIME型にマップする辞書。 
これは、最初はモジュールで定義されたグローバルな common_types のコピーです。 
guess_extension() 関数と同様に、オブジェクトの一部として保存されたテーブルを使用します。 
guess_type() 関数と同様に、オブジェクトの一部として保存されたテーブルを使用します。 
MIME情報を、pathという名のファイルからロードします。 
これはファイルを解析するのに readfp() を使用します。 
MIME型情報を、オープンしたファイルからロードします。 
ファイルは、標準の mime.types ファイルの形式でなければなりません。 
モジュールは、本質的にはDOM 1.0 互換の DOM に、いくつかの DOM 2 機能 (主に名前空間機能) を追加したものです。 Python における DOM インタフェースは率直なものです。 
以下の対応付け規則が適用されます: 
インタフェースはインスタンスオブジェクトを介してアクセスされます。 
アプリケーション自身から、クラスをインスタンス化してはなりません;Document オブジェクト上で利用可能な生成関数 (creator function)を使わなければなりません。 導出インタフェースでは基底インタフェースの全ての演算 (および属性) に加え、新たな演算をサポートします。 
演算はメソッドとして使われます。 
DOM では in パラメタのみを使うので、引数は通常の順番 (左から右へ) で渡されます。 オプション引数はありません。 
void 演算はNoneを返します。 
IDL 属性はインスタンス属性に対応付けられます。 
OMG IDL 言語における Python への対応付けとの互換性のために、属性 fooはアクセサメソッド _get_foo() および _set_foo()でもアクセスできます。 readonly 属性は変更してはなりません; とはいえ、これは実行時には強制されません。 
short int 、 unsigned int 、 unsignedlong long 、および boolean 型は、全て Python 整数オブジェクトに対応付けられます。 
DOMString 型は Python 文字列型に対応付けられます。 
ではバイト文字列 (byte string) およびUnicode 文字列のどちらかに対応づけられますが、通常 Unicode 文字列を生成します。 
DOMString 型の値は、W3C の DOM 仕様で、IDLnull 値になってもよいとされている場所では None になることもあります。 
const 宣言を行うと、(xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE のように)対応するスコープ内の変数に対応付けを行います;これらは変更してはなりません。 
DOMException は現状では 
でサポートされていません。 
その代わり、 
は、TypeError や AttributeError といった標準の Python 例外を使います。 
NodeList オブジェクトは Python の組み込みリスト型を使って実装されています。 
Python 2.2 からは、これらのオブジェクトはDOM 仕様で定義されたインタフェースを提供していますが、それ以前のバージョンの Python では、公式の API をサポートしていません。 
しかしながら、これらの API は W3C 勧告で定義されたインタフェースよりも ``Python 的な'' ものになっています。 
以下のインタフェースは 
では全く実装されていません: 
これらの大部分は、ほとんどの DOM のユーザにとって一般的な用途として有用とはならないような XML 文書内の情報を反映しています。 
6.29.3 複数の出力先にログを出力する 
logging パッケージには高い柔軟性があり、その設定にたじろぐこともあるでしょう。 
そこでこの節では、 logging パッケージを簡単に使う方法もあることを示します。 
以下の最も単純な例では、コンソールにログを表示します: 
上のスクリプトを実行すると、以下のようなメッセージを目にするでしょう: 
ここではロガーを特定しなかったので、システムはルートロガーを使っています。 デバッグメッセージや情報メッセージは表示されませんが、これはデフォルトのルートロガーが WARNING 以上の重要度を持つメッセージしか処理しないように設定されているからです。 
メッセージの書式もデフォルトの設定に従っています。 出力先はsys.stderr で、これもデフォルトの設定です。 
重要度レベルやメッセージの形式、ログの出力先は、以下の例のように簡単に変更できます: 
ここでは、basicConfig() メソッドを使って、以下のような出力例になる (そして/tmp/myapp.log に書き込まれる) ように、デフォルト設定を変更しています: 
書式化文字列は、以下の指定子 (specifier) を常にとります。 
指定子の完全なリストについては Formatter のドキュメントを参照してください。 
書式 
ロガーの名前 (ログチャネル) の名前です。 
メッセージのログレベル('DEBUG', 'INFO','WARNING', 'ERROR','CRITICAL') です。 
LogRecord が生成された際の時刻を、人間が読み取れる形式にしたものです。 
デフォルトでは、``2003-07-08 16:49:45,896'' のような形式 (コンマの後ろはミリ秒)です。 
ログメッセージです。 
以下のように、追加のキーワードパラメタ datefmt を渡すと日付や時刻の書式を変更できます: 
出力は以下のようになります: 
日付を書式化する文字列は、strftime() の要求に従います - 
モジュールを参照してください。 コンソールやファイルではなく、別個に作成しておいたファイル類似オブジェクトにログを出力したい場合には、basicConfig() にstream キーワード引数で渡します。 
stream とfilename の両方の引数を指定した場合、stream は無視されるので注意してください。 状況に応じて変化する情報ももちろんログ出力できます。 
以下のように、単にメッセージを書式化文字列にして、その後ろに可変情報の引数を渡すだけです: 
出力は以下のようになります: 
6.6 雑多なテキストマークアップ インラインマークアップに加えて、 ``ブロック'' マークアップがいくつか定義されていて、様々なテキスト断片に対して読者の注意を引かせやすくしています。 
この節で述べているマークアップは、こうした目的の他に、(verbatim 環境のように) 一つ以上の段落や、他のブロック構造をマークする際に使うためのものです。 
読者がさらに注意を払うべき段落をラベルします。 
どの種の注意を求めているかは、type に指定します。 
type 用に定義されている値はnote とwarning です; これらは、同名のインラインマークアップと同じ目的に使います。 types を省略すると、note を使います。 
type が撮りうる値は将来新たに追加されるかもしれません。 
6.7 モジュール特有のマークアップ ご意見やご指摘をお寄せになりたい方は、 
5. 各種サービス 
この章では、Pythonのすべてのバージョンで利用可能な各種サービスについて説明します。 
以下に概要を示します。 
ドキュメント生成とオンラインヘルプシステム 
対話モードを使った使用例の内容を検証するためのフレームワーク。 
単体テストフレームワーク 
Python用テストスイートを含む回帰テストパッケージ。 
Python 回帰テストのサポート 
汎用 10 進数算術仕様 (General Decimal Arithmetic Specification)の実装。 
数学関数(sin() など)。 
複素数のための数学関数です。 
よく知られている様々な分布をもつ擬似乱数を生成する。 
浮動小数点数の擬似乱数生成器。 
バイナリサーチ用の配列二分法アルゴリズム。 
ヒープキュー (別名優先度キュー) アルゴリズム。 
一様な型を持つ数値からなる効率のよいアレイ。 
ユニークな要素の集合の実装 
効率的なループ実行のためのイテレータ生成関数。 
Perlのような複数の入力ストリームをまたいだ行の繰り返し処理をサポートする(その場で保存する機能つき)。 
Unix の cal プログラム相当の機能を含んだカレンダーに関する関数群 
行指向のコマンドインタープリタを構築 
Unix シェル類似の言語に対する単純な字句解析。 
ミキサオブジェクトには、2つのファイル類似メソッドがあります: 
すでに開かれているミキサデバイスファイルを閉じます。 
ファイルを閉じた後でミキサを使おうとすると、IOErrorを送出します。 
開かれているミキサデバイスファイルのファイルハンドルナンバを返します。 
以下はオーディオミキシング固有のメソッドです。 
このメソッドは、利用可能なミキサコントロール (SOUND_MIXER_PCMやSOUND_MIXER_SYNTH のように、ミキシングを行えるチャネル)を指定するビットマスクを返します。 
このビットマスクは利用可能な全てのミキサコントロールのサブセットです -- 定数SOUND_MIXER_*はモジュールレベルで定義されています。 
例えば、もし現在のミキサオブジェクトがPCM ミキサをサポートしているか調べるには、以下のPythonコードを実行します: 
ほとんどの用途には、SOUND_MIXER_VOLUME (マスタボリューム) とSOUND_MIXER_PCMコントロールがあれば十分でしょう --とはいえ、ミキサを使うコードを書くときには、コントロールを選ぶ時に柔軟性を持たせるべきです。 
例えばGravis Ultrasound にはSOUND_MIXER_VOLUME がありません。 
ステレオミキサコントロールを示すビットマスクを返します。 
ビットが立っているコントロールはステレオであることを示し、立っていないコントロールはモノラルか、ミキサがサポートしていないコントロールである (どちらの理由かはcontrols() と組み合わせて使うことで判別できます) ことを示します。 ビットマスクから情報を得る例は関数controls()のコード例を参照してください。 
録音に使用できるミキサコントロールを特定するビットマスクを返します。 
ビットマスクから情報を得る例は関数controls()のコード例を参照してください。 
指定したミキサコントロールのボリュームを返します。 
2 要素のタプル(left_volume,right_volume) を返します。 
ボリュームの値は 0 (無音) から100 (最大) で示されます。 
指定したミキサコントロールのボリュームを(left,right)に設定します。 leftとrightは整数で、0 (無音) から100 (最大) の間で指定せねばなりません。 
呼び出しに成功すると新しいボリューム値を 2 要素のタプルで返します。 サウンドカードによっては、ミキサの分解能上の制限から、指定したボリュームと厳密に同じにはならない場合があります。 
不正なコントロールを指定した場合や、指定したボリューム値が範囲外であった場合、IOError を送出します。 get_recsrc 
現在録音のソースに使われているコントロールを示すビットマスクを返します。 
録音のソースを指定にはこの関数を使ってください。 
呼び出しに成功すると、新たな録音の (場合によっては複数の) ソースを示すビットマスクを返します;不正なソースを指定するとIOErrorを送出します。 
現在の録音のソースとしてマイク入力を設定するには、以下のようにします: 
この章で記述されているモジュールは、主にマルチメディアアプリケーションに役立つさまざまなアルゴリズムまたはインターフェイスを実装しています。 
これらのモジュールはインストール時の自由裁量に応じて利用できます。 
生の音声データを操作する 
生の画像データを操作する。 
AIFFあるいはAIFCフォーマットのオーディオファイルの読み書き 
Sun AUサウンドフォーマットへのインターフェース 
WAVサウンドフォーマットへのインターフェイス 
IFFチャンクデータの読み込み。 
RGB 他の色体系間の変換。 
``SGI RGB'' 形式の画像ファイルを読み書きします (とはいえ、このモジュールは SGI 特有のものではありません !)。 
ファイルやバイトストリームに含まれる画像の形式を決定する。 
サウンドファイルの識別 
OSS互換オーディオデバイスへのアクセス。 
46 新しいDistutilsコマンドの作成 
22. MS Windows 特有のサービス 
Windowsプラットフォームで利用できます。 
これらの関数は Windows レジストリ API を Python で使えるようにします。 
他の計算機上にある既定のレジストリハンドル接続を確立し、ハンドルオブジェクト (handle object) を返します。 
computer_name はリモートコンピュータの名前で、r"computername" の形式をとります。 
Noneの場合、ローカルの計算機が使われます。 
特定のキーを生成するか開き、ハンドルオブジェクトを返します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つです。 
特定のキーを削除します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つです。 
sub_key は文字列で、key パラメタによって特定されたキーのサブキーでなければなりません。 
この値は None であってはならず、キーはサブキーを持っていてはなりません。 
このメソッドはサブキーをもつキーを削除することはできません。 
このメソッドの実行が成功すると、キー全体が、その値すべてを含めて削除されます。 
このメソッドが失敗した場合、EnvironmentError 例外が送出されます。 
レジストリキーから指定された名前つきの値を削除します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つでなければなりません。 
value は削除したい値を指定するための文字列です。 
開かれているレジストリキーのサブキーを列挙し、文字列で返します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つでなければなりません。 
index は整数値で、取得するキーのインデクスを特定します。 この関数は呼び出されるたびに一つのサブキーの名前を取得します。 
この関数は通常、これ以上サブキーがないことを示すEnvironmentError 例外が送出されるまで繰り返し呼び出されます。 
開かれているレジストリキーの値を列挙し、タプルで返します。 
index は整数値で、取得する値のインデクスを特定します。 この関数は呼び出されるたびに一つの値の名前を取得します。 
この関数は通常、これ以上値がないことを示すEnvironmentError 例外が送出されるまで繰り返し呼び出されます。 結果は 3 要素のタプルになります: 
値の名前を特定する文字列 
値のデータを保持するためのオブジェクトで、その型は背後のレジストリ型に依存します 
値のデータ型を特定する整数です 
キーのすべての属性をレジストリに書き込みます。 
また、システムの遮断時にもディスクにフラッシュされます。 
CloseKey() と違って、FlushKey() メソッドはレジストリに全てのデータを書き終えたときにのみ返ります。 アプリケーションは、レジストリへの変更を絶対に確実にディスク上に反映させる必要がある場合にのみ、FlushKey() を呼ぶべきです。 
FlushKey() を呼び出す必要があるかどうか分からない場合、おそらくその必要はありません。 
指定されたキーの下にサブキーを生成し、サブキーに指定されたファイルのレジストリ情報を記録します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つです。 
sub_key は記録先のサブキーを指定する文字列です。 file_name はレジストリデータを読み出すためのファイル名です。 
指定されたキーを開き、ハンドルオブジェクト を返します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つです。 
sub_key は開きたいサブキーを特定する文字列です。 
res 予約されている整数値で、ゼロでなくてはなりません。 
標準の値はゼロです。 
sam は必要なキーへのセキュリティアクセスを記述する、アクセスマスクを指定する整数です。 
標準の値は KEY_READ です。 
指定されたキーへの新しいハンドルが返されます。 この関数が失敗すると 、EnvironmentError が送出されます。 
OpenKeyEx() の機能は OpenKey()を標準の引数で使うことで提供されています。 
キーに関数情報をタプルとして返します。 
key はすでに開かれたキーか、既定の HKEY_* 定数のうちの一つです。 結果は以下の 3 要素からなるタプルです: 
インデクス 
このキーが持つサブキーの数を表す整数。 
このキーが持つ値の数を表す整数。 
最後のキーの変更が (あれば) いつだったかを表す長整数で、1600 年 1 月 1 日からの 100 ナノ秒単位で数えたもの。 
キーに対する、名前付けられていない値を文字列で取得します。 
sub_key は値が関連付けられているサブキーの名前を保持する文字列です。 
この引数が None または空文字列の場合、この関数はkey で特定されるキーに対して SetValue() メソッドで設定された値を取得します。 レジストリ中の値は名前、型、およびデータから構成されています。 
開かれたレジストリキーに関連付けられている、指定した名前の値に対して、型およびデータを取得します。 
value_name は要求する値を指定する文字列です。 結果は 2 つの要素からなるタプルです: 
レジストリ要素の名前。 
この値のレジストリ型を表す整数。 
指定されたキーと、そのサブキー全てを指定したファイルに保存します。 
file_name はレジストリデータを保存するファイルの名前です、このファイルはすでに存在していてはいけません。 
この特権はファイルパーミッションとは異なります - 詳細は Win32 ドキュメンテーションを参照してください。 この関数は security_attributes を NULL にして API に渡します。 
値を指定したキーに関連付けます。 
sub_key は値が関連付けられているサブキーの名前を表す文字列です。 
type はデータの型を指定する整数です。 現状では、この値はREG_SZ でなければならず、これは文字列だけがサポートされていることを示します。 
他のデータ型をサポートするにはSetValueEx() を使ってください。 
(2048 バイト以上の)長い値はファイルに保存して、そのファイル名を設定レジストリに保存するべきです。 
そうすればレジストリを効率的に動作させる役に立ちます。 key 引数に指定されたキーは KEY_SET_VALUEアクセスで開かれていなければなりません。 
開かれたレジストリキーの値フィールドにデータを記録します。 
type はデータの型を指定する整数です。 
値はこのモジュールで定義されている以下の定数のうちの一つでなければなりません: 
何らかの形式のバイナリデータ。 
32 ビットの数。 
32 ビットのリトルエンディアン形式の数。 
32 ビットのビッグエンディアン形式の数。 
環境変数を参照している、ヌル文字で終端された文字列。 
("%PATH%")。 
REG_LINK Unicode のシンボリックリンク。 
ヌル文字で終端された文字列からなり、二つのヌル文字で終端されている配列 (Python はこの終端の処理を自動的に行います)。 
定義されていない値の形式。 
デバイスドライバリソースのリスト。 REG_SZ 
ヌルで終端された文字列。 
reserved は何もしません - API には常にゼロが渡されます。 
value は新たな値を指定する文字列です。 このメソッドではまた、指定されたキーに対して、さらに別の値や型情報を設定することができます。 
そうすればレジストリを効率的に動作させる役に立ちます。 
22.2.1 レジストリハンドルオブジェクト 
11. インターネットプロトコルとその支援 
このモジュールでは、 HTTP サーバ (Web サーバ) を実装するための二つののクラスを定義しています。 
通常、このモジュールが直接使用されることはなく、特定の機能を持つ Web サーバを構築するために使われます。 
モジュールを参照してください。 最初のクラス、HTTPServer は SocketServer.TCPServer のサブクラスです。 
HTTPServer は HTTP ソケットを生成してリクエスト待ち (listen) を行い、リクエストをハンドラに渡します。 
サーバを作成して動作させるためのコードは以下のようになります: 
クラスHTTPServer 
このクラスは TCPServer 型のクラスの上に構築されており、サーバのアドレスをインスタンス変数 server_nameおよび server_port に記憶します。 
サーバはハンドラからアクセス可能で、通常 server インスタンス変数でアクセスします。 
クラスBaseHTTPRequestHandler 
このクラスはサーバに到着したリクエストを処理します。 
このメソッド自体では、実際のリクエストに応答することはできません; (GET や POST のような) 各リクエストメソッドを処理するためにはサブクラス化しなければなりません。 
BaseHTTPRequestHandler では、サブクラスで使うためのクラスやインスタンス変数、メソッド群を数多く提供しています。 このハンドラはリクエストを解釈し、次いでリクエスト形式ごとに固有のメソッドを呼び出します。 
メソッド名はリクエストの名称から構成されます。 
例えば、リクエストメソッド "SPAM" に対しては、do_SPAM() メソッドが引数なしで呼び出されます。 
リクエストに関連する情報は全て、ハンドラのインスタンス変数に記憶されています。 
サブクラスでは __init__() メソッドを上書きしたり拡張したりする必要はありません。 
BaseHTTPRequestHandler は以下のインスタンス変数を持っています: 
HTTP クライアントのアドレスを参照している、(host, port) の形式をとるタプルが入っています。 
HTTP 命令 (リクエスト形式) が入っています。 
例えば 'GET' です。 
リクエストされたパスが入っています。 
リクエストのバージョン文字列が入っています。 
例えば 'HTTP/1.0'です。 
MessageClass クラス変数で指定されたクラスのインスタンスを保持しています。 
このインスタンスは HTTP リクエストのヘッダを解釈し、管理しています。 
入力ストリームが入っており、そのファイルポインタはオプション入力データ部の先頭を指しています。 
クライアントに返送する応答を書き込むための出力ストリームが入っています。 このストリームに書き込む際には、HTTP プロトコルに従った形式をとらなければなりません。 
BaseHTTPRequestHandler は以下のクラス変数を持っています: 
サーバのソフトウェアバージョンを指定します。 
この値は上書きする必要が生じるかもしれません。 書式は複数の文字列を空白で分割したもので、各文字列はソフトウェア名[/バージョン] の形式をとります。 
例えば、'BaseHTTP/0.2' です。 sys_version 
Python 処理系のバージョンが、version_string メソッドやserver_version クラス変数で利用可能な形式で入っています。 
例えば 'Python/1.4' です。 
クライアントに返すエラー応答を構築するための書式化文字列を指定します。 
この文字列は丸括弧で囲ったキー文字列で指定する形式を使うので、書式化の対象となる値は辞書でなければなりません。 
message および explain の標準の値はresponse クラス変数でみつけることができます。 
この値には応答に使われる HTTP プロトコルのバージョンを指定します。 
'HTTP/1.1' に設定されると、サーバは持続的 HTTP 接続を許可します; しかしその場合、サーバは全てのクライアントに対する応答に、正確な値を持つ Content-Length ヘッダを (send_header() を使って) 含め なければなりません。 
以前のバージョンとの互換性を保つため、標準の設定値は'HTTP/1.0' です。 
HTTP ヘッダを解釈するための rfc822.Message 類似のクラスを指定します。 
通常この値が上書きされることはなく、標準の値mimetools.Message になっています。 
この変数はエラーコードを表す整数を二つの要素をもつタプルに対応付けます。 タプルには短いメッセージと長いメッセージが入っています。 
例えば、{code: (shortmessage, longmessage)}といったようになります。 
shortmessage は通常、エラー応答における message キーの値として使われ、longmessage は explain キーの値として使われます(error_message_format クラス変数を参照してください) 。 
BaseHTTPRequestHandler インスタンスは以下のメソッドを持っています: 
handle_one_request() を一度だけ (持続的接続が有効になっている場合には複数回) 呼び出して、HTTP リクエストを処理します。 このメソッドを上書きする必要はまったくありません; そうする代わりに適切な do_*() を実装してください。 
このメソッドはリクエストを解釈し、適切な do_*() メソッドに転送します。 
このメソッドを上書きする必要はまったくありません。 
完全なエラー応答をクライアントに送信し、ログ記録します。 
code は数値型で、 HTTP エラーコードを指定します。 message はオプションで、より詳細なメッセージテキストです。 
完全なヘッダのセットが送信された後、error_message_formatクラス変数を使って組み立てられたテキストが送られます。 
応答ヘッダを送信し、受理したリクエストをログ記録します。 
HTTP応答行が送られた後、Server および Date ヘッダが送られます。 
これら二つのヘッダはそれぞれ version_string() および date_time_string() メソッドで取り出します。 
出力ストリームに特定の HTTP ヘッダを書き込みます。 
keywordはヘッダのキーワードを指定し、value にはその値を指定します。 
応答中の HTTP ヘッダの終了を示す空行を送信します。 
受理された (成功した) リクエストをログに記録します。 code にはこの応答に関連付けられた HTTP コード番号を指定します。 
応答メッセージの大きさを知ることができる場合、size パラメタに渡すとよいでしょう。 
リクエストを遂行できなかった際に、エラーをログに記録します。 
標準では、メッセージを log_message() に渡します。 従って同じ引数 (format と追加の値) を取ります。 
任意のメッセージを sys.stderr にログ記録します。 
このメソッドは通常、カスタムのエラーログ記録機構を作成するために上書きされます。 
format 引数は標準の printf 形式の書式化文字列で、log_message() に渡された追加の引数は書式化の入力として適用されます。 
ログ記録される全てのメッセージには、クライアントのアドレスおよび現在の日付、時刻が先頭に付けられます。 
サーバソフトウェアのバージョン文字列を返します。 
この文字列はクラス変数 server_version および sys_version を組み合わせたものです。 
メッセージヘッダ向けに書式化された、現在の日付および時刻を返します。 
ログ記録向けに書式化された、現在の日付および時刻を返します。 
ログ記録向けに書式化された、クライアントのアドレスを返します。 
このときクライアントの IP アドレスに対する名前解決を行います。 
参考: 
:モジュール 
CGI スクリプトをサポートするように拡張されたリクエストハンドラ。 
ドキュメントルートの下にあるファイルに対する要求への応答のみに制限した基本リクエストハンドラ。 . 
バージョン 2.3 で 変更 された仕様:Disabled module 
警告:このドキュメントは、Bastionモジュールを使用している古いコードを読む際の参照用として残されています。 
辞書によると、バスティアン (bastion、要塞) とは、``防衛された領域や地点''、または ``最後の砦と考えられているもの'' であり、オブジェクトの特定の属性へのアクセスを禁じる方法を提供するこのモジュールにふさわしい名前です。 
制限モード下のプログラムに対して、あるオブジェクトにおける特定の安全な属性へのアクセスを許可し、かつその他の安全でない属性へのアクセスを拒否するには、要塞オブジェクトは常に 
モジュールと共に使われなければなりません。 
オブジェクト object を保護し、オブジェクトに対する要塞オブジェクトを返します。 
オブジェクトの属性に対するアクセスの試みは全て、filter 関数によって認可されなければなりません; アクセスが拒否された場合 AttributeError 例外が送出されます。 filter が存在する場合、この関数は属性名を含む文字列を受理し、その属性に対するアクセスが許可される場合には真を返さなければなりません; filter が偽を返す場合、アクセスは拒否されます。 
標準のフィルタは、アンダースコア ("_") で始まる全ての関数に対するアクセスを拒否します。 
name の値が与えられた場合、要塞オブジェクトの文字列表現は "Bastion for name" になります; そうでない場合、"repr(object)" が使われます。 
class が存在する場合、BastionClass のサブクラスでなくてはなりません; 詳細は bastion.py のコードを参照してください。 
稀に BastionClass の標準設定を上書きする必要ほとんどないはずです。 
クラスBastionClass 
実際に要塞オブジェクトを実装しているクラスです。 
このクラスはBastion() によって使われる標準のクラスです。 
getfunc 引数は関数で、唯一の引数である属性の名前を与えて呼び出した際、制限された実行環境に対して、開示すべき属性の値を返します。 name は BastionClass インスタンスのrepr() を構築するために使われます。 
CGIHTTPServer モジュールでは、BaseHTTPServer.BaseHTTPRequestHandler 互換のインタフェースを持ち、SimpleHTTPServer.SimpleHTTPRequestHandler の動作を継承していますが CGI スクリプトを動作することもできる、HTTP 要求処理機構クラスを定義しています。 
注意:このモジュールは CGI スクリプトを Unix および Windows システム上で実行させることができます; Mac OS 上では、自分と同じプロセス内でPython スクリプトを実行することしかできないはずです。 
CGIHTTPServer モジュールでは、以下のクラスを定義しています: 
クラスCGIHTTPRequestHandler 
このクラスは、現在のディレクトリかその下のディレクトリにおいて、ファイルかCGI スクリプト出力を提供するために使われます。 
HTTP 階層構造からローカルなディレクトリ構造への対応付けはSimpleHTTPServer.SimpleHTTPRequestHandler と全く同じなので注意してください。 このクラスでは、ファイルが CGI スクリプトであると推測された場合、これをファイルして提供する代わりにスクリプトを実行します。 
他の一般的なサーバ設定は特殊な拡張子を使って CGI スクリプトであることを示すのに対し、ディレクトリベースの CGI だけが使われます。 do_GET() および do_HEAD() 関数は、HTTP 要求が cgi_directories パス以下のどこかを指している場合、ファイルを提供するのではなく、CGI スクリプトを実行してその出力を提供するように変更されています。 
CGIHTTPRequestHandler では以下のデータメンバを定義しています: 
この値は標準で ['/cgi-bin', '/htbin'] であり、CGI スクリプトを含んでいることを示すディレクトリを記述します。 
CGIHTTPRequestHandler では以下のメソッドを定義しています: 
このメソッドは、CGI スクリプトでのみ許されている 'POST' 型の HTTP 要求に対するサービスを行います。 
CGI でない url に対して POST を試みた場合、出力はError 501, "Can only POST to CGI scripts" になります。 
セキュリティ上の理由から、CGI スクリプトはユーザ nobody の UID で動作するので注意してください。 
CGI スクリプトが原因で発生した問題は、Error 403 に変換されます。 
使用例については、test() 関数の実装を参照してください。 
参考: 
Web サーバとリクエスト処理機構を実装した基底クラスです。 . 
Macintoshプラットフォームで利用できます。 
CFBase, CFArray, CFData, CFDictionary,CFString と CFURL オブジェクトがいくらか部分的にサポートされています。 
ColorPicker モジュールは標準色選択ダイアログへのアクセスを提供します。 
標準色選択ダイアログを表示し、ユーザが色を選択することを可能にします。 
このモジュールでは, ConfigParserクラスを定義しています。 
ConfigParser クラスは,Microsoft Windows の INI ファイルに見られるような構造をもつ,基礎的な設定ファイルを実装しています.このモジュールを使って,エンドユーザーが簡単にカスタマイズできるようなPython プログラムを書くことができます。 
警告:このライブラリでは、Windowsのレジストリ用に拡張された INI 文法はサポートしていません。 
設定ファイルは 1 つ以上のセクションからなり、セクションは"[section]" ヘッダとそれに続くRFC 822 形式の"name: value" エントリからなっています。 
例: 
この場合"%(dir)s"は変数"dir" (この場合は"frob")に展開されます。 
参照の展開は必要に応じて実行されます。 デフォルト値はConfigParserのコンストラクタに辞書として渡すことで設定できます。 
追加の(他の値をオーバーライドする)デフォルト値はget()メソッドに渡すことができます。 
クラスRawConfigParser 
基本的な設定オブジェクトです。 
defaultsが与えられた場合、オブジェクトに固有のデフォルト値がその値で初期化されます。 
このクラスは値の置換をサポートしません。 バージョン 2.3 で 新たに追加 された仕様です。 
クラスConfigParser 
RawConfigParserの派生クラスで値の置換を実装しており、get()メソッドとitems()メソッドに省略可能な引数を追加しています。 
defaultsに含まれる値は"%()s"による値の置換に適当なものである必要があります。 
__name__は組み込みのデフォルト値で、セクション名が含まれるのでdefaultsで設定してもオーバーライドされます。 置換で使われるすべてのオプション名は、ほかのオプション名への参照と同様にoptionxform() メソッドを介して渡されます。 
たとえば、optionxform() のデフォルト実装 (これはオプション名を小文字に変換します) を使うと、値 "foo %(bar)s" および "foo %(BAR)s" は同一になります。 
クラスSafeConfigParser 
ConfigParserの派生クラスでより安全な値の置換を実装しています。 
指定したセクションが見つからなかった時に起きる例外です。 
すでに存在するセクション名に対して add_section() が呼び出された際に起きる例外です。 
指定したオプションが指定したセクションに存在しなかった時に起きる例外です。 
文字列の置換中に問題が起きた時に発生する例外の基底クラスです。 
InterpolationErrorの派生クラスで、文字列の置換回数がMAX_INTERPOLATION_DEPTHを越えたために完了しなかった場合に発生する例外です。 
InterpolationErrorの派生クラスで、値が参照しているオプションが見つからない場合に発生する例外です。 
InterpolationErrorの派生クラスで、指定された構文で値を置換することができなかった場合に発生する例外です。 バージョン 2.3 で 新たに追加 された仕様です。 
セクションヘッダを持たないファイルを構文解析しようとした時に起きる例外です。 
ファイルの構文解析中にエラーが起きた場合に発生する例外です。 
ConfigParserクラスだけに関係します。 
Unix のシェルに似た,アプリケーションの設定ファイル用フォーマットとして使えるもう一つの小型言語です.. 
CookieモジュールはHTTPの状態管理機能であるcookieの概念を抽象化、定義しているクラスです。 
単純な文字列のみで構成されるcookieのほか、シリアル化可能なあらゆるデータ型でクッキーの値を保持するための機能も備えています。 このモジュールは元々RFC 2109とRFC 2068に定義されている構文解析の規則を厳密に守っていました。 
しかし、MSIE 3.0xがこれらのRFCで定義された文字の規則に従っていないことが判明したため、結局、やや厳密さを欠く構文解析規則にせざるを得ませんでした。 
属性やSet-Cookie:ヘッダが正しくないなど、RFC 2109に合致していないときに発生する例外です。 
クラスBaseCookie 
このクラスはキーが文字列、値がMorselインスタンスで構成される辞書風オブジェクトです。 
値に対するキーを設定するときは、値がキーと値を含むMorselに変換されることに注意してください。 inputが与えられたときは、そのままload()メソッドへ渡されます。 
クラスSimpleCookie 
このクラスはBaseCookieの派生クラスで、value_decode() は与えられた値の正当性を確認するように、value_encode()はstr()で文字列化するようにそれぞれオーバライドします。 
クラスSerialCookie 
このクラスはBaseCookieの派生クラスで、value_decode()とvalue_encode()をそれぞれpickle.loads()とpickle.dumps()を実行するようにオーバーライドします。 
リリース 2.3 で撤廃されました。 このクラスを使ってはいけません! 信頼できないcookieのデータから pickle 化された値を読み込むことは、あなたのサーバ上で任意のコードを実行するために pickle 化した文字列の作成が可能であることを意味し、重大なセキュリティホールとなります。 
クラスSmartCookie 
このクラスはBaseCookieの派生クラスで、value_decode() を、値が pickle 化されたデータとして正当なときはpickle.loads()を実行、そうでないときはその値自体を返すようにオーバーライドします。 
またvalue_encode()を、値が文字列以外のときはpickle.dumps()を実行、文字列のときはその値自体を返すようにオーバーライドします。 
リリース 2.3 で撤廃されました。 SerialCookieと同じセキュリティ上の注意が当てはまります。 
関連して、さらなるセキュリティ上の注意があります。 
後方互換性のため、CookieモジュールはCookieというクラス名をSmartCookieのエイリアスとしてエクスポートしています。 
これはほぼ確実に誤った措置であり、将来のバージョンでは削除することが適当と思われます。 
アプリケーションにおいてSerialCookieクラスを使うべきでないのと同じ理由でCookieクラスを使うべきではありません。 
Webクライアント向けの HTTP クッキー処理です。 
cookielibとCookieは互いに独立しています。 . 
このモジュールが実装しているHTTPの状態管理に関する規格です。 
20. SGI IRIX 特有のサービス 
IRIXプラットフォームで利用できます。 
このモジュールには、Silicon GraphicsのGraphics Libraryで使われる定数が定義されています。 これらはCのプログラマーがヘッダーファイルgl/device.hの中から使っているものです。 
詳しくはモジュールのソースファイルをご覧ください。 
DocXMLRPCServer モジュールは SimpleXMLRPCServer クラスを拡張し、HTTP GET リクエストに対し HTML ドキュメントを返します。 
サーバは DocXMLRPCServer を使ったスタンドアロン環境、DocCGIXMLRPCRequestHandler を使った CGI 環境の2つがあります。 
クラスDocXMLRPCServer 
当たなサーバ・インスタンスを生成します。 
各パラメータの内容はSimpleXMLRPCServer.SimpleXMLRPCServer のものと同じですが、requestHandler のデフォルトは DocXMLRPCRequestHandler になっています。 
クラスDocCGIXMLRPCRequestHandler 
CGI環境に XMR-RPC リクエスト・ハンドラの新たなインスタンスを生成します。 
クラスDocXMLRPCRequestHandler 
リクエスト・ハンドラの新たなインスタンスを生成します。 
このリクエスト・ハンドラは XML-RPC POST リクエスト、ドキュメントの GET、そしてDocXMLRPCServer コンストラクタに与えられた logRequests パラメータ設定を優先するため、ロギングの変更をサポートします。 
EasyDialogsモジュールには、 Macintosh で単純なダイアログ操作を行うためのルーチンが入っています。 
EasyDialogs モジュールでは以下の関数を定義しています。 
メッセージテキストstr付きのモーダルダイアログを表示します。 テキストの長さは最大255文字です。 
ボタンのテキストはデフォルトでは``OK''ですが、文字列の引数ok を指定して変更できます。 
ユーザが``OK''ボタンをクリックすると処理を戻します。 
ユーザに文字列値の入力を促すモーダルダイアログを表示します。 
promptはプロンプトメッセージで、オプションのdefault 引数は入力文字列の初期値です(指定しなければ"" を使います)。 
``OK''と``Cancel''ボタンの文字列はokとcancelの引数で変更できます。 
文字列の長さは全て最大255文字です。 入力された文字列か、ユーザがキャンセルした場合にはNoneを返します。 
ユーザに文字列値の入力を促すモーダルダイアログを表示します。 
AskString()に似ていますが、ユーザの入力したテキストは点で表示されます。 
引数はAskString()のものと同じ意味です。 
プロンプトquestionと``Yes''、``No''、``Cancel''というラベルの3つボタンが付いたダイアログを表示します。 
ユーザが ``Yes''を押した場合には1 を、``No'' ならば0 を、``Cancel'' ならば-1 を返します。 
RETURNキーを押した場合はdefaultの値(default を指定しない場合は0)を返します。 
ボタンのテキストはそれぞれ引数 yes、no、cancelで変更できます。 ボタンを表示したくなければ引数に""を指定します。 
プログレスバー付きのモードレスダイアログを表示します。 
コマンドライン引数リストの作成を補助するためのダイアログを表示します。 
これらの引数が真の場合、それぞれ実在のファイル、まだ (おそらく) 存在しないファイル、フォルダへのパスをコマンドラインのパスとして設定できます。 (注意: getopt.getopt() がファイルやフォルダ引数を認識できるようにするためには、オブションの引数がそれらより前に現れるようにしなければなりません。 
)空白を含む引数は、空白をシングルクォートあるいはダブルクォートで囲んで指定できます。 
ユーザが``Cancel''ボタンを押した場合、SystemExit例外を送出します。 
optionlist には、ポップアップメニューで選べる選択肢を定義したリストを指定します。 
ポップアップメニューの要素には、次の2つの形式、optstr または(optstr, descr) があります。 
descr に短い説明文字列を指定すると、該当の選択肢をポップアップメニューで選択しいる間その文字列をダイアログに表示します。 
optstrとコマンドライン引数の対応を以下に示します: 
-x(短いオプション) 
x:あるいはx= 
-x (値を持つ短いオプション) 
--xyz (長いオプション) 
xyz:あるいはxyz= 
--xyz(値を持つ長いオプション) 
commandlistはcmdstrあるいは(cmdstr,descr)の形のアイテムからなるリストです。 descrは上と同じです。 
cmdstrはポップアップメニューに表示されます。 
メニューを選択するとcmdstr はコマンドラインに追加されますが、それに続く":"や"=" は (存在していれば) 取り除かれます。 
どのファイルを開くかをユーザに尋ねるダイアログを表示し、ユーザが選択したファイルを返します。 
ユーザがダイアログをキャンセルした場合にはNoneを返します。 
その他の引数の説明についてはApple Navigation ServicesのドキュメントとEasyDialogsのソースコードを参照してください。 
保存先のファイルをユーザに尋ねるダイアログを表示して、ユーザが選択したファイルを返します。 
ユーザがダイアログをキャンセルした場合にはNoneを返します。 
savedFileName は保存先のファイル名 (戻り値) のデフォルト値です。 
その他の引数の説明についてはAskFileForOpen()を参照してください。 
フォルダの選択をユーザに促すダイアログを表示して、ユーザが選択したフォルダを返します。 
ユーザがダイアログをキャンセルした場合にはNoneを返します。 
Programmer's reference documentationの Carbon framework の Navigation Services の項。 
2.8.1 プログレスバーオブジェクト 
FrameWork モジュールは、対話型 Macintosh アプリケーションのクラスで、同時にフレームワークを提供します。 
プログラマは、サブクラスを作って基底クラスの様々なメソッドをオーバーライドし、必要な機能を実装することでアプリケーションを組み立てられます。 
ソースか例題を詳しく見てください。 
次にあげるのは、MacPython ニュースグループにポストされたコメントで、FrameWork の強力さと限界について述べています。 
FrameWork の最大の強みは、制御の流れをたくさんの異なる部分に分割できることです。 
例えば W 
を使って、いろいろな方法でメニューをオン/オフしたり、残りをいじらずにうまくプラグインさせることができます。 
FrameWork の弱点は、コマンドインタフェースが抽象化されていないこと(といっても難しいわけではないですが)、ダイアログサポートが最低限しかないこと、それからコントロール/ツールバーサポートが全くないことです。 
FrameWork モジュールは次の関数を定義しています。 
アプリケーション全体を表現しているオブジェクト。 
メソッドについての詳細は以下の記述を参照してください。 
デフォルト __init__() ルーチンは、空のウィンドウ辞書とアップルメニューつきのメニューバーをを作成します。 
メニューバーを表現するオブジェクト。 
このオブジェクトは普通はユーザは作成しません。 
メニューを表現するオブジェクト。 
生成時には、メニューが現われる MenuBar と、title 文字列、メニューが表示されるべき(1から始まる)位置 after (デフォルトは末尾)を渡します。 
メニューアイテムオブジェクトを作成します。 
引数は作成するメニューと、アイテムのタイトル文字列、オプションのキーボードショートカット、コールバックルーチンです。 
コールバックは、メニューID、メニュー内のアイテム番号(1から数える)、現在のフロントウィンドウ、イベントレコードを引数に呼ばれます。 呼び出し可能なオブジェクトのかわりに、コールバックは文字列でも良いです。 
この場合、メニューの選択は、最前面のウィンドウとアプリケーションの中でメソッド探索を引き起こします。 
メソッド名は、コールバック文字列の前に 'domenu_' を付けたものです。 MenuBar の fixmenudimstate()メソッドを呼びだすと、現在のフロントウィンドウにもとづいて、適切なディム化を全てのメニューアイテムに対してほどこします。 
メニューの最後にセパレータを追加します。 
label の名前のサブメニューを、メニュー menu の下に作成します。 
メニューオブジェクトが返されます。 
(モードレス)ウィンドウを作成します。 
Parent は、ウィンドウが属するアプリケーションオブジェクトです。 
作成されたウィンドウはまだ表示されません。 
モードレスダイアログウィンドウを作成します。 
与えた幅と高さのウィンドウを作成するのに必要な、(left,top, right, bottom) からなるタプルを返します。 
ウィンドウは以前のウィンドウに対して位置をずらして作成され、全体のウィンドウが画面からなるべく外れないようにします。 
しかし、ウィンドウはいつでも全く同じサイズで、そのため一部は画面から隠れる場合もあります。 
マウスカーソルを時計型に設定します。 
マウスカーソルを矢印型に設定します。 
2.9.1 アプリケーションオブジェクト 
13. 構造化マークアップツール 
13.1.1 HTML パーザアプリケーションの例 
このモジュールでは HTMLParser クラスを定義します。 このクラスは HTML 
(ハイパーテキスト記述言語、HyperText Mark-up Language) および XHTML 
で書式化されているテキストファイルを解釈するための基礎となります。 
にあるパーザと違って、このパーザは 
の SGML パーザに基づいてはいません。 
クラスHTMLParser 
HTMLParser クラスは引数なしでインスタンス化します。 
HTMLParser インスタンスに HTML データが入力されると、タグが開始したとき、及び終了したときに関数を呼び出します。 
HTMLParser クラスは、ユーザが行いたい動作を提供するために上書きできるようになっています。 
のパーザと違い、このパーザは終了タグが開始タグと一致しているか調べたり、外側のタグ要素が閉じるときに内側で明示的に閉じられていないタグ要素のタグ終了ハンドラを呼び出したりはしません。 
例外も定義されています: 
パーズ中にエラーに遭遇した場合にHTMLParser クラスが送出する例外です。 
この例外は三つの属性を提供しています: msg はエラーの内容を説明する簡単なメッセージ、lineno は壊れたマークアップ構造を検出した場所の行番号、offset は問題のマークアップ構造の行内での開始位置を示す文字数です。 
HTMLParser インスタンスは以下のメソッドを提供します: 
インスタンスをリセットします。 
未処理のデータは全て失われます。 
インスタンス化の際に非明示的に呼び出されます。 
パーザにテキストを入力します。 
入力が完全なタグ要素で構成されている場合に限り処理が行われます; 不完全なデータであった場合、新たにデータが入力されるか、close() が呼び出されるまでバッファされます。 
全てのバッファされているデータについて、その後にファイル終了マークが続いているとみなして強制的に処理を行います。 
このメソッドは入力データの終端で行うべき追加処理を定義するために導出クラスで上書きすることができますが、再定義を行ったクラスでは常に、HTMLParser 基底クラスのメソッド close() を呼び出さなくてはなりません。 
現在の行番号およびオフセット値を返します。 
最も最近開かれた開始タグのテキスト部分を返します。 
このテキストは必ずしも元データを構造化する上で必須ではありませんが、``広く知られている (as deployed)'' HTML を扱ったり、入力を最小限の変更で再生成 (属性間の空白をそのままにする、など) したりする場合に便利なことがあります。 
このメソッドはタグの開始部分を処理するために呼び出されます。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
tag 引数はタグの名前で、小文字に変換されています。 
attrs 引数は (name, value) のペアからなるリストで、タグの 括弧内にある属性が収められています。 
name は小文字に変換され、value 内のエンティティ参照は変換されます。 二重引用符やバックスラッシュは変換しません。 
例えば、タグ A HREF="http://www.cwi.nl/" を処理する場合、このメソッドは"handle_starttag('a', [('href', 'http://www.cwi.nl/')])"として呼び出されます。 
handle_starttag() と似ていますが、パーザが XHTML 形式の空タグ (a .../) に遭遇した場合に呼び出されます。 
この特定の語彙情報 (lexical information) が必要な場合、このメソッドをサブクラスで上書きすることができます; 標準の実装では、単に handle_starttag() および handle_endtag()を呼ぶだけです。 
このメソッドはあるタグ要素の終了タグを処理するために呼び出されます。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
tag 引数はタグの名前で、小文字に変換されています。 
このメソッドは、他のメソッドに当てはまらない任意のデータを処理するために呼び出されます。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
このメソッドはタグ外の "#ref;" 形式の文字参照(character reference) を処理するために呼び出されます。 ref には、先頭の"#" および末尾の";" は含まれません。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
このメソッドはタグ外の "name;" 形式の一般のエンティティ参照 (entity reference) name を処理するために呼び出されます。 name には、先頭の"" および末尾の";" は含まれません。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
このメソッドはコメントに遭遇した場合に呼び出されます。 
comment引数は文字列で、"-" および "-" デリミタ間の、デリミタ自体を除いたテキストが収められています。 
例えば、コメント"!-text-" があると、このメソッドは引数'text' で呼び出されます。 
パーザが SGML 宣言を読み出した際に呼び出されるメソッドです。 
decl パラメタは !... 記述内の宣言内容全体になります。 導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
処理指令に遭遇した場合に呼び出されます。 
dataには、処理指令全体が含まれ、例えば?proc color='red'という処理指令の場合、handle_pi("proc color='red'")のように呼び出されます。 
このメソッドは導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
注意:The HTMLParserクラスでは、処理指令にSGMLの構文を使用します。 
末尾に"?"がXHTMLの処理指令では、"?"がdataに含まれます。 
このモジュールは、Python インタプリタ内の MacOS 固有の機能に対するアクセスを提供します。 例えば、インタプリタのイベントループ関数などです。 
'carbon' か 'macho' のいずれかです。 
現在利用している Python が Mac OS X および Mac OS 9互換性をもつ CarbonLib 形式、あるいは Mac OS X のみの Mach-O 形式をのどちらであるか判断できます。 
Python の初期のバージョンでは、値がさらに古い Mac OS 8 ランタイムモデル用の 'ppc' である事があります。 
インタープリタがどのような方法でリンクされているかを返します。 
拡張モジュールがリンクモデル間で非互換性かもしれない場合、パッケージはより多くの適切なエラーメッセージを伝えるためにこの情報を使用することができます。 
値は静的リンクした Python は 'static'、Mac OS X framework で構築した Python は 'framework'、標準の unix 共有ライブラリ(shared library)で構築された Python は 'shared'、Mac OS 9 互換 Python では 'cfm' となります。 
MacOS でエラーがあると、このモジュールの関数か、Mac 固有なツールボックスインターフェースモジュールから、この例外が生成されます。 
引数は、整数エラーコード(OSErr 値)とテキストで記述されたエラーコードです。 分かっている全てのエラーコードのシンボル名は、標準モジュール 
で定義されています。 
内部のインタプリタループでは、ScheduleParams() で止めないかぎり、Python は時々イベントをチェックします。 
イベントがある場合は、この関数を使うと、Pythonイベントハンドラ関数を渡せます。 
既にイベントハンドラがセットされているのに、さらにセットしようとするとエラーになります。 有効性:MacPython-OS9 
これはインタプリタの内部ループイベントハンドラに影響を与えます。 
Interval は、インタプリタがどれだけの頻度(浮動小数点数の秒で表わされる)でイベント処理コードに入るかを指定します。 
真なら doint は割り込み(コマンドドット)チェックが行われます。 evtmask はインタプリタに、イベントをマスクして (再描画、他のアプリケーションに切り替わるマウスクリックなど)イベント処理するよう指示します。 
besocial フラグは、他のプロセスが動作するチャンスを与えます。 
Python が最前面で動いている時は、最小限の実行時間が割り当てられ、Python が背景にある場合は、interval 当りに bgyield 秒が与えられます。 全てのパラメータはオプションで、現在の値がデフォルト値となります。 
イベントレコード ev を Python のイベントループに渡す、というよりは、sys.stdout ウィンドウ(Pythonをビルドしたコンパイラにもとづいて) のハンドラに渡されることになります。 
MacOSのエラーコード errno のテキスト表現を返します。 
この関数は、resid で与えた DLOG リソースの内容で、スプラッシュウィンドウを画面に表示します。 
引数なしで呼びだすと、スプラッシュ画面を取り除きます。 
拡張モジュールをたくさんロードさせる前に、初期化のタイミングでアプレットにスプラッシュ画面を表示させたいときに、この関数が便利でしょう。 有効性:MacPython-OS9 
Mac OS 9上では、メッセージ message を出してローレベルデバッガに入ります。 
オプションの object 引数は使われませんが、デバッガから内容を容易に検査することができます。 
この関数は主に Python 拡張モジュールの開発者のために用意されています。 
ベルを鳴らします。 
システム起動時からのチック数(clock ticks、1/60秒)を得ます。 
2つの4文字の文字列としてファイルクリエータおよびファイルタイプを返します。 file 引数はパスもしくは、FSSpec、FSRef オブジェクトを与える事ができます。 
ファイルのリソースフォークを開きます。 
引数は組み込み関数 open() と同じです。 
返されたオブジェクトはファイルのように見えるかもしれませんが、これは Python のファイルオブジェクトではありませんので扱いに微妙な違いがあります。 
現在のプロセスが動作しているウィンドウマネージャにアクセスします。 例えば、Mac OS X サーバー上、あるいは SSH でログインしている、もしくは現在のインタープリタがフルブローンアプリケーションバンドル(fullblownapplication bundle)から起動されていない場合などのような、ウィンドウマネージャが存在しない場合は False を返します。 
Mac OS 9 上ではこの関数はつねに True を返します。 
リリース 2.3 で撤廃されました。 
パッケージを、MimeWriterモジュールよりも優先して使用すべきです。 
このモジュールは、下位互換性維持のためだけに存在します。 
このモジュールは、クラス MimeWriterを定義します。 
このMimeWriter クラスは、MIME マルチパートファイルを作成するための基本的なフォーマッタを実装します。 
これは出力ファイル内をあちこち移動することも、大量のバッファスペースを使うこともありません。 
あなたは、最終のファイルに現れるであろう順番に、パートを書かなければなりません。 
MimeWriter は、あなたが追加するヘッダをバッファして、それらの順番を並び替えることができるようにします。 
クラスMimeWriter 
MimeWriter クラスの新しいインスタンスを返します。 
渡される唯一の引数 fp は、書くために使用するファイルオブジェクトです。 
StringIO オブジェクトを使うこともできることに注意して下さい。 
12.8.1 MimeWriter オブジェクト 
MiniAEFrameモジュールは、アプリケーションにオープンスクリプティングアーキテクチャ 
(OSA)サーバ機能を持たせるためのフレームワークを提供します。 
つまり、AppleEvents 
の受信と処理を行わせます。 
と連携させても良いし、単独でも使えます。 
実例として、このモジュールはPythonCGISlaveの中で使われています。 MiniAEFrameには以下のクラスが定義されています。 
クラスAEServer 
AppleEventの分岐を処理するクラス。 
作成するアプリケーションはこのクラスと、MiniApplicationあるいはFrameWork.Applicationのサブクラスでなければなりません。 
サブクラス化したクラスでは__init__()メソッドで、継承した両方のクラスの__init__()メソッドを呼びださなければなりません。 
クラスMiniApplication 
FrameWork.Applicationとある程度互換なクラスですが、機能は少ないです。 
3.5.1 AEServer オブジェクト 
Navigation Servicesの低レベルインターフェース。 
PixMapWrapper はPixMap オブジェクトを Python オブジェクトでラップしたもので、各フィールドに対し名前でアクセスできるようになります。 
PIL 画像との相互の変換をするメソッドも用意されています。 
7. オプションのオペレーティングシステムサービス 
Queueモジュールは、多生産者-多消費者FIFOキューを実装します。 
これは、複数のスレッドの間で情報を安全に交換しなければならないときのスレッドプログラミングで特に有益です。 
このモジュールのQueueクラスは、必要なすべてのロックセマンティクスを実装しています。 
これはPythonのスレッドサポートの状況に依存します。 Queueモジュールは以下のクラスと例外を定義します: 
クラスQueue 
クラスのコンストラクタです。 maxsizeはキューに置くことのできる要素数の上限を設定する整数です。 
いったんこの大きさに達したら、挿入はキューの要素が消費されるまでブロックされます。 
もしmaxsizeが0以下であるならば、キューの大きさは無限です。 
空なQueueオブジェクトで、非ブロックメソッドとしてget()(またはget_nowait())が呼ばれたとき、送出される例外です。 
満杯なQueueオブジェクトで、非ブロックメソッドとしてput()(またはput_nowait())が呼ばれたとき、送出される例外です。 
Tkプラットフォームで利用できます。 
ScrolledTextモジュールは``正しい動作''をするように設定された垂直スクロールバーをもつ基本的なテキストウィジェットを実装する同じ名前のクラスを提供します。 ScrolledTextクラスを使うことは、テキストウィジェットとスクロールバーを直接設定するより簡単です。 
コンストラクタはTkinter.Textクラスのものを同じです。 テキストウィジェットとスクロールバーはFrameの中に一緒にpackされ、GridとPackジオメトリマネジャのメソッドはFrameオブジェクトから得られます。 
これによって、もっとも標準的なジオメトリマネジャの振る舞いにするために、直接ScrolledTextウィジェットを使えるようになります。 特定の制御が必要ならば、以下の属性が利用できます: 
テキストとスクロールバーウィジェットを取り囲むフレーム。 
スクロールバーウィジェット。 
クラスSimpleHTTPRequestHandler 
このクラスは、現在のディレクトリ以下にあるファイルを、HTTP リクエストにおけるディレクトリ構造に直接対応付けて提供するために利用されます。 
リクエストの解釈のような、多くの作業は基底クラスBaseHTTPServer.BaseHTTPRequestHandler で行われます。 このクラスは関数 do_GET() および do_HEAD() を実装しています。 
SimpleHTTPRequestHandler では以下のメンバ変数を定義しています: 
server_version この値は "SimpleHTTP/" + __version__ になります。 
__version__ はこのモジュールで定義されている値です。 
extensions_map 拡張子を MIME 型指定子に対応付ける辞書です。 
標準の型指定は空文字列で表され、この値は application/octet-stream と見なされます。 対応付けは大小文字の区別をするので、小文字のキーのみを入れるべきです。 
SimpleHTTPRequestHandler では以下のメソッドを定義しています: 
このメソッドは 'HEAD' 型のリクエスト処理を実行します: すなわち、GET リクエストの時に送信されるものと同じヘッダを送信します。 
送信される可能性のあるヘッダについての完全な説明は do_GET() メソッドを参照してください。 
このメソッドはos.listdir()をディレクトリのスキャンに用いており、listdir()が失敗した場合には 404 応答が返されます。 リクエストがファイルに対応付けられた場合、そのファイルを開いて内容を返します。 
要求されたファイルを開く際に何らかの IOError 例外が送出された場合、リクエストは 404、'File not found' エラーに対応づけられます。 
そうでない場合、コンテントタイプがextensions_map 変数を用いて推測されます。 出力は 'Content-type:' と推測されたコンテントタイプで、その後にヘッダの終了を示す空白行が続き、さらにその後にファイルの内容が続きます。 
このファイルはコンテントタイプがtext/で始まっている場合はテキストモードで、そうでなければバイナリモードで開かれます。 
使用例については関数 test() の実装を参照してください。 
Web サーバおよび要求ハンドラの基底クラス実装。 . 
11.22.9 クライアントのサンプル 
SimpleXMLRPCServerモジュールはPythonで記述された基本的なXML-RPCサーバーフレームワークを提供します。 
サーバーはスタンドアロンであるか、SimpleXMLRPCServer を使うか、CGIXMLRPCRequestHandler を使って CGI 環境に組み込まれるかの、いずれかです。 
クラスSimpleXMLRPCServer 
新しくサーバーインスタンスを作成します。 
引数requestHandlerには、リクエストハンドラーインスタンスのファクトリーを設定します。 デフォルトはSimpleXMLRPCRequestHandlerです。 
引数addrとrequestHandlerは 
.TCPServerのコンストラクターに引き渡されます。 
もし引数logRequestsが真(true)であれば、(それがデフォルトですが、)リクエストはログに記録されます。 偽(false)である場合にはログは記録されません。 
このクラスはXML-RPCプロトコルで呼ばれる関数の登録のためのメソッドを提供します。 
クラスCGIXMLRPCRequestHandler 
CGI 環境における XML-RPC リクエストハンドラーを、新たに作成します。 
クラスSimpleXMLRPCRequestHandler 
新しくリクエストハンドラーインスタンスを作成します。 
このリクエストハンドラーはPOSTリクエストを受け持ち、SimpleXMLRPCServerのコンストラクターの引数logRequestsに従ったログ出力を行います。 
SocketServer モジュールはネットワークサーバを実装するタスクを単純化します。 このモジュールには 4 つのサーバクラスがあります:TCPServer は、クライアントとサーバ間に継続的なデータ流路を提供する、インターネット TCP プロトコルを使います。 
UDPServer は、順序通りに到着しなかったり、転送中に喪失してしまってもかまわない情報の断続的なパケットである、データグラムを使います。 
UnixStreamServer および UnixDatagramServer クラスも同様ですが、Unix ドメインソケットを使います; 従って非 Unixプラットフォームでは利用できません。 
ネットワークプログラミングについての詳細は、W. Richard Steven 著 UNIX Network Programmingや、 Ralph Davis 著 Win32 Network Programming のような書籍を参照してください。 これらの 4 つのクラスは要求を 同期的に (synchronously) 処理します; 各要求は次の要求を開始する前に完結していなければなりません。 
同期的な処理は、サーバで大量の計算を必要とする、あるいはクライアントが処理するには時間がかかりすぎるような大量のデータを返す、といった理由によってリクエストに長い時間がかかる状況には向いていません。 
こうした状況の解決方法は別のプロセスを生成するか、個々の要求を扱うスレッドを生成することです; ForkingMixIn および ThreadingMixIn 配合クラス(mix-in classes) を使えば、非同期的な動作をサポートできます。 サーバの作成にはいくつかのステップがあります。 
最初に、BaseRequestHandler クラスをサブクラス化して要求処理クラス (request hander class) を生成し、その handle()メソッドを上書きしなければなりません; このメソッドで入力される要求を処理します。 
次に、サーバクラスのうち一つをインスタンス化して、サーバのアドレスと要求処理クラスを渡さなければなりません。 
最後に、サーバオブジェクトの handle_request() または serve_forever() メソッドを呼び出して、単一または多数の要求を処理します。 ThreadingMixIn から継承してスレッドを利用した接続を行う場合、突発的な通信切断時の処理を明示的に指定する必要があります。 
ThreadingMixIn クラスには daemon_threads 属性があり、サーバがスレッドの終了を待ち合わせるかどうかを指定する事ができます。 
サーバが要求待ちを行っているソケットのファイル記述子を整数で返します。 
この関数は一般的に、同じプロセス中の複数のサーバを監視できるようにするために、 select.select() に渡されます。 
単一の要求を処理します。 
この関数は以下のメソッド:get_request()、 verify_request()、およびprocess_request() を順番に呼び出します。 
ハンドラ中でユーザによって提供された handle() が例外を送出した場合、サーバの handle_error() メソッドが呼び出されます。 
無限個の要求を処理します。 
この関数は単に無限ループ内でhandle_request() を呼び出します。 
address_family サーバのソケットが属しているプロトコルファミリです。 
取りえる値は socket.AF_INET および socket.AF_UNIX です。 
ユーザが提供する要求処理クラスです; 要求ごとにこのクラスのインスタンスが生成されます。 
インターネットプロトコルでは、この値は例えば('127.0.0.1', 80)のようにアドレスを与える文字列と整数のポート番号を含むタプルです。 
サーバが入力の要求待ちを行うためのソケットオブジェクトです。 
サーバクラスは以下のクラス変数をサポートします: 
サーバがアドレスの再使用を許すかどうかを示す値です。 
この値は標準で False で、サブクラスで再使用ポリシを変更するために設定することができます。 
要求待ち行列 (queue) のサイズです。 単一の要求を処理するのに長時間かかる場合には、サーバが処理中に届いた要求は最大request_queue_size 個まで待ち行列に置かれます。 
待ち行列が一杯になると、それ以降のクライアントからの要求は``接続拒否 (Connection denied)'' エラーになります。 
標準の値は通常 5 ですが、この値はサブクラスで上書きすることができます。 
サーバが使うソケットの型です; 取りえる値は 2 つで、socket.SOCK_STREAM と socket.SOCK_DGRAM です。 
TCPServer のような基底クラスのサブクラスで上書きできるサーバメソッドは多数あります; これらのメソッドはサーバオブジェクトの外部のユーザにとっては役にたたないものです。 
RequestHandlerClass をインスタンス化し、handle()メソッドを呼び出して、実際に要求を処理します。 
ソケットから要求を受理して、 クライアントとの通信に使われる新しい ソケットオブジェクト、およびクライアントのアドレスからなる、2 要素のタプルを返します。 
この関数は RequestHandlerClass の handle() メソッドが例外を送出した際に呼び出されます。 
必要なら、この関数から新たなプロセスかスレッドを生成して要求を処理することができます;その処理は ForkingMixIn または ThreadingMixIn クラスが行います。 
サーバのコンストラクタによって呼び出され、サーバを活動状態にします。 
このメソッドは上書きできます。 
要求処理クラスでは、新たな handle() メソッドを定義しなくてはならず、また以下のメソッドのいずれかを上書きすることができます。 
各要求ごとに新たなインスタンスが生成されます。 
handle() メソッドが呼び出された後、何らかの後始末を行うために呼び出されます。 
標準の実装では何も行いません。 
setup() またはhandle() が例外を送出した場合には、この関数は呼び出されません。 
この関数では、クライアントからの要求を実現するために必要な全ての作業を行わなければなりません。 
self.request の型はサービスがデータグラム型かストリーム型かで異なります。 
ストリーム型では、self.request はソケットオブジェクトです; データグラムサービスでは、self.request は文字列になります。 
しかし、この違いは要求処理配合クラスのStreamRequestHandler やDatagramRequestHandlerを使うことで隠蔽することができます。 
これらのクラスでは setup() および finish() メソッドを上書きしており、self.rfile および self.wfile 属性を提供しています。 
self.rfile および self.wfile は、要求データを取得したりクライアントにデータを返すために、それぞれ読み出し、書き込みを行うことができます。 
handle() メソッドより前に呼び出され、何らかの必要な初期化処理を行います。 
標準の実装では何も行いません。 
このモジュールは、(メモリファイルとしても知られている)文字列のバッファに対して読み書きを行うファイルのようなクラス、StringIO 、を実装しています。 
操作方法についてはファイルオブジェクトの説明を参照してください(セクション2.3.9)。 
クラスStringIO 
StringIO オブジェクトを作る際に、コンストラクターに文字列を渡すことで初期化することができます。 
文字列を渡さない場合、最初は StringIO はカラです。 StringIO オブジェクトはユニコードも 8-bit の文字列も受け付けますが、この2つを混ぜることには少し注意が必要です。 
この2つが一緒に使われると、 getvalue() が呼ばれたときに、(8th ビットを使っている)7-bit ASCII に解釈できない 8-bit の文字列は、UnicodeError を引き起こします。 
次にあげる StringIO オブジェクトのメソッドには特別な説明が必要です: 
StringIO オブジェクトの close() メソッドが呼ばれる前ならいつでも、``file'' の中身全体を返します。 
ユニコードと 8-bit の文字列を混ぜることの説明は、上の注意を参照してください。 この2つの文字コードを混ぜると、このメソッドは UnicodeError を引き起こすかもしれません。 
メモリバッファを解放します。 
16.1.6.9 画像 
Tix (Tk Interface Extension)モジュールは豊富な追加ウィジェットを提供します。 
標準Tkライブラリには多くの有用なウィジェットがありますが、完全では決してありません。 
Tixライブラリは標準Tkに欠けている一般的に必要とされるウィジェットの大部分を提供します: HList、ComboBox、Control (別名SpinBox)および各種のスクロール可能なウィジェット。 
アプリケーションとユーザに特有の要求に合うように、大部分のアプリケーションウィジェットを選ぶことによって、アプリケーションを設計できます。 
Tixのホームページ。 
ここには追加ドキュメントとダウンロードへのリンクがあります。 
manページと参考資料のオンライン版。 
プログラマ用参考資料のオンライン版。 
TixとTkinterプログラムの開発のためのTixアプリケーション。 TideアプリケーションはTkまたはTkinterに基づいて動作します。 
また、リモートでTix/Tk/Tkinterアプリケーションを変更やデバグするためのインスペクタTixInspectが含まれます。 
16.2.2.1 基本ウィジェット 
16.2.2.2 ファイルセレクタ 
16.2.2.3 ハイアラキカルリストボックス 
16.2.2.4 タビュラーリストボックス 
16.2.2.5 管理ウィジェット 
16.2.2.6 画像タイプ 
16.2.2.7 その他のウィジェット 
16.2.2.8 ジオメトリマネジャを作る 
Tkinter モジュール (``Tk インタフェース'') は、Tk GUI ツールキットに対する標準の Python インタフェースです。 
Tk と Tkinter はほとんどの Unix プラットフォームの他、 Windows や Macintosh システム上でも利用できます。 
(Tk 自体は Python の一部ではありません。 Tk は ActiveState で保守されています。 
) 参考: 
Python Tkinter Topic Guide では、Tk を Python から利用する上での情報と、その他の Tk にまつわる情報源を数多く提供しています。 
Fredrik Lundh のオンラインリファレンス資料です。 
オンラインリファレンス資料です。 
Jython から Tkinter へのインタフェースです。 
John Graysonによる解説書 (ISBN 1-884777-81-3) です。 
16.1.2 Tkinter お助け手帳 (life preserver) 
16.1.2.1 この節の使い方 
16.1.2.2 簡単なHello Worldプログラム 
16.1.3 Tcl/Tk を (本当に少しだけ) 見渡してみる 
16.1.6.1 オプションの設定 
16.1.6.3 Packer のオプション 
16.1.6.4 ウィジェット変数を関連付ける 
16.1.6.5 ウィンドウマネジャ 
16.1.6.6 Tk オプションデータ型 
16.1.6.7 バインドとイベント 
16.1.6.8 index パラメータ 
注意:このモジュールは後方互換性のためだけに残されています。 
Python 2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、組み込みdict型から直接サブクラス化することを検討してください。 
このモジュールは辞書オブジェクトのラッパーとして働くクラスを定義します。 
独自の辞書に似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。 
このような方法で、辞書に新しい振る舞いを追加できます。 最小限のマッピングインターフェイスをすでに持っているクラスのために、モジュールはすべての辞書メソッドを定義しているmixinも定義しています。 
これによって、shelveモジュールのような辞書の代わりをする必要があるクラスを書くことが非常に簡単になります。 UserDictモジュールはUserDictクラスとDictMixinを定義しています: 
クラスUserDict 
辞書をシミュレートするクラス。 
インスタンスの内容は通常の辞書に保存され、UserDictインスタンスのdata属性を通してアクセスできます。 
initialdataが与えられれば、dataはその内容で初期化されます。 他の目的のために使えるように、initialdataへの参照が保存されないことがあるということに注意してください。 
マッピングのメソッドと演算(節2.3.8を参照)に加えて、UserDictインスタンスは次の属性を提供します: 
UserDictクラスの内容を保存するために使われる実際の辞書。 
クラスDictMixin 
__getitem__、__setitem__、__delitem__およびkeys といった最小の辞書インタフェースを既に持っているクラスのために、全ての辞書メソッドを定義する mixin です。 このmixinはスーパークラスとして使われるべきです。 
上のそれぞれのメソッドを追加することで、より多くの機能がだんだん追加されます。 
Python 2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、組み込みlist型から直接サブクラス化することを検討してください。 
このモジュールはリストオブジェクトのラッパーとして働くクラスを定義します。 
独自のリストに似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。 
このような方法で、リストに新しい振る舞いを追加できます。 UserListモジュールはUserListクラスを定義しています: 
クラスUserList 
リストをシミュレートするクラス。 
インスタンスの内容は通常のリストに保存され、UserListインスタンスのdata属性を通してアクセスできます。 
インスタンスの内容は最初にlistのコピーに設定されますが、デフォルトでは空リスト[]です。 listは通常のPythonリストか、UserList(またはサブクラス)のインスタンスのどちらかです。 
変更可能シーケンスのメソッドと演算(節2.3.6を参照)に加えて、UserListインスタンスは次の属性を提供します: 
UserListクラスの内容を保存するために使われる実際のPythonリストオブジェクト。 
サブクラス化の要件: UserListのサブクラスは引数なしか、あるいは一つの引数のどちらかとともに呼び出せるコンストラクタを提供することが期待されます。 
新しいシーケンスを返すリスト演算は現在の実装クラスのインスタンスを作成しようとします。 
バージョン 2.0 で 変更 された仕様:Pythonバージョン1.5.2と1.6では、コンストラクタが引数なしで呼び出し可能であることと変更可能なdata属性を提供するということも要求されます。 
Pythonの初期のバージョンでは、導出クラスのインスタンスを作成しようとはしません。 
注意:このモジュールのUserStringクラスは後方互換性のためだけに残されています。 
Python 2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、UserStringを使う代わりに組み込みstr型から直接サブクラス化することを検討してください(組み込みのMutableStringと等価なものはありません)。 
このモジュールは文字列オブジェクトのラッパーとして働くクラスを定義します。 
独自の文字列に似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。 
クラスUserString 
文字列またはユニコード文字列オブジェクトをシミュレートするクラス。 
インスタンスの内容は通常の文字列またはユニコード文字列オブジェクトに保存され、UserStringインスタンスのdata属性を通してアクセスできます。 
インスタンスの内容は最初にsequenceのコピーに設定されます。 sequenceは通常のPython文字列またはユニコード文字列、UserString(またはサブクラス)のインスタンス、あるいは組み込みstr()関数を使って文字列に変換できる任意のシーケンスのいずれかです。 
クラスMutableString 
このクラスは上のUserStringから導出され、変更可能になるように文字列を再定義します。 
変更可能な文字列は辞書のキーとして使うことができません。 なぜなら、辞書はキーとして変更不能なオブジェクトを要求するからです。 
このクラスの主な目的は、辞書のキーとして変更可能なオブジェクトを使うという試みを捕捉するために、継承と__hash__()メソッドを取り除く(オーバーライドする)必要があることを示す教育的な例を提供することです。 そうしなければ、非常にエラーになりやすく、突き止めることが困難でしょう。 
文字列とユニコードオブジェクトのメソッドと演算(節2.3.6、``文字列メソッド''を参照)に加えて、UserStringインスタンスは次の属性を提供します: 
UserStringクラスの内容を保存するために使われる実際のPython文字列またはユニコードオブジェクト。 
W ウィジェットは、IDE で頻繁に使われています。 
aepack モジュールは、Python 変数から AppleEvent ディスクリプタへの変換(パック)と、その逆に変換(アンパック)する関数を定義しています。 Python 内では AppleEvent ディスクリプタは、組み込み型である AEDesc のPython オブジェクトとして扱われます。 
aepack モジュールは次の関数を定義しています。 
Python 値 x を変換した値を保持する AEDesc オブジェクトを返します。 
forcetype が与えることで、結果のディスクリプタ型を指定できます。 
それ以外では、Python 型から Apple Eventディスクリプタ型へのデフォルトのマッピングが使われます。 マッピングは次の通りとなります。 
x がPythonインスタンスなら、この関数は __aepack__() メソッドを呼びだそうとします。 
このメソッドは AEDesc オブジェクトを返します。 x の変換が上で定義されていない場合は、この関数は、テキストディスクリプタとしてエンコードされた、値の(repr()関数による)Python文字列表現が返されます。 
x は AEDesc タイプのオブジェクトでなければいけません。 
この関数は、Apple Eventディスクリプタ x のデータのPythonオブジェクト表現を返します。 
単純なAppleEventデータ型(整数、テキスト、浮動少数点数)の、対応するPython型が返されます。 Apple EventリストはPythonリストとして返され、リストの要素は再帰的にアンパックされます。 
formodulename の指定がない場合、オブジェクト参照(例:line 3 of document 1)が、aetypes.ObjectSpecifier のインスタンスとして返されます。 
ディスクリプタ型がtypeFSSであるAppleEventディスクリプタが、FSSpec オブジェクトとして返されます。 
AppleEventレコードディスクリプタが、再帰的にアンパックされた、型の4文字キーと要素を持つPython辞書として返されます。 オプションの formodulename 引数は gensuitemodule より作成されるスタブパッケージにより利用され、オブジェクト指定子のための OSA クラスをモジュールの中で見つけられることを保証します。 
これは、例えば、ファインダがウィンドウに対してオブジェクト指定子を返す場合、Finder.Window のインスタンスが得られ、aetypes.Window が得られないことを保証します。 
前者は、ファインダ上のウィンドウが持っている、すべての特性および要素のことを知っています。 一方、後者のものはそれらのことを知りません。 
参考: Carbon.AE 
:モジュール 
Apple Eventディスクリプタ型としてコードされたPython定義. 
Macintosh上でのプロセス間通信に関する情報 
aetools モジュールは Python で AppleScript クライアントとしての機能をサポートするアプリケーションを構築するための基本的な機能を含んでいます。 
さらに、このモジュールは、 aetypes および aepack モジュールの中核機能をインポートし再 エクスポートします。 
gensuitemodule によって生成されたスタブパッケージは aetools のかなり適切な部分をインポートするので、通常はそれを明示的にインポートする必要はありません。 
生成されたパッケージ群を使用することができない場合と、スクリプト対応のためにより低いレベルのアクセスを必要としている場合、例外が発生します。 aetools モジュールはそれ自身、Carbon.AE モジュールによって提供される AppleEvent サポートを利用します。 
このモジュールにはウィンドウマネージャへのアクセスを必要とするという1つの欠点があります。 詳細は第 1.1.2 章を見てください。 
この制限は将来のリリースで撤廃されるかもしれません。 aetools モジュールは下記の関数を定義しています。 
あらかじめ作成された Carbon.AE.AEDesc オブジェクト中のパラメーターおよび属性を保存します。 parameters と attributes はPython オブジェクトの4文字の OSA パラメータのキーを写像した辞書です。 
このオブジェクトをパックするには aepack.pack() を使います。 
再帰的に、Carbon.AE.AEDesc イベントをPython オブジェクトへアンパックします。 
関数は引数の辞書および属性の辞書を返します。 formodulename 引数は AppleScript クラスをどこに捜しに行くか制御するために、生成されたスタブパッケージにより使用されます。 
Python キーワード引数辞書 arguments を、写像による4文字の OSA キーとして keydict の中で指定されたPython 識別子であるキーの交換により packevent によって要求されるフォーマットへ変換します。 
生成されたパッケージ群によって使用されます。 
aetools モジュールは次のクラスを定義しています。 
クラスTalkTo 
timeout を明示的に設定する事で、 AppleEvent の返答を待つデフォルトのタイムアウト時間を変更する事ができます。 _start 
アプリケーションが起動していてるか確認し、起動していなければ起動しようとします。 
OSA指示子 code, subcode (いずれも通常4文字の文字列です)を持った変数のために、parameters をパックし、attributesに戻し、目標アプリケーションにそれを送って、返答を待ち、unpackevent を含んだ返答をアンパックし、AppleEvent の返答を返し、辞書としてアンパックした値と属性を返して、AppleEvent Carbon.AE.AEDesc を作成します。 
aetypes では、 Apple Event データデスクリプタ(data descriptor) や Apple Eventオブジェクト指定子(object specifier) を表現するクラスを定義しています。 Apple Event データはデスクリプタに含まれていて、これらのデスクリプタは片付けされています。 
多くのデスクリプタは、単に対応するPython の型で表現されています。 例えば、OSA 中の typeText は Python 文字列型で、typeFloat は 浮動小数点型になる、といった具合です。 
このモジュールでは、OSA の型のうち、直接的に対応する Python の型がないもののためにクラスを定義しています。 
そのようなクラスのインスタンスに対するパックやアンパック操作は、 aepack モジュール自動的に処理します。 オブジェクト指定子は、本質的には Apple Event サーバ中に実装されているオブジェクトへのアドレスです。 
クラスUnknown 
aepack や aetypes がサポートしていない OSA のデスクリプタデータ、すなわち、このモジュールで扱っている他のクラスや、Python の組み込み型の値で表現されていないようなデータを表現するクラスです。 
クラスEnum 
列挙値 (enumeration value) を表すクラスです。 値は 4 文字の文字列型になります。 
クラスInsertionLoc 
オブジェクト of の中の pos の位置を表すクラスです。 
クラスBoolean 
ブール値 (真偽値) を表すクラスです。 
クラスStyledText 
スタイル情報 (フォント、タイプフェイスなど) つきのテキストを表すクラスです。 
クラスAEText 
スクリプトシステム (script system) およびスタイル情報の入ったテキストを表すクラスです。 
クラスIntlText 
スクリプトシステムと言語情報 (language information) の入ったテキストを表すクラスです。 
クラスIntlWritingCode 
スクリプトシステムと言語情報を表すクラスです。 
クラスQDPoint 
QuickDrawの点を表すクラスです。 
クラスQDRectangle 
QuickDrawの矩形を表すクラスです。 
クラスRGBColor 
色を表すクラスです。 
クラスType 
OSA の型 (type value) を表すクラスです。 4 文字からなる名前を値に持ちます。 
クラスKeyword 
OSA のキーワードです。 
4 文字からなる名前を値に持ちます。 クラスRange 
範囲を表すクラスです。 
クラスOrdinal 
先頭を表す "firs" や中央を表す"midd" のように、数値でない絶対位置指定子を表すクラスです。 
クラスLogical 
演算子 logc をterm に適用したときの論理式を表すクラスです。 
クラスComparison 
obj1 と obj2 の relo による比較を表すクラスです。 
以下のクラスは、生成されたスタブパッケージが、AppleScript のクラスやプロパティを Python で表現する上で基底クラスとして利用します。 
クラスComponentItem 
OSA クラス用の抽象基底クラスです。 
サブクラスでは、クラス属性want を 4 文字の OSA クラスコードに設定せねばなりません。 
このクラスのサブクラスのインスタンスは AppleScript オブジェクト指定子と同じになります。 
インスタンス化を行う最には、which にセレクタを渡さねばなりません。 また、任意で親オブジェクトをfr に渡せます。 
クラスNProperty 
OSA プロパティ用の抽象基底クラスです。 
サブクラスでは、クラス属性want と which を設定して、どのプロパティを表しているかを指定せねばなりません。 
このクラスのサブクラスのインスタンスはオブジェクト指定子と同じになります。 
クラスObjectSpecifier 
ComponentItem と NProperty の基底クラスで、汎用の OSA オブジェクト指定子を表します。 
パラメタの説明はApple Open Scripting Architecture のドキュメントを参照してください。 
このクラスは抽象クラスではないので注意してください。 
このモジュールはAIFFとAIFF-Cファイルの読み書きをサポートします。 
AIFF(Audio Interchange File Format)はデジタルオーディオサンプルをファイルに保存するためのフォーマットです。 
AIFF-CはAIFFの新しいバージョンで、オーディオデータの圧縮に対応しています。 
チャンネル数は、モノラル、ステレオ、4チャンネルかどうかを示します。 
フレームはそれぞれ、チャンネルごとに一つのサンプルからなります。 
サンプルサイズは、一つのサンプルの大きさをバイト数で示したものです。 
したがって、一つのフレームはnchannels*samplesizeバイトからなり、1秒間ではnchannels*samplesize*framerateバイトで構成されます。 例えば、CD品質のオーディオは2バイト(16ビット)のサンプルサイズを持っていて、2チャンネル(ステレオ)であり、44,100フレーム/秒のフレームレートを持っています。 
そのため、フレームサイズは4バイト(2*2)で、1秒間では2*2*44100バイト(176,400バイト)になります。 aifcモジュールは以下の関数を定義しています: 
AIFFあるいはAIFF-Cファイルを開き、後述するメソッドを持つインスタンスを返します。 
引数fileはファイルを示す文字列か、ファイルオブジェクトのいずれかです。 modeは、読み込み用に開くときには'r'か'rb'のどちらかで、書き込み用に開くときには'w'か'wb'のどちらかでなければなりません。 
もし省略されたら、 
file.modeが存在すればそれが使用され、なければ'rb'が使われます。 
書き込み用にこのメソッドを使用するときには、これから全部でどれだけのサンプル数を書き込むのか分からなかったり、writeframesraw()とsetnframes()を使わないなら、ファイルオブジェクトはシーク可能でなければなりません。 
ファイルがopen()によって読み込み用に開かれたときに返されるオブジェクトには、以下のメソッドがあります: 
オーディオチャンネル数(モノラルなら1、ステレオなら2)を返します。 
サンプルサイズをバイト数で返します。 
サンプリングレート(1秒あたりのオーディオフレーム数)を返します。 
ファイルの中のオーディオフレーム数を返します。 
オーディオファイルで使用されている圧縮形式を示す4文字の文字列を返します。 
AIFFファイルでは'NONE'が返されます。 
オーディオファイルの圧縮形式を人に判読可能な形にしたものを返します。 
AIFFファイルでは'not compressed'が返されます。 
以上の全ての値を上の順に並べたタプルを返します。 
オーディオファイルのマーカーのリストを返します。 
一つのマーカーは三つの要素のタプルです。 
要素の1番目はマークID(整数)、2番目はマーク位置のフレーム数をデータの始めから数えた値(整数)、3番目はマークの名称(文字列)です。 
与えられたidのマークの要素をgetmarkers()で述べたタプルで返します。 
オーディオファイルの次のnframes個のフレームを読み込んで返します。 
返されるデータは、全チャンネルの圧縮されていないサンプルをフレームごとに文字列にしたものです。 
読み込むポインタをデータの始めに巻き戻します。 
次にreadframes()を使用すると、データの始めから読み込みます。 
指定したフレーム数の位置にポインタを設定します。 
現在のポインタのフレーム位置を返します。 
AIFFファイルを閉じます。 
このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。 
ファイルがopen()によって書き込み用に開かれたときに返されるオブジェクトには、readframes()とsetpos()を除く上述の全てのメソッドがあります。 
さらに以下のメソッドが定義されています。 
get*()メソッドは、対応するset*()を呼び出したあとでのみ呼び出し可能です。 
最初にwriteframes()あるいはwriteframesraw()を呼び出す前に、フレーム数を除く全てのパラメータが設定されていなければなりません。 
AIFFファイルを作ります。 
デフォルトではAIFF-Cファイルが作られますが、ファイル名が'.aiff'で終わっていればAIFFファイルが作られます。 
AIFF-Cファイルを作ります。 
オーディオファイルのチャンネル数を設定します。 
オーディオのサンプルサイズをバイト数で設定します。 
サンプリングレートを1秒あたりのフレーム数で設定します。 
オーディオファイルに書き込まれるフレーム数を設定します。 もしこのパラメータが設定されていなかったり正しくなかったら、ファイルはシークに対応していなければなりません。 
圧縮形式を設定します。 
もし設定しなければ、オーディオデータは圧縮されません。 
AIFFファイルは圧縮できません。 
変数nameは圧縮形式を人に判読可能にしたもので、変数typeは4文字の文字列でなければなりません。 
現在のところ、以下の圧縮形式がサポートされています:NONE, ULAW, ALAW, G722。 
上の全パラメータを一度に設定します。 
引数はそれぞれのパラメータからなるタプルです。 
つまり、setparams()の引数として、getparams()を呼び出した結果を使うことができます。 
指定したID(1以上)、位置、名称でマークを加えます。 
このメソッドは、close()の前ならいつでも呼び出すことができます。 
出力ファイルの現在の書き込み位置を返します。 
setmark()との組み合わせで使うと便利です。 
出力ファイルにデータを書き込みます。 
このメソッドは、オーディオファイルのパラメータを設定したあとでのみ呼び出し可能です。 
オーディオファイルのヘッダ情報が更新されないことを除いて、writeframes()と同じです。 
ファイルのヘッダ情報は、オーディオデータの実際のサイズを反映して更新されます。 
このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。 
このモジュールには、組み込みモジュール 
(上記参照)を使用するのに必要とされるシンボリック定数が定義されています。 定数の名前はCのincludeファイルaudioio.hで接頭辞"AL_"を除いたものと同じです。 
定義されている名前の完全なリストについてはモジュールのソースを参照してください。 
お勧めの使い方は以下の通りです: 
このモジュールを使うと、SGI IndyとIndigoワークステーションのオーディオ装置にアクセスできます。 
詳しくはIRIXのmanページのセクション3Aを参照してください。 
ここに書かれた関数が何をするかを理解するには、manページを読む必要があります!IRIXのリリース4.0.5より前のものでは使えない関数もあります。 
お使いのプラットフォームで特定の関数が使えるかどうか、マニュアルで確認してください。 
このモジュールで定義された関数とメソッドは全て、名前に"AL"の接頭辞を付けたCの関数と同義です。 Cのヘッダーファイルaudio.hのシンボル定数は標準モジュール 
に定義されています。 下記を参照してください。 
警告:オーディオライブラリの現在のバージョンは、不正な引数が渡されるとエラーステイタスが返るのではなく、coreを吐き出すことがあります。 
このモジュールには、以下の関数が定義されています: 
引数nameとdirectionは文字列です。 
省略可能な引数configは、newconfig()で返されるコンフィギュレーションオブジェクトです。 
返り値はaudio port objectです;オーディオポートオブジェクトのメソッドは下に書かれています。 
返り値は新しいaudio configuration objectです;オーディオコンフィギュレーションオブジェクトのメソッドは下に書かれています。 
引数deviceは整数です。 
返り値はALqueryparams()で返されるデータを含む整数のリストです。 
引数listはqueryparams()で返されるようなリストです;queryparams()を適切に(!)修正して使うことができます。 
引数listはqueryparams()で返されるようなリストです。 
20.1.1 コンフィギュレーションオブジェクト 
、および 
-- への汎用インタフェースです。 
これらのモジュールがどれもインストールされていない場合、 
モジュールの低速で単純な DBM 実装が使われます。 
データベースファイル filename を開き、対応するオブジェクトを返します。 データベースファイルがすでに存在する場合、 
オプションの mode 引数は、新たにデータベースを作成しなければならない場合に使われる Unix のファイルモードです。 
標準の値は 8 進数の0666 です (この値は現在有効な umask で修飾されます)。 
サポートされているモジュールのどれかによって送出されうる例外が収められるタプルで、先頭の要素は anydbm.error になっています -- anydbm.error が送出された場合、後者が使われます。 
open() によって返されたオブジェクトは辞書とほとんど同じ同じ機能をサポートします; キーとそれに対応付けられた値を記憶し、引き出し、削除することができ、has_key() およびkeys() メソッドを使うことができます。 
キーおよび値は常に文字列です。 
BSD db データベースインタフェース。 
標準の Unix データベースインタフェース。 
dbm インタフェースの移植性のある実装。 
dbm インタフェースに基づいた GNU データベースインタフェース。 
Python dbm インタフェース上に構築された汎用オブジェクト永続化機構。 
既存のデータベースがどの形式のデータベースか判定するユーティリティモジュール。 . 
このモジュールでは、基本的な値 (文字、整数、浮動小数点数) のアレイ(array、配列) を効率よく表現できるオブジェクト型を定義しています。 
アレイ 
はシーケンス (sequence) 型であり、中に入れるオブジェクトの型に制限があることを除けば、リストとまったく同じように振る舞います。 
オブジェクト生成時に一文字の型コード を用いて型を指定します。 
次の型コードが定義されています: 
型コード 
C の型 
Python の型 
最小サイズ (バイト単位) 
文字(str型) 
int型 
Unicode文字(unicode型) 
long型 
float型 
値の実際の表現はマシンアーキテクチャ (厳密に言うとCの実装) によって決まります。 
値の実際のサイズはitemsize 属性から得られます。 
Python の通常の整数型では C の unsigned (long) 整数の最大範囲を表せないため、'L'と'I' で表現されている要素に入る値は Pythonでは長整数として表されます。 このモジュールでは次の型を定義しています: 
それ以外の場合には、イテレーション可能オブジェクト initializer は新たに作成されたオブジェクトのextend()メソッドに渡されます。 
arrayの別名です。 
撤廃されました。 アレイオブジェクトでは、インデクス指定、スライス、連結および反復といった、通常のシーケンスの演算をサポートしています。 
アレイを作るときに使う型コード文字です。 
アレイの要素 1 つの内部表現に使われるバイト長です。 
値x の新たな要素をアレイの末尾に追加します。 
アレイの内容を記憶するために使っているバッファの、現在のメモリアドレスと要素数の入ったタプル(address, length) を返します。 
バイト単位で表したメモリバッファの大きさは 
array.buffer_info()[1] * array.itemsizeで計算できます。 
例えばioctl() 操作のような、メモリアドレスを必要とする低レベルな (そして、本質的に危険な) I/Oインタフェースを使って作業する場合に、ときどき便利です。 
アレイ自体が存在し、長さを変えるような演算を適用しない限り、有効な値を返します。 
注意:C やC++ で書いたコードからアレイオブジェクトを使う場合(buffer_info の情報を使う意味のある唯一の方法です) は、アレイオブジェクトでサポートしているバッファインタフェースを使う方がより理にかなっています。 
このメソッドは後方互換性のために保守されており、新しいコードでの使用は避けるべきです。 
バッファインタフェースの説明は 
Python/C APIリファレンスマニュアル 
アレイのすべての要素に対して「バイトスワップ」(リトルエンディアンとビッグエンディアンの変換) を行います。 
このメソッドは大きさが 1、2、4 および 8 バイトの値にのみをサポートしています。 他の型の値に使うとRuntimeError を送出します。 
異なるバイトオーダをもつ計算機で書かれたファイルからデータを読み込むときに役に立ちます。 
シーケンス中のx の出現回数を返します。 
iterable から要素を取り出し、アレイの末尾に要素を追加します。 
iterable が別のアレイ型である場合、二つのアレイは全く同じ型コードをでなければなりません。 それ以外の場合にはTypeError を送出します。 
iterable がアレイでない場合、アレイに値を追加できるような正しい型の要素からなるイテレーション可能オブジェクトでなければなりません。 バージョン 2.4 で 変更 された仕様:以前は他のアレイ型しか引数に指定できませんでした。 
ファイルオブジェクトf から (マシン依存のデータ形式そのままで)n 個の要素を読み出し、アレイの末尾に要素を追加します。 
n 個の要素を読めなかったときはEOFError を送出しますが、それまでに読み出せた値はアレイに追加されています。 
f は本当の組み込みファイルオブジェクトでなければなりません。 read()メソッドをもつ他の型では動作しません。 
リストから要素を追加します。 
型に関するエラーが発生した場合にアレイが変更されないことを除き、"for x in list: a.append(x)"と同じです。 
文字列から要素を追加します。 
文字列は、 (ファイルからfromfile() メソッドを使って値を読み込んだときのように)マシン依存のデータ形式で表された値の配列として解釈されます。 
指定した Unicode 文字列のデータを使ってアレイを拡張します。 
アレイ中でx が出現するインデクスのうち最小の値 i を返します。 
アレイ中の位置i の前に値x をもつ新しい要素を挿入します。 
i の値が負の場合、アレイの末尾からの相対位置として扱います。 
アレイからインデクスがi の要素を取り除いて返します。 
オプションの引数はデフォルトで-1 になっていて、最後の要素を取り除いて返すようになっています。 
リリース 1.5.1 で撤廃されました。 
fromfile()メソッドを使ってください。 
アレイ中のx のうち、最初に現れたものを取り除きます。 
アレイの要素の順番を逆にします。 
アレイのすべての要素をファイルオブジェクトfに(マシン依存のデータ形式そのままで)書き込みます。 
アレイを同じ要素を持つ普通のリストに変換します。 
アレイをマシン依存のデータアレイに変換し、文字列表現(tofile() メソッドによってファイルに書き込まれるものと同じバイト列) を返します。 
アレイを Unicode 文字列に変換します。 
アレイの型コードは 'u' でなければなりません。 それ以外の場合には ValueError を送出します。 
他の型のアレイから Unicode 文字列を得るには、"array.tostring().decode(enc)" を使ってください。 
リリース 1.5.1 で撤廃されました。 
tofile()メソッドを使ってください。 
ファイルオブジェクトfに、全ての要素を(マシン依存のデータ形式そのままで)書き込みます。 
アレイオブジェクトを表示したり文字列に変換したりすると、array(typecode, initializer) という形式で表現されます。 
アレイが空の場合、initializer の表示を省略します。 アレイが空でなければ、typecode が 'c' の場合には文字列に、それ以外の場合には数値のリストになります。 
関数array() をfrom array import array で import している限り、変換後の文字列に逆クォーテーション(``)を用いると元のアレイオブジェクトと同じデータ型と値を持つアレイに逆変換できることが保証されています。 
文字列表現の例を以下に示します: 
異なる種類のバイナリデータのパックおよびアンパック。 
遠隔手続き呼び出しシステムで使われる外部データ表現仕様 (External DataRepresentation, XDR) のデータのパックおよびアンパック。 . 
Numeric Python 拡張モジュール (NumPy) では、別の方法でシーケンス型を定義しています。 
Numerical Python に関する詳しい情報はhttp://numpy.sourceforge.net/を参照してください。 (NumPy マニュアルの PDF バージョンはhttp://numpy.sourceforge.net/numdoc/numdoc.pdfで手に入ります。 
11.25.1 asyncoreの例:簡単なHTTPクライアント 
asynchat を使うと、 
は同じ非同期ループを使用しており、asyncore.dispatcherもasynchat.async_chatも同じチャネルマップに登録する事ができます。 
通常、asyncore.dispatcherはサーバチャネルとして使用し、リクエストの受け付け時にasynchat.async_chatオブジェクトを生成します。 
クラスasync_chat 
このクラスは、asyncore.dispatcherから継承した抽象クラスです。 
使用する際にはasync_chatのサブクラスを作成し、collect_incoming_data()とfound_terminator()を定義しなければなりません。 
asyncore.dispatcherのメソッドを使用する事もできますが、メッセージ/レスポンス処理を中心に行う場合には使えないメソッドもあります。 
asyncore.dispatcherと同様に、async_chatもselect()呼出し後のソケットの状態からイベントを生成します。 
ポーリングループ開始後、イベント処理フレームワークが自動的にasync_chatのメソッドを呼び出しますので、プログラマが処理を記述する必要はありません。 
asyncore.dispatcherと違い、async_chatではプロデューサの first-in-first-outキュー(fifo)を作成する事ができます。 
プロデューサはmore()メソッドを必ず持ち、このメソッドでチャネル上に送出するデータを返します。 
プロデューサが枯渇状態(i.e. これ以上のデータを持たない状態)にある場合、more()は空文字列を返します。 
この時、async_chatは枯渇状態にあるプロデューサをfifoから除去し、次のプロデューサが存在すればそのプロデューサを使用します。 
fifoにプロデューサが存在しない場合、handle_write()は何もしません。 
リモート端点からの入力の終了や重要な中断点を検出する場合は、set_terminator()に記述します。 async_chatのサブクラスでは、入力メソッドcollect_incoming_data()とfound_terminator()を定義し、チャネルが非同期に受信するデータを処理します。 
以下にメソッドの解説を示します。 
プロデューサfifoのトップにNoneをプッシュします。 
このプロデューサがポップされると、チャネルがクローズします。 
チャネルが受信した不定長のデータをdataに指定して呼び出されます。 このメソッドは必ずオーバライドする必要があり、デフォルトの実装では、NotImplementedError 例外を送出します。 
非常用のメソッドで、全ての入出力バッファとプロデューサfifoを廃棄します。 
入力データストリームが、set_terminatorで指定した終了条件と一致した場合に呼び出されます。 
このメソッドは必ずオーバライドする必要があり、デフォルトの実装では、NotImplementedError 例外を送出します。 
入力データを参照する必要がある場合でも引数としては与えられないため、入力バッファをインスタンス属性として参照しなければなりません。 
現在のチャネルの終了条件を返します。 
チャネル閉じた時に呼び出されます。 
デフォルトの実装では単にチャネルのソケットをクローズします。 
チャネルの非同期ループでreadイベントが発生した時に呼び出され、デフォルトの実装では、set_terminator()で設定された終了条件をチェックします。 
終了条件として、特定の文字列か受信文字数を指定する事ができます。 
終了条件が満たされている場合、handle_readは終了条件が成立するよりも前のデータを引数としてcollect_incoming_data()を呼び出し、その後found_terminator()を呼び出します。 
アプリケーションがデータを出力する時に呼び出され、デフォルトの実装ではinitiate_send()を呼び出します。 
initiate_send()ではrefill_buffer()を呼び出し、チャネルのプロデューサfifoからデータを取得します。 
dataを持つsimple_producer(後述)オブジェクトを生成し、チャネルのproducer_fifoにプッシュして転送します。 
データをチャネルに書き出すために必要なのはこれだけですが、データの暗号化やチャンク化などを行う場合には独自のプロデューサを使用する事もできます。 push_with_producer 
指定したプロデューサオブジェクトをチャネルのfifoに追加します。 
これより前にpushされたプロデューサが全て枯渇した後、チャネルはこのプロデューサからmore()メソッドでデータを取得し、リモート端点に送信します。 
select()ループでこのチャネルの読み込み可能チェックを行う場合には、Trueを返します。 
fifoの先頭にあるプロデューサのmore()メソッドを呼び出し、出力バッファを補充します。 
先頭のプロデューサが枯渇状態の場合にはfifoからポップされ、その次のプロデューサがアクティブになります。 アクティブなプロデューサがNoneになると、チャネルはクローズされます。 
チャネルで検出する終了条件を設定します。 termは入力プロトコルデータの処理方式によって以下の3つの型の何れかを指定します。 
入力ストリーム中でstringが検出された時、found_terminator()を呼び出します。 
指定された文字数が読み込まれた時、found_terminator()を呼び出します。 
永久にデータを読み込みます。 
終了条件が成立しても、その後に続くデータは、found_terminator()の呼出し後に再びチャネルを読み込めば取得する事ができます。 
Should return True as long as items remain on the producer fifo,or the channel is connected and the channel's output buffer is non-empty.プロデューサfifoが空ではないか、チャネルが接続中で出力バッファが空でない場合、Trueを返します。 
このモジュールは、非同期ソケットサービスのクライアント・サーバを開発するための基盤として使われます。 
CPUが一つしかない場合、プログラムが``二つのことを同時に''実行する方法は二つしかありません。 
もっとも簡単で一般的なのはマルチスレッドを利用する方法ですが、これとはまったく異なるテクニックで、一つのスレッドだけでマルチスレッドと同じような効果を得られるテクニックがあります。 このテクニックはI/O処理が中心である場合にのみ有効で、CPU負荷の高いプログラムでは効果が無く、この場合にはプリエンプティブなスケジューリングが可能なスレッドが有効でしょう。 
asyncoreは多くの複雑な問題を解決済みなので、洗練され、パフォーマンスにも優れたネットワークサーバとクライアントを簡単に開発することができます。 
とくに、 
のような、対話型のアプリケーションやプロトコルには非常に有効でしょう。 基本的には、この二つのモジュールを使う場合は一つ以上のネットワークチャネルをasyncore.dispatcherクラス、またはasynchat.async_chatのインスタンスとして作成します。 
作成されたチャネルはグローバルマップに登録され、loop()関数で参照されます。 loop()には、専用のマップを渡す事も可能です。 
チャネルを生成後、loop()を呼び出すとチャネル処理が開始し、最後のチャネル(非同期処理中にマップに追加されたチャネルを含む)が閉じるまで継続します。 
ポーリングループを開始し、count回が過ぎるか、全てのオープン済みチャネルがクローズされた場合のみ終了します。 
全ての引数はオプションです。 
引数countのデフォルト値はNoneで、ループは全てのチャネルがクローズされた場合のみ終了します。 
引数mapには、監視するチャネルをアイテムとして格納した辞書を指定します。 
mapが省略された場合、グローバルなマップが使用される。 
グローバルなマップは、チャネルクラスの__init__()メソッドが呼び出されたときに自動的に更新されます。 - この仕組みを利用するのであれば、チャネルクラスの__init__()はオーバライドするのではなく、拡張しなければなりません。 
クラスdispatcher 
dispatcherクラスは、低レベルソケットオブジェクトの薄いラッパーです。 便宜上、非同期ループから呼び出されるイベント処理メソッドを追加していますが、これ以外の点では、non-blockingなソケットと同様です。 
dispatcherクラスには二つのクラス属性があり、パフォーマンス向上やメモリの削減のために更新する事ができます。 
非同期入力バッファのサイズ(デフォルト 4096) 
非同期出力バッファのサイズ(デフォルト 4096) 
非同期ループ内で低レベルイベントが発生した場合、発生のタイミングやコネクションの状態から特定の高レベルイベントへと置き換えることができます。 
例えばソケットを他のホストに接続する場合、最初の書き込み可能イベントが発生すれば接続が完了した事が分かります(この時点で、ソケットへの書き込みは成功すると考えられる)。 
このように判定できる高レベルイベントを以下に示します: 
イベント 
解説 
最初にwriteイベントが発生した時 
読み込み可能なデータなしでreadイベントが発生した時 
listen中のソケットでreadイベントが発生した時 
非同期処理中、マップに登録されたチャネルのreadable()メソッドとwritable()メソッドが呼び出され、select()かpoll()でread/writeイベントを検出するリストに登録するか否かを判定します。 
このようにして、チャネルでは低レベルなソケットイベントの種類より多くの種類のイベントを検出する事ができます。 
以下にあげるイベントは、サブクラスでオーバライドすることが可能です: handle_read 
非同期ループで、チャネルのソケットのread()メソッドの呼び出しが成功した時に呼び出されます。 
非同期ループで、書き込み可能ソケットが実際に書き込み可能になった時に呼び出される。 
このメソッドは、パフォーマンスの向上のためバッファリングを行う場合などに利用できます。 
out of band (OOB)データが検出された時に呼び出されます。 
OOBはあまりサポートされておらず、また滅多に使われないので、handle_expt()が呼び出されることはほとんどありません。 
ソケットの接続が確立した時に呼び出されます。 ``welcome''バナーの送信、プロトコルネゴシエーションの初期化などを行います。 
ソケットが閉じた時に呼び出されます。 
捕捉されない例外が発生した時に呼び出されます。 
デフォルトでは、短縮したトレースバック情報が出力されます。 
listen中のチャネルがリモートホストからのconnect()で接続され、接続が確立した時に呼び出されます。 
非同期ループ中に呼び出され、readイベントの監視リストに加えるか否かを決定します。 
デフォルトのメソッドではTrueを返し、readイベントの発生を監視します。 
非同期ループ中に呼び出され、writeイベントの監視リストに加えるか否かを決定します。 
デフォルトのメソッドではTrueを返し、writeイベントの発生を監視します。 
さらに、チャネルにはソケットのメソッドとほぼ同じメソッドがあり、チャネルはソケットのメソッドの多くを委譲・拡張しており、ソケットとほぼ同じメソッドを持っています。 
引数も含め、通常のソケット生成と同じ。 
モジュールを参照のこと。 
通常のソケットオブジェクトと同様、addressには一番目の値が接続先ホスト、2番目の値がポート番号であるタプルを指定します。 
リモート側の端点にdataを送出します。 
リモート側の端点より、最大buffer_sizeバイトのデータを読み込みます。 長さ0の文字列が返ってきた場合、チャネルはリモートから切断された事を示します。 
ソケットへの接続を待つ。 
引数backlogは、キューイングできるコネクションの最大数を指定します(1以上)。 最大数はシステムに依存でします(通常は5) 
ソケットをaddressにバインドします。 
ソケットはバインド済みであってはなりません。 
接続を受け入れます。 
ソケットはアドレスにバインド済みであり、listen()で接続待ち状態でなければなりません。 
戻り値は(conn, address)のペアで、connはデータの送受信を行うソケットオブジェクト、addressは接続先ソケットがバインドされているアドレスです。 
ソケットをクローズします。 
以降の全ての操作は失敗します。 
リモート端点では、キューに溜まったデータ以外、これ以降のデータ受信は行えません。 
ソケットはガベージコレクト時に自動的にクローズされます。 
11.25.1 asyncoreの例:簡単なHTTPクライアント 
atexit モジュールでは、後始末関数を登録するための関数を一つだけ定義しています。 
注意: sys.exitfuncを設定する他のコードとともに使用した場合には、このモジュールは正しく動作しないでしょう。 
特に、他のコア Python モジュールでは、プログラマの意図を知らなくてもatexitを自由に使えます。 
sys.exitfunc を使っている人は、代わりにatexitを使うコードに変換してください。 
sys.exitfunc を設定するコードを変換するには、atexit をimport し、sys.exitfunc へ束縛されていた関数を登録するのが最も簡単です。 
終了時に実行される関数としてfuncを登録します。 
すべてのfuncへ渡すオプションの引数を、register()へ引数としてわたさなければなりません。 通常のプログラムの終了時、例えばsys.exit() が呼び出されるとき、あるいは、メインモジュールの実行が完了したときに、登録された全ての関数を、最後に登録されたものから順に呼び出します。 
通常、より低レベルのモジュールはより高レベルのモジュールより前に import されるので、後で後始末が行われるという仮定に基づいています。 終了ハンドラの実行中に例外が発生すると、(SystemExit以外の場合は)トレースバックを表示して、例外の情報を保存します。 
全ての終了ハンドラに動作するチャンスを与えた後に、最後に送出された例外を再送出します。 
:モジュール 
ヒストリファイルを読み書きするためのatexitの有用な例です。 
audioop モジュールは音声データを操作する関数を収録しています。 
このモジュールは、Python 文字列型中に入っている 8, 16, 32 ビットの符号付き整数でできた音声データ、すなわち 
で使われているのと同じ形式の音声データを操作します。 
特に指定の無いかぎり、スカラ量を表す要素はすべて整数型になっています。 このモジュールはu-LAWとIntel/DVI ADPCMエンコードをサポートしています。 
複雑な操作のうちいくつかはサンプル幅が 16 ビットのデータに対してのみ働きますが、それ以外は常にサンプル幅を操作のパラメタとして (バイト単位で) 渡します。 このモジュールでは以下の変数と関数を定義しています: 
この例外は、未知のサンプル当たりのバイト数を指定した時など、全般的なエラーに対して送出されます。 
パラメタに渡した 2 つのデータを加算した結果を返します。 widthはサンプル幅をバイトで表したもので、1、2、4のうちいずれかです。 
2 つのデータは同じサンプル幅でなければなりません。 
Intel/DVI ADPCM 形式のデータをリニア (linear) 形式にデコードします。 
ADPCM 符号化方式の詳細についてはlin2adpcm() の説明を参照して下さい。 (sample, newstate) からなるタプルを返し、サンプルはwidth に指定した幅になります。 
3 ビット符号を使う別の ADPCM で符号化されているデータをデコードします。 
詳しくはlin2adpcm3()を参照して下さい。 
データ中の全サンプルの平均値を返します。 
データ中の全サンプルの平均 peak-peak 振幅を返します。 フィルタリングを行っていない場合、このルーチンの有用性は疑問です。 
元データの各サンプルにバイアスを加えたデータを返します。 
引数に渡したデータ中のゼロ交差回数を返します。 
rms(add(fragment, mul(reference, -F))) を最小にするような係数F 、すなわち、reference に乗算したときにもっとも fragment に近くなるような値を返します。 fragmentとreference のサンプル幅はいずれも 2バイトでなければなりません。 
このルーチンの実行に要する時間はlen(fragment)に比例します。 
reference を可能な限り fragment に一致させようとします(fragment は reference より長くなければなりません)。 
この処理は (概念的には) fragment からスライスをいくつか取り出し、それぞれについてfindfactor() を使って最良な一致を計算し、誤差が最小の結果を選ぶことで実現します。 
fragmentとreferenceのサンプル幅は両方とも2バイトでなければなりません。 
(offset, factor) からなるタプルを返します。 offset は最適な一致箇所が始まるfragmentのオフセット値(整数)で、factorはfindfactor() の返す係数(浮動小数点数) です。 
fragment から、長さがlength サンプル (バイトではありません!)で最大のエネルギーを持つスライス、すなわち、rms(fragment[i*2:(i+length)*2]) を最大にするようなスライスを探し、 i を返します。 データのはサンプル幅は 2バイトでなければなりません。 
このルーチンの実行に要する時間はlen(fragment)に比例します。 
データ中のindex サンプル目の値を返します。 
サンプル幅を 1、2、4 バイト形式の間で変換します。 
データを 4 ビットの Intel/DVI ADPCM 符号化方式に変換します。 
ADPCM 符号化方式とは適応符号化方式の一つで、あるサンプルと(可変の) ステップだけ離れたその次のサンプルとの差を 4 ビットの整数で表現する方式です。 
Intel/DVI ADPCMアルゴリズムは IMA (国際MIDI協会) に採用されているので、おそらく標準になるはずです。 
state はエンコーダの内部状態が入ったタプルです。 
エンコーダは(adpcmfrag, newstate) のタプルを返し、次に lin2adpcm()を呼び出す時にnewstate を渡さねばなりません。 
最初に呼び出す時にはstateにNone を渡してもかまいません。 adpcmfrag は ADPCMで符号化されたデータで、バイト当たり 2 つの4ビット値がパックされています。 
サンプル当たり 3 ビットだけしか使わない別の ADPCM 符号化方式のエンコーダです。 Intel/DVI ADPCM 形式との互換性はなく、(作者の怠慢から) 出力はパックされていません。 
このエンコーダの使用は推奨しません。 
音声データの各サンプルを u-LAW 符号でエンコードし、Python文字列として返します。 
u-LAW とは音声符号化方式の一つで、約 14 ビットに相当するダイナミックレンジをわずか 8 ビットで実現できます。 
Sun やその他の音声ハードウェアで使われています。 
音声データ全サンプル中における最小値と最大値からなるタプルを返します。 
音声データ全サンプルの絶対値 の最大値を返します。 
音声データの最大 peak-peak 振幅を返します。 
元のデータの全サンプルに浮動小数点数factorを掛けたデータを返します。 
オーバフローが起きても例外を送出せず無視します。 
入力したデータのフレームレートを変換します。 
state は変換ルーチンの内部状態を入れたタプルです。 
変換ルーチンは(newfragment, newstate)を返し、次にratecv()を呼び出す時にはnewstateを渡さなねばなりません。 
最初の呼び出しではNoneを渡します。 引数weightAとweightB は単純なデジタルフィルタのパラメタで、デフォルト値はそれぞれ1 と0です。 
データ内のサンプルの順序を逆転し、変更されたデータを返します。 
データの自乗平均根 (root-mean-square) 、すなわち を返します。 
これはオーディオ信号の強度 (power) を測る一つの目安です。 
ステレオ音声データをモノラル音声データに変換します。 
左チャネルのデータに lfactor、右チャネルのデータに rfactorを掛けた後、二つのチャネルの値を加算して単一チャネルの信号を生成します。 
モノラル音声データをステレオ音声データに変換します。 
ステレオ音声データの各サンプル対は、モノラル音声データの各サンプルをそれぞれ左チャネルは lfactor 倍、右チャネルは rfactor 倍して生成します。 
u-LAW で符号化されている音声データを線形に符号化された音声データに変換します。 
u-LAW 符号化は常にサンプル当たり 8 ビットを使うため、width は出力音声データのサンプル幅にしか使われません。 
mul() やmax() といった操作はモノラルとステレオを区別しない、すなわち全てのデータを平等に扱うということに注意してください。 
この仕様が問題になるようなら、あらかじめステレオ音声データを二つのモノラル音声データに分割しておき、操作後に再度統合してください。 
そのような例を以下に示します: 
ADPCM エンコーダを使って音声データの入ったネットワークパケットを構築する際、自分のプロトコルを (パケットロスに耐えられるように)ステートレス (stateless) にしたいなら、データだけでなく状態変数 (state)も伝送せねばなりません。 
このとき、伝送するのはエンコード後状態(エンコーダの返す値) ではなく、エンコーダの初期状態 (lin2adpcm() に渡した値) initial なので注意してください。 
struct.struct()を使って状態変数をバイナリ形式で保存したいなら、最初の要素 (予測値) は 16 ビットで、次の値 (デルタ係数: delta index) は 8 ビットで符号化できます。 このモジュールの ADPCM 符号のテストは自分自身に対してのみ行っており、他の ADPCM 符号との間では行っていません。 
エコー除去を十分高速に行うには、出力サンプル中から最も大きなエネルギーを持った部分を取り出し、この部分が入力サンプル中のどこにあるかを調べ、入力サンプルから出力サンプル自体を減算します: 
def echocancel(outputdata, inputdata):pos = audioop.findmax(outputdata, 800) # 1/10秒out_test = outputdata[pos*2:]in_test = inputdata[pos*2:]ipos, factor = audioop.findfit(in_test, out_test)# Optional (for better cancellation):# factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)], # out_test)prefill = '\0'*(pos+ipos)*2postfill = '\0'*(len(inputdata)-len(prefill)-len(outputdata))outputdata = prefill + audioop.mul(outputdata,2,-factor) + postfillreturn audioop.add(inputdata, outputdata, 2) 
autoGILモジュールは、自動的にイベントループを実行する場合 、Python のグローバルインタープリタをロックしたり、ロックの解除をしたりするための関数 installAutoGIL を提供します。 
例えば現在のスレッドがループしていないなど、オブザーバにコールバックができない場合に発生します。 
現在のスレッドのイベントループ(CFRunLoop)中のオブザーバにコールバックを行ない、適切な時にグローバルインタープリタロック(GIL)を、イベントループが使用されていない間、他の Python スレッドの起動ができるようにロックしたり、ロックの解除をしたりします。 有効性:OSX 10.1以降 
このモジュールは、 RFC 3548 で定められた仕様によるデータの符号化 (エンコード、encoding) および復元 (デコード、decoding) を提供します。 
この RFC 標準では Base16, Base32 および Base64 が定義されており、これはバイナリ文字列とテキスト文字列とをエンコードあるいはデコードするためのアルゴリズムです。 変換されたテキスト文字列は email で確実に送信したり、URL の一部として使用したり、HTTP POST リクエストの一部に含めることができます。 
これらの符号化アルゴリズムは uuencode で使われているものとは別物です。 このモジュールでは 2つのインターフェイスが提供されています。 
現代的なインターフェイスは、これら 3種類のアルファベット集合を使った文字列オブジェクトのエンコードおよびデコードをすべてサポートします。 
一方、レガシーなインターフェイスは、文字列とともにファイル風のオブジェクトに対するエンコード / デコードを提供しますが、Base64 標準のアルファベット集合しか使いません。 
現代的なインターフェイスは以下のものを提供します: b64encode 
Base64 をつかって、文字列を エンコード (符号化) します。 
s はエンコードする文字列です。 
オプション引数 altchars は最低でも 2 の長さをもつ文字列で (これ以降の文字は無視されます)、これは + と / の代わりに使われる代替アルファベットを指定します。 
これにより、アプリケーションはたとえば URL やファイルシステムの影響をうけないBase64 文字列を生成することができます。 
デフォルトの値は None で、これは標準の Base64 アルファベット集合が使われることを意味します。 エンコードされた文字列が返されます。 
Base64 文字列をデコード (復元) します。 
s にはデコードする文字列を渡します。 
オプション引数の altchars は最低でも 2 の長さをもつ文字列で (これ以降の文字は無視されます)、これは + と / の代わりに使われる代替アルファベットを指定します。 
デコードされた文字列が返されます。 s が正しくパディングされていなかったり、規定のアルファベット以外の文字が含まれていた場合には TypeError が発生します。 
標準の Base64 アルファベット集合をもちいて文字列 s をエンコード (符号化) します。 
標準の Base64 アルファベット集合をもちいて文字列 s をデコード (復元) します。 
URL 用に安全なアルファベット集合をもちいて文字列 s をエンコード (符号化) します。 
これは、標準の Base64 アルファベット集合にある + のかわりに - を使い、/ のかわりに _ を使用します。 urlsafe_b64decode 
URL 用に安全なアルファベット集合をもちいて文字列 s をデコード (復元) します。 
これは、標準の Base64 アルファベット集合にある + のかわりに - を使い、/ のかわりに _ を使用します。 b32encode 
Base32 をつかって、文字列をエンコード (符号化) します。 
s にはエンコードする文字列を渡し、エンコードされた文字列が返されます。 
Base32 をつかって、文字列をデコード (復元) します。 
s にはエンコードする文字列を渡します。 
オプション引数 casefold は小文字のアルファベットを受けつけるかどうかを指定します。 
セキュリティ上の理由により、デフォルトではこれは False になっています。 
RFC 3548 は付加的なマッピングとして、数字の 0 (零) をアルファベットの O (オー) に、数字の 1 (壱) をアルファベットの I (アイ) または L (エル) に対応させることを許しています。 
オプション引数は map01 は、None でないときは、数字の 1 をどの文字に対応づけるかを指定します(map01 が None でないとき、数字の 0 はつねにアルファベットの O (オー) に対応づけられます)。 
セキュリティ上の理由により、これはデフォルトでは None になっているため、0 および 1 は入力として許可されていません。 デコードされた文字列が返されます。 
s にはエンコードする文字列を渡し、エンコードされた文字列が返されます。 
Base16 をつかって、文字列をデコード (復元) します。 
セキュリティ上の理由により、デフォルトではこれは False になっています。 デコードされた文字列が返されます。 
s が正しくパディングされていなかったり、規定のアルファベット以外の文字が含まれていた場合には TypeError が発生します。 
レガシーなインターフェイスは以下のものを提供します: 
input.read()が空文字列を返すまで読まれます。 
文字列sをデコードして結果のバイナリデータを返します。 sには一行以上のbase64形式でエンコードされたデータが含まれている必要があります。 
inputの中身をbase64形式でエンコードした結果をoutputに出力します。 input、outputともにファイルオブジェクトか、ファイルオブジェクトと同じインターフェースを持ったオブジェクトである必要があります。 
文字列s(任意のバイナリデータを含むことができます)をbase64形式でエンコードした結果の(1行以上の文字列)データを返します。 
encodestring()はエンコードされた一行以上のデータと改行文字('n')を出力します。 
ASCII からバイナリへ、バイナリからASCIIへの変換をサポートするモジュール。 
binascii モジュールにはバイナリと ASCIIコード化されたバイナリ表現との間の変換を行うための多数のメソッドが含まれています。 
通常、これらの関数を直接使う必要はなく、 
や 
uuencode された 1 行のデータ をバイナリに変換し、変換後のバイナリデータを返します。 
最後の行を除いて、通常 1 行には(バイナリデータで) 45 バイトが含まれます。 
入力データの先頭には空白文字が連続していてもかまいません。 
バイナリデータを uuencode して 1 行の ASCII 文字列に変換します。 戻り値は変換後の 1 行の文字列で、改行を含みます。 
data の長さは45 バイト以下でなければなりません。 
base64 でエンコードされたデータのブロックをバイナリに変換し、変換後のバイナリデータを返します。 
一度に 1 行以上のデータを与えてもかまいません。 
バイナリデータを base64 でエンコードして 1 行の ASCII 文字列に変換します。 戻り値は変換後の 1 行の文字列で、改行文字を含みます。 
base64 標準を遵守するためには、data の長さは 57 バイト以下でなくてはなりません。 a2b_qp 
quoted-printable 形式のデータをバイナリに変換し、バイナリデータを返します。 一度に 1 行以上のデータを渡すことができます。 
オプション引数 header が与えられており、かつその値が真であれば、アンダースコアは空白文字にデコードされます。 
バイナリデータを quoted-printable 形式でエンコードして 1 行から複数行のASCII 文字列に変換します。 
変換後の文字列を返します。 オプション引数 quptetabs が存在し、かつその値が真であれば、全てのタブおよび空白文字もエンコードされます。 
binhex4 形式の ASCII 文字列データを RLE 展開を行わないでバイナリに変換します。 
文字列はバイナリのバイトデータを完全に含むような長さか、または (binhex4 データの最後の部分の場合) 余白のビットがゼロになっていなければなりません。 
data に対し、binhex4 標準に従って RLE 展開を行います。 
このアルゴリズムでは、あるバイトの後ろに 0x90 がきた場合、そのバイトの反復を指示しており、さらにその後ろに反復カウントが続きます。 
カウントが 0 の場合 0x90 自体を示します。 
このルーチンは入力データの末端における反復指定が不完全でないかぎり解凍されたデータを返しますが、不完全な場合、例外Incomplete が送出されます。 
binhex4 方式の RLE 圧縮を data に対して行い、その結果を返します。 
バイナリを hexbin4 エンコードして ASCII 文字列に変換し、変換後の文字列を返します。 
引数の data はすでに RLE エンコードされていなければならず、その長さは (最後のフラグメントを除いて) 3 で割り切れなければなりません。 
data の binhex4 CRC 値を計算します。 
初期値は crc で、計算結果を返します。 crc32 
32 ビットチェックサムである CRC-32 を data に対して計算します。 初期値は crc です。 
これは ZIP ファイルのチェックサムと同じです。 
このアルゴリズムはチェックサムアルゴリズムとして設計されたもので、一般的なハッシュアルゴリズムには向きません。 
以下のようにして使います: 
バイナリデータ data の16進数表現を返します。 
data の各バイトは対応する 2 桁の16進数表現に変換されます。 
従って、変換結果の文字列はdata の 2 倍の長さになります。 
16 進数表記の文字列 hexstr の表すバイナリデータを返します。 
エラーが発生した際に送出される例外です。 
通常はプログラムのエラーです。 
変換するデータが不完全な場合に送出される例外です。 
通常はプログラムのエラーではなく、多少追加読み込みを行って再度変換を試みることで対処できます。 
参考: base64 
Machintosh で使われる binhex フォーマットのサポート。 
Unixで使われる UU エンコードのサポート。 
MIME 電子メールメッセージで使われる quoted-printable エンコードのサポート。 
このモジュールは binhex4 形式のファイルに対するエンコードやデコードを行います。 binhex4 は Macintosh のファイルを ASCIIで表現できるようにしたものです。 
ファイル名 input のバイナリファイルをファイル名 outputの binhex 形式ファイルに変換します。 
output パラメタはファイル名でも (write() および close() メソッドをサポートするような)ファイル様オブジェクトでもかまいません。 
以下の例外も定義されています: 
binhex 形式を使ってエンコードできなかった場合 (例えば、ファイル名が filename フィールドに収まらないくらい長かった場合など) や、入力が正しくエンコードされた binhex 形式のデータでなかった場合に送出される例外です。 
ASCIIからバイナリ、およびバイナリからASCII への変換をサポートするモジュール。 
このモジュールは、挿入の度にリストをソートすることなく、リストをソートされた順序に保つことをサポートします。 
大量の比較操作を伴うような、アイテムがたくさんあるリストでは、より一般的なアプローチに比べて、パフォーマンスが向上します。 
動作に基本的な二分法アルゴリズムを使っているので、bisect と呼ばれています。 
ソースコードはこのアルゴリズムの実例として一番役に立つかもしれません(境界条件はすでに正しいです!)。 次の関数が用意されています。 
ソートされた順序を保ったまま item を list に挿入するのに適した挿入点を探し当てます。 
リストの中から検索する部分集合を指定するには、パラメーターの lo とhi を使います。 デフォルトでは、リスト全体が使われます。 
item がすでに list に含まれている場合、挿入点はどのエントリーよりも前(左)になります。 
戻り値は、 
list.insert() の第一引数として使うのに適しています。 list はすでにソートされているものとします。 
バージョン 2.1 で 新たに追加 された仕様です。 
bisect_right() のエイリアス。 
item を list にソートされた順序で(ソートされたまま)挿入します。 
これは、 
list.insert(bisect.bisect_left(list, item, lo, hi), item)と同等です。 
list はすでにソートされているものとします。 バージョン 2.1 で 新たに追加 された仕様です。 
insort_left() と似ていますが、list に含まれる itemのうち、どのエントリーよりも後ろに item を挿入します。 バージョン 2.1 で 新たに追加 された仕様です。 
insort_right() のエイリアス。 
7.13.1 ハッシュ、BTree、およびレコードオブジェクト 
Unix, Windowsプラットフォームで利用できます。 
bsddb モジュールは Berkeley DB ライブラリへのインタフェースを提供します。 
ユーザは適当な open 呼び出しを使うことで、ハッシュ、B-Tree、 またはレコードに基づくデータベースファイルを生成することができます。 
bsddb オブジェクトは辞書と大体同じように振る舞います。 
新しいBerkeley DBインターフェースのドキュメントがあります。 新しいインターフェースは、BerkeleyDB 3と4でsleepycatが提供しているオブジェクト指向インターフェースとほぼ同じインターフェースとなっています。 
Sleepycat Software は、最新のBerkeley DBライブラリを開発しています。 
以下では、従来のbsddbモジュールと互換性のある、古いインターフェースを解説しています。 
現在の、Db と DbEnvによるオブジェクト指向的インターフェースについては上記 pybsddb のURLを参照してください。 bsddb モジュールでは、適切な形式の Berkeley DB ファイルにアクセスするオブジェクトを生成する以下の関数を定義しています。 
各関数の最初の二つの引数は同じです。 
可搬性のために、ほとんどのインスタンスでは最初の二つの引数だけが使われているはずです。 
filename と名づけられたハッシュ形式のファイルを開きます。 
filename に None を指定することで、ディスクに保存するつもりがないファイルを生成することもできます。 
オプションの flag には、ファイルを開くためのモードを指定します。 
このモードは"r" (読み出し専用), "w" (読み書き可能)、"c" (読み書き可能 - 必要ならファイルを生成 … これがデフォルトです) または"n" (読み書き可能 - ファイル長を 0 に切り詰め)、にすることができます。 
他の引数はほとんど使われることはなく、下位レベルのdbopen() 関数に渡されるだけです。 
他の引数の使い方およびその解釈については Berkeley DB のドキュメントを読んで下さい。 
filename と名づけられた B-Tree 形式のファイルを開きます。 
filename に None を指定することで、ディスクに保存するつもりがないファイルを生成することもできます。 
このモードは"r" (読み出し専用)、 "w" (読み書き可能)、"c" (読み書き可能 - 必要ならファイルを生成 … これがデフォルトです)、または"n" (読み書き可能 - ファイル長を 0 に切り詰め)、にすることができます。 
他の引数はほとんど使われることはなく、下位レベルのdbopen() 関数に渡されるだけです。 
他の引数の使い方およびその解釈については Berkeley DB のドキュメントを読んで下さい。 
他の引数はほとんど使われることはなく、下位レベルのdbopen() 関数に渡されるだけです、他の引数の使い方およびその解釈については Berkeley DB のドキュメントを読んで下さい。 
注意:2.3以降のUnix版Pythonには、bsddb185モジュールが存在する場合があります。 
このモジュールは古いBerkeley DB 1.85データベースライブラリを持つシステムをサポートするためだけに存在しています。 
新規に開発するコードでは、bsddb185を直接使用しないで下さい。 
bsddb への DBM 形式のインタフェース. 
7.13.1 ハッシュ、BTree、およびレコードオブジェクト 
このモジュールはPythonの全ての「組み込み」識別子を直接アクセスするためのものです。 
例えば __builtin__.open はopen()関数のための全ての組み込み関数を表示します。 
第2.1節, ``組み込み関数''も参照してください。 
BZ2File クラスは、readline(), readlines(),writelines(), seek() 等を含む、完全なファイルインタフェースを実装します。 
BZ2File クラスは seek() をエミュレーションでサポートします。 
BZ2File クラスは広範囲の改行文字バリエーションをサポートします。 
BZ2File クラスはファイルオブジェクトで言うところの先読みアルゴリズムを用いた行単位のイテレーション機能を提供します。 
BZ2Compressor およびBZ2Decompressor クラスでは逐次的圧縮(解凍)をサポートしています。 
compress() およびdecompress() では一括圧縮(解凍)を関数サポートしています。 
個別のロックメカニズムによってスレッド安全性を持っています。 
埋め込みドキュメントが完備しています。 
7.17.1 ファイルの圧縮(解凍) 
cPickle モジュールは Python オブジェクトの直列化および非直列化をサポートし、 
モジュールとほとんど同じインタフェースと機能を提供します。 
つまり、pickle 化や unpickle 化を行うカスタムのサブクラスを導出することができないということです。 
多くのアプリケーションではこの機能は不要なので、cPickleモジュールによる大きなパフォーマンス向上の恩恵を受けられるはずです。 pickle と cPickle で作られた pickle データ列は同じなので、既存の pickle データに対してpickle と cPickle を互換に使用することができます 
3.11 。 
cPickle と pickle の API 間には他にも些細な相違がありますが、ほとんどのアプリケーションで互換性があります。 
... を互換に使用することができます 3.11 
pickle データ形式は実際には小規模なスタック指向のプログラム言語であり、またあるオブジェクトをエンコードする際に多少の自由度があるため、二つのモジュールが同じ入力オブジェクトに対して異なるデータ列を生成することもあります。 
しかし、常に互いに他のデータ列を読み出せることが保証されています。 
cStringIO モジュールは 
モジュールと同様のインターフェースを提供しています。 
StringIO.StringIO オブジェクトを酷使する場合、 このモジュールにある StringIO() 関数をかわりに使うと効果的です。 このモジュールは、ビルトイン型のオブジェクトを返すファクトリー関数を提供しているので、サブクラス化して自分用の物を作ることはできません。 
そうした場合には、オリジナルの 
モジュールを使ってください。 
モジュールで実装されているメモリファイルとは異なり、このモジュールで提供されているものは、プレイン ASCII 文字列にエンコードできないユニコードを受け付けることができません。 
また、引数に文字列を指定してStringIO()呼び出すと読み出し専用のオブジェクトが生成されますが、この場合 cStringIO.StringIO() では write()メソッドを持たないオブジェクトを生成します。 
これらのオブジェクトは普段は見えません。 
トレースバックに StringI と StringO として表示されます。 次にあげるデータオブジェクトも提供されています: 
文字列をパラメーターに渡して StringIO を呼んだときに作られるオブジェクトのオブジェクト型。 
パラメーターを渡さすに StringIO を呼んだときに返されるオブジェクトのオブジェクト型。 
このモジュールには C API もあります。 詳しくはこのモジュールのソースを参照してください。 
このモジュールはUnixのcalプログラムのようなカレンダー出力を行い、それに加えてカレンダーに関する有益な関数群を提供します。 
標準ではこれらのカレンダーは(ヨーロッパの慣例に従って)月曜日を週の始まりとし、日曜日を最後の日としています。 
setfirstweekday()を用いることで、日曜日(6)や他の曜日を週の始まりに設定することができます。 
日付を表す引数は整数値で与えます。 このモジュールで提供する関数のほとんどは datetime に依存しており、過去も未来も現代のグレゴリオ暦を利用します。 
この方式はDershowitzとReingoldの書籍「Calendrical Calculations」にあるproleptic Gregorian暦に一致しており、同書では全ての計算の基礎となる暦としています。 
週の最初の曜日(0は月曜日, 6は日曜日)を設定します。 
定数MONDAY, TUESDAY,WEDNESDAY,THURSDAY, FRIDAY,SATURDAY及びSUNDAY は便宜上提供されています。 
例えば、日曜日を週の開始日に設定するとき: 
現在設定されている週の最初の曜日を返します。 バージョン 2.0 で 新たに追加 された仕様です。 
yearが閏年ならTrueを、そうでなければFalseを返します。 
ここでy1やy2は年を表します。 
バージョン 2.0 で 変更 された仕様:Python 1.5.2では、この関数は世紀をまたがった範囲では動作しません。 
year(1970-...), month (1-12),day(1-31)で与えられた日の曜日(0は月曜日)を返します。 
yearとmonthで指定された月の一日の曜日と日数を返します。 
月のカレンダーを行列で返します。 
各行が週を表し、月の範囲外の日は0になります。 それぞれの週はsetfirstweekday()で設定をしていない限り月曜日から始まります。 
month()関数によって返される月のカレンダーを出力します。 
月のカレンダーを複数行の文字列で返します。 
wにより日の列幅を変えることができ、それらはセンタリングされます。 
lにより各週の表示される行数を変えることができます。 
週の最初の曜日はsetfirstweekday()関数の設定に依存します。 バージョン 2.0 で 新たに追加 された仕様です。 
calendar()関数で返される一年間のカレンダーを出力します。 
3列からなる一年間のカレンダーを複数行の文字列で返します。 任意の引数w,l, 及びcはそれぞれ、日付列の表示幅、各週の行数及び月と月の間のスペースの数を変更するためのものです。 
週の最初の曜日はsetfirstweekday()関数の設定に依存します。 
出力されるカレンダーの起点となる年はプラットフォームに依存します。 バージョン 2.0 で 新たに追加 された仕様です。 
関連はありませんが便利な関数で、 
モジュールのgmtime()関数の戻値のような時間のタプルを受け取り、 1970年を起点とし、POSIX規格のエンコードによるUnixのタイムスタンプに相当する値を返します。 
実際、time.gmtime()とtimegm()は反対の動作をします。 バージョン 2.0 で 新たに追加 された仕様です。 
:モジュール 
モジュールと似た機能を持った日付と時間用のオブジェクト指向インタフェース。 
低レベルの時間に関連した関数群。 . 
CD-ROMデバイスをopen()で開き、createparser()でCDからデータをパースするためのパーザを作ります。 
open()で返されるオブジェクトはCDからデータを読み込むのに使われますが、CD-ROMデバイスのステータス情報や、CDの情報、たとえば目次などを得るのにも使われます。 
CDから得たデータはパーザに渡され、パーザはフレームをパースし、あらかじめ加えられたコールバック関数を呼び出します。 オーディオCDはトラックtracksあるいはプログラムprograms(同じ意味で、どちらかの用語が使われます)に分けられます。 
トラックはさらにインデックスindicesに分けられます。 
オーディオCDは、CD上の各トラックのスタート位置を示す目次table of contentsを持っています。 
インデックス0は普通、トラックの始まりの前のポーズです。 
目次から得られるトラックのスタート位置は通常、インデックス1のスタート位置です。 CD上の位置は2通りの方法で得ることができます。 
それはフレームナンバーと、分、秒、フレームの3つの値からなるタプルの2つです。 
ほとんどの関数は後者を使います。 
位置はCDの開始位置とトラックの開始位置の両方に相対的になります。 モジュールcdは、以下の関数と定数を定義しています: 
不透明なパーザオブジェクトを作って返します。 
パーザオブジェクトのメソッドは下に記載されています。 
絶対的なタイムコードである(minutes, seconds, frames)の3つ組の表現を、相当するCDのフレームナンバーに変換します。 
CD-ROMデバイスを開きます。 
不透明なプレーヤーオブジェクトを返します;プレーヤーオブジェクトのメソッドは下に記載されています。 
デバイスdeviceはSCSIデバイスファイルの名前で、例えば'/dev/scsi/sc0d4l0'あるいはNoneです。 
もし省略したり、Noneなら、ハードウエアが検索されてCD-ROMデバイスを割り当てます。 
modeは、省略しないなら'r'にすべきです。 
このモジュールでは以下の変数を定義しています: 
様々なエラーについて発生する例外です。 
オーディオデータの1フレームのサイズです。 
これはaudioタイプのコールバックへ渡されるオーディオデータのサイズです。 
オーディオデータが読み取られていないフレーム1つのサイズです。 
以下の変数はgetstatus()で返されるステータス情報です: 
オーディオCDがロードされて、ドライブが操作可能であることを示します。 
ドライブにCDがロードされていないことを示します。 
ドライブにCD-ROMがロードされていることを示します。 
続いてplayあるいはreadの操作をすると、I/Oエラーを返します。 
ディスクや目次を読み込もうとしているときに起こるエラー。 
ドライブがオーディオCDをCDプレーヤーモードでオーディオ端子から再生していることを示します。 
ドライブがCDプレーヤーモードで、再生を一時停止していることを示します。 
PAUSEDと同じですが、古いモデル(non 3301)であるToshiba CD-ROMドライブのものです。 
このドライブはもうSGIから出荷されていません。 
cfmfile は、コードフラグメントと関連する``cfrg''リソースを処理するモジュールです。 
このモジュールでコードフラグメントを分解やマージできて、全てのプラグインモジュールをまとめて、一つの実行可能ファイルにするため、BuildApplicationによって利用されます。 
ゲートウェイインタフェース規格 (CGI) に準拠したスクリプトをサポートするためのモジュールです。 
このモジュールでは、 Python で CGI スクリプトを書く際に使える様々なユーティリティを定義しています。 
11.2.1 はじめに 
11.2.10 よくある問題と解決法 
cgitb モジュールでは、Python スクリプトのための特殊な例外処理を提供します。 
(実はこの説明は少し的外れです。 
このモジュールはもともと徹底的なトレースバック情報を CGI スクリプトで生成した HTML 内に表示するための設計されました。 
その後この情報を平文テキストでも表示できるように一般化されています。 
)このモジュールの有効化後に捕捉されない例外が生じた場合、詳細で書式化された報告が Web ブラウザに送信されます。 
この報告には各レベルにおけるソースコードの抜粋が示されたトレースバックと、現在動作している関数の引数やローカルな変数が収められており、問題のデバッグを助けます。 
オプションとして、この情報をブラウザに送信する代わりにファイルに保存することもできます。 この機能を有効化するためには、単に自作の CGI スクリプトの最初に以下の一行を追加します: 
enable() 関数のオプションは、報告をブラウザに表示するかどうかと、後で解析するためにファイルに報告をログ記録するかどうかを制御します。 
この関数は、 
.excepthook を設定することで、インタプリタの標準の例外処理を cgitb モジュールに肩代わりさせるようにします。 
オプションの引数 display は標準で 1 になっており、この値は 0 にしてトレースバックをブラウザに送らないように抑制することもできます。 
その他の値を指定すると平文テキストの出力を強制します。 
デフォルトの値は "html" です。 
この関数は標準の設定 (ブラウザに報告を表示しますがファイルにはログを書き込みません) を使って例外を処理します。 この関数は、例外を捕捉した際に cgitb を使って報告したい場合に使うことができます。 
オプションの info 引数は、例外の型、例外の値、トレースバックオブジェクトからなる 3 要素のタプルでなければなりません。 これは 
.exc_info() によって返される値と全く同じです。 
info 引数が与えられていない場合、現在の例外は 
.exc_info() から取得されます。 
このモジュールはEA IFF 85チャンクを使用しているファイルの読み込みのためのインターフェースを提供します。 
このフォーマットは少なくとも、Audio 
Interchange File Format(AIFF/AIFF-C) とReal 
(RMFF)で使われています。 
WAVEオーディオファイルフォーマットも厳密に対応しているので、このモジュールで読み込みできます。 チャンクは以下の構造を持っています: 
Offset値 
長さ 
チャンクID 
big-endianで示したチャンクのサイズで、ヘッダは含みません 
バイトデータで、nはこれより先のフィールドのサイズ 
nが奇数ならチャンクの整頓のために埋められるバイト 
このモジュールで定義されるChunkクラスの使い方として提案しているのは、それぞれのチャンクの始めにインスタンスを作り、終わりに達するまでそのインスタンスから読み取り、その後で新しいインスタンスを作るということです。 ファイルの終わりで新しいインスタンスを作ろうとすると、EOFErrorの例外が発生して失敗します。 
クラスChunk 
チャンクを表現するクラス。 
引数fileはファイルのようなオブジェクトであることが想定されています。 
このクラスのインスタンスは特別にそのように認められています。 
必要とされるメソッドはread()だけです。 
もしseek()とtell()メソッドが呼び出されて例外を発生させなかったら、これらのメソッドも動作します。 
これらのメソッドが呼び出されて例外を発生させても、オブジェクトを変化させないようになっています。 
省略可能な引数alignがtrueなら、チャンクデータが偶数個で2バイトごとに整頓されていると想定します。 
もしalignがfalseなら、チャンクデータが奇数個になっていると想定します。 
デフォルト値はtrueです。 
もし省略可能な引数bigendianがfalseなら、チャンクサイズはlittle-endianであると想定します。 
この引数の設定はWAVEオーディオファイルで必要です。 デフォルト値はtrueです。 
もし省略可能な引数inclheaderがtrueなら、チャンクのヘッダから得られるサイズはヘッダのサイズを含んでいると想定します。 
デフォルト値はfalseです。 
Chunkオブジェクトには以下のメソッドが定義されています: 
チャンクの名前(ID)を返します。 
これはチャンクの始めの4バイトです。 
チャンクのサイズを返します。 
オブジェクトを閉じて、チャンクの終わりまで飛びます。 
これは元のファイル自体は閉じません。 
残りの以下のメソッドは、close()メソッドを呼び出した後に呼び出すと例外IOErrorを発生します。 
Falseを返します。 
チャンクの現在位置を設定します。 
引数whenceは省略可能で、デフォルト値は0(ファイルの絶対位置)です;他に1(現在位置から相対的にシークします)と2(ファイルの末尾から相対的にシークします)の値を取ります。 何も値は返しません。 
もし元のファイルがシークに対応していなければ、前方へのシークのみが可能です。 
チャンク内の現在位置を返します。 
チャンクから最大でsizeバイト(sizeバイトを読み込むまで、少なくともチャンクの最後に行き着くまで)読み込みます。 
もし引数sizeが負か省略されたら、チャンクの最後まで全てのデータを読み込みます。 
バイト値は文字列のオブジェクトとして返されます。 
チャンクの最後に行き着いたら、空文字列を返します。 
チャンクの最後まで飛びます。 
さらにチャンクのread()を呼び出すと、''が返されます。 
もしチャンクの内容に興味がないなら、このメソッドを呼び出してファイルポインタを次のチャンクの始めに設定します。 
...のインターフェースを提供します。 
このモジュールは常に利用できます。 
このモジュールでは、複素数を扱う数学関数へのアクセス手段を提供しています。 
提供している関数を以下に示します: 
x の逆双曲線余弦を返します。 branch cut が一つあり、1 の左側に実数軸に沿って -へと延びていて、上から連続しています。 
x の逆正弦を返します。 acos() と同じ branch cut を持ちます。 
x の余弦を返します。 
x の双曲線余弦を返します。 
baseを底とするx の対数を返します。 
もしbaseが指定されていない場合には、xの自然対数を返します。 
branch cut を一つもち、0 から負の実数軸に沿って -に延びており、上で連続しています。 バージョン 2.4 で 変更 された仕様:引数base が追加されました。 
x の底 10 対数を返します。 
log() と同じbranch cut を持ちます。 
x の正弦を返します。 
x の双曲線正弦を返します。 
x の平方根を返します。 
log() と同じ branch cut を持ちます。 
x の正接を返します。 
x の双曲線正接を返します。 
このモジュールではまた、以下の数学定数も定義しています: 
数学上の定数 pi で、実数です。 
数学上の定数 e で、実数です。 
と同じような関数が選ばれていますが、全く同じではないので注意してください。 
機能を二つのモジュールに分けているのは、複素数に興味がなかったり、もしかすると複素数とは何かすら知らないようなユーザがいるからです。 
これらは多くの複素関数における必然的な特性です。 
複素関数を計算する必要がある場合、これらの branch cut に関して理解しているものと仮定しています。 
悟りに至るために何らかの(到底基礎的とはいえない) 複素数に関する書をひもといてください。 
数値計算を目的とした branch cut の正しい選択方法についての情報としては、以下がよい参考文献となります: 
Cmdクラスでは、行指向のコマンドインタープリタを書くための簡単なフレームワークを提供します。 
テスト用の仕掛けや管理ツール、そして、後により洗練されたインターフェイスでラップするプロトタイプとして、こうしたインタープリタはよく役に立ちます。 
クラスCmd 
Cmdインスタンス、あるいはサブクラスのインスタンスは、行指向のインタープリタ・フレームワークです。 
名です。 デフォルトはTabです。 
completekeyがNoneでなく、readlineが利用できるならば、コマンド補完は自動的に行われます。 
オプション引数 stdinとstdoutには、Cmd またはそのサブクラスのインスタンスが入出力に使用するファイルオブジェクトを指定します。 
省略時にはsys.stdin と sys.stdout が使用されます。 
バージョン 2.3 で 変更 された仕様:引数 stdin と stdout を追加 
codeモジュールはread-eval-print(読み込み-評価-表示)ループをPythonで実装するための機能を提供します。 
対話的なインタプリタプロンプトを提供するアプリケーションを作るために使える二つのクラスと便利な関数が含まれています。 
クラスInteractiveInterpreter 
このクラスは構文解析とインタプリタ状態(ユーザの名前空間)を取り扱います。 
入力バッファリングやプロンプト出力、または入力ファイル指定を扱いません(ファイル名は常に明示的に渡されます)。 オプションのlocals引数はその中でコードが実行される辞書を指定します。 
その初期値は、キー'__name__'が'__console__'に設定され、キー'__doc__'がNoneに設定された新しく作られた辞書です。 クラスInteractiveConsole 
対話的なPythonインタプリタの振る舞いを厳密にエミュレートします。 
このクラスはInteractiveInterpreterを元に作られていて、通常のsys.ps1とsys.ps2をつかったプロンプト出力と入力バッファリングが追加されています。 
read-eval-printループを実行するための便利な関数。 
これはInteractiveConsoleの新しいインスタンスを作り、readfuncが与えられた場合はraw_input()メソッドとして使われるように設定します。 
localが与えられた場合は、インタプリタループのデフォルト名前空間として使うためにInteractiveConsoleコンストラクタへ渡されます。 
そして、インスタンスのinteract()メソッドは見出しとして使うために渡されるbannerを受け取り実行されます。 
コンソールオブジェクトは使われた後捨てられます。 
この関数はPythonのインタプリタメインループ(別名、read-eval-printループ)をエミュレートしようとするプログラムにとって役に立ちます。 
扱いにくい部分は、ユーザが(完全なコマンドや構文エラーではなく)さらにテキストを入力すれば完全になりうる不完全なコマンドを入力したときを決定することです。 
この関数はほとんどの場合に実際のインタプリタメインループと同じ決定を行います。 
コマンドが完全で構文エラーを含む場合は、SyntaxErrorを発生させます。 または、コマンドが無効なリテラルを含む場合は、OverflowErrorもしくはValueErrorを発生させます。 
codec 検索関数を登録します。 
検索関数は第 1 引数にアルファベットの小文字から成るエンコーディング名を取り、関数のタプル (encoder, decoder, stream_reader,stream_writer) を返すことになっています。 戻り値の関数が取る引数は以下の通りです。 
encoder と decoder: これらの引数は、Codec インスタンスのencode()とdecode() (Codec Interface 参照) と同じインタフェースを持つ関数、またはメソッドでなければなりません。 
これらの関数・メソッドは内部状態を持たずに動作する (stateless mode) と想定されています。 
stream_reader と stream_writer: これらの引数は、次のようなインタフェースを持つファクトリ関数でなければなりません: 
ファクトリ関数は、基底クラスの StreamWriter やStreamReader が定義しているインタフェースを提供するオブジェクトを返さねばなりません。 
Python codec レジストリから codec のタプルを探し、上で定義したような関数のタプルを返します。 encoding の検索は、まずにレジストリのキャッシュから行います。 
見つからなければ、登録されている検索関数のリストから探します。 
見つからなければ、LookupError を送出し、見つかれば codecのタプルをキャッシュに保存して、見つかったエンコーディングを呼び出し側に返します。 
さまざまな codec へのアクセスを簡便化するために、このモジュールは以下のような関数を提供しています。 これらの関数は、 codec の検索にlookup() を使います。 
encoding に指定した codec を検索し、エンコーダ関数を返します。 encoding が見つからなければ LookupError を送出します。 
encoding に指定した codec を検索し、デコーダ関数を返します。 encoding が見つからなければ LookupError を送出します。 
encoding に指定した codec を検索し、StreamReader クラス、またはファクトリ関数を返します。 encoding が見つからなければ LookupError を送出します。 
encoding に指定した codec を検索し、StreamWriter クラス、またはファクトリ関数を返します。 encoding が見つからなければ LookupError を送出します。 
エラー処理関数はこの例外を送出するか、別の例外を送出するか、または入力のエンコードができなかった部分の代替文字列とエンコードを再開する場所の指定が入ったタプルを返すかしなければなりません。 
最後の場合、エンコーダは代替文字列をエンコードし、元の入力中の指定位置からエンコードを再開します。 
位置を負の値にすると、入力文字列の末端からの相対位置として扱われます。 
境界の外側にある位置を返した場合にはIndexError が送出されます。 デコードと翻訳は同様に働きますが、エラー処理関数に渡されるのがUnicodeDecodeError かUnicodeTranslateError である点と、エラー処理関数の置換した内容が直接出力になる点が異なります。 
名前name で登録済みのエラー処理関数を返します。 
エラー処理関数が見つからなければ LookupError を送出します。 strict_errors 
strict エラー処理の実装です。 
replace エラー処理の実装です。 
ignore エラー処理の実装です。 
xmlcharrefreplace エラー処理の実装です。 
backslashreplace エラー処理の実装です。 
エンコードされたファイルやストリームの処理を簡便化するため、, このモジュールは次のようなユーティリティ関数を定義しています。 
mode でエンコードされたファイルを開き、 透過的にエンコード・デコードを行うようにラップしたファイルオブジェクトを返します。 
注意:ラップ版のファイルオブジェクトを操作する関数は、該当する codec が定義している形式のオブジェクトだけを受け付けます。 
多くの組み込み codec では Unicode オブジェクトです。 
関数の戻り値も codec に依存し、通常は Unicode オブジェクトです。 
encoding にはファイルのエンコーディングを指定します。 
errors を指定して、エラー処理を定義することもできます。 
デフォルトでは 'strict' で、エンコード時にエラーがあれば ValueError を送出します。 
buffering は、組み込み関数 open() と同じです。 
デフォルトでは行バッファリングです。 
ラップしたファイルオブジェクトを返します。 
このオブジェクトは透過なエンコード変換を提供します。 
ラップされたファイルに書かれた文字列は、input に指定したエンコーディングに従って変換され、output に指定したエンコーディングを使って string 型に変換され、ファイルに書き込まれます。 
中間エンコーディングは指定された codecs に依存しますが、普通は Unicode です。 output が与えられなければ、input がデフォルトになります。 
errors を与えて、エラー処理を定義することもできます。 
デフォルトでは 'strict' で、エンコード時にエラーがあれば ValueError を送出します。 
このモジュールは以下のような定数を定義しています。 プラットフォーム依存なファイルを読み書きするのに役立ちます。 
ここで定義された定数は、様々なエンコーディングの Unicode のバイトオーダマーカ (BOM) で、UTF-16 と UTF-32 におけるデータストリームやファイルストリームのバイトオーダを指定したり、UTF-8 における Unicode signature として使われます。 
4.9.1.3 StreamReader オブジェクト 
4.9.1.4 StreamReaderWriter オブジェクト 
4.9.1.5 StreamRecoder オブジェクト 
3.24 codeop --Pythonコードをコンパイルする 
モジュールで行われているようなPythonのread-eval-printループをエミュレートするユーティリティをcodeopモジュールは提供します。 
結果的に、直接モジュールを使いたいとは思わないかもしれません。 あなたのプログラムにこのようなループを含めたい場合は、代わりに 
モジュールを使うことをおそらく望むでしょう。 この仕事には二つの部分があります: 
入力の一行がPythonの文として完全であるかどうかを見分けられること: 簡単に言えば、次が`'か、あるいは`...'かどうかを見分けます。 
どのfuture文をユーザが入力したのかを覚えていること。 
Pythonコードの文字列であるべきsourceをコンパイルしてみて、sourceが有効なPythonコードの場合はコードオブジェクトを返します。 
このような場合、コードオブジェクトのファイル名属性は、デフォルトで'input'であるfilenameでしょう。 
sourceが有効なPythonコードではないが、有効なPythonコードの接頭語である場合には、Noneを返します。 
他のどんな値もValueErrorを発生させる原因となります。 
警告:ソースの終わりに達する前に、成功した結果をもってパーサは構文解析を止めることが(できそうではなく)できます。 このような場合、後ろに続く記号はエラーとならずに無視されます。 
例えば、改行が後ろに付くバックスラッシュには不定のゴミが付いているかもしれません。 
パーサのAPIがより良くなればすぐに、これは修正されるでしょう。 
クラスCompile 
このクラスのインスタンスは組み込み関数compile()とシグネチャが一致する__call__()メソッドを持っていますが、インスタンスが__future__文を含むプログラムテキストをコンパイルする場合は、インスタンスは有効なその文とともに続くすべてのプログラムテキストを'覚えていて'コンパイルするという違いがあります。 
クラスCommandCompiler ( 
このクラスのインスタンスはcompile_command()とシグネチャが一致する__call__()メソッドを持っています。 
インスタンスが__future__文を含むプログラムテキストをコンパイルする場合に、インスタンスは有効なその文とともにそれに続くすべてのプログラムテキストを'覚えていて'コンパイルするという違いがあります。 
バージョン間の互換性についての注意: CompileとCommandCompilerはPython 2.2で導入されました。 
2.2のfuture-tracking機能を有効にするだけでなく、2.1とPythonのより以前のバージョンとの互換性も保ちたい場合は、次のようにかくことができます 
これは影響の小さい変更ですが、あなたのプログラムにおそらく望まれないグローバル状態を導入します。 または、次のように書くこともできます: 
そして、新たなコンパイラオブジェクトが必要となるたびにCommandCompilerを呼び出します。 
このモジュールでは高性能なコンテナ・データ型を実装しています。 
現在のところ、実装されている型は deque のみです。 
将来的に B-tree と Fibonacci heap がふくまれるかもしれません。 
iterable で与えられるデータから、新しい deque オブジェクトを(append() をつかって) 左→右に初期化し、返します。 
iterable が指定されない場合、新しい deque オブジェクトは空になります。 Deque とは、スタックとキューを一般化したものです (この名前は「デック」と発音され、これは「double-ended queue」の省略形です)。 
Deque オブジェクトは以下のようなメソッドをサポートしています: 
x を deque の右側につけ加えます。 
x を deque の左側につけ加えます。 
Deque からすべての要素を削除し、長さを 0 にします。 
イテレータ化可能な引数 iterable から得られる要素を deque の右側に追加し拡張します。 
イテレータ化可能な引数 iterable から得られる要素を deque の左側に追加し拡張します。 
注意: 左から追加した結果は、イテレータ引数の順序とは逆になります。 
Deque の右側から要素をひとつ削除し、その要素を返します。 要素がひとつも存在しない場合は IndexError を発生させます。 
Deque の左側から要素をひとつ削除し、その要素を返します。 要素がひとつも存在しない場合は IndexError を発生させます。 
Deque の要素を全体で nステップだけ右にローテートします。 
n が負の値の場合は、左にローテートします。 
Deque をひとつ右にローテートすることは "d.appendleft(d.pop())" と同じです。 
colorsys モジュールは、計算機のディスプレイモニタで使われている RGB (Red Green Blue) 色空間で表された色と、他の3 種類の色座標系: YIQ, HLS (Hue Lightness Saturation: 色相、彩度、飽和) および HSV (Hue Saturation Value: 色相、彩度、明度) との間の双方向の色値変換を定義します。 
これらの色空間における色座標系は全て浮動小数点数で表されます。 
YIQ 空間では、Y 軸は 0 から 1 ですが、 I および Q 軸は正の値も負の値もとり得ます。 
RGB から YIQ に変換します。 
YIQ から RGB に変換します。 
RGB から HLS に変換します。 
HLS から RGB に変換します。 
RGB から HSV に変換します。 
HSV から RGB に変換します。 
サンプルコード: 
Unixプラットフォームで利用できます。 
文字列cmdをos.popen()を使いシェル上で実行し、タプル(status, output)を返します。 
実際には{ cmd ; } 21と実行されるため、標準出力とエラー出力が混合されます。 
また、出力の最後の改行文字は取り除かれます。 
コマンドの終了ステータスはC言語関数のwait()の規則に従って解釈することができます。 
getstatusoutput()に似ていますが、終了ステータスは無視され、コマンドの出力のみを返します。 
"ls -ld file "の出力を文字列で返します。 
例: 
このモジュールは、指定したディレクトリに含まれるPythonソースをコンパイルする関数を定義しています。 
dirで指定されたディレクトリを再帰的に下降し、見つかった.pyを全てコンパイルします。 
maxlevelsは、下降する最大の深さ(デフォルトは10)を指定します。 
ddirには、エラーメッセージで使用されるファイル名の、親ディレクトリ名を指定する事ができます。 
forceが真の場合、モジュールはファイルの更新日付に関わりなく再コンパイルされます。 
rxには、検索対象から除外するファイル名の正規表現式を指定します。 
sys.pathに含まれる、全ての.pyファイルをバイトコンパイルします。 
skip_curdirが真(デフォルト)の時、カレントディレクトリは検索されません。 
maxlevelsとforceはデフォルトでは0で、compile_dir()に渡されます。 
参考: py_compile 
compiler.ast モジュールは、各ノードのタイプとその要素を記述したテキストファイルからつくられます。 
各ノードのタイプはクラスとして表現され、そのクラスは抽象基底クラス compiler.ast.Node を継承し子ノードの名前属性を定義しています。 
クラスNode 
Node インスタンスはパーザジェネレータによって自動的に作成されます。 
ある特定の Node インスタンスに対する推奨されるインターフェイスとは、子ノードにアクセスするために public な (訳注: 公開された) 属性を使うことです。 
public な属性は単一のノード、あるいは一連のノードのシーケンスに束縛されている (訳注: バインドされている) かもしれませんが、これは Node のタイプによって違います。 
たとえば Class ノードの bases 属性は基底クラスのノードのリストに束縛されており、doc 属性は単一のノードのみに束縛されている、といった具合です。 各 Node インスタンスは lineno 属性をもっており、これは None かもしれません。 
XXX どういったノードが使用可能な lineno をもっているかの規則は定かではない。 
Node オブジェクトはすべて以下のメソッドをもっています: 
子ノードと子オブジェクトを、これらが出てきた順で、平らなリスト形式にして返します。 
とくにノードの順序は、 Python 文法中に現れるものと同じになっています。 
すべての子が Node インスタンスなわけではありません。 
たとえば関数名やクラス名といったものは、ただの文字列として表されます。 
子ノードをこれらが出てきた順で平らなリスト形式にして返します。 
このメソッドは getChildren() に似ていますが、Node インスタンスしか返さないという点で異なっています。 
Node クラスの一般的な構造を説明するため、以下に 2つの例を示します。 
while 文は以下のような文法規則により定義されています: 
While ノードは 3つの属性をもっています: test、body、 および else_ です。 
(ある属性にふさわしい名前がPython の予約語としてすでに使われているとき、その名前を属性名にすることはできません。 
If ノードでは、tests および else_ の2つだけの属性が定義されています。 
tests 属性には条件式とその後の動作のタプルがリスト形式で入っています。 
おのおのの if/elif 節ごとに1タプルです。 
各タプルの最初の要素は条件式で、2番目の要素はもしその式が真ならば実行されるコードをふくんだ Stmt ノードになっています。 
If の getChildren() メソッドは、子ノードの平らなリストを返します。 
if/elif 節が 3つあってelse 節がない場合なら、getChildren() は 6要素のリストを返すでしょう: 最初の条件式、最初の Stmt、2番目の条件式…といった具合です。 以下の表は compiler.ast で定義されている Node サブクラスと、それらのインスタンスに対して使用可能なパブリックな属性です。 
ほとんどの属性の値じたいは Node インスタンスか、インスタンスのリストです。 
この値がインスタンス型以外の場合、その型は備考の中で記されています。 
これら属性の順序は、getChildren() および getChildNodes() が返す順です。 
ノードの型 
左側の項 
右側の項 
項のリスト 
代入先をあらわす属性 
ドット(.) の左側の式 
属性名をあらわす文字列 
代入先のリスト要素のリスト 
代入先の名前 
代入先のタプル要素のリスト 
検査される条件式 
AssertionError の値 
代入先のリスト、代入記号(=)ごとにひとつ 
代入する値 
呼ばれる側をあらわす式 
引数のリスト 
*-arg 拡張引数の値 
**-arg 拡張引数の値 
クラス名をあらわす文字列 
基底クラスのリスト 
doc string、文字列あるいは None 
クラス文の本体 
関数のデコレータ表現のリスト 
Decorators か None 
引数をあわらす文字列のリスト 
デフォルト値のリスト 
関数の本体 
モジュール本体、Stmt インスタンス 
文のリスト 
このパッケージのトップレベルでは 4つの関数が定義されています。 
compiler モジュールを import すると、これらの関数およびこのパッケージに含まれている一連のモジュールが使用可能になります。 
buf 中の Python ソースコードから得られた抽象構文木 AST を返します。 ソースコード中にエラーがある場合、この関数は SyntaxError を発生させます。 
返り値は compiler.ast.Module インスタンスであり、この中に構文木が格納されています。 
path で指定されたファイル中の Python ソースコードから得られた抽象構文木 AST を返します。 
これは parse(open(path).read()) と等価な働きをします。 
ast に格納された抽象構文木の各ノードを先行順序 (pre-order) でたどっていきます。 
各ノードごとに visitor インスタンスの該当するメソッドが呼ばれます。 
文字列 source、Python モジュール、文あるいは式をexec 文あるいは eval() 関数で実行可能なバイトコードオブジェクトにコンパイルします。 
ファイル source をコンパイルし、.pyc ファイルを生成します。 
compiler パッケージは以下のモジュールを含んでいます: 
、 consts,、 future、misc、 pyassem、 pycodegen、 symbols、transformer、 そして 
。 
visitor パターンは ... 
パッケージは、Python のイントロスペクション機能を利用してvisitor のために必要な大部分のインフラを省略した、visitor パターンの変種を使っています。 visit されるクラスは、visitor を受け入れるようにプログラムされている必要はありません。 
visitor が必要なのはただそれがとくに興味あるクラスに対して visit メソッドを定義することだけです。 それ以外はデフォルトの visit メソッドが処理します。 
クラスASTVisitor 
ASTVisitor は構文木を正しい順序でわたり歩くようにします。 
それぞれのノードはまず preorder() の呼び出しではじまります。 
もしそのメソッドが存在している場合、それはそのノードを第一引数として呼び出されます。 ある特定のノード型に対する visitor メソッドでは、その子ノードをどのようにわたり歩くかが制御できます。 
ASTVisitor は visitor に visit メソッドを追加することで、その visitor 引数を修正します。 
特定のノード型に対する visitor が存在しない場合、 default() メソッドが呼び出されます。 
ASTVisitor オブジェクトには以下のようなメソッドがあります:XXX 追加の引数を記述 
cookielib モジュールは HTTP クッキーの自動処理をおこなうクラスを定義します。 
RFC 2109 のクッキーは Netscape クッキーとして解析され、のちにRFC 2965 として処理されます。 
cookielib はデファクトスタンダードのNetscape クッキープロトコル (これは元々 Netscape が策定した仕様とはかなり異なっています) に従うようになっており、RFC 2109 で導入された max-age や port などのクッキー属性にも注意を払います。 
この例外は FileCookieJar インスタンスがファイルからクッキーを読み込むのに失敗した場合に発生します。 
以下のクラスが提供されています: 
クラスCookieJar ( 
policy は CookiePolicy インターフェイスを実装するオブジェクトです。 
CookieJar クラスには HTTP クッキーを保管します。 
これは HTTP リクエストに応じてクッキーを取り出し、それをHTTP レスポンスの中で返します。 必要に応じて、CookieJar インスタンスは保管されているクッキーを自動的に破棄します。 
このサブクラスは、クッキーをファイルやデータベースに格納したり取り出したりする操作をおこなう役割を負っています。 
クラスFileCookieJar 
policy は CookiePolicy インターフェイスを実装するオブジェクトです。 
これ以外の引数については、該当する属性の説明を参照してください。 FileCookieJar はディスク上のファイルからのクッキーの読み込み、もしくは書き込みをサポートします。 
実際には、load() または revert() のどちらかのメソッドが呼ばれるまでクッキーは指定されたファイルからはロードされません。 このクラスのサブクラスは 11.20.2 節で説明します。 
クラスCookiePolicy 
このクラスは、あるクッキーをサーバから受け入れるべきか、そしてサーバに返すべきかを決定する役割を負っています。 
クラスDefaultCookiePolicy 
コンストラクタはキーワード引数しか取りません。 
blocked_domains はドメイン名からなるシーケンスで、ここからは決してクッキーを受けとらないし、このドメインにクッキーを返すこともありません。 allowed_domains が None でない場合、これはこのドメインのみからクッキーを受けとり、返すという指定になります。 
これ以外の引数についてはCookiePolicy および DefaultCookiePolicy オブジェクトの説明をごらんください。 
DefaultCookiePolicy は Netscape および RFC 2965 クッキーの標準的な許可 / 拒絶のルールを実装しています。 
RFC 2109 のクッキー(Set-Cookie: の version クッキー属性が 1 で受けとられるもの) はRFC 2965 のルールで扱われます。 
また DefaultCookiePolicy にはいくつかの細かいポリシー設定をおこなうパラメータが用意されています。 
クラスCookie 
このクラスは Netscape クッキー、RFC 2109 のクッキー、および RFC 2965 のクッキーを表現します。 
cookielib のユーザが自分で Cookie インスタンスを作成することは想定されていません。 
かわりに、必要に応じて CookieJar インスタンスのmake_cookies() を呼ぶことになっています。 
参考: urllib2 
HTTP のクッキークラスで、基本的にはサーバサイドのコードで有用です。 
cookielib および Cookie モジュールは互いに依存してはいません。 
このモジュールの拡張で、Windows 上の Microsoft Internet Explorer クッキーを読みこむクラスが含まれています。 
元祖 Netscape のクッキープロトコルの仕様です。 
今でもこれが主流のプロトコルですが、現在のメジャーなブラウザ (と cookielib) が実装している「Netscape クッキープロトコル」は cookie_spec.html で述べられているものとおおまかにしか似ていません。 
RFC 2965 によって過去の遺物になりました。 Set-Cookie: の version=1 で使います。 
Netscape プロトコルのバグを修正したものです。 
Set-Cookie: のかわりにSet-Cookie2: を使いますが、普及してはいません。 
RFC 2965 に対する未完の正誤表です。 
11.20.1 CookieJar および FileCookieJar オブジェクト 
このモジュールでは汎用の (浅い/深い) コピー操作を提供しています。 
以下にインタフェースをまとめます: 
このモジュール固有のエラーに対しては、copy.error が送出されます。 浅い (shallow) コピーと深い (deep) コピーの違いが関係するのは、複合オブジェクト (リストやクラスインスタンスのような他のオブジェクトを含むオブジェクト) だけです: 
浅いコピー (shallow copy) は新たな複合オブジェクトを作成し、その後 (可能な限り) 元のオブジェクト中に見つかったオブジェクトに対する参照 を挿入します。 
深いコピー (deep copy) は新たな複合オブジェクトを作成し、その後元のオブジェクト中に見つかったオブジェクトの コピーを挿入します。 
深いコピー操作には、しばしば浅いコピー操作の時には存在しない 2 つの問題がついてまわります: 
再帰的なオブジェクト (直接、間接に関わらず、自分自身に対する参照を持つ複合オブジェクト) は再帰ループを引き起こします。 
深いコピーでは、何もかも をコピーするため、例えば複数のコピー間で共有されるべき管理データ構造までも、余分にコピーしてしまいます。 
deepcopy() 関数では、これらの問題を以下のようにして回避しています: 
現在のコピー過程ですでにコピーされたオブジェクトからなる、 ``メモ'' 辞書を保持します; かつ 
ユーザ定義のクラスでコピー操作やコピーされる内容の集合を上書きできるようにします。 
現在のバージョンでは、モジュール、クラス、関数、メソッド、スタック追跡、スタック構造、ファイル、ソケット、ウィンドウ、アレイ、その他これらに類似の型をコピーしません。 クラスでは、pickle 化を制御するためのインタフェースと同じインタフェースをコピーの制御に使うことができます。 
これらのメソッドに関する情報は 
モジュールの記述を参照してください。 
copy モジュールはpickle 用関数登録モジュール 
copy_reg を使いません。 
クラス独自のコピー実装を定義するために、特殊メソッド __copy__()および __deepcopy__() を定義することができます。 
前者は浅いコピー操作を実装するために使われます; 追加の引数はありません。 
後者は深いコピー操作を実現するために呼び出されます; この関数には単一の引数としてメモ辞書が渡されます。 
__deepcopy__()の実装で、内容のオブジェクトに対して深いコピーを生成する必要がある場合、deepcopy() を呼び出し、最初の引数にそのオブジェクトを、メモ辞書を二つ目の引数に与えなければなりません。 
オブジェクト状態の取得と復元をサポートするために使われる特殊メソッドについて議論されています。 . 
copy_regモジュールは 
と 
モジュールに対するサポートを提供します。 
その上、 
モジュールは将来これをつかう可能性が高いです。 
クラスでないオブジェクトコンストラクタについての設定情報を提供します。 
このようなコンストラクタはファクトリ関数か、またはクラスインスタンスでしょう。 
objectを有効なコンストラクタであると宣言します。 
objectが呼び出し可能でなければ(そして、それゆえコンストラクタとして有効でないならば)、TypeErrorを発生します。 
functionが型typeのオブジェクトに対する``リダクション''関数として使うことを宣言します。 
typeは``標準的な''クラスオブジェクトであってはいけません。 
(標準的なクラスは異なった扱われ方をします。 詳細は、 
objectがクラスであるか、またはconstructorが呼び出し可能でない場合に、TypeErrorを発生します。 functionとconstructorの求められるインターフェイスについての詳細は、 
モジュールを参照してください。 
このモジュールは DES アルゴリズムに基づいた一方向ハッシュ関数である 
ルーチンを実装しています。 
詳細については Unix マニュアルページを参照してください。 
このモジュールは、Python スクリプトがユーザから入力されたパスワードを受理できるようにしたり、Unixパスワードに (脆弱性検査のための) 辞書攻撃を試みるのに使えます。 このモジュールは実行環境の 
の実装に依存しています。 
そのため、現在の実装で利用可能な拡張を、このモジュールでもそのまま利用できます。 
word は通常はユーザのパスワードで、プロンプトやグラフィカルインタフェースからタイプ入力されます。 salt は通常ランダムな2 文字からなる文字列で、DES アルゴリズムに 4096 通りのうち 1 つの方法で外乱を与えるために使われます。 
salt に使う文字は集合[./a-zA-Z0-9] の要素でなければなりません。 
ハッシュされたパスワードを文字列として返します。 パスワード文字列は salt と同じ文字集合に含まれる文字からなります (最初の2 文字は salt 自体です). いくつかの拡張された 
は異なる値とsalt の長さを許しているので、パスワードをチェックする際にはcrypt されたパスワード文字列全体をsaltとして渡すよう勧めます。 
典型的な使用例のサンプルコード: 
CSV (Comma Separated Values、カンマ区切り値列) と呼ばれる形式は、スプレッドシートやデータベース間でのデータのインポートやエクスポートにおける最も一般的な形式です。 
``CSV 標準'' は存在しないため、CSV 形式はデータを読み書きする多くのアプリケーション上の操作に応じて定義されているにすぎません。 
標準がないということは、異なるアプリケーションによって生成されたり取り込まれたりするデータ間では、しばしば微妙な違いが発生するということを意味します。 
こうした違いのために、複数のデータ源から得られた CSV ファイルを処理する作業が鬱陶しいものになることがあります。 
とはいえ、デリミタ (delimiter) やクオート文字の相違はあっても、全体的な形式は十分似通っているため、こうしたデータを効率的に操作し、データの読み書きにおける細々としたことをプログラマから隠蔽するような単一のモジュールを書くことは可能です。 csv モジュールでは、CSV 形式で書かれたテーブル状のデータを読み書きするためのクラスを実装しています。 
このモジュールを使うことで、プログラマは Excel で使われている CSV 形式に関して詳しい知識をもっていなくても、 ``このデータを Excel で推奨されている形式で書いてください'' とか、 ``データを Excel で作成されたこのファイルから読み出してください'' と言うことができます。 
プログラマはまた、他のアプリケーションが解釈できる CSV 形式を記述したり、独自の特殊な目的をもった CSV 形式を定義することができます。 csv モジュールの reader および writer オブジェクトはシーケンス型を読み書きします。 
プログラマはDictReader や DictWriter クラスを使うことで、データを辞書形式で読み書きすることもできます。 
注意:このバージョンの csv モジュールは Unicode 入力をサポートしていません。 
また、現在のところ、 ASCII NUL 文字に関連したいくつかの問題があります。 
従って、安全を期すには、全ての入力を一般的には印字可能なASCII にしなければなりません。 
これらの制限は将来取り去られることになっています。 
Python へのこのモジュールの追加を提案している Python 改良案 (PEP: Python Enhancement Proposal) 
6.18 curses.ascii -- ASCII 文字に関するユーティリティ 
6. 汎用オペレーティングシステムサービス 
6.18 curses.ascii --ASCII 文字に関するユーティリティ 
バージョン 1.6 で 新たに追加 された仕様です。 
curses.ascii モジュールでは、 ASCII 文字を指す名前定数と、様々な ASCII 文字区分についてある文字が帰属するかどうかを調べる関数を提供します。 
このモジュールで提供されている定数は以下の制御文字の名前です: 
NUL 空 
ヘディング開始、コンソール割り込み 
テキスト開始 
テキスト終了 
テキスト伝送終了 
問い合わせ、ACK フロー制御時に使用 
肯定応答 
ベル 
一文字後退 
タブ 
TAB の別名: ``水平タブ'' 
改行 
LF の別名: ``改行'' 
垂直タブ 
改頁 
復帰 
シフトアウト、他の文字セットの開始 
シフトイン、標準の文字セットに復帰 
データリンクでのエスケープ 
装置制御 1、フロー制御のための XON 
装置制御 2、ブロックモードフロー制御 
装置制御 3、フロー制御のための XOFF 
装置制御 4 
否定応答 
同期信号 
ブロック転送終了 
キャンセル 
媒体終端 
代入文字 
エスケープ文字 
ファイル区切り文字 
グループ区切り文字 
レコード区切り文字、ブロックモード終了子 
単位区切り文字 
空白文字 
削除 
これらの大部分は、最近は実際に定数の意味通りに使われることがほとんどないので注意してください。 
これらのニーモニック符号はデジタル計算機より前のテレプリンタにおける慣習から付けられたものです。 このモジュールでは、標準 C ライブラリの関数を雛型とする以下の関数をサポートしています: 
ASCII 英数文字かどうかを調べます; "isalpha(c) or isdigit(c)" と等価です。 
ASCII アルファベット文字かどうかを調べます; "isupper(c) or islower(c)" と等価です。 
文字が 7 ビット ASCII 文字に合致するかどうかを調べます。 
ASCII 余白文字かどうかを調べます。 
ASCII 制御文字 (0x00 から 0x1f の範囲) かどうかを調べます。 
ASCII 10 進数字、すなわち "0" から "9" までの文字かどうかを調べます。 
c in string.digits" と等価です。 
空白以外の ASCII 印字可能文字かどうかを調べます。 
ASCII 小文字かどうかを調べます。 
空白文字を含め、 ASCII 印字可能文字かどうかを調べます。 
空白または英数字以外の ASCII 印字可能文字かどうかを調べます。 
ASCII 余白文字、すなわち空白、改行、復帰、改頁、水平タブ、垂直タブかどうかを調べます。 
ASCII 大文字かどうかを調べます。 
ASCII 16 進数字かどうかを調べます。 
c in string.hexdigits" と等価です。 
ASCII 制御文字 (0 から 31 までの値) かどうかを調べます。 
非 ASCII 文字 (0x80 またはそれ以上の値) かどうかを調べます。 
これらの関数は数字も文字列も使えます; 引数を文字列にした場合、組み込み関数 ord() を使って変換されます。 これらの関数は全て、関数に渡した文字列の最初の文字から得られたビット値を調べるので注意してください; 関数はホスト計算機で使われている文字列エンコーディングについて何ら関知しません。 
文字列エンコーディングについて関知する (そして国際化に関するプロパティを正しく扱う) 関数については、 モジュール 
を参照してください。 以下の 2 つの関数は、引数として 1 文字の文字列または整数で表したバイト値のどちらでもとり得ます; これらの関数は引数と同じ型で値を返します。 
ASCII 値を返します。 c の下位 7 ビットに対応します。 
与えた文字に対応する制御文字を返します (0x1f とビット単位で論理積を取ります) 。 
与えた文字に対応する 8 ビット文字を返します (0x80 とビット単位で論理和を取ります) 。 
以下の関数は 1 文字からなる文字列値または整数値を引数に取り、文字列を返します。 
ASCII 文字 c の文字列表現を返します。 
もし c が印字可能文字であれば、返される文字列は c そのものになります。 
もし c が制御文字 (0x00-0x1f) であれば、キャレット ("^") と、その後ろに続く c に対応した大文字からなる文字列になります。 c が ASCII 削除文字 (0x7f)であれば、文字列は '^?' になります。 
c のメタビット(0x80) がセットされていれば、メタビットは取り去られ、前述のルールが適用され、"!" が前につけられます。 
0 (NUL) から 0x1f (US) までの 32 の ASCII 制御文字と、空白文字"SP" のニーモニック符号名からなる 33 要素の文字列によるシーケンスです。 
バージョン 1.6 で 変更 された仕様:ncurses ライブラリのサポートを追加し、パッケージに変換しました 
curses モジュールは、可搬性のある端末操作を行うためのデファクトスタンダードである、curses ライブラリへのインタフェースを提供します。 Unix 環境では curses は非常に広く用いられていますが、DOS、OS2、そしておそらく他のシステムのバージョンも利用することができます。 
この拡張モジュールは Linux および BSD 系の Unixで動作するオープンソースの curses ライブラリである ncurses の API に合致するように設計されています。 
ロケール設定に関わらず ASCII 文字を扱うためのユーティリティ。 
curses ウィンドウにデプス機能を追加するパネルスタック拡張。 
Emacs ライクなキーバインディングをサポートする編集可能な curses 用テキストウィジェット。 
アプリケーションの起動時および終了時に適切な端末のセットアップとリセットを確実に行うための関数。 . 
Andrew Kuchling および Eric Raymondによって書かれた、curses を Python で使うためのチュートリアルです。 Python Web サイトで入手できます。 
Python ソースコードの Demo/curses/ ディレクトリには、このモジュールで提供されている curses バインディングを使ったプログラム例がいくつか収められています。 
6.19 curses.panel -- curses のためのパネルスタック拡張 
6.19.1 関数 
パネルは深さ (depth) の機能が追加されたウィンドウです。 これにより、ウィンドウをお互いに重ね合わせることができ、各ウィンドウの可視部分だけが表示されます。 
パネルはスタック中に追加したり、スタック内で上下移動させたり、スタックから除去することができます。 
6.16 curses.textpad -- curses プログラムのためのテキスト入力ウィジェット 
6.16 curses.textpad --curses プログラムのためのテキスト入力ウィジェット 
curses.textpad モジュールでは、curses ウィンドウ内での基本的なテキスト編集を処理し、Emacs に似た (すなわち Netscape Navigator, BBedit 6.x, FrameMaker, その他諸々のプログラムとも似た) キーバインドをサポートしている Textbox クラスを提供します。 
このモジュールではまた、テキストボックスを枠で囲むなどの目的のために有用な、矩形描画関数を提供しています。 
curses.textpad モジュールでは以下の関数を定義しています: 
矩形を描画します。 
最初の引数はウィンドウオブジェクトでなければなりません; 残りの引数はそのウィンドウからの相対座標になります。 
2 番目および 3 番目の引数は描画すべき矩形の左上角の y および x座標です; 4 番目および 5 番目の引数は右下角の y および x 座標です。 矩形は、 VT100/IBM PC におけるフォーム文字を利用できる端末(xterm やその他のほとんどのソフトウェア端末エミュレータを含む)ではそれを使って描画されます。 
そうでなければ ASCII 文字のダッシュ、垂直バー、およびプラス記号で描画されます。 
6.17 curses.wrapper -- curses プログラムのための端末ハンドラ 
6.17 curses.wrapper --curses プログラムのための端末ハンドラ 
このモジュールでは関数 wrapper() 一つを提供しています。 これは curses 使用アプリケーションの残りの部分となるもう一つの関数です。 
アプリケーションが例外を送出した場合、wrapper() は例外を再送出してトレースバックを生成する前に端末を正常な状態に復元します。 
フック関数を呼び出す前に、 wrapper() は cbreak モードをオン、エコーをオフにし、端末キーパッドを有効にします。 端末がカラーをサポートしている場合にはカラーを初期化します。 
(通常終了も例外による終了も) 終了時には cooked モードに復元し、エコーをオンにし、端末キーパッドを無効化します。 
datetime モジュールでは、日付や時間データを簡単な方法と複雑な方法の両方で操作するためのクラスを提供しています。 
特定の数字がメートルか、マイルか、質量を表すかといったことがプログラムの問題であるように、naive な datetime オブジェクトが標準世界時 (UTC: CoordinatedUniversal time) を表現するか、ローカルの時刻を表現するか、ありは他のいずれかのタイムゾーンにおける時刻を表現するかは純粋にプログラムの問題となります。 
tzinfo オブジェクトは UTC 時刻からのオフセット、タイムゾーン名、夏時間が有効になっているかどうか、といった情報を記憶しています。 
datetime モジュールでは具体的な tsinfo クラスを提供していないので注意してください。 
必要な詳細仕様を備えたタイムゾーン機能を提供するのはアプリケーションの責任です。 
世界各国における時刻の修正に関する法則は合理的というよりも政治的なものであり、全てのアプリケーションに適した標準というものが存在しないのです。 datetime モジュールでは以下の定数を公開しています: 
date や datetime オブジェクトで許されている、年を表現する最小の数字です。 
MINYEAR は 1 です。 
date や datetime オブジェクトで許されている、年を表現する最大の数字です。 
MAXYEAR は 9999 です。 
汎用のカレンダー関連関数。 
時刻へのアクセスと変換。 
dbhash モジュールでは BSD db ライブラリを使ってデータベースを開くための関数を提供します。 
このモジュールは、 DBM 形式のデータベースへのアクセスを提供する他の Python データベースモジュールのインタフェースをそのまま反映しています。 
dbhash を使うには 
モジュールが必要です。 このモジュールでは一つの例外と一つの関数を提供しています: 
KeyError 以外のデータベースのエラーで送出されます。 
bsddb.error と同じ意味です。 
データベース db を開き、データベースオブジェクトを返します。 
オプションの mode 引数は、新たにデータベースを作成しなければならないときにデータベースファイルに設定すべき Unix ファイル権限ビットを表すために使われます; この値はプロセスの現在の umask 値でマスクされます。 
dbm 形式のデータベースへの汎用インタフェース。 
BSD db ライブラリへの低レベルインタフェース。 
既存のデータベースがどの形式のデータベースか判定するユーティリティモジュール。 
dbmモジュールはUnix(n)dbmインタフェースのライブラリを提供します。 dbmオブジェクトは、キーと値が必ず文字列である以外は辞書オブジェクトのようなふるまいをします。 
I/Oエラーのようなdbm特有のエラーが起ったときに上げられる値です。 また、正しくないキーが与えられた場合に通常のマッピングエラーのようなKeyErrorが上げられます。 
ndbmが使用している実装ライブラリ名です。 
dbmデータベースを開いてdbmオブジェクトを返します。 
存在するデータベースを読取り専用で開きます。 
(デフォルト) 'w' 
存在するデータベースを読み書き可能な状態で開きます。 
データベースを読み書き可能な状態で開きます。 
また、データベースが存在しない場合は新たに作成します。 'n' 
デフォルトでは8進数の0666です 
dbmスタイルの一般的なインタフェース. 
GNU GDBMライブラリの類似したインタフェース. 
存在しているデータベースの形式を決めるためのユーティリティモジュール. 
decimal モジュールは10 進の浮動小数点算術をサポートします。 
decimal には、 float() データ型に比べて、以下のような利点があります: 
10 進数を正確に表現できます。 
1.1 のような数は、2 進数の浮動小数点型では正しく表現できません。 エンドユーザは普通、2 進数における1.1 の近似値が1.1000000000000001 だからといって、そのように表示してほしいとは考えないものです。 
値の正確さは算術にも及びます。 
10 進の浮動小数点による計算では、"0.1 + 0.1 + 0.1 - 0.3" は厳密にゼロに等しくなります。 
2 進浮動小数点では5.5511151231257827e-017 になってしまいます。 
decimal モジュールでは、有効桁数の表記が取り入れられており、例えば "1.30 + 1.20" は 2.50 になります。 
すなわち、末尾のゼロは有効数字を示すために残されます。 
こうした仕様は通貨計算を行うアプリケーションでは慣例です。 
乗算の場合、「教科書的な」アプローチでは、乗算の被演算子すべての桁数を使います。 
例えば、"1.3 * 1.2" は 1.56 になり、"1.30 * 1.20" は 1.5600 になります。 
ハードウェアによる 2 進浮動小数点表現と違い、decimal モジュールでは計算精度をユーザが指定できます(デフォルトでは 28 桁です)。 この桁数はほとんどの問題解決に十分な大きさです: 
2 進と 10 進の浮動小数点は、いずれも広く公開されている標準仕様のもとに実装されています。 
組み込みの浮動小数点型では、標準仕様で提唱されている機能のほんのささやかな部分を利用できるにすぎませんが、 decimal では標準仕様が要求している全ての機能を利用できます。 必要に応じて、プログラマは値の丸めやシグナル処理を完全に制御できます。 
このモジュールは、 10 進数型、算術コンテキスト (context for arithmetic)、そしてシグナル (signal) という三つの概念を中心に設計されています、10 進数型は変更不可能な型です。 
この型には符号部、仮数部、そして指数部があります。 
有効桁数を残すために、仮数部の末尾にあるゼロの切り詰めは行われません。 
decimal では、Infinity, -Infinity, および NaN といった特殊な値も定義されています。 
丸め規則にはROUND_CEILING,ROUND_DOWN, ROUND_FLOOR, ROUND_HALF_DOWN,ROUND_HALF_EVEN, ROUND_HALF_UP, およびROUND_UP があります。 シグナルとは、演算の過程で生じる例外的条件です。 
個々のシグナルは、アプリケーションそれぞれの要求に従って、無視されたり、単なる情報とみなされたり、例外として扱われたりします。 
decimal モジュールには、Clamped, InvalidOperation,DivisionByZero, Inexact, Rounded,Subnormal, Overflow, および Underflowといったシグナルがあります。 各シグナルには、フラグとトラップイネーブラがあります。 
演算上何らかのシグナルに遭遇すると、フラグはゼロからインクリメントされてゆきます。 このとき、もしトラップイネーブラが 1 にセットされていれば、例外を送出します。 
フラグの値は膠着型 (sticky) なので、演算によるフラグの変化をモニタしたければ、予めフラグをリセットしておかねばなりません。 
IBM による汎用 10 進演算仕様、 
IEEE 標準化仕様 854-1987, 
IEEE 854 に関する非公式のテキスト 
。 
柔軟性のあるクラスで、ハッシュ化できる要素の連続であれば、どんな型のものであっても比較可能です。 
基礎的なアルゴリズムは可塑的なものであり、1980年代の後半に発表されたRatcliffとObershelpによるアルゴリズム、大げさに名づけられた``ゲシュタルトパターンマッチング''よりはもう少し良さそうなものです。 その考え方は、``junk''要素を含まない最も長いマッチ列を探すことです(RatcliffとObershelpのアルゴリズムではjunkを示しません)。 
このアイデアは、下位のマッチ列から左または右に伸びる列の断片に対して再帰的にあてはまります。 
これは小さな文字列に対して効率良いものではありませんが、人間の目からみて「良く見える」ようにマッチする傾向があります。 
タイミング: 基本的なRatcliff-Obershelpアルゴリズムは、予想の3乗、最悪の場合でも2乗となります。 SequenceMatcherオブジェクトは、最悪のケースに比べて4倍、予想される挙動は、シーケンスの中にどのくらいの要素があるのか(最良なのは一列の場合)、というややこしい状況に依存しています。 
テキスト行からなるシーケンスを比較するクラスです。 
コード 
列は文字列1にのみ存在する 
列は文字列2にのみ存在する 
列は両方の文字列で同一 
列は入力文字列のどちらにも存在しない 
'? 'で始まる列は線内の差異に注意を向けようとします。 その差異は、入力されたシーケンスのどちらにも存在しません。 
シーケンスがタブ文字を含むとき、これらのラインは判別しづらいものになることがあります。 
このクラスは、二つのテキストを左右に並べて比較表示し、行間あるいは行内の変更点を強調表示するような HTML テーブル (またはテーブルの入った完全な HTML ファイル) を生成するために使います。 
テーブルは完全差分モード、コンテキスト差分モードのいずれでも生成できます。 このクラスのコンストラクタは以下のようになっています: 
HtmlDiff のインスタンスを初期化します。 
tabsize はオプションのキーワード引数で、タブストップ幅を指定します。 デフォルトは 8 です。 
wrapcolumn はオプションのキーワード引数で、テキストを折り返すカラム幅を指定します。 デフォルトは None で折り返しを行いません。 
linejunk および charjunk はオプションのキーワード引数で、ndiff() (HtmlDiff はこの関数を使って左右のテキストの差分を HTML で生成します) に渡されます。 
それぞれの引数のデフォルト値および説明は ndiff() のドキュメントを参照してください。 
以下のメソッドが public になっています: 
fromlines と tolines (いずれも文字列のリスト) を比較し、行間または行内の変更点が強調表示された行差分の入った表を持つ完全な HTML ファイルを文字列で返します。 
fromdesc および todesc はオプションのキーワード引数で、差分表示テーブルにおけるそれぞれ差分元、差分先ファイルのカラムのヘッダになる文字列を指定します (いずれもデフォルト値は空文字列です)。 
context および numlines はともにオプションのキーワード引数です。 contest を True にするとコンテキスト差分を表示し、デフォルトの False にすると完全なファイル差分を表示します。 
context が False の場合、numlines は "next" と書かれたハイパーリンクをたどった時に到達する場所が次の変更部分より何行前にあるかを制御します(値をゼロにした場合、"next" ハイパーリンクを辿ると変更部分の強調表示がブラウザの最上部に表示されるようになります)。 
fromlines と tolines (いずれも文字列のリスト) を比較し、行間または行内の変更点が強調表示された行差分の入った完全な HTML テーブルを文字列で返します。 このメソッドの引数は、make_file() メソッドの引数と同じです。 
Tools/scripts/diff.py はこのクラスへのコマンドラインフロントエンドで、使い方を学ぶ上で格好の例題が入っています。 
a と b (文字列のリスト) を比較し、差異 (差異のある行を生成するジェネレータ) を、diff のコンテクスト形式で返します。 コンテクスト形式は、変更があった行に前後数行を加えてある、コンパクトな表現方法です。 
変更箇所は、変更前/変更後に分けて表します。 
行末に改行文字を持たない入力に対しては、出力でも改行文字を付加しないように lineterm 引数に "" を渡してください。 diff コンテクスト形式は、通常、ヘッダにファイル名と変更時刻を持っています。 
この情報は、文字列 fromfile、tofile、fromfiledate、tofiledate で指定できます。 変更時刻の書式は、通常、time.ctime() の戻り値と同じものを使います。 
指定しなかった場合のデフォルト値は、空文字列です。 
Tools/scripts/diff.py は、この関数のコマンドラインのフロントエンド(インターフェイス)になっています。 
possibilitiesはwordにマッチさせる(一般的には文字列)シーケンスのリストです。 
可能性のある、(少なくとも n に比べて)最もよいマッチはリストによって返され、同一性を表す数値に応じて最も近いものから順に格納されます。 
a と b (文字列からなるリスト)を比較し、Differ オブジェクト形式の差異(解析器は差異のある列)を返します。 オプションのパラメータ linejunk と charjunk は、filter機能のためのキーワードです(使わないときは空にする)。 
linejunk: string型の引数ひとつを受け取る関数で、文字列がjunkか否かによってtrueを(違うときにはtrueを)返します。 Python2.3以降、デフォルトでは(None)になります。 
charjunk: 長さ1の文字を受け取る関数です。 デフォルトでは、モジュールレべルの関数 IS_CHARACTER_JUNK()であり、これは空白文字列(空白またはタブ、注:改行文字をこれに含めるのは悪いアイデア!)をフィルタリングします。 
Tools/scripts/ndiff.py は、この関数のコマンドラインのフロントエンド(インターフェイス)です。 
差異を生成したシーケンスのひとつを返します。 
与えられるsequenceは Differ.compare() または ndiff()によって生成され、ファイル1または2(引数whichで指定される)によって元の列に復元され、行頭のプレフィクスが取りのぞかれます。 
例: diff = ndiff('one\ntwo\nthree\n'.splitlines(1),... 'ore\ntree\nemu\n'.splitlines(1)) diff = list(diff) # materialize the generated delta into a list print ''.join(restore(diff, 1)),onetwothree print ''.join(restore(diff, 2)),oretreeemu 
a と b (共に文字列のリスト) を比較し、diff の unified 形式で、差異 (差分行を生成するジェネレータ) を返します。 unified 形式は変更があった行に前後数行を加えた、コンパクトな表現方法です。 
変更箇所は (変更前/変更後を分離したブロックではなく) インライン・スタイルで表されます。 
行末に改行文字を持たない入力には、出力も同じように改行なしになるように、lineterm 引数を "" にセットしてくださいdiff コンテクスト形式は、通常、ヘッダにファイル名と変更時刻を持っています。 
Tools/scripts/diff.py は、この関数のコマンドラインのフロントエンド(インターフェイス)です。 
無視できる列のときtrueを返します。 
列 line が空白、または "#"" ひとつのときには無視できます。 それ以外の時には無視できません。 
ndiff() の引数linkjunkとしてデフォルトで使用されます。 ndiff()のlinejunkはPython 2.3以前のものです。 
無視できる文字のときtrueを返します。 
文字 ch が空白、またはタブ文字のときには無視できます。 それ以外の時には無視できません。 
ndiff() の引数charjunkとしてデフォルトで使用されます。 
Pattern Matching: The Gestalt Approach (パターンマッチング: 全体アプローチ) 
John W. Ratcliff と D. E. Metzener による同一性アルゴリズムに関する議論。 
1988年7月号掲載。 
os.listdir() によって得た path のディレクトリ一覧を返します。 
path を変えない限り、以降の listdir() を呼び出してもディレクトリ構造を読み込みなおすことはしないので注意してください。 
返されるリストは読み出し専用であると見なされるので注意してください(おそらく将来のバージョンではタプルを返すように変更されるはず ? です)。 
listdir() と同じです。 
以前のバージョンとの互換性のために定義されています。 
list を head の相対パスからなるリストとして、各パスがディレクトリを指す場合には "/" をパス名の後ろに追加したものに置き換えます。 
18.10.1 Pythonバイトコード命令 
disモジュールはPythonバイトコードを逆アセンブルしてバイトコードの解析を助けます。 
Pythonアセンブラがないため、このモジュールがPythonアセンブリ言語を定義しています。 
このモジュールが入力として受け取るPythonバイトコードはファイルInclude/opcode.hに定義されており、コンパイラとインタプリタが使用しています。 例: 関数myfuncを考えると: 
次のコマンドをmyfunc()の逆アセンブリを得るために使うことができます: 
(``2''は行番号です)。 disモジュールは次の関数と定数を定義します: 
bytesourceオブジェクトを逆アセンブルします。 
bytesourceはモジュール、クラス、関数、あるいはコードオブジェクトのいずれかを示します。 
モジュールに対しては、すべての関数を逆アセンブルします。 
クラスに対しては、すべてのメソッドを逆アセンブルします。 
単一のコードシーケンスに対しては、バイトコード命令ごとに一行をプリントします。 
オブジェクトが与えられない場合は、最後のトレースバックを逆アセンブルします。 
トレースバックのスタックの先頭の関数を逆アセンブルします。 Noneが渡された場合は最後のトレースバックを使います。 
例外を引き起こした命令が表示されます。 
コードオブジェクトを逆アセンブルします。 lastiが与えられた場合は、最後の命令を示します。 
出力は次のようなカラムに分割されます: 
各行の最初の命令に対する行番号。 
現在の命令。 "-"として示されます。 
命令のアドレス。 
演算コード名。 
演算パラメータ。 
括弧の中のパラメータのインタプリテーション。 
パラメータインタープリテーションはローカルおよびグルーバル変数名、定数値、分岐目標、そして比較演算子を認識します。 
disassembleの別名。 
よりタイプしやすく、以前のPythonリリースと互換性があります。 
演算名。 一連のバイトコードを使ってインデキシングできます。 
すべての比較演算名。 
定数腹メータを持つ一連のバイトコード。 
自由変数にアクセスする一連のバイトコード。 
名前によって属性にアクセスする一連のバイトコード。 
相対ジャンプターゲットをもつ一連のバイトコード。 
絶対ジャンプターゲットをもつ一連のバイトコード。 
ローカル変数にアクセスする一連のバイトコード。 
ブール演算の一連のバイトコード。 
18.10.1 Pythonバイトコード命令 
このモジュールはアーカイブファイル(tarやzip)を作成する関数を提供します。 
アーカイブファイル(例: zipやtar)を作成します。 
base_nameは作成するファイル名からフォーマットの拡張子を除いたものです。 formatはアーカイブのフォーマットでzip、tar、ztar、gztarのいずれかです。 
アーカイブファイル名を返します。 
警告:この関数はbz2ファイルを扱えるように変更されるべきです 
base_dir以下の全ファイルから、tarファイルを作成(オプションで圧縮)します。 compressは'gzip'、'compress'、'bzip2'、または Noneである必要があります。 
'tar'と圧縮ユーティリティ'compress'にはパスが通っている必要があるので、これはおそらくUnixだけで有効です。 
出力tarファイルは 
base_dir.tarという名前になり、圧縮によって拡張子がつきます(.gz、 .bz2 または.Z)。 
出力ファイル名が返ります。 
警告:これはtarfileモジュールの呼び出しに置換されるべきです。 
base_dir以下の全ファイルから、zipファイルを作成します。 
出力されるzipファイルはbase_dir + .zipという名前になります。 
zipfilePythonモジュール(利用可能なら)またはInfoZIP zipユーティリティ(インストールされていてパスが通っているなら)を使います。 
もしどちらも利用できなければ、DistutilsExecErrorが起きます。 
出力zipファイル名が返ります。 
このモジュールはBorlandCCompilerクラスを提供します。 抽象クラスCCompilerの具象クラスでBorland C++ コンパイラ向けです。 
このモジュールは CCompilerクラスの抽象ベースクラスを提供します。 
CCompilerのインスタンスはプロジェクトにおける全てのコンパイルおよびリンクに使われます。 
コンパイラのオプションを設定するためのメソッドが提供されます -- マクロ定義、includeディレクトリ、リンクパス、ライブラリなど。 このモジュールは以下の関数を提供します。 
ライブラリを探索するディレクトリ、特定のライブラリとのリンクをするためのリンカオプションを生成します。 libraries と library_dirs はそれぞれライブラリ名(ファイル名ではありません!)のリストと、探索ディレクトリのリストです。 
compilerで利用できるコマンドラインオプションのリスト(指定されたフォーマット文字列に依存します)を返します。 
Unix のコンパイラと、Visual C++で利用できるコマンドラインオプションのリストを返します。 
指定されたプラットフォームのデフォルトコンパイラを返します。 
問い合わせのosnameはPython標準のOS名(os.nameで返されるもの)のひとつであるべきで、platformはsys.platformで返される共通の値です。 
パラメータが指定されていない場合のデフォルト値はos.nameと sys.platformです。 
指定されたプラットフォーム/コンパイラの組み合わせ向けに、CCompilerサブクラスのインスタンスを生成するファクトリ関数です。 
plat のデフォルト値は os.name (例: 'posix', 'nt'), compiler)、compilerのデフォルト値はプラトフォームのデフォルトコンパイラです。 
現在は 'posix'と'nt'だけがサポートされています、デフォルトのコンパイラは``traditional Unix interface''(UnixCCompilerクラス) と、Visual C++(MSVCCompiler クラス) です。 
WindowsでUnixコンパイラオブジェクトを要求することも、UnixでMicrosoftコンパイラオブジェクトを要求することも可能です。 compiler引数を与えると platは無視されます。 
利用可能なコンパイラのリストを表示します(build,build_ext, build_clibの、--help-compilerオプションで使われます。 
) クラスCCompiler 
抽象ベースクラス CCompilerは実際のコンパイラクラスで実装される必要のあるインタフェースを定義しています。 
このクラスはコンパイラクラスで利用されるユーティリティメソッドも定義しています。 コンパイラ抽象クラスの基本的な前提は、各インスタンスはあるプロジェクトをビルドするときの全コンパイル/リンクで利用できるということです。 
そこで、コンパイルとリンクステップで共通する属性 -- インクルードディレクトリ、マクロ定義、リンクするライブラリ など -- はコンパイラインスタンスの属性になります。 
フラグは verbose(冗長な出力を表示します)、dry_run(実際にはそのステップを実行しません)、そしてforce(依存関係を無視して全て再ビルドします)です。 
これらのフラグは全てデフォルト値が0(無効)になっています。 
CCompilerまたはサブクラスを直接インスタンス化したくない場合には、かわりにdistutils.CCompiler.new_compiler()ファクトリ関数を利用してください。 以下のメソッドで、Compilerクラスのインスタンスが使うコンパイラオプションを手動で変更できます。 
dirをヘッダファイル探索ディレクトリのリストに追加します。 
コンパイラはadd_include_dir()を呼び出した順にディレクトリを探索するよう指定されます。 
探索されるディレクトリのリストを dirs (文字列のリスト)に設定します。 
先に実行された add_include_dir()は上書きされます。 後で実行するadd_include_dir()はset_include_dirs()のリストにディレクトリを追加します。 
これはコンパイラがデフォルトで探索する標準インクルードディレクトリには影響しません。 
libnameをコンパイラオブジェクトによるリンク時に使われるライブラリのリストに追加します。 
libnameはライブラリを含むファイル名ではなく、ライブラリそのものの名前です: 実際のファイル名はリンカ、コンパイラ、またはコンパイラクラス(プラットフォームに依存します)から推測されます。 リンカはadd_library()とset_library()で渡された順にライブラリをリンクしようとします。 
ライブラリ名が重なることは問題ありません。 リンカは指定された回数だけライブラリとリンクしようとします。 
コンパイラオブジェクトによるリンク時に使われるライブラリのリストを libnames(文字列のリスト)に設定します。 
これはリンカがデフォルトでリンクする標準のシステムライブラリには影響しません。 
add_library() と set_libraries()で指定されたライブラリを探索するディレクトリのリストにdirを追加します。 
リンカはadd_library_dir()と set_library_dirs()で指定された順にディレクトリを探索されます。 
ライブラリを探索するディレクトリを dirs(文字列のリスト)に設定します。 
これはリンカがデフォルトで探索する標準ライブラリ探索パスには影響しません。 
実行時に共有ライブラリを探索するディレクトリのリストにdirを追加します。 
実行時に共有ライブラリを探索するディレクトリのリストをdirに設定します。 
これはランタイムリンカがデフォルトで利用する標準探索パスには影響しません。 
このコンパイラオブジェクトで実行される全てのコンパイルで利用されるプリプロセッサのマクロを定義します。 
このコンパイラオブジェクトで実行される全てのコンパイルで利用されるプリプロセッサのマクロ定義を消します。 
同じマクロをdefine_macro()で定義し、undefine_macro()で定義を削除した場合、後で呼び出されたものが優先される(複数の再定義と削除を含みます)。 
もしコンパイルごと(すなわちcompile()の呼び出しごと)にマクロが再定義/削除される場合も後で呼び出されたものが優先されます。 
このコンパイラオブジェクトによる全てのリンクで利用されるオブジェクトファイル(または類似のライブラリファイルや``リソースコンパイラ''の出力)のリストにobjectを追加します。 
このコンパイラオブジェクトによる全てのリンクで利用されるオブジェクトファイル(または類似のもの)のリストをobjectsに設定します。 
これはリンカがデフォルト利用する標準オブジェクトファイル(システムライブラリなど)には影響しません。 
以下のメソッドはコンパイラオプションの自動検出を実装しており、GNU autoconfに似たいくつかの機能を提供します。 
与えられたファイルまたはファイルのリストの言語を検出します。 
インスタンス属性language_map(辞書)と、language_order (リスト)を仕事に使います。 
指定されたディレクトリのリストから、スタティックまたは共有ライブラリファイルlibを探し、そのファイルのフルパスを返します。 
もしdebugが真なら、(現在のプラットフォームで意味があれば)デバッグ版を探します。 
指定されたどのディレクトリでも lib が見つからなければ Noneを返します。 
funcnameが現在のプラットフォームでサポートされているかどうかをブール値で返します。 
省略可能引数は追加のインクルードファイルやパス、ライブラリやパスを与えることでコンパイル環境を指定します。 
dirをライブラリ探索ディレクトリに追加するコンパイラオプションを返します。 
共有ライブラリまたは実行ファイルにリンクされるライブラリ一覧にlibを追加するコンパイラオプションを返します。 
ランタイムライブラリを検索するディレクトリのリストに dirを追加するコンパイラオプションを返します。 
コンパイルのいろいろなステージで実行される実行ファイル(とその引数)を定義します。 
コンパイラクラス(の 'executables' 属性)によって実行ファイルのセットは変わる可能性がありますが、ほとんどは以下のものを持っています: 
C/C++ コンパイラ 
シェアードオブジェクト、ライブラリを作るために使うリンカ 
バイナリ実行可能ファイルを作るために使うリンカ 
静的ライブラリを作るアーカイバ 
コマンドラインをもつプラットフォーム(Unix, DOS/Windows)では、それぞれの文字列は実行ファイル名と(省略可能な)引数リストに分割されます。 
(文字列の分割は Unix のシェルが行うものに似ています: 単語はスペースで区切られますが、クォートとバックスラッシュでオーバーライドできます。 
distutils.util.split_quoted()をごらんください。 ) 
以下のメソッドはビルドプロセスのステージを呼び出します。 
1つ以上のソースファイルをコンパイルします。 
オブジェクトファイルを生成(たとえば .c ファイルを .oファイルに変換)します。 
sources はファイル名のリストである必要があります。 
おそらく C/C++ファイルですが、実際にはコンパイラとコンパイラクラスで扱えるもの(例:MSVCCompilerはリソースファイルを sourcesにとることができます)なら何でも指定できます。 
sourcesのソースファイルひとつずつに対応するオブジェクトファイル名のリストを返します。 
前者はマクロを定義します。 
もしvalueがNoneであれば、マクロは特定の値をもたないで定義されます。 
1要素のタプルはマクロ定義を削除します。 
後で実行された定義/再定義/削除が優先されます。 
もし真なら、コンパイラはデバッグシンボルをオブジェクトファイルに(または別ファイルに)出力します。 
extra_postargsとextra_postargsは実装依存です。 
コマンドラインをもっているプラットフォーム(例 Unix, DOS/Windows)では、おそらく文字列のリスト: コンパイラのコマンドライン引数の前/後に追加するコマンドライン引数です。 
他のプラットフォームでは、実装クラスのドキュメントを参照してください。 
どの場合でも、これらの引数は抽象コンパイラフレームワークが期待に沿わない時の脱出口として意図されています。 
dependsは(もし指定されていれば)ターゲットが依存しているファイル名のリストです。 
ソースファイルが依存しているファイルのどれかより古ければ、ソースファイルは再コンパイルされます。 
これは依存関係のトラッキングをサポートしていますが、荒い粒度でしか行われません。 失敗するとCompileErrorを起こします。 
静的ライブラリファイルを作るために元ファイル群をリンクします。 
「元ファイル群」はobjectsで指定されたオブジェクトファイルのリストを基礎にしています。 
output_dirはライブラリファイルが起かれるディレクトリです。 
debugはブール値です。 
真なら、デバッグ情報がライブラリに含まれます(ほとんどのプラットフォームではコンパイルステップで意味をもちます:debugフラグは一貫性のためにここにもあります。 )。 
target_lang はオブジェクトがコンパイルされる対象になる言語です。 
これはその言語特有のリンク時の処理を可能にします。 失敗すると LibError を起こします。 
もしoutput_dirが指定されていれば、それに対する相対パスとしてoutput_filenameは扱われます(必要ならばoutput_filename はディレクトリ名を含むことができます。 )。 
librariesはリンクするライブラリのリストです。 
ただしこれらはディレクトリ名を含むことができ、その場合はリンカは通常の場所全体を探すのではなく特定のディレクトリを参照します。 
library_dirsはもし指定されるならば、修飾されていない(ディレクトリ名を含んでいない)ライブラリ名で指定されたライブラリを探索するディレクトリのリストです。 
)。 export_symbolsは共有ライブラリがエクスポートするシンボルのリストです。 
(これはWindowsだけで意味があるようです。 
) debugは compile() や create_static_lib()と同じですが、 少しだけ違いがあり、(create_static_lib()ではdebugフラグは形式をあわせるために存在していたのに対して)ほとんどのプラットフォームで意識されます。 
extra_preargs と extra_postargs は compile() と同じですが、コンパイラではなくリンカへの引数として扱われます。 
target_langは指定されたオブジェクトがコンパイルされた対象言語です。 
リンク時に言語特有の処理を行えるようにします。 失敗すると LinkError が起きます。 
実行ファイルをリンクします。 
output_prognameは実行ファイルの名前です。 
objectsはリンクされるオブジェクトのファイル名のリストです。 
他の引数はlinkメソッドと同じです。 
共有ライブラリをリンクします。 
output_libnameは出力先のライブラリ名です。 objectsはリンクされるオブジェクトのファイル名のリストです。 
共有オブジェクトをリンクします。 
objectsはリンクされるオブジェクトのファイル名のリストです。 
sourceで指定されたひとつの C/C++ソースファイルをプリプロセスします。 
以下のユーティリティメソッドは具体的なサブクラスで使うために、CCompilerクラスで定義されています。 
basenameで指定された実行ファイルのファイル名を返します。 
Windows以外の典型的なプラットフォームではbasenameそのままが、Windowsでは .exeが追加されたものが返ります。 
現在のプラットフォームでのライブラリファイル名を返します。 Unixでlib_typeが'static'の場合、liblibname.aの形式を返し、lib_type が 'dynamic' の場合はliblibname.soの形式を返します。 
指定されたソースファイルに対応するオブジェクトファイル名を返します。 
source_filenames はファイル名のリストです。 shared_object_filename 
basenameに対応する共有オブジェクトファイルのファイル名を返します。 
distutils.util.execute()を呼びだします。 
このメソッドはログを取り、dry_runフラグを考慮にいれて、Python関数funcに引数argsを与えて呼びだします。 
distutils.util.spawn()を呼び出します。 
これは指定したコマンドを実行する外部プロセスを呼び出します。 
distutils.dir_util.mkpath()を呼び出します。 
これは親ディレクトリ込みでディレクトリを作成します。 
distutils.file_util.move_file()を呼び出します。 
src をdstにリネームします。 
distutils.log.debug()関数を使ってメッセージを書き出します。 
警告メッセージmsgを標準エラー出力に書き出します。 
もしこの CCompilerインスタンスで debugフラグが指定されていればmsgを標準出力に出力し、そうでなければ何も出力しません。 
このモジュールは抽象ベースクラス Command を提供します。 
クラスCommand 
コマンドクラスを定義するための抽象ベースクラス -- distutilsの「働きバチ」-- です。 
コマンドクラスは options とよばれるローカル変数を持ったサブルーチンと考えることができます。 
オプションはinitialize_options()で宣言され、finalize_options() で定義さ(最終的な値を与えら)れます。 どちらも全てのコマンドクラスで実装する必要があります。 
サブルーチンの本体は全ての処理をオプションの値にもとづいて行うrun()メソッドで、これも全てのコマンドクラスで実装される必要があります。 クラスのコンストラクタはDistributionのインスタンスである単一の引数distをとります。 
29 distutils.command.bdist_dumb -- ``ダム''インストー ラを構築 
30 distutils.command.bdist_rpm -- Redhat RPMとSRPM形式 のバイナリディストリビューションを構築 
31 distutils.command.bdist_wininst -- Windowsインストー ラの構築 
33 distutils.command.build -- パッケージ中の全ファイルを 構築 
40 distutils.command.install -- パッケージのインストー ル 
41 distutils.command.install_data -- パッケージ中のデータファイルをインストール 
42 distutils.command.install_headers -- パッケージから C/C++ ヘッダファイルをインストール 
43 distutils.command.install_lib -- パッケージから ライブラリファイルをインストール 
44 distutils.command.install_scripts -- パッケージから スクリプトファイルをインストール 
45 distutils.command.register -- モジュールをPython Package Indexに登録する 
registerコマンドはパッケージをPython Package Index に登録します。 
この詳細は PEP 301 に記述されています。 
Distutilsを使うためにインストールする必要がある唯一のモジュールがdistutils.coreモジュールです。 
setup()関数(セットアップスクリプトから呼び出されます)を提供します。 
間接的にdistutils.dist.Distributionクラスと distutils.cmd.Commandクラスを提供します。 
全てを実行する基本的な関数で、Distutilsでできるほとんどのことを実行します。 
XXXXを参照してください。 setup関数はたくさんの引数をとります。 
以下のテーブルにまとめます。 
パッケージの名前 
文字列 
パッケージのバージョン番号 
1行で書いたパッケージ解説 
パッケージの長い解説 
パッケージ作者の名前 
パッケージ作者のemailアドレス 
現在のメンテナの名前(パッケージ作者と異なる場合) 
文字列 
maintainer_email 現在のメンテナのemailアドレス(パッケージ作者と異なる場合) 
パッケージのURL(ホームページ) 
パッケージダウンロード用URL 
distutilsが操作するPythonパッケージのリスト 
文字列のリスト 
distutilsが操作するPythonモジュールのリスト 
ビルドおよびインストールする単体スクリプトファイルのリスト 
ビルドする拡張モジュール 
distutils.core.Extensionインスタンスのリスト 
パッケージのTrove カテゴリのリスト 
XXX もっと良い定義へのリンク 
使用する Distributionクラス 
distutils.core.Distributionのサブクラス 
setup.pyスクリプトの名前 - デフォルトではsys.argv[0] 
セットアップスクリプトの引数 
セットアップスクリプトのデフォルト引数 
パッケージのライセンス 
説明用メタデータ。 
PEP 314を参照してください 
コマンド名から Command サブクラスへのマッピング 
辞書 
制御された環境でセットアップスクリプトを実行し、いろいろなものを操作するdistutils.dist.Distributionクラスのインスタンスを返します。 
これはディストリビューションのメタデータ(キーワード引数scriptとして 関数setup()に渡される)を参照したり、設定ファイルやコマンドラインの内容を調べる時に便利です。 
script_name は execfile()で実行されるファイルです。 
stop_after は いつ動作を停止するか関数setup() に伝えます。 とりうる値は: 
値 
説明 
Distributionインスタンスを作成し、キーワード引数をsetup()に渡したあとに停止する。 
設定ファイルをパーズしたあと停止する(そしてそのデータはDistributionインスタンスに保存される)。 
コマンドライン (sys.argv[1:] またはscript_args) がパーズされたあとに停止する (そしてそのデータはDistributionインスタンスに保存される)。 
全てのコマンドを実行したあとに停止する(関数 setup()を通常の方法で呼び出した場合と同じ)。 
デフォルト値。 
これに加えて、distutils.coreモジュールは他のモジュールにあるいくつかのクラスを公開しています。 
Extension は 
distutils.extension から。 
Command は 
distutils.cmd から。 
Distribution は 
完全な説明についてはそれぞれのモジュールをごらんください。 
Extension クラスは、セットアップスクリプト中で C または C++拡張モジュールを表します。 
コンストラクタで以下のキーワード引数をとります。 
拡張のフルネーム(パッケージを含む) -- ファイル名やパス名ではなく、Pythonのピリオド区切りの名前 
ソースファイル名のリスト。 配布物ルートディレクトリ(setupスクリプトのある場所) からの相対パス、プラットフォーム独立のためUnix形式(スラッシュで区切る)で記述します。 
ソースファイルは C, C++,SWIG (.i)、特定プラットフォーム用のリソースファイル、その他build_extコマンドがソースファイルだと認識するどの形式でもありえます。 
C/C++ヘッダファイルを検索するディレクトリのリスト(プラットフォーム独立のため Unix 形式で記述する) 
定義するマクロのリスト; それぞれのマクロは2要素のタプルで定義されます。 '値'には定義しようとしている文字列、または内容なしで定義する場合はNone(ソースコード中で#define FOOと書く、または Unix Cコンパイラのコマンドラインで-DFOO を指定するのと等価です)を指定します。 
(string,string) または (name,None) のタプル 
定義を消すマクロのリスト 
リンク時にC/C++ライブラリを検索するディレクトリのリスト 
リンクするライブラリ名のリスト (ファイル名やパスではない) 
実行時(shared extensionでは、拡張が読み込まれる時)に C/C++ライブラリを探索するディレクトリのリスト 
追加でリンクするファイル('sources'に対応するコードが含まれていないファイル、バイナリ形式のリソースファイルなど)のリスト 
'sources'のソースをコンパイルする時に追加するプラットフォーム特有またはコンパイラ特有の情報コマンドラインを利用できるプラットホームとコンパイラでは、これは通常コマンドライン引数のリストですが、他のプラットホームでも、それは何かに使えます。 
オブジェクトファイルをリンクして拡張(または新しいPythonインタプリタ)を作る時に追加するプラットフォーム特有またはコンパイラ特有の情報'extra_compile_args'に似た実装です。 
shared extensionからエクスポートされるシンボルのリスト。 
全てのプラットフォームでは使われず、Python拡張(典型的には init + extension_name という1つのシンボルだけエクスポートする)に一般的に必要なものでもない。 
拡張が依存するファイルのリスト 
拡張の言語 (例: 'c', 'c++','objc')。 
指定しなければソースの拡張子で検出される。 
DistributionはPythonソフトウェアパッケージをどのようにビルド、インストール、パッケージするかを定義する。 
Distributionのコンストラクタが取りうるキーワード引数のリストに関しては、setup()関数を見てください。 setup()はDistributionのインスタンスを作ります。 
Commandクラス(そのサブクラスのインスタンス)はdistutilsのあるコマンドを実装します。 
このモジュールはCygwinCCompilerクラスを提供します。 UnixCCompilerのサブクラスで Cygwinに移植されたWindows用の GNUC コンパイラ向けです。 
さらに Mingw32CCompiler クラスを含んでおり、これは mingw32 向けに移植されたGCC (cygwinの no-cygwin モードと同じ)向けです。 
このモジュールはDEBUGフラグを提供します。 
このモジュールはシンプルなタイムスタンプを元にしたファイルやファイル群の依存関係を処理する関数を提供します。 さらに、それらの依存関係解析を元にした関数を提供します。 
sourceが存在して、targetより最近変更されている、またはsourceが存在して、targetが存在していない場合は真を返します。 両方が存在していて、targetのほうがsourceより新しいか同じ場合には偽を返します。 
sourceが存在しない場合には DistutilsFileErrorを起こします。 newer_pairwise 
ふたつのファイル名リストを並列に探索して、それぞれのソースが対応するターゲットより新しいかをテストします。 
newer()の意味でターゲットよりソースが新しいペアのリスト(sources,targets)を返します。 
targetがsourceにリストアップされたどれかのファイルより古ければ真を返します。 
もし'ignore'なら、単に存在しないソースファイルを無視します。 もし'newer'なら、存在しないソースファイルについてはtargetが古いとみなします(これは''dry-tun''モードで便利です: 入力がないのでコマンドは実行できませんが実際に実行しようとしていないので問題になりません)。 
このモジュールはディレクトリとディレクトリツリーを操作する関数を提供します。 
ディレクトリと、必要な親ディレクトリを作成します。 
もしディレクトリが既に存在している(nameが空文字列の場合、カレントディレクトリを示すのでもちろん存在しています)場合、何もしません。 
ディレクトリを作成できなかった場合(例: ディレクトリと同じ名前のファイルが既に存在していた)、DistutilsFileErrorを起こします。 
もし verboseが真なら、それぞれのmkdirについて1行、標準出力に出力します。 
実際に作成されたディレクトリのリストを返します。 create_tree 
srcディレクトリツリー全体をdstにコピーします。 
srcと dstはどちらもディレクトリ名である必要があります。 
もしsrcがディレクトリでなければ、DistutilsFileErrorを起こします。 
もしdstが存在しなければ、mkpath()で作成されます。 
実行結果は、src以下の全てのファイルがdstにコピーされ、src以下の全てのディレクトリがdstに再帰的にコピーされます。 
コピーされた(またはされるはず)のファイルのリストを返します。 
返り値はupdateまたはdry_runに影響されません: src以下の全ファイルを単にdst以下に改名したリストが返されます。 
preserve_mode と preserve_times は 
のcopy_fileと同じです: 通常のファイルには適用されますが、ディレクトリには適用されません。 
もしpreserve_symlinks が真なら、シンボリックリンクは(サポートされているシステムでは)シンボリックリンクとしてコピーされます。 
再帰的に directoryとその下の全ファイルを削除します。 
エラーは無視されます(verboseが真の時はstdoutに出力されます) 
このモジュールはDistributionクラスを提供します。 これは構築/インストール/配布される配布物をあらわします。 
このモジュールはEMXCCompilerクラスを提供します。 UnixCCompilerのサブクラスで GNU C コンパイラの OS/2 向け EMXポートを扱います。 
distutilsのモジュールで使用される例外を提供します。 
16 distutils.debug 15 distutils.extension -- Extension クラス 
このモジュールはExtensionクラスを提供します。 
C/C++拡張モジュールをセットアップスクリプトで表すために使われます。 
18 distutils.fancy_getopt -- 標準 getopt モジュールのラッパ 
このモジュールはファイルシステムを見て、ファイルのリストを構築するために使われるFileList クラスを提供します。 
このモジュールはそれぞれのファイルを操作するユーティリティ関数を提供します。 
ファイルsrcをdstにコピーします。 
もしdstがディレクトリなら、srcはそこへ同じ名前でコピーされます; そうでなければ、ファイル名として扱われます。 
(もしファイルが存在するなら、上書きされます。 
) mosilpreserve_modeが真(デフォルト)なら、ファイルのモード(タイプやパーミッション、その他プラットフォームがサポートするもの)もコピーされます。 
もし preserve_timesが真(デフォルト)なら、最終更新、最終アクセス時刻もコピーされます。 
もしupdateが真なら、srcはdstが存在しない場合か、dstがsrcより古い時にだけコピーします。 
linkは値を'hard'または'sym'に設定することでコピーのかわりにハードリンク(os.linkを使います)またはシンボリックリンク(os.symlinkを使います)を許可します。 
None(デフォルト)の時には、ファイルはコピーされます。 
linkをサポートしていないシステムで有効にしないでください。 copy_file()はハードリンク、シンボリックリンクが可能かチェックしていません。 
ファイルの内容をコピーするために_copy_file_contents()を利用しています。 "(dest_name, copied)"のタプルを返します: dest_nameは出力ファイルの実際の名前、copiedはファイルがコピーされた(dry_runが真の時にはコピーされることになった)場合には真です。 
ファイルsrcをdstに移動します。 
もしdstがディレクトリなら、ファイルはそのディレクトリに同じ名前で移動されます。 そうでなければ、srcはdstに単にリネームされます。 
新しいファイルの名前を返します。 
警告:Unix では デバイスをまたがる移動はcopy_file()を利用して扱っています。 
他のシステムではどうなっている ??? 
filename を作成し、contents(行末文字がない文字列のシーケンス)を書き込みます。 
18.10.1 Pythonバイトコード命令 
distutils パッケージは、現在インストールされている Python に追加するためのモジュール構築、および実際のインストールを支援します。 
新規のモジュールは 100%-pure Python でも、C で書かれた拡張モジュールでも、あるいは Python と C 両方のコードが入っているモジュールからなるPython パッケージでもかまいません。 このパッケージは、Python ドキュメンテーション パッケージに含まれているこれとは別の 2つのドキュメントで詳しく説明されています。 
distutilsの機能を使って新しいモジュールを配布する方法は、 
Python モジュールを配布する 
に書かれています。 このドキュメントには distutils を拡張する方法も含まれています。 
Python モジュールをインストールする方法は、モジュールの作者が distutils パッケージを使っている場合でもいない場合でも、 
Python モジュールをインストールする 
に書かれています。 
このマニュアルはPython モジュールの開発者およびパッケージ担当に向けたものです。 
ここでは、現在インストールされている Python に簡単に追加できるdistutilsベースのパッケージをどうやって用意するかについて説明しています。 
現在インストールされている Python にモジュールを追加するための情報が書かれた ``管理者'' 向けのマニュアルです。 この文書を読むのに Python プログラマである必要はありません。 
20 distutils.log -- シンプルな PEP 282 スタイルのロギ ング 
警告:標準のlogging モジュールに置き換えられるべき 
このモジュールは MSVCCompilerクラスを提供します。 抽象クラスCCompilerの具象クラスでMicrosoft Visual Studio向けのものです。 
.Net SDKの一部として無償で入手できるコンパイラを扱うこともできます。 
8 distutils.mwerkscompiler -- Metrowerks CodeWarrior サポート 
MWerksCompilerクラスを提供します。 抽象クラスCCompilerの具象クラスで Macintoshの MetroWerks CodeWarrior向けです。 
CW on Windows をサポートするには作業が必要です。 
22 distutils.sysconfig -- システム設定情報 
distutils.sysconfig モジュールでは、 Python の低水準の設定情報へのアクセス手段を提供しています。 
どの設定情報変数にアクセスできるかは、プラットフォームと設定自体に大きく左右されます。 また、特定の変数は、使っている Python のバージョンに対するビルドプロセスに左右されます; こうした変数は、Unix システムでは、Makefile や Python と一緒にインストールされる設定ヘッダから探し出されます。 
設定ファイルのヘッダは、2.2 以降のバージョンではpyconfig.h 、それ以前のバージョンでは config.h です。 他にも、distutils パッケージの別の部分を操作する上で便利な関数がいくつか提供されています。 
os.path.normpath(sys.prefix) の結果です。 
os.path.normpath(sys.exec_prefix) の結果です。 
ある一つの設定変数に対する値を返します。 
get_config_vars().get(name) と同じです。 
定義されている変数のセットを返します。 
引数を指定しなければ、設定変数名を変数の値に対応付けるマップ型を返します。 
引数を指定する場合、引数の各値は文字列でなければならず、戻り値は引数に関連付けられた各設定変数の値からなるシーケンスになります。 
引数に指定した名前の設定変数に値がない場合、その変数値にはNone が入ります。 get_config_h_filename 
設定ヘッダのフルパス名を返します。 
Unixの場合、このヘッダファイルはconfigure スクリプトによって生成されるヘッダファイル名です;他のプラットフォームでは、ヘッダは Python ソース配布物中で直接与えられています。 
ファイルはプラットフォーム固有のテキストファイルです。 
Python をビルドする際に用いる Makefile のフルパスを返します。 
Unixの場合、このファイルは configure スクリプトによって生成されます; 他のプラットフォームでは、この関数の返す値の意味は様々です。 有意なファイル名を返す場合、ファイルはプラットフォーム固有のテキストファイル形式です。 
この関数は POSIX プラットフォームでのみ有用です。 
C インクルードファイルディレクトリについて、一般的なディレクトリ名か、プラットフォーム依存のディレクトリ名のいずれかを返します。 
plat_specific が真であれば、プラットフォーム依存のインクルードディレクトリ名を返します; plat_specific が偽か、省略された場合には、プラットフォームに依存しないディレクトリを返します。 
prefix が指定されていれば、PREFIXの代わりに用いられます。 
また、 plat_specific が真の場合、EXEC_PREFIX の代わりに用いられます。 get_python_lib 
ライブラリディレクトリについて、一般的なディレクトリ名か、プラットフォーム依存のディレクトリ名のいずれかを返します。 
plat_specific が真であれば、プラットフォーム依存のライブラリディレクトリ名を返します; plat_specific が偽か、省略された場合には、プラットフォームに依存しないディレクトリを返します。 prefix が指定されていれば、PREFIXの代わりに用いられます。 
また、 plat_specific が真の場合、EXEC_PREFIX の代わりに用いられます。 
standard_lib が真であれば、サードパーティ製の拡張モジュールをインストールするディレクトリの代わりに、標準ライブラリのディレクトリを返します。 
以下の関数は、distutils パッケージ内の使用だけを前提にしています。 
distutils.ccompiler.CCompiler インスタンスに対して、プラットフォーム固有のカスタマイズを行います。 この関数は現在のところ、Unix だけで必要ですが、将来の互換性を考慮して一貫して常に呼び出されます。 
この関数は様々な Unix の変種ごとに異なる情報や、Python のMakefile に書かれた情報をインスタンスに挿入します。 
この情報には、選択されたコンパイラやコンパイラ/リンカのオプション、そして共有オブジェクトを扱うためにリンカに指定する拡張子が含まれます。 
この関数はもっと特殊用途向けで、Python 自体のビルドプロセスでしか使われません。 set_python_build 
distutils.sysconfig モジュールに、モジュールが Python のビルドプロセスの一部として使われることを知らせます。 
これによって、ファイルコピー先を示す相対位置が大幅に変更され、インストール済みのPython ではなく、ビルド作業領域にファイルが置かれるようになります。 
24 distutils.version 23 distutils.text_file -- TextFile クラス 
このモジュールは TextFileクラスを提供します。 
これはテキストファイルへのインタフェースを提供し、コメントの削除、空行の無視、バックスラッシュでの行の連結を任意に行えます。 クラスTextFile 
このクラスはファイルのようなオブジェクトを提供します。 これは行指向のテキストファイルを処理する時に共通して必要となる処理を行います: (#がコメント文字なら)コメントの削除、空行のスキップ、(行末のバックスラッシュでの)改行のエスケープによる行の連結、先頭/末尾の空白文字の削除。 
またunreadline()メソッドが一行先読みを実装するために提供されています。 
TextFileのインスタンスはfilename、file、またはその両方をとって作成されます。 
両方が None の場合 RuntimeError が起きます。 filenameは文字列、fileはファイルオブジェクト(またはreadline()とclose()のメソッドを提供する何か)である必要があります。 
TextFileが生成する警告メッセージに含めることができるので、filenameを与えることが推奨されます、もしfileが提供されなければ、 TextFile は組み込みの open()を利用して自分で作成します。 
オプションは全て真偽値で、readline()で返される値に影響します。 
オプション名 
デフォルト値 
行を返す前に先頭の空白文字の並びを削除します。 
行を返す前に行末の空白文字(改行文字を含みます!)の並びを削除します。 
コメントと空白を除いた*あとで*内容がない行をスキップします。 
もしコメントと空白文字を削除したあとで、バックスラッシュが最後の改行文字でない文字なら、次の行を接続して一つの論理行とします: N行の連続した行がバックスラッシュで終わる場合、N+1 行の物理行が1行の論理行として扱われます。 
前の行と接続するとき、行頭の空白文字を削除します。 "(join_linesand not lstrip_ws)" の時だけ意味をもちます。 
rstrip_wsは行末の改行を削除するので、readline()のセマンティクスが組み込みファイルオブジェクトのreadline()メソッドとは変わってしまいます!特に、 rstrip_ws が真で skip_blanks が偽のとき、readline() はファイルの終端でNoneを返し、空文字列を返したときは空行(または全て空白文字の行)です。 
新しいファイルfilenameを開きます。 
これはコンストラクタ引数のfileとfilenameを上書きします。 
現在のファイルを閉じ、(ファイル名や現在の行番号を含め)現在のファイルについての情報を全て消します。 
標準エラー出力に現在のファイルの論理行に結びついた警告メッセージを出力します。 
もし現在の論理行が複数の物理行に対応するなら、警告メッセージは以下のように全体を参照します: ""lines 3-5""。 
もし line が与えられていれば、現在の行番号を上書きします; 物理行のレンジをあらわすリストまたはタプル、もしくはある物理行をあらわす整数のどれでも与えられます。 
現在のファイル(またはunreadline()で''unread''を直前に行っていればバッファ)から論理行を1行読み込んで返します。 
もしjoin_linesオプションが真なら、このメソッドは複数の物理行を読み込んで接続した文字列を返します。 
現在の行番号を更新します。 そのためreadline()のあとにwarn()を呼ぶと丁度読んだ行についての警告を出します。 
rstrip_wsが真で、strip_blanksが偽のとき空文字列が返るので、ファイルの終端ではNoneを返します。 
現在のファイルで残っている全ての論理行のリストを読み込んで返します。 行番号を、ファイルの最後の行に更新します。 
line(文字列)を次のreadline()用に、内部バッファにpushします。 
行の先読みを必要とするパーサを実装する時に便利です。 
unreadlineで``unread''された行はreadlineで読み込む際に再度処理(空白の除去など)されません。 
もしunreadlineeを、readlineを呼ぶ前に複数回実行すると、最後にunreadした行から返されます。 
このモジュールはUnixCCompilerクラスを提供します。 CCompilerクラスのサブクラスで、典型的なUnixスタイルのコマンドラインCコンパイラを扱います: 
マクロは -Dname 
で定義されます。 マクロは -Uname 
ライブラリは -llib で指定されます。 
ライブラリの探索ディレクトリは -Ldir で指定されます。 
コンパイルは cc (またはそれに似た) 実行ファイルに、-c オプションをつけて実行します: .c を.oにコンパイルします。 
静的ライブラリは arコマンドで処理されます(ranlibを使うかもしれません) 
共有ライブラリのリンクは cc -shared で処理されます。 
このモジュールは他のユーティリティモジュールにあわないものを提供しています。 
現在のプラットフォームを示す文字列を返します。 
これはプラットフォーム依存のビルドディレクトリやプラットフォーム依存の配布物を区別するために使われます。 
POSIX でないプラットフォームでは、今のところ単にsys.platformが返されます。 
'pathname' をファイルシステムで利用できる名前にして返します。 すなわち、'/'で分割し、現在のディレクトリセパレータで接続しなおします。 
セットアップスクリプト中のファイル名はUnixスタイルで提供され、実際に利用する前に変換する必要があるため、この関数が必要になります。 
もし pathname の最初または最後が スラッシュの場合、Unix的でないシステムではValueErrorが起きます。 
pathnameの前にnew_rootを追加したものを返します。 
'os.environ'に、ユーザがconfigファイル、コマンドラインオプションなどで利用できることを保証している環境変数があることを確認します。 
現在は以下のものが含まれています: 
HOME - ユーザのホームディレクトリ (Unix のみ) 
PLAT - ハードウェアとOSを含む現在のプラットフォームの説明。 
( get_platform()を参照) subst_vars 
shell/Perlスタイルの変数置換をsについて行います。 
全ての$に名前が続いたものは変数とみなされ、辞書local_varsでみつかった値に置換されます。 local_varsで見つからなかった場合にはos.environで置換されます。 
os.environは最初にある値を含んでいることをチェックされます:check_environ()を参照。 
local_vars or os.environのどちらにも値が見つからなかった場合、ValueErrorを起こします。 
これは完全な文字列挿入関数ではないことに注意してください。 
$variableの名前には大小英字、数字、アンダーバーだけを含むことができます。 
{ } や 
を使った引用形式は利用できません。 
例外オブジェクト EnvironmentError (IOError または OSError) から、エラーメッセージを生成します。 
Python 1.5.1 またはそれ以降の形式を扱い、ファイル名を含んでいない例外オブジェクトも扱います。 このような状況はエラーが2つのファイルに関係する操作、たとえばrename()やlink()で発生します。 
prefixをプレフィクスに持つエラーメッセージを返します。 
文字列をUnixのシェルのようなルール(引用符やバックスラッシュの扱い)で分割します。 
2文字でのエスケープシーケンスに使われているバックスラッシュは削除され、エスケープされていた文字だけが残ります。 
引用符は文字列から削除されます。 
語のリストが返ります。 
外部に影響するいくつかのアクション(たとえば、ファイルシステムへの書き込み)を実行します。 
そのようなアクションはdry_runフラグで無効にする必要があるので特別です。 
この関数はその繁雑な処理を行います。 関数と引数のタプル、(実行する「アクション」をはっきりさせるための)表示に使われる任意のメッセージを渡してください。 
valが上のどれでもない時は ValueErrorを起こします。 
0 - 最適化しない (.pycファイルを作成します) 
1 - 通常の最適化 ("python -O"のように) 
2 - さらに最適化 ("python -OO"のように) 
通常はbyte_compile()に直接かそうでないかをまかせます(詳細についてはソースをごらんください)。 
directフラグは関節モードで作成されたスクリプトで使用されます。 何をやっているか理解していない時はNoneのままにしておいてください。 
dlモジュールはdlopen()関数へのインターフェースを定義します。 これはダイナミックライブラリにハンドルするためのUnixプラットフォーム上の最も一般的なインターフェースです。 
そのライブラリの任意の関数を呼ぶプログラムを与えます。 
注意:このモジュールはsizeof(int) == sizeof(long) == sizeof(char *)でなければ働きません。 
そうでなければimportするときにSystemErrorが送出されるでしょう。 
dlモジュールは次の関数を定義します: 
共有オブジェクトファイルを開いて、ハンドルを返します。 
モードは遅延結合(RTLD_LAZY)または即時結合(RTLD_NOW)を表します。 
デフォルトはRTLD_LAZYです。 
いくつかのシステムはRTLD_NOWをサポートしていないことに注意してください。 返り値はdlobjectです。 
dlモジュールは次の定数を定義します: 
open()の引数として使います。 
即時結合をサポートしないシステムでは、この定数がモジュールに現われないことに注意してください。 
最大のポータビリティを求めるならば、システムが即時結合をサポートするかどうかを決定するためにhasattr()を使用してください。 
dlモジュールは次の例外を定義します: 
動的なロードやリンクルーチンの内部でエラーが生じたときに送出される例外です。 
例: 
この例はDebian GNU/Linuxシステム上で行なったもので、このモジュールの使用はたいてい悪い選択肢であるという事実のよい例です。 
5.2 doctest --対話モードを使った使用例の内容をテストする 
モジュールは、対話的 Python セッションのように見えるテキストを探し出し、セッションの内容を実行して、そこに書かれている通りに振舞うかを調べます。 
doctest は以下のような用途によく使われています: 
モジュールの docstring (ドキュメンテーション文字列) 中にある対話モードでの使用例全てが書かれている通りに動作するかを検証することで、docstring の内容が最新のものになるよう保ちます。 
テストファイルやテストオブジェクト中の対話モードにおける使用例が期待通りに動作するかを検証することで、回帰テストを実現します。 
入出力例をふんだんに使ったパッケージのチュートリアルドキュメントを書けます。 
入出力例と解説文のどちらに注目するかによって、ドキュメントは「読めるテスト」にも「実行できるドキュメント」にもなります。 
以下にちょっとした、それでいて完全な例を示します: 
doctest モジュールは、モジュールの docstring から、これらのセッションを実際に実行して、そこに書かれている通りに動作するか検証します。 
example.py をコマンドラインから直接実行すると、 
はその魔法を働かせます: 
出力は何もありません! しかしこれが正常で、全ての例が正しく動作することを意味しています。 
スクリプトに -v を与えると、 
は何を行おうとしているのかを記録した詳細なログを出力し、最後にまとめを出力します: 
といった具合で、最後には: 
詳細な事柄は後続の各節で全て説明しています。 
doctest の例は、標準の Python テストスイートやライブラリ中に沢山あります。 
標準のテストファイル Lib/test/test_doctest.py には、特に便利な例題があります。 
doctest.py 内の docstring には doctest の全ての側面についての詳細な情報が入っており、ここではより重要な点をカバーするだけにします。 
5.2.5 実行コンテキストとは何か? 
注意: dumbdbm モジュールは、 
が安定なモジュールを他に見つけることができなかった際の最後の手段とされています。 dumbdbm モジュールは速度を重視して書かれているわけではなく、他のデータベースモジュールのように重い使い方をするためのものではありません。 
dumbdbm モジュールは永続性辞書に類似したインタフェースを提供し、全て Python で書かれています。 
や 
といったモジュールと異なり、外部ライブラリは必要ありません。 
他の永続性マップ型のように、キーおよび値は常に文字列でなければなりません。 このモジュールでは以下の内容を定義してします: 
I/O エラーのような dumbdbm 特有のエラーの際に送出されます。 
不正なキーを指定したときのような、一般的な対応付けエラーの際にはKeyError が送出されます。 
dumbdbm データベースを開き、 dubmdbm オブジェクトを返します。 
filename 引数はデータベースファイル名の雛型 (特定の拡張子をもたないもの) です。 
デフォルトでは 8 進コードの 0666 になっています (umask によって修正を受けます)。 バージョン 2.2 で 変更 された仕様:mode 引数は以前のバージョンでは無視されます 
dbm 形式のデータベースに対する汎用インタフェース。 
DBM/NDBM ライブラリに対する同様のインタフェース。 
GNU GDBM ライブラリに対する同様のインタフェース。 
非文字列データを記録する永続化モジュール。 
既存のデータベースの形式を判定するために使われるユーティリティモジュール。 
このモジュールは 
モジュールのインターフェースをそっくりまねるものです。 
モジュールがサポートされていないプラットフォームで import することを意図して作られたものです。 使用例: 
生成するスレッドが、他のブロックしたスレッドを待ち、デッドロック発生の可能性がある場合には、このモジュールを使わないようにしてください。 
ブロッキング I/O を使っている場合によく起きます。 
モジュールのインターフェースをそっくりまねるものです。 
使用例: 
このモジュールは文字セットを表現する Charset クラスと電子メールメッセージにふくまれる文字セット間の変換、および文字セットのレジストリとこのレジストリを操作するためのいくつかの便宜的なメソッドを提供します。 
Charset インスタンスはemail パッケージ中にあるほかのいくつかのモジュールで使用されます。 
バージョン 2.2.2 で 新たに追加 された仕様です。 
クラスCharset ( 
文字セットを email のプロパティに写像する。 
Map character sets to their email properties.このクラスはある特定の文字セットに対し、電子メールに課される制約の情報を提供します。 
また、与えられた適用可能な codec をつかって、文字セット間の変換をおこなう便宜的なルーチンも提供します。 
この値はつねに小文字に強制的に変換されます。 
そして文字セットの別名が正規化されたあと、この値は文字セットのレジストリ内を検索し、ヘッダのエンコーディングとメッセージ本体のエンコーディング、および出力時の変換に使われる codec をみつけるのに使われます。 
たとえば input_charset が iso-8859-1 の場合、ヘッダおよびメッセージ本体はquoted-printable でエンコードされ、出力時の変換用 codec は必要ありません。 
もし input_charset が euc-jp ならば、ヘッダは base64 でエンコードされ、メッセージ本体はエンコードされませんが、出力されるテキストは euc-jp 文字セットからiso-2022-jp 文字セットに変換されます。 
Charset インスタンスは以下のようなデータ属性をもっています: 
最初に指定される文字セットです。 
一般に通用している別名は、正式な 電子メール用の名前に変換されます(たとえば、latin_1 は iso-8859-1 に変換されます)。 
デフォルトは 7-bit の us-ascii です。 
この文字セットが電子メールヘッダに使われる前にエンコードされる必要がある場合、この属性は Charset.QP (quoted-printable エンコーディング)、Charset.BASE64 (base64 エンコーディング)、あるいは最短の QP または BASE64 エンコーディングである Charset.SHORTEST に設定されます。 そうでない場合、この値は None になります。 
header_encoding と同じですが、この値はメッセージ本体のためのエンコーディングを記述します。 これはヘッダ用のエンコーディングとは違うかもしれません。 
body_encoding では、Charset.SHORTEST を使うことはできません。 
文字セットによっては、電子メールのヘッダあるいはメッセージ本体に使う前にそれを変換する必要があります。 
もし input_charset がそれらの文字セットのどれかをさしていたら、この output_charset 属性はそれが出力時に変換される文字セットの名前をあらわしています。 
それ以外の場合、この値は None になります。 
input_charset を Unicode に変換するための Python 用 codec 名です。 
変換用の codec が必要ないときは、この値は None になります。 
Unicode を output_charset に変換するための Python 用 codec 名です。 
変換用の codec が必要ないときは、この値は None になります。 この属性は input_codec と同じ値をもつことになるでしょう。 
Charset インスタンスは、以下のメソッドも持っています: 
文字列 s を input_codec から output_codec に変換します。 
おそらくマルチバイトの文字列を、安全に split できる形式に変換します。 
split できる文字列をエンコードされた文字列に変換しなおします。 
ustr は ``逆split'' するための Unicode 文字列です。 
このメソッドでは、文字列を Unicode からべつのエンコード形式に変換するために適切な codec を使用します。 
to_output が False の場合、これはinput_codec を使用します。 
出力用の文字セットを返します。 これは output_charset 属性が None でなければその値になります。 
それ以外の場合、この値は input_charset と同じです。 encoded_header_len 
エンコードされたヘッダ文字列の長さを返します。 
これは quoted-printable エンコーディングあるいは base64 エンコーディングに対しても正しく計算されます。 header_encode 
文字列 s をヘッダ用にエンコードします。 
convert が True の場合、文字列は入力用文字セットから出力用文字セットに自動的に変換されます。 
これは行の長さ問題のあるマルチバイトの文字セットに対しては役に立ちません(マルチバイト文字はバイト境界ではなく、文字ごとの境界で split する必要があります)。 これらの問題を扱うには、高水準のクラスである Header クラスを使ってください ( 
email.Header を参照)。 
convert の値はデフォルトでは False です。 エンコーディングの形式 (base64 または quoted-printable) は、header_encoding 属性に基づきます。 
文字列 s をメッセージ本体用にエンコードします。 
Charset クラスには、標準的な演算と組み込み関数をサポートするいくつかのメソッドがあります。 
input_charset を小文字に変換された文字列型として返します。 __repr__() は、__str__() の別名となっています。 
このメソッドは、2つの Charset インスタンスが同じかどうかをチェックするのに使います。 
このメソッドは、2つの Charset インスタンスが異なるかどうかをチェックするのに使います。 
また、email.Charset モジュールには、グローバルな文字セット、文字セットの別名(エイリアス) および codec 用のレジストリに新しいエントリを追加する以下の関数もふくまれています: add_charset 
文字の属性をグローバルなレジストリに追加します。 
デフォルトの値はエンコーディングなしの None になっています。 オプション引数 output_charset には出力用の文字セットが入ります。 
Charset.convert() が呼ばれたときの変換はまず入力用の文字セットを Unicode に変換し、それから出力用の文字セットに変換されます。 
デフォルトでは、出力は入力と同じ文字セットになっています。 
モジュールの文書を参照してください。 グローバルな文字セット用のレジストリは、モジュールの global 辞書CHARSETS 内に保持されています。 
与えられた文字セットの文字と Unicode との変換をおこなう codec を追加します。 
charset はある文字セットの正式名称で、codecname は Python 用 codec の名前です。 これは組み込み関数 unicode() の第2引数か、あるいは Unicode 文字列型の encode() メソッドに適した形式になっていなければなりません。 
12.2.8 例外および障害クラス 
実際にはこれらのエンコーダは MIMEAudio および MIMEImage クラスのコンストラクタでデフォルトエンコーダとして使われています。 
すべてのエンコーディング関数は、エンコードするメッセージオブジェクトひとつだけを引数にとります。 
これらはふつうペイロードを取りだし、それをエンコードして、ペイロードをエンコードされたものにセットしなおします。 
これらはまた Content-Transfer-Encoding: ヘッダを適切な値に設定します。 
提供されているエンコーディング関数は以下のとおりです: encode_quopri 
これはそのペイロードのほとんどが通常の印刷可能な文字からなっているが、印刷不可能な文字がすこしだけあるときのエンコード方法として適しています。 
ペイロードを base64 形式でエンコードし、Content-Transfer-Encoding: ヘッダをbase64 に変更します。 
これはペイロード中のデータのほとんどが印刷不可能な文字である場合に適しています。 quoted-printable 形式よりも結果としてはコンパクトなサイズになるからです。 
base64 形式の欠点は、これが人間にはまったく読めないテキストになってしまうことです。 
これは実際にはペイロードを変更はしませんが、ペイロードの形式に応じてContent-Transfer-Encoding: ヘッダを 7bit あるいは8bit に適した形に設定します。 
これは何もしないエンコーダです。 Content-Transfer-Encoding: ヘッダを設定さえしません。 
注意: encode_quopri() を使ってエンコードすると、データ中のタブ文字や空白文字もエンコードされます。 
email.Errors モジュールでは、以下の例外クラスが定義されています: 
例外MessageError 
これは email パッケージが発生しうるすべての例外の基底クラスです。 
これは標準の Exception クラスから派生しており、追加のメソッドはまったく定義されていません。 
例外MessageParseError 
これは Parser クラスが発生しうる例外の基底クラスです。 
MessageError から派生しています。 
例外HeaderParseError 
メッセージの RFC 2822 ヘッダを解析している途中にある条件でエラーがおこると発生します。 これは MessageParseError から派生しています。 
メッセージの RFC 2822 ヘッダを解析している途中にある条件でエラーがおこると発生します。 これは MessageParseError から派生しています。 
この例外は、Message オブジェクトに add_payload() メソッドを使ってペイロードを追加するとき、そのペイロードがすでに単一の値である(訳注: リストでない) にもかかわらず、そのメッセージの Content-Type: ヘッダのメインタイプがすでに設定されていて、それが multipart 以外になってしまっている場合にこの例外が発生します。 
MultipartConversionError は MessageError と組み込みの TypeError を両方継承しています。 Message.add_payload() はもはや推奨されないメソッドのため、この例外はふつうめったに発生しません。 
しかしこの例外はattach() メソッドが MIMENonMultipart から派生したクラスのインスタンス (例: MIMEImage など) に対して呼ばれたときにも発生することがあります。 
以下は FeedParser がメッセージの解析中に検出する障害 (defect) の一覧です。 
注意: これらの障害は、問題が見つかったメッセージに追加されるため、たとえばmultipart/alternative 内にあるネストしたメッセージが異常なヘッダをもっていた場合には、そのネストしたメッセージが障害を持っているが、その親メッセージには障害はないとみなされます。 すべての障害クラスは email.Errors.MessageDefect のサブクラスですが、これは例外とは違いますので注意してください。 
バージョン 2.4 で 新たに追加 された仕様:All the defect classes were added 
NoBoundaryInMultipartDefect - メッセージが multipart だと宣言されているのに、boundary パラメータがない。 
StartBoundaryNotFoundDefect - Content-Type: ヘッダで宣言された開始境界がない。 
FirstHeaderLineIsContinuationDefect - メッセージの最初のヘッダが継続行から始まっている。 
MisplacedEnvelopeHeaderDefect - ヘッダブロックの途中に ``Unix From'' ヘッダがある。 
MalformedHeaderDefect - コロンのないヘッダがある、あるいはそれ以外の異常なヘッダである。 
MultipartInvariantViolationDefect - メッセージが multipart だと宣言されているのに、サブパートが存在しない。 
注意: メッセージがこの障害を持っているとき、is_multipart() メソッドは たとえその content-type が multipart であってもfalse を返すことがあります。 
12.2.2.3 追加事項 
よくある作業のひとつは、メッセージオブジェクト構造からフラットな電子メールテキストを生成することです。 
この作業は 
や 
モジュールを使ってメッセージを送信したり、メッセージをコンソールに出力したりするときに必要になります。 
あるメッセージオブジェクト構造をとってきて、そこからフラットなテキスト文書を生成するのは Generator クラスの仕事です。 
繰り返しになりますが、 email.Parser 
モジュールと同じく、この機能は既存の Generator だけに限られるわけではありません。 
Generator クラスで公開されているメソッドには、以下のようなものがあります: クラスGenerator 
これは、このような行が Unix のmailbox 形式のエンペローブヘッダ区切り文字列として誤認識されるのを防ぐための、移植性ある唯一の方法です (詳しくはWHY THE CONTENT-LENGTH FORMAT IS BAD (なぜ Content-Length 形式が有害か)を参照してください)。 
デフォルトでは mangle_from_ は True になっていますが、Unix の mailbox 形式ファイルに出力しないのならばこれは False に設定してもかまいません。 オプション引数 maxheaderlen は連続していないヘッダの最大長を指定します。 
ひとつのヘッダ行が maxheaderlen (これは文字数です、tab は空白 8文字に展開されます) よりも長い場合、ヘッダはemail.Header クラスで定義されているように途中で折り返され、間にはセミコロンが挿入されます。 もしセミコロンが見つからない場合、そのヘッダは放置されます。 
ヘッダの折り返しを禁止するにはこの値にゼロを指定してください。 
デフォルトは 78 文字で、RFC 2822 で推奨されている (ですが強制ではありません) 値です。 
これ以外のパブリックな Generator メソッドは以下のとおりです: 
msg を基点とするメッセージオブジェクト構造体の文字表現を出力します。 出力先のファイルにはこの Generator インスタンスが作成されたときに指定されたものが使われます。 
各 subpart は深さ優先順序(depth-first) で出力され、得られるテキストは適切に MIME エンコードされたものになっています。 オプション引数 unixfrom は、基点となるメッセージオブジェクトの最初の RFC 2822 ヘッダが現れる前に、エンペローブヘッダ区切り文字列を出力することを強制するフラグです。 
そのメッセージオブジェクトがエンペローブヘッダをもたない場合、標準的なエンペローブヘッダが自動的に作成されます。 
デフォルトではこの値は False に設定されており、エンペローブヘッダ区切り文字列は出力されません。 注意: 各 subpart に関しては、エンペローブヘッダは出力されません。 
この Generator インスタンスの独立したクローンを生成し返します。 オプションはすべて同一になっています。 
文字列 s を既定のファイルに出力します。 
ここでいう出力先は Generator コンストラクタに渡した outfp のことをさします。 
この関数はただ単に拡張 print 文で使われる Generator インスタンスに対してファイル操作風の API を提供するためだけのものです。 
ユーザの便宜をはかるため、メソッド Message.as_string() とstr(aMessage) (つまり Message.__str__() のことです) をつかえばメッセージオブジェクトを特定の書式でフォーマットされた文字列に簡単に変換することができます。 
詳細は 
これは DecodedGenerator と呼ばれるもので、Generator 基底クラスと似ていますが、非text型の subpart を特定の書式でフォーマットされた表現形式で置きかえるところが違っています。 
クラスDecodedGenerator 
このクラスは Generator から派生したもので、メッセージの subpart をすべて渡り歩きます。 
type - 非text型 subpart の MIME 形式 
maintype - 非text型 subpart の MIME 主形式 (maintype) 
subtype - 非text型 subpart の MIME 副形式 (subtype) 
filename - 非text型 subpart のファイル名 
description - 非text型 subpart につけられた説明文字列 
encoding - 非text型 subpart の Content-transfer-encoding 
fmt のデフォルト値は None です。 
こうすると以下の形式で出力します: [Non-text (%(type)s) part of message omitted, filename %(filename)s] 
訳注: file-like object 12.2.3.1 Deprecated methods 
12.2.4 電子メールおよび MIME オブジェクトをゼロから作成する 
RFC 2822 は電子メールメッセージの形式を規定する基本規格です。 
これはほとんどの電子メールが ASCII 文字のみで構成されていたころ普及したRFC 822 標準から発展したものです。 
Message オブジェクトの該当フィールドに文字列ではなく、Header インスタンスを値として使うのです。 たとえば: 
from email.Message import Message from email.Header import Header msg = Message() h = Header('p\xf6stal', 'iso-8859-1') msg['Subject'] = h print msg.as_string()Subject: ptal 
Subject: フィールドに非ASCII文字をふくめていることに注目してください。 
ここでは、含めたいバイト列がエンコードされている文字セットを指定して Header インスタンスを作成することによって実現しています。 
のちにこの Message インスタンスからフラットなテキストを生成するさいに、この Subject: フィールドはRFC 2047 準拠の適切な形式にエンコードされます。 
MIME 機能のついているメーラなら、このヘッダに埋めこまれた ISO-8859-1 文字をただしく表示するでしょう。 
以下は Header クラスの説明です: 
クラスHeader 
別の文字セットの文字列をふくむ MIME準拠なヘッダを作成します。 
オプション引数 s はヘッダの値の初期値です。 
これが None の場合 (デフォルト)、ヘッダの初期値は設定されません。 
もうひとつの目的は、これ以降 charset 引数を省略した append() メソッド呼び出しすべてにおける、デフォルト文字セットを決定するものです。 
コンストラクタにcharset が与えられない場合 (デフォルト)、初期値の s および以後の append() 呼び出しにおける文字セットとしてus-ascii が使われます。 行の最大長は maxlinelen によって明示的に指定できます。 
最初の行を (Subject: などの s に含まれないフィールドヘッダの責任をとるため) 短く切りとる場合、header_name にそのフィールド名を指定してください。 
ここで指定された文字は複数にわたる行の行頭に挿入されます。 オプション引数 errors は、append() メソッドにそのまま渡されます。 
この MIME ヘッダに文字列 s を追加します。 オプション引数 charset がもし与えられた場合、これはCharset インスタンス ( 
email.Charset を参照) か、あるいは文字セットの名前でなければなりません。 
この場合は Charset インスタンスに変換されます。 
この値が None の場合 (デフォルト)、コンストラクタで与えられた charset が使われます。 
s はバイト文字列か、Unicode 文字列です。 
こればバイト文字列 (isinstance(s, str) が真) の場合、charset はその文字列のエンコーディングであり、これが与えられた文字セットでうまくデコードできないときはUnicodeError が発生します。 いっぽう s が Unicode 文字列の場合、charset はその文字列の文字セットを決定するためのヒントとして使われます。 
この場合、RFC 2822準拠のヘッダは RFC 2047 の規則をもちいて作成され、Unicode 文字列は以下の文字セットを (この優先順位で) 適用してエンコードされます:us-ascii、 charset で与えられたヒント、それもなければ utf-8。 
最初の文字セットは UnicodeError をなるべくふせぐために使われます。 オプション引数 errors は unicode() 又は ustr.encode()の呼び出し時に使用し、デフォルト値は ``strict''です。 
メッセージヘッダを RFC に沿ったやり方でエンコードします。 おそらく長い行は折り返され、非ASCII部分は base64 またはquoted-printable エンコーディングで包含されるでしょう。 
オプション引数 splitchars には長いASCII行を分割する文字の文字列を指定し、 RFC 2822 のhighest level syntactic breaksの大まかなサポートの為に使用します。 
この引数は RFC 2047 でエンコードされた行には影響しません。 
Header クラスは、標準の演算子や組み込み関数をサポートするためのメソッドもいくつか提供しています。 
Header.encode() と同じです。 
str(aHeader) などとすると有用でしょう。 
組み込みの unicode() 関数の補助です。 
ヘッダを Unicode 文字列として返します。 
このメソッドは、ふたつの Header インスタンスどうしが等しいかどうか判定するのに使えます。 
このメソッドは、ふたつの Header インスタンスどうしが異なっているかどうかを判定するのに使えます。 
さらに、email.Header モジュールは以下のような便宜的な関数も提供しています。 
decode_header() によって返される 2要素タプルのリストからHeader インスタンスを作成します。 
decode_header() はヘッダの値をとってきて、(decoded_string, charset) という形式の 2要素タプルからなるリストを返します。 
ここで decoded_string はデコードされた文字列、charset はその文字セットです。 この関数はこれらのリストの項目から、Header インスタンスを返します。 
オプション引数 maxlinelen、header_name およびcontinuation_ws は Header コンストラクタに与えるものと同じです。 
Message.walk() メソッドを使うと、簡単にメッセージオブジェクトツリー内を次から次へとたどる (iteration) ことができます。 
email.Iterators モジュールはこのための高水準イテレータをいくつか提供します。 
このイテレータは msg 中のすべてのサブパートに含まれるペイロードをすべて順にたどっていき、ペイロード内の文字列を 1行ずつ返します。 
サブパートのヘッダはすべて無視され、Python 文字列でないペイロードからなるサブパートも無視されます。 
これは readline() を使って、ファイルからメッセージを (ヘッダだけとばして) フラットなテキストとして読むのにいくぶん似ているかもしれません。 
オプション引数 decode は、Message.get_payload()にそのまま渡されます。 typed_subpart_iterator 
以下の関数は役に立つデバッグ用ツールとして追加されたもので、パッケージとして公式なサポートのあるインターフェイスではありません。 
そのメッセージオブジェクト構造の content-type をインデントつきで表示します。 
たとえば: 
12.2.1.1 推奨されないメソッド 
Message クラスは、 email パッケージの中心となるクラスです。 これは email オブジェクトモデルの基底クラスになっています。 
Message はヘッダフィールドを検索したりメッセージ本体にアクセスするための核となる機能を提供します。 概念的には、Message オブジェクトには ヘッダ と ペイロード が格納されています。 
ヘッダは、RFC 2822 形式のフィールド名およびフィールド値がコロンで区切られたものです。 
コロンはフィールド名またはフィールド値のどちらにも含まれません。 ヘッダは大文字小文字を区別した形式で保存されますが、ヘッダ名が一致するかどうかの検査は大文字小文字を区別せずにおこなうことができます。 
Unix-From ヘッダまたはFrom_ ヘッダとして知られるエンベロープヘッダがひとつ存在することもあります。 
ペイロードは、単純なメッセージオブジェクトの場合は単なる文字列ですが、MIME コンテナ文書 (multipart/* またはmessage/rfc822 など) の場合は Message オブジェクトのリストになっています。 
Message オブジェクトは、メッセージヘッダにアクセスするためのマップ (辞書) 形式のインタフェイスと、ヘッダおよびペイロードの両方にアクセスするための明示的なインタフェイスを提供します。 
これにはメッセージオブジェクトツリーからフラットなテキスト文書を生成したり、一般的に使われるヘッダのパラメータにアクセスしたり、またオブジェクトツリーを再帰的にたどったりするための便利なメソッドを含みます。 
Message クラスのメソッドは以下のとおりです: クラスMessage 
コンストラクタは引数をとりません。 
メッセージ全体をフラットな文字列として返します。 
たとえば、これはデフォルトでは From で始まる行を変更してしまいます。 
以下の例のように Generator のインスタンスを生成して flatten() メソッドを直接呼び出せばより柔軟な処理を行う事ができます。 
as_string(unixfrom=True) と同じです。 
メッセージのペイロードが子 Message オブジェクトからなるリストであれば True を返し、そうでなければ False を返します。 
is_multipart() が False を返した場合は、ペイロードは文字列オブジェクトである必要があります。 
メッセージのエンベロープヘッダを unixfrom に設定します。 
これは文字列である必要があります。 get_unixfrom 
メッセージのエンベロープヘッダを返します。 
エンベロープヘッダが設定されていない場合は None が返されます。 
ペイロードにスカラーオブジェクト (文字列など) を格納したい場合は、かわりにset_payload() を使ってください。 
現在のペイロードへの参照を返します。 これは is_multipart() が Trueの場合 Message オブジェクトのリストになり、is_multipart() がFalse の場合は文字列になります。 
ペイロードがリストの場合、リストを変更することはそのメッセージのペイロードを変更することになります。 オプション引数の i がある場合、is_multipart() が True ならば get_payload() はペイロード中で 0 から数えて i 番目の要素を返します。 
i が0 より小さい場合、あるいはペイロードの個数以上の場合はIndexError が発生します。 
これ以外のエンコーディングが使われている場合、Content-Transfer-Encoding: ヘッダがない場合、あるいは曖昧なbase64データが含まれる場合は、ペイロードはそのまま (デコードされずに) 返されます。 
もしメッセージが multipart で decode フラグが True の場合はNone が返されます。 
decode のデフォルト値は False です。 
メッセージ全体のオブジェクトのペイロードを payload に設定します。 
ペイロードの形式をととのえるのは呼び出し側の責任です。 
オプションの charset はメッセージのデフォルト文字セットを設定します。 詳しくは set_charset() を参照してください。 
バージョン 2.2.2 で 変更 された仕様:charset 引数の追加 
ペイロードの文字セットを charset に変更します。 ここには Charsetインスタンス ( 
参照)、文字セット名をあらわす文字列、あるいは None のいずれかが指定できます。 
文字列を指定した場合、これは Charset インスタンスに変換されます。 
charset が None の場合、charset パラメータはContent-Type: ヘッダから除去されます。 
これ以外のものを文字セットとして指定した場合、TypeError が発生します。 ここでいうメッセージとは、charset.input_charset でエンコードされたtext/* 形式のものを仮定しています。 
これは、もし必要とあらばプレーンテキスト形式を変換するさいに charset.output_charset のエンコードに変換されます。 
MIME ヘッダ (MIME-Version:, Content-Type:, Content-Transfer-Encoding:)は必要に応じて追加されます。 
そのメッセージ中のペイロードの Charset インスタンスを返します。 バージョン 2.2.2 で 新たに追加 された仕様です。 
以下のメソッドは、メッセージの RFC 2822 ヘッダにアクセスするためのマップ (辞書) 形式のインタフェイスを実装したものです。 
これらのメソッドと、通常のマップ (辞書) 型はまったく同じ意味をもつわけではないことに注意してください。 
たとえば辞書型では、同じキーが複数あることは許されていませんが、ここでは同じメッセージヘッダが複数ある場合があります。 
また、辞書型では keys() で返されるキーの順序は保証されていませんが、Message オブジェクト内のヘッダはつねに元のメッセージ中に現れた順序、あるいはそのあとに追加された順序で返されます。 
複製されたものもふくめてヘッダ数の合計を返します。 
このメソッドは以下のように in 演算子で使われます: 
指定された名前のヘッダフィールドの値を返します。 name は最後にコロンをふくんでいてはいけません。 
そのヘッダがない場合は None が返され、KeyError 例外は発生しません。 注意: 指定された名前のフィールドがメッセージのヘッダに 2回以上現れている場合、どちらの値が返されるかは未定義です。 
ヘッダに存在するフィールドの値をすべて取り出したい場合は get_all() メソッドを使ってください。 
メッセージヘッダに name という名前の val という値をもつフィールドをあらたに追加します。 
このフィールドは現在メッセージに存在するフィールドのいちばん後に追加されます。 
注意: このメソッドでは、すでに同一の名前で存在するフィールドは上書きされません。 もしメッセージが名前 name をもつフィールドをひとつしか持たないようにしたければ、最初にそれを除去してください。 
たとえば: del msg['subject']msg['subject'] = 'PythonPythonPython!' 
メッセージのヘッダから、 name という名前をもつフィールドをすべて除去します。 
たとえこの名前をもつヘッダが存在していなくても例外は発生しません。 
メッセージが name という名前をもつヘッダフィールドを持っていれば真を、そうでなければ偽を返します。 
メッセージ中にあるすべてのヘッダのフィールド名のリストを返します。 
メッセージ中にあるすべてのフィールドの値のリストを返します。 
メッセージ中にあるすべてのヘッダのフィールド名とその値を2-タプルのリストとして返します。 
指定された名前をもつフィールドの値を返します。 
これは指定された名前がないときにオプション引数の failobj (デフォルトでは None) を返すことをのぞけば、__getitem__() と同じです。 
役に立つメソッドをいくつか紹介します: 
name の名前をもつフィールドのすべての値からなるリストを返します。 
該当する名前のヘッダがメッセージ中に含まれていない場合は failobj (デフォルトでは None) が返されます。 
拡張ヘッダ設定。 
このメソッドは __setitem__() と似ていますが、追加のヘッダ・パラメータをキーワード引数で指定できるところが違っています。 
パラメータの値が None のときはキーのみが追加されます。 例を示しましょう: 
こうするとヘッダには以下のように追加されます。 
ヘッダの置換。 
_name と一致するヘッダで最初に見つかったものを置き換えます。 このときヘッダの順序とフィールド名の大文字小文字は保存されます。 
一致するヘッダがない場合、 KeyError が発生します。 
そのメッセージの content-type を返します。 
返された文字列は強制的に小文字で maintype/subtype の形式に変換されます。 
メッセージ中に Content-Type: ヘッダがない場合、デフォルトのcontent-type は get_default_type() が返す値によって与えられます。 
RFC 2045 によればメッセージはつねにデフォルトの content-type をもっているので、get_content_type() はつねになんらかの値を返すはずです。 
RFC 2045 はメッセージのデフォルト content-type を、それが multipart/digest コンテナに現れているとき以外はtext/plain に規定しています。 あるメッセージがmultipart/digest コンテナ中にある場合、そのcontent-type は message/rfc822 になります。 
もし Content-Type: ヘッダが適切でない content-type 書式だった場合、RFC 2045 はそれのデフォルトを text/plain として扱うよう定めています。 
そのメッセージの主 content-type を返します。 
これは get_content_type() によって返される文字列の maintype 部分です。 
そのメッセージの副 content-type (sub content-type、subtype) を返します。 
これは get_content_type() によって返される文字列の subtype 部分です。 
デフォルトの content-type を返します。 
ほどんどのメッセージではデフォルトの content-type はtext/plain ですが、メッセージが multipart/digest コンテナに含まれているときだけ例外的に message/rfc822 になります。 
デフォルトの content-type を設定します。 ctype は text/plain あるいは message/rfc822である必要がありますが、強制ではありません。 
デフォルトの content-type はヘッダの Content-Type: には格納されません。 
メッセージの Content-Type: パラメータをリストとして返します。 
返されるリストは キー/値の組からなる 2要素タプルが連なったものであり、これらは "=" 記号で分離されています。 
"=" の左側はキーになり、右側は値になります。 パラメータ中に "=" がなかった場合、値の部分は空文字列になり、そうでなければその値は get_param() で説明されている形式になります。 
また、オプション引数 unquote がTrue (デフォルト) である場合、この値は unquote されます。 オプション引数 failobj は、Content-Type: ヘッダが存在しなかった場合に返すオブジェクトです。 
オプション引数 header にはContent-Type: のかわりに検索すべきヘッダを指定します。 
バージョン 2.2.2 で 変更 された仕様:unquote が追加されました 
メッセージの Content-Type: ヘッダ中のパラメータ param を文字列として返します。 
返り値は文字列か 3 要素のタプルで、タプルになるのはパラメータが RFC 2231 エンコードされている場合です。 
3 要素タプルの場合、各要素の値は(CHARSET, LANGUAGE, VALUE) の形式になっています。 
CHARSET と LAGUAGE は None になることがあり、その場合VALUE は us-ascii 文字セットでエンコードされているとみなさねばならないので注意してください。 
普段は LANGUAGE を無視できます。 この関数を使うアプリケーションが、パラメータが RFC 2231 形式でエンコードされているかどうかを気にしないのであれば、email.Utils.collapse_rfc2231_value() にget_param() の返り値を渡して呼び出すことで、このパラメータをひとつにまとめることができます。 
この値がタプルならばこの関数は適切にデコードされた Unicode 文字列を返し、そうでない場合は unquote された元の文字列を返します。 
たとえば: 
いずれの場合もパラメータの値は (文字列であれ 3要素タプルのVALUE 項目であれ) つねに unquote されます。 ただし、unquote が False に指定されている場合はunquote されません。 
バージョン 2.2.2 で 変更 された仕様:unquote 引数の追加、3要素タプルが返り値になる可能性あり 
Content-Type: ヘッダ中のパラメータを設定します。 
指定されたパラメータがヘッダ中にすでに存在する場合、その値はvalue に置き換えられます。 
オプション引数 language は RFC 2231 の言語を指定しますが、デフォルトではこれは空文字列となります。 
charset とlanguage はどちらも文字列である必要があります。 
指定されたパラメータを Content-Type: ヘッダ中から完全にとりのぞきます。 
ヘッダはそのパラメータと値がない状態に書き換えられます。 
requote が False でない限り (デフォルトでは True です)、すべての値は必要に応じて quote されます。 
オプション変数 header が与えられた場合、Content-Type: のかわりにそのヘッダが使用されます。 
type は maintype/subtype という形の文字列でなければなりません。 
それ以外の場合は ValueError が発生します。 このメソッドは Content-Type: ヘッダを置き換えますが、すべてのパラメータはそのままにします。 
そのメッセージ中の Content-Disposition: ヘッダにある、filename パラメータの値を返します。 目的のヘッダが欠けていたり、filename パラメータがない場合には failobj が返されます。 
返される文字列はつねに Utils.unquote() によって unquote されます。 get_boundary 
そのメッセージ中の Content-Type: ヘッダにある、boundary パラメータの値を返します。 
目的のヘッダが欠けていたり、boundary パラメータがない場合には failobj が返されます。 
返される文字列はつねに Utils.unquote() によって unquote されます。 
メッセージ中の Content-Type: ヘッダにある、boundary パラメータに値を設定します。 
そのメッセージ中の Content-Type: ヘッダにある、charset パラメータの値を返します。 値はすべて小文字に変換されます。 
メッセージ中に含まれる文字セットの名前をすべてリストにして返します。 
しかし、その subpart が Content-Type: をもってないか、charset がないか、あるいは MIME maintype が text でないいずれかの場合には、リストの要素として failobj が返されます。 
walk() メソッドは多目的のジェネレータで、これはあるメッセージオブジェクトツリー中のすべての part および subpart をわたり歩くのに使えます。 
Message オブジェクトはオプションとして 2つのインスタンス属性をとることができます。 これはある MIME メッセージからプレーンテキストを生成するのに使うことができます。 
MIME ドキュメントの形式では、ヘッダ直後にくる空行と最初の multipart 境界をあらわす文字列のあいだにいくらかのテキスト (訳注: preamble, 序文) を埋めこむことを許しています。 このテキストは標準的な MIME の範疇からはみ出しているので、MIME 形式を認識するメールソフトからこれらは通常まったく見えません。 
しかしメッセージのテキストを生で見る場合、あるいはメッセージをMIME 対応していないメールソフトで見る場合、このテキストは目に見えることになります。 preamble 属性は MIME ドキュメントに加えるこの最初の MIME 範囲外テキストを含んでいます。 
Parser があるテキストをヘッダ以降に発見したが、それはまだ最初の MIME 境界文字列が現れる前だった場合、パーザはそのテキストをメッセージの preamble 属性に格納します。 
を参照してください。 
epilogue 属性はメッセージの最後の MIME 境界文字列からメッセージ末尾までのテキストを含むもので、それ以外は preamble 属性と同じです。 注意: multipart メッセージからフラットなテキストを生成するとき、(標準的な Generator を使ったとして) もしそのメッセージに epilogue がない場合、最後の MIME 境界文字列のあとには改行文字が追加されません。 
もしそのメッセージオブジェクトが epilogue をもっており、それが改行文字から始まっていない場合、改行文字が MIME 境界文字列のあとに追加されます。 
これはややぶかっこうに見えますが、ほとんどの場合はこれでうまくいきます。 
要するに、もし multipart 境界のあとにかならず改行を入れるようにしたければ、epilogue に空文字列を入れておけばよいのです。 
12.2.1.1 推奨されないメソッド 
このパーザに文字列あるいはファイルオブジェクトを渡せば、パーザはそのオブジェクト構造の基底となる (root の) Message インスタンスを返します。 
簡単な非MIMEメッセージであれば、この基底オブジェクトのペイロードはたんにメッセージのテキストを格納する文字列になるでしょう。 
旧式の Parser API はメッセージ全体のテキストが文字列としてすでにメモリ上にあるか、それがローカルなファイルシステム上に存在しているときには問題ありません。 
FeedParser はメッセージを読み込むときに、そのストリームが入力待ちのためにブロックされるような場合 (ソケットから email メッセージを読み込む時など) に、より有効です。 
FeedParser は漸進的にメッセージを読み込み、解析します。 パーザを close したときには根っこ (root) のオブジェクトのみが返されます 
12.1 。 
このパーザは、ある制限された方法で拡張できます。 また、もちろん自分でご自分のパーザを完全に無から実装することもできます。 
email パッケージについているパーザと Message クラスの間に隠された秘密の関係はなにもありませんので、ご自分で実装されたパーザも、それが必要とするやりかたでメッセージオブジェクトツリーを作成することができます。 
...返されます 12.1 
Python 2.4 から導入された email パッケージ バージョン 3.0 では、旧式の Parser は FeedParser によって書き直されました。 
そのためパーザの意味論と得られる結果は 2つのパーザで同一のものになります。 
12.2.2.2 Parser クラス API 
email.Utils モジュールではいくつかの便利なユーティリティを提供しています。 
文字列 str 内のバックスラッシュを バックスラッシュ2つ に置換した新しい文字列を返します。 また、ダブルクォートは バックスラッシュ + ダブルクォートに置換されます。 
文字列 str を 逆クォートした新しい文字列を返します。 もし str の先頭あるいは末尾がダブルクォートだった場合、これらは単に切りおとされます。 
同様にもし str の先頭あるいは末尾が角ブラケット (、) だった場合も切りおとされます。 
アドレスをパーズします。 
To: や Cc: のようなアドレスをふくんだフィールドの値を与えると、構成部分の実名 と 電子メールアドレス を取り出します。 パーズに成功した場合、これらの情報をタプル(realname, email_address) にして返します。 
失敗した場合は 2要素のタプル ('', '') を返します。 
parseaddr() の逆で、実名と電子メールアドレスからなる2要素のタプル (realname, email_address) を引数にとり、To: あるいは Cc: ヘッダに適した形式の文字列を返します。 
タプル pair の第1要素が偽である場合、第2要素の値をそのまま返します。 
このメソッドは 2要素タプルのリストを parseaddr() と同じ形式で返します。 fieldvalues はたとえば Message.get_all() が返すような、ヘッダのフィールド値からなるシーケンスです。 
以下はある電子メールメッセージからすべての受け取り人を得る一例です: 
日付の解析に成功した場合、parsedate() は関数 time.mktime() に直接渡せる形式の9要素からなるタプルを返し、失敗した場合は None を返します。 
返されるタプルの 6、7、8番目のフィールドは有効ではないので注意してください。 
parsedate() と同様の機能を提供しますが、None または 10要素のタプルを返すところが違います。 
最初の 9つの要素は time.mktime() に直接渡せる形式のものであり、最後の 10番目の要素は、その日付の時間帯の UTC(グリニッジ標準時の公式な呼び名です) に対するオフセットです 
入力された文字列に時間帯が指定されていなかった場合、10番目の要素にはNone が入ります。 
タプルの 6、7、8番目のフィールドは有効ではないので注意してください。 
parsedate_tz() が返す 10要素のタプルを UTC のタイムスタンプに変換します。 
与えられた時間帯が None である場合、時間帯として現地時間 (localtime) が仮定されます。 
マイナーな欠点: mktime_tz() はまず tuple の最初の 8要素をlocaltime として変換し、つぎに時間帯の差を加味しています。 
夏時間を使っている場合には、これは通常の使用にはさしつかえないものの、わずかな誤差を生じるかもしれません。 
日付を RFC 2822 形式の文字列で返します。 
例: Fri, 09 Nov 2001 01:08:47 -0000 
オプションとして float 型の値をもつ引数 timeval が与えられた場合、これは time.gmtime() および time.localtime() に渡されます。 
それ以外の場合、現在の時刻が使われます。 
これは (HTTP などの) いくつかのプロトコルで必要です。 
この機能は localtime が False のときのみ適用されます。 
RFC 2822 準拠形式の Message-ID: ヘッダに適した文字列を返します。 
オプション引数 idstring が文字列として与えられた場合、これはメッセージ ID の一意性を高めるのに利用されます。 
RFC 2231 に従って文字列 s をデコードします。 
RFC 2231 に従って s をエンコードします。 
オプション引数 charset および language が与えられた場合、これらは文字セット名と言語名として使われます。 
もしこれらのどちらも与えられていない場合、s はそのまま返されます。 
charset は与えられているが language が与えられていない場合、文字列 s は language の空文字列を使ってエンコードされます。 
オプション引数 errors は built-in である unicode() 関数の引数 errors に渡されます。 このデフォルト値は replace となっています。 
オプション引数 fallback_charset は、もし RFC 2231 ヘッダの使用している文字セットが Python の知っているものではなかった場合の非常用文字セットとして使われます。 デフォルトでは、この値は us-ascii です。 
RFC 2231 に従ってパラメータのリストをデコードします。 params は (content-type, string-value) のような形式の2要素からなるタプルです。 
バージョン 2.4 で 変更 された仕様:dump_address_pair() 関数は撤去されました。 かわりに formataddr() 関数を使ってください。 
バージョン 2.4 で 変更 された仕様:decode() 関数は撤去されました。 かわりに Header.decode_header() メソッドを使ってください。 
バージョン 2.4 で 変更 された仕様:encode() 関数は撤去されました。 
かわりに Header.encode() メソッドを使ってください。 
... に対するオフセットです 
注意: この時間帯のオフセット値は time.timezone の値と符合が逆です。 
これは time.timezone が POSIX 標準に準拠しているのに対して、こちらは RFC 2822 に準拠しているからです。 
12.2.1 電子メールメッセージの表現 
email パッケージは電子メールのメッセージを管理するライブラリです。 これには MIME やそれ以外の RFC 2822ベースのメッセージ文書もふくまれます。 
このパッケージはいくつかの古い標準パッケージ、 
などにふくまれていた機能のほとんどを持ち、くわえて標準ではなかった mimecntl などの機能もふくんでいます。 
このパッケージは、とくに電子メールのメッセージをSMTP (RFC 2821) サーバに送信するために作られているというわけではありません。 それは 
モジュールの機能です。 
email パッケージは RFC 2822 に加えて、RFC 2045, RFC 2046, RFC 2047および RFC 2231 など MIME 関連の RFC をサポートしており、できるかぎり RFC に準拠することをめざしています。 email パッケージの一番の特徴は、電子メールの内部表現であるオブジェクトモデル と、電子メールメッセージの解析および生成とを分離していることです。 
email パッケージを使うアプリケーションは基本的にはオブジェクトを処理することができます。 メッセージに子オブジェクトを追加したり、メッセージから子オブジェクトを削除したり、内容を完全に並べかえたり、といったことができます。 
フラットなテキスト文書からオブジェクトモデルへの変換、またそこからフラットな文書へと戻す変換はそれぞれ別々の解析器 (パーサ) と生成器 (ジェネレータ) が担当しています。 
また、一般的な MIME オブジェクトタイプのいくつかについては手軽なサブクラスが存在しており、メッセージフィールド値を抽出したり解析したり、RFC 準拠の日付を生成したりなどのよくおこわれるタスクについてはいくつかの雑用ユーティリティもついています。 
この場合も上と似たような作業順序になるでしょう。 またここには email パッケージが提供するすべてのクラスおよびモジュールに関する説明と、email パッケージを使っていくうえで遭遇するかもしれない例外クラス、いくつかの補助ユーティリティ、そして少々のサンプルも含まれています。 
古い mimelib や前バージョンのemail パッケージののユーザのために、現行バージョンとの違いと移植についての節も設けてあります。 
SMTP プロトコル クライアント. 
12.2.1 電子メールメッセージの表現 
このモジュールでは RFC 3490 (アプリケーションにおける国際化ドメイン名, IDNA: Internationalized Domain Names inApplications) および RFC 3492 (Nameprep: 国際化ドメイン名 (IDN) のための stringprep プロファイル) を実装しています。 
このモジュールは punycode エンコーディングおよびstringprep の上に構築されています。 
これらの RFC はともに、非 ASCII 文字の入ったドメイン名をサポートするためのプロトコルを定義しています。 
(``www.Alliancefranaise.nu'' のような) 非 ASCII 文字を含むドメイン名は、 ASCIIと互換性のあるエンコーディング (ACE、``www.xn-alliancefranaise-npb.nu'' のような形式) に変換されます。 
ドメイン名の ACE 形式は、DNS クエリ、HTTP Host: フィールドなどといった、プロトコル中で任意の文字を使えないような全ての局面で用いられます。 
この変換はアプリケーション内で行われます; 可能ならユーザからは不可視となります: アプリケーションは Unicode ドメインラベルをワイヤ上に載せる際に IDNA に、 ACE ドメインラベルをユーザに提供する前に Unicode に、それぞれ透過的に変換しなければなりません。 
Python ではこの変換をいくつかの方法でサポートします: idnacodec は Unicode と ACE 間の変換を行います。 
さらに、socket モジュールは Unicode ホスト名を ACE に透過的に変換するため、アプリケーションはホスト名を socket モジュールに渡す際にホスト名の変換に煩わされることがありません。 
(逆引きなどによって) ワイヤ越しにホスト名を受信する際、Unicodeへの自動変換は行われません: こうしたホスト名をユーザに提供したいアプリケーションでは、Unicode にデコードしてやる必要があります。 
encodings.idna ではまた、nameprep 手続きを実装しています。 nameprep はホスト名に対してある正規化を行って、国際化ドメイン名で大小文字を区別しないようにするとともに、類似の文字を一元化します。 
nameprep 関数は必要なら直接使うこともできます。 
label を nameprep したバージョンを返します。 
現在の実装ではクエリ文字列を仮定しているので、 AllowUnassigned は真です。 
RFC 3490 仕様に従ってラベルを ASCIIに変換します。 UseSTD3ASCIIRules は偽であると仮定します。 
RFC 3490 仕様に従ってラベルを Unicode に変換します。 
errno 値を背後のシステムにおける文字列表現に対応付ける辞書です。 
例えば、errno.errorcode[errno.EPERM] は 'EPERM'に対応付けられます。 
数値のエラーコードをエラーメッセージに変換するには、os.strerror() を使ってください。 
以下のリストの内、現在のプラットフォームで使われていないシンボルはモジュール上で定義されていません。 
定義されているシンボルだけを挙げたリストは errno.errorcode.keys() として取得することができます。 
取得できるシンボルには以下のようなものがあります: 
許可されていない操作です (Operation not permitted) 
ファイルまたはディレクトリがありません (No such file or directory) 
指定したプロセスが存在しません (No such process) 
割り込みシステムコールです (Interrupted system call) 
I/O エラーです (I/O error) 
そのようなデバイスまたはアドレスはありません (No such device or address) 
引数リストが長すぎます (Arg list too long) 
実行形式にエラーがあります (Exec format error) 
ファイル番号が間違っています (Bad file number) 
子プロセスがありません (No child processes) 
再試行してください (Try again) 
空きメモリがありません (Out of memory) 
許可がありません (Permission denied) 
不正なアドレスです (Bad address) 
ブロックデバイスが必要です (Block device required) 
そのデバイスまたは資源は使用中です (Device or resource busy) 
ファイルがすでに存在します(File exists) 
デバイス間のリンクです (Cross-device link) 
そのようなデバイスはありません (No such device) 
ディレクトリではありません (Not a directory) 
ディレクトリです (Is a directory) 
無効な引数です (Invalid argument) 
ファイルテーブルがオーバフローしています (File table overflow) 
開かれたファイルが多すぎます (Too many open files) 
タイプライタではありません (Not a typewriter) 
テキストファイルが使用中です (Text file busy) 
ファイルが大きすぎます (File too large) 
デバイス上に空きがありません (No space left on device) 
不正なシークです (Illegal seek) 
読み出し専用ファイルシステムです (Read-only file system) 
リンクが多すぎます (Too many links) 
パイプが壊れました (Broken pipe) 
数学引数が関数の定義域を越えています (Math argument out of domain of func) 
表現できない数学演算結果になりました (Math result not representable) 
リソースのデッドロックが起きます (Resource deadlock would occur) 
ファイル名が長すぎます (File name too long) 
レコードロッキングが利用できません (No record locks available) 
実装されていない機能です (Function not implemented) 
ディレクトリが空ではありません (Directory not empty) 
これ以上シンボリックリンクを追跡できません (Too many symbolic links encountered) 
操作がブロックします (Operation would block) 
指定された型のメッセージはありません (No message of desired type) 
識別子が除去されました (Identifier removed) 
チャネル番号が範囲を超えました (Channel number out of range) 
レベル 2 で同期がとれていません (Level 2 not synchronized) 
レベル 3 で終了しました (Level 3 halted) 
レベル 3 でリセットしました (Level 3 reset) 
リンク番号が範囲を超えています (Link number out of range) 
プロトコルドライバが接続されていません (Protocol driver not attached) 
CSI 構造体がありません (No CSI structure available) 
レベル 2 で終了しました (Level 2 halted) 
無効な変換です (Invalid exchange) 
無効な要求記述子です (Invalid request descriptor) 
変換テーブルが一杯です (Exchange full) 
陰極がありません (No anode) 
無効なリクエストコードです (Invalid request code) 
無効なスロットです (Invalid slot) 
ファイルロックにおけるデッドロックエラーです (File locking deadlock error) 
フォントファイル形式が間違っています (Bad font file format) 
ストリーム型でないデバイスです (Device not a stream) 
利用可能なデータがありません (No data available) 
時間切れです (Timer expired) 
streams リソースを使い切りました (Out of streams resources) 
計算機はネットワーク上にありません (Machine is not on the network) 
パッケージがインストールされていません (Package not installed) 
対象物は遠隔にあります (Object is remote) 
リンクが切られました (Link has been severed) 
Advertise エラーです (Advertise error) 
Srmount エラーです (Srmount error) 
送信時の通信エラーです (Communication error on send) 
プロトコルエラーです (Protocol error) 
多重ホップを試みました (Multihop attempted) 
RFS 特有のエラーです (RFS specific error) 
データメッセージではありません (Not a data message) 
定義されたデータ型にとって大きすぎる値です (Value too large for defined data type) 
名前がネットワーク上で一意でありません (Name not unique on network) 
ファイル記述子の状態が不正です (File descriptor in bad state) 
遠隔のアドレスが変更されました (Remote address changed) 
必要な共有ライブラリにアクセスできません (Can not access a needed shared library) 
壊れた共有ライブラリにアクセスしています (Accessing a corrupted shared library) 
a.out の .lib セクションが壊れています (.lib section in a.out corrupted) 
リンクを試みる共有ライブラリが多すぎます (Attempting to link in too many shared libraries) 
共有ライブラリを直接実行することができません (Cannot exec a shared library directly) 
不正なバイト列です (Illegal byte sequence) 
割り込みシステムコールを復帰しなければなりません (Interrupted system call should be restarted) 
ストリームパイプのエラーです (Streams pipe error) 
ユーザが多すぎます (Too many users) 
非ソケットに対するソケット操作です (Socket operation on non-socket) 
目的アドレスが必要です (Destination address required) 
メッセージが長すぎます (Message too long) 
ソケットに対して不正なプロトコル型です (Protocol wrong type for socket) 
利用できないプロトコルです (Protocol not available) 
サポートされていないプロトコルです (Protocol not supported) 
サポートされていないソケット型です (Socket type not supported) 
通信端点に対してサポートされていない操作です (Operation not supported on transport endpoint) 
サポートされていないプロトコルファミリです (Protocol family not supported) 
プロトコルでサポートされていないアドレスファミリです (Address family not supported by protocol) 
アドレスは使用中です (Address already in use) 
要求されたアドレスを割り当てできません (Cannot assign requested address) 
ネットワークがダウンしています (Network is down) 
ネットワークに到達できません (Network is unreachable) 
リセットによってネットワーク接続が切られました (Network dropped connection because of reset) 
ソフトウェアによって接続が終了されました (Software caused connection abort) 
接続がピアによってリセットされました (Connection reset by peer) 
バッファに空きがありません (No buffer space available) 
通信端点がすでに接続されています (Transport endpoint is already connected) 
通信端点が接続されていません (Transport endpoint is not connected) 
通信端点のシャットダウン後は送信できません (Cannot send after transport endpoint shutdown) 
参照が多すぎます: 接続できません (Too many references: cannot splice) 
接続がタイムアウトしました (Connection timed out) 
接続を拒否されました (Connection refused) 
ホストはシステムダウンしています (Host is down) 
ホストへの経路がありません (No route to host) 
すでに処理中です (Operation already in progress) 
現在処理中です (Operation now in progress) 
無効な NFS ファイルハンドルです (Stale NFS file handle) 
XENIX 名前付きファイルではありません (Not a XENIX named type file) 
XENIX セマフォは利用できません (No XENIX semaphores available) 
名前付きファイルです (Is a named type file) 
遠隔側の I/O エラーです (Remote I/O error) 
ディスククオータを超えました (Quota exceeded) 
例外はクラスオブジェクトです。 
例外はモジュール exceptions で定義されています。 
このモジュールを明示的にインポートする必要はありません:例外は exceptions モジュールと同様に組み込み名前空間で与えられます。 
注意:過去の Python のバージョンでは、文字列の例外がサポートされていました。 
これはプログラマに対して、例外処理を指定する際に、文字列ではなく例外名を使わせるための変更です。 組み込み例外の文字列値は全てその名前となりますが、ユーザ定義の例外やライブラリモジュールで定義される例外についてもそうするように要求しているわけではありません。 
文の中で、except 
節を使って特定の例外クラスについて記述した場合、その節は指定した例外クラスから導出されたクラスも扱います (指定した例外クラスを導出した元のクラスは含みません)サブクラス化の関係にない例外クラスが二つあった場合、それらに同じ名前を付けたとしても、等しくなることはありません。 
以下に列挙した組み込み例外はインタプリタや組み込み関数によって生成されます。 
文の二つ目の引数です。 
文字列の例外の場合、関連値自体は except 節 (あった場合)の二つ目の引数として与えた名前を持つ変数に記憶されます。 
クラス例外の場合、この値は例外クラスのインスタンスです。 
例外が標準のルートクラスである Exception から導出された場合、関連値は例外インスタンスの args 属性中に他の属性と同様に置かれます。 ユーザによるコードも組み込み例外を送出することができます。 
例外を定義する上での詳しい情報は、 
の``ユーザ定義の例外'' の項目にあります。 
以下の例外クラスは他の例外クラスの基底クラスとしてのみ使われます。 
例外のルートクラスです。 
全ての組み込み例外はこのクラスから導出されています。 
全てのユーザ定義例外はこのクラスから導出されるべきですが、(今のところまだ) それは強制ではありません。 
str() をこのクラス (またはほとんどの導出クラス) のインスタンスに適用すると、引数を文字列にしたが返されるか、インスタンスのコンストラクタが引数なしの場合には空の文字列が返されます。 
インスタンスをシーケンスとして使うと、コンストラクタに渡された引数にアクセスすることができます (古いコードとの互換性のために便利です)。 
引数はまた、インスタンスの args 属性として、タプルで得ることもできます。 
StopIteration および SystemExit 以外の、全ての組み込み例外の基底クラスです。 StandardError 自体はルートクラス Exceptionから導出されています。 
算術上の様々なエラーにおいて送出される組み込み例外: OverflowError、ZeroDivisionError、FloatingPointError の基底クラスです。 
マップ型またはシーケンス型に使ったキーやインデクスが無効な値の場合に送出される例外:IndexError、KeyErrorの基底クラスです。 
sys.setdefaultencoding()によって直接送出されることもあります。 
Python システムの外部で起こっているはずの例外: IOError、OSError の基底クラスです。 
この型の例外が 2 つの要素をもつタプルで生成された場合、最初の要素はインスタンスの errno 属性で得ることができます (この値はエラー番号と見なされます)。 二つめの要素は strerror 属性です (この値は通常、エラーに関連するメッセージです)。 
タプル自体は args 属性から得ることもできます。 バージョン 1.5.2 で 新たに追加 された仕様です。 
EnvironmentError 例外が 3 要素のタプルで生成された場合、最初の 2 つの要素は上と同様に得ることができる一方、3 つ目の要素はfilename 属性で得ることができます。 
しかしながら、以前のバージョンとの互換性のために、args 属性にはコンストラクタに渡した最初の 2 つの引数からなる 2 要素のタプルしか含みません。 この例外が 3 つ以外の引数で生成された場合、filename 属性はNone になります。 
この例外が 2 または 3 つ以外の引数で生成された場合、errno および strerror 属性もNone になります。 
後者のケースでは、args がコンストラクタに与えた引数をそのままタプルの形で含んでいます。 
以下の例外は実際に送出される例外です。 
assert 文が失敗した場合に送出されます。 
属性の参照や代入が失敗した場合に送出されます。 
(対照のオブジェクトが属性の参照や属性の代入をまったくサポートしていない場合にはTypeError が送出されます。 ) 
浮動小数点演算が失敗した場合に送出されます。 
この例外はどの Pythonのバージョンでも常に定義されていますが、Python が --with-fpectl オプションをつけた状態に設定されているか、pyconfig.h ファイルにシンボルWANT_SIGFPE_HANDLER が定義されている場合にのみ送出されます。 
(print 文、組み込みの open() またはファイルオブジェクトに対するメソッドといった) I/O 操作が、例えば``ファイルが存在しません'' や ``ディスクの空き領域がありません''といった I/O に関連した理由で失敗した場合に送出されます。 このクラスは EnvironmentError から導出されています。 
この例外クラスのインスタンス属性に関する情報は上記の EnvironmentError に関する議論を参照してください。 
import 文でモジュール定義を見つけられなかった場合や、from ... import 文で指定した名前をインポートすることができなかった場合に送出されます。 
シーケンスのインデクス指定がシーケンスの範囲を超えている場合に送出されます。 
(スライスのインデクスはシーケンスの範囲に収まるように暗黙のうちに調整されます; インデクスが通常の整数でない場合、TypeErrorが送出されます。 ) 
マップ型 (辞書型) オブジェクトのキーが、オブジェクトのキー集合内に見つからなかった場合に送出されます。 
ユーザが割り込みキー (通常は Control-C または Delete キーです) を押した場合に送出されます。 
割り込みが起きたかどうかはインタプリタの実行中に定期的に調べられます。 組み込み関数 input() や raw_input() がユーザの入力を待っている間に割り込みキーを押しても、この例外が送出されます。 
ある操作中にメモリが不足したが、その状況は (オブジェクトをいくつか消去することで) まだ復旧可能かもしれない場合に送出されます。 
例外に関連づけられた値は、どの種の (内部) 操作がメモリ不足になっているかを示す文字列です。 背後にあるメモリ管理アーキテクチャ (C のmalloc() 関数) によっては、インタプリタが常にその状況を完璧に復旧できるとはかぎらないので注意してください; プログラムの暴走が原因の場合にも、やはり実行スタックの追跡結果を出力できるようにするために例外が送出されます。 
ローカルまたはグローバルの名前が見つからなかった場合に送出されます。 
これは非限定の名前のみに適用されます。 
関連付けられた値は見つからなかった名前を含むエラーメッセージです。 
この例外は RuntimeError から導出されています。 
ユーザ定義の基底クラスにおいて、そのクラスの導出クラスにおいてオーバライドすることが必要な抽象化メソッドはこの例外を送出しなくてはなりません。 バージョン 1.5.2 で 新たに追加 された仕様です。 
このクラスは EnvironmentError から導出されており、主に 
モジュールの os.error 例外で使われています。 
例外に関連付けられる可能性のある値については、上記の EnvironmentError を参照してください。 バージョン 1.5.2 で 新たに追加 された仕様です。 
算術演算の結果、表現するには大きすぎる値になった場合に送出されます。 
これは長整数の演算では起こりません (長整数の演算ではむしろMemoryError が送出されることになるでしょう)。 
C では浮動小数点演算における例外処理の標準化が行われていないので、ほとんどの浮動小数点演算もチェックされていません。 
通常の整数では、オーバフローを起こす全ての演算がチェックされます。 例外は左シフトで、典型的なアプリケーションでは左シフトのオーバフローでは例外を送出するよりもむしろ、オーバフローしたビットを捨てるようにしています。 
弱参照については 
モジュールを参照してください。 バージョン 2.2 で 新たに追加 された仕様:以前は 
.ReferenceError例外として知られていました。 
他のカテゴリに分類できないエラーが検出された場合に送出されます。 
関連付けられた値は何が問題だったのかをより詳細に示す文字列です。 
(この例外はほとんど過去のバージョンのインタプリタにおける遺物です;この例外はもはやあまり使われることはありません) 
パーザが構文エラーに遭遇した場合に送出されます。 
インタプリタが内部エラーを発見したが、その状況は全ての望みを棄てさせるほど深刻ではないように思われる場合に送出されます。 
この例外は sys.exit() 関数によって送出されます。 
この例外が処理されなかった場合、Python インタプリタは終了します; スタックのトレースバックは全く印字されません。 
即座に終了することが真に強く必要であるとき(例えば、fork() を呼んだ後の子プロセス内) にはos._exit() 関数を使うことができます。 
組み込み演算または関数が適切でない型のオブジェクトに対して適用された際に送出されます。 
関連付けられる値は型の不整合に関して詳細を述べた文字列です。 
関数やメソッド内のローカルな変数に対して参照を行ったが、その変数には値がバインドされていなかった際に送出されます。 
NameErrorのサブクラスです。 バージョン 2.0 で 新たに追加 された仕様です。 
Unicode に関するエンコードまたはデコードのエラーが発生した際に送出されます。 
ValueError のサブクラスです。 バージョン 2.0 で 新たに追加 された仕様です。 
Unicode 関連のエラーがエンコード中に発生した際に送出されます。 
UnicodeError のサブクラスです。 バージョン 2.3 で 新たに追加 された仕様です。 
Unicode 関連のエラーがデコード中に発生した際に送出されます。 
Unicode 関連のエラーがコード翻訳に発生した際に送出されます。 
組み込み演算や関数が、正しい型だが適切でない値を受け取った場合、および IndexError のように、より詳細な説明のできない状況で送出されます。 
Windows 特有のエラーか、エラー番号が errno 値に対応しない場合に送出されます。 
除算またモジュロ演算における二つ目の引数がゼロであった場合に送出されます。 
関連付けられている値は文字列で、その演算における被演算子の型を示します。 
以下の例外は警告カテゴリとして使われます; 詳細については 
モジュールを参照してください。 
警告カテゴリの基底クラスです。 
ユーザコードによって生成される警告の基底クラスです。 
廃用された機能に対する警告の基底クラスです。 
将来廃用されることになっている機能に対する警告の基底クラスです。 
曖昧な構文に対する警告の基底クラスです。 
あいまいなランタイム挙動に対する警告の基底クラスです。 
将来意味構成が変わることになっている文の構成に対する警告の基底クラスです。 
組み込み例外のクラス階層は以下のようになっています: 
Exception+-- SystemExit+-- StopIteration+-- StandardError| +-- KeyboardInterrupt| +-- ImportError| +-- EnvironmentError| | +-- IOError| | +-- OSError| | +-- WindowsError| +-- EOFError| +-- RuntimeError| | +-- NotImplementedError| +-- NameError| | +-- UnboundLocalError| +-- AttributeError| +-- SyntaxError| | +-- IndentationError| | +-- TabError| +-- TypeError| +-- AssertionError| +-- LookupError| | +-- IndexError| | +-- KeyError| +-- ArithmeticError| | +-- OverflowError| | +-- ZeroDivisionError| | +-- FloatingPointError| +-- ValueError| | +-- UnicodeError| | +-- UnicodeEncodeError| | +-- UnicodeDecodeError| | +-- UnicodeTranslateError| +-- ReferenceError| +-- SystemError| +-- MemoryError+---Warning+-- UserWarning+-- DeprecationWarning+-- PendingDeprecationWarning+-- SyntaxWarning+-- OverflowWarning (2.4では生成されません。 2.5では無くなります)+-- RuntimeWarning+-- FutureWarning 
このモジュールでは、ファイル記述子 (file descriptor) に基づいたファイル制御および I/O 制御を実現します。 このモジュールは、 Unix のルーチンである fcntl() および ioctl() へのインタフェースです。 
このモジュール内の全ての関数はファイル記述子 fd を最初の引数に取ります。 
この値は sys.stdin.fileno() が返すような整数のファイル記述子でも、sys.stdin 自体のような、純粋にファイル記述子だけを返す fileno() メソッドを提供しているファイルオブジェクトでもかまいません。 このモジュールでは以下の関数を定義しています: 
要求された操作をファイル記述子 fd (または fileno() メソッドを提供しているファイルオブジェクト) に対して実行します。 操作は op で定義され、オペレーティングシステム依存です。 
これらの操作コードは fcntl モジュール内にもあります。 
引数 arg はオプションで、標準では整数値 0 です。 
この引数を与える場合、整数か文字列の値をとります。 
引数が無いか整数値の場合、この関数の戻り値は C 言語のfcntl() を呼び出した際の整数の戻り値になります。 
引数が文字列の場合には、 
.pack() で作られるようなバイナリの構造体を表します。 
バイナリデータはバッファにコピーされ、そのアドレスがC 言語の fcntl() 呼び出しに渡されます。 
呼び出しが成功した後に戻される値はバッファの内容で、文字列オブジェクトに変換されています。 
返される文字列は arg 引数と同じ長さになます。 
この値は 1024 バイトに制限されています。 
オペレーティングシステムからバッファに返される情報の長さが 1024 バイトよりも大きい場合、大抵はセグメンテーション違反となるか、より不可思議なデータの破損を引き起こします。 fcntl() が失敗した場合、IOError が送出されます。 
ファイル記述子 fd (fileno() メソッドを提供しているファイルオブジェクトも含む) に対してロック操作 op を実行します。 
詳細は Unix マニュアルの 
flock(3) を参照してください(システムによっては、この関数は fcntl() を使ってエミュレーションされています)。 
本質的に fcntl() によるロッキングの呼び出しをラップしたものです。 
fd はロックまたはアンロックするファイルのファイル記述子で、operation は以下の値: 
LOCK_UN - アンロック 
LOCK_SH - 共有ロックを取得 
LOCK_EX - 排他的ロックを取得 
のうちいずれかになります。 operation が LOCK_SH または LOCK_EXの場合、LOCK_NB とビット OR にすることでロック取得時にブロックしないようにすることができます。 
LOCK_NB が使われ、ロックが取得できなかった場合、IOError が送出され、例外は errno 属性を持ち、その値は EACCESSまたは EAGAIN になります (オペレーティングシステムに依存します; 可搬性のため、両方の値をチェックしてください)。 
少なくともいくつかのシステムでは、 ファイル記述子が参照しているファイルが書き込みのために開かれている場合、LOCK_EXだけしか使うことができません。 
length はロックを行いたいバイト数、start はロック領域先頭の whence からの相対的なバイトオフセット、whence は fileobj.seek() と同じで、具体的には: 
0 - ファイル先頭からの相対位置(SEEK_SET) 
1 - 現在のバッファ位置からの相対位置(SEEK_CUR) 
2 - ファイルの末尾からの相対位置(SEEK_END) 
start の標準の値は 0 で、ファイルの先頭から開始することを意味します。 
whence の標準の値も 0 です。 
以下に (全ての SVR4 互換システムでの) 例を示します: 
最初の例では、戻り値 rv は整数値を保持しています; 二つ目の例では文字列値を保持しています。 
lockdata 変数の構造体レイアウトはシステム依存です -- 従って flock() を呼ぶ方がベターです。 
filecmp モジュールでは、ファイルおよびディレクトリを比較するため、様々な時間/正確性のトレードオフに関するオプションを備えた関数を定義しています。 filecmp モジュールでは以下の関数を定義しています: 
名前が f1 および f2 のファイルを比較し、二つのファイルが同じらしければ True を返し、そうでなければ false を返します。 
shallow が与えられておりかつ偽でなければ、os.stat()の返すシグネチャが一致するファイルは同じであると見なされます。 バージョン 2.3 で 変更 された仕様:use_statcache は廃止され、指定しても無視されます。 
のキャッシュから古いファイル stat 値が使われます。 可搬性と効率のために、個の関数は外部プログラムを一切呼び出さないので注意してください。 
ファイル名からなる 3つのリスト: match、mismatch、errors を返します。 
このモジュールは標準入力やファイルの並びにまたがるループを素早く書くためのヘルパークラスと関数を提供しています。 典型的な使い方は以下の通りです: 
このプログラムはsys.argv[1:]に含まれる全てのファイルをまたいで繰り返します。 もし該当するものがなければ、sys.stdinがデフォルトとして扱われます。 
ファイル名として'-'が与えられた場合も、sys.stdinに置き換えられます。 
別のファイル名リストを使いたい時には、input()の最初の引数にリストを与えます。 
FileInputクラスのインスタンスを作ります。 
生成されたインスタンスは、このモジュールの関数群が利用するグローバルな状態として利用されます。 
この関数への引数はFileInputクラスのコンストラクタへ渡されます。 
以下の関数はinput()関数によって作られたグローバルな状態を利用します。 アクティブな状態が無い場合には、RuntimeErrorが発生します。 
現在読み込み中のファイル名を返します。 
一行目が読み込まれる前はNoneを返します。 
最後に読み込まれた行の、累積した行番号を返します。 
1行目が読み込まれる前は0を返します。 
最後のファイルの最終行が読み込まれた後には、その行の行番号を返します。 
現在のファイル中での行番号を返します。 
1行目が読み込まれる前は0を返します。 
最後のファイルの最終行が読み込まれた後には、その行のファイル中での行番号を返します。 
最後に読み込まれた行がファイルの1行目ならTrue、そうでなければFalseを返します。 
最後に読み込まれた行がsys.stdinから読まれていればTrue、そうでなければFalseを返します。 
ファイル名は次のファイルの最初の行が読み込まれるまで変更されません。 
最初の行の読み込みが行われるまでは、この関数は呼び出されても何もしませんので、最初のファイルをスキップするために利用することはできません。 
最後のファイルの最終行が読み込まれた後にも、この関数は呼び出されても何もしません。 
シーケンスを閉じます。 
このモジュールのシーケンスの振舞いを実装しているクラスのサブクラスを作ることもできます。 
クラスFileInput 
FileInputクラスはモジュールの関数に対応するメソッドfilename()、lineno()、fileline()、isfirstline()、isstdin()、nextfile()、close()を実装しています。 
それに加えて、次の入力行を返すreadline()メソッドと、シーケンスの振舞いの実装をしている__getitem__()メソッドがあります。 
シーケンスはシーケンシャルに読み込むことしかできません。 つまりランダムアクセスとreadline()を混在させることはできません。 
その場で保存するオプション機能: キーワード引数 
inplace=1 が input()かFileInputクラスのコンストラクタに渡された場合には、入力ファイルはバックアップファイルに移動され、標準出力が入力ファイルに設定されます(バックアップファイルと同じ名前のファイルが既に存在していた場合には、警告無しに置き替えられます)。 これによって入力ファイルをその場で書き替えるフィルタを書くことができます。 
キーワード引数 
その場で保存する機能は、標準入力を読み込んでいる間は無効にされます。 
警告: 現在の実装はMS-DOSの8+3ファイルシステムでは動作しません。 
このモジュールのルーチンを使うと、Pythonプログラムからファインダが持ついくつかの機能へアクセスできます。 
これらの機能はファインダへのAppleEvent 
ファインダにfileを起動するように命令します。 
起動が意味するものはfileに依存します。 アプリケーションなら起動しますし、フォルダなら開かれ、文書なら適切なアプリケーションで開かれます。 
ファインダにファイルを印刷するよう命令します。 
実際の動作はファイルを選択し、ファインダのファイルメニューから印刷コマンドを使うのと同じです。 
ファインダにファイルかフォルダであるfileをフォルダdestdirにコピーするよう命令します。 
この関数は新しいファイルを示すAliasオブジェクトを返します。 
ファインダにファイルかフォルダであるfileをフォルダdestdirに移動するように命令します。 
マシンがサポートしていれば、ファインダにMacintoshをスリープさせるよう命令します。 
ファインダに、マシンを適切に再起動するよう命令します。 
ファインダに、マシンを適切にシャットダウンするよう命令します。 
を使うのに必要なシンボル定数が定義されています(上記参照);これらは名前の接頭辞"FL_"が省かれていることを除いて、Cのヘッダファイルforms.hに定義されているものと同じです。 
定義されている名称の完全なリストについては、モジュールのソースをご覧ください。 
お勧めする使い方は以下の通りです: 
へのインターフェースを提供します。 
FORMSライブラリのソースはanonymous ftp "ftp.cs.ruu.nl"のSGI/FORMSディレクトリから入手できます。 
最新のテストはバージョン2.0bで行いました。 ほとんどの関数は接頭辞の"fl_"を取ると、対応するCの関数名になります。 
ライブラリで使われる定数は後述の 
しかし、GLイベントハンドルへのFORMSインターフェースが利用可能で、純粋なGLウィンドウにFORMSを組み合わせることができます。 
注意: flをインポートすると、GLの関数foreground()とFORMSのルーチンfl_init()を呼び出します。 
このモジュールには、FORMSライブラリ(上記の 
このモジュールはIRIS Font Managerライブラリへのアクセスを提供します。 
フォントハンドルオブジェクトを返します。 fmfindfont(fontname)を呼び出します。 
利用可能なフォント名のリストを返します。 この関数はfmenumerate()へのインターフェースです。 
現在のフォントを使って文字列をレンダリングします(下のフォントハンドルメソッドsetfont()を参照)。 fmprstr(string)を呼び出します。 
現在のフォント検索パスを返します。 
フォントハンドルオブジェクトは以下の操作をサポートします: 
scalefont (フォントハンドルメソッド)( 
このフォントを拡大/縮小したハンドルを返します。 fmscalefont(fh, factor)を呼び出します。 
setfont (フォントハンドルメソッド)( 
getfontname (フォントハンドルメソッド)( 
このフォントの名前を返します。 fmgetfontname(fh)を呼び出します。 
getcomment (フォントハンドルメソッド)( 
このフォントに関連付けられたコメント文字列を返します。 
コメント文字列が何もなければ例外を返します。 fmgetcomment(fh)を呼び出します。 
getfontinfo (フォントハンドルメソッド)( 
このフォントに関連したデータを含むタプルを返します。 
これはfmgetfontinfo()へのインターフェースです。 以下の数値を含むタプルを返します:( 
printermatched、fixed_width、xorig、yorig、xsize、ysize、height、nglyphs 
)。 
getstrwidth (フォントハンドルメソッド)( 
このフォントでstringを描いたときの幅をピクセル数で返します。 fmgetstrwidth(fh, string)を呼び出します。 
このモジュールは Unix のシェル形式のワイルドカードへの対応を提供しますが、( 
モジュールでドキュメント化されている)正規表現と同じではありません。 
シェル形式のワイルドカードで使われる特別な文字は、 
すべてにマッチします 
任意の一文字にマッチします 
seqにある任意の文字にマッチします 
seqにない任意の文字にマッチします 
ファイル名のセパレーター(Unixでは'/')はこのモジュールに固有なものでは ない ことに注意してください。 
パス名展開については、 
モジュールを参照してください( 
はパス名の部分にマッチさせるのにfnmatch()を使っています)。 
同様に、ピリオドで始まるファイル名はこのモジュールに固有ではなくて、* と? のパターンでマッチします。 
filenameの文字列がpatternの文字列にマッチするかテストして、真、偽のいずれかを返します。 
オペレーティングシステムが大文字、小文字を区別しない場合、比較を行う前に、両方のパラメタを全て大文字、または全て小文字に揃えます。 
オペレーティングシステムが標準でどうなっているかに関係なく、大小文字を区別して比較したい場合には、fnmatchcase() を代わりに使ってください。 
filename が pattern にマッチするかテストして、真、偽を返します。 比較は大文字、小文字を区別します。 
pattern にマッチする names のリストの部分集合を返します。 
[n for n in names if fnmatch(n, pattern)]と同じですが、もっと効率よく実装しています。 バージョン 2.2 で 新たに追加 された仕様です。 
Unix シェル形式のパス展開。 . 
このモジュールでは、二つのインタフェース定義を提供しており、それらの各インタフェースについて複数の実装を提供しています。 
formatter インタフェースは 
モジュールのHTMLParser クラスで使われており、writer インタフェースは formatter インタフェースを使う上で必要です。 
formatter オブジェクトはある抽象化された書式イベントの流れをwriter オブジェクト上の特定の出力イベントに変換します。 
formatter はいくつかのスタック構造を管理することで、writer オブジェクトの様々な属性を変更したり復元したりできるようにしています; このため、writer は相対的な変更や ``元に戻す'' 操作を処理できなくてもかまいません。 
writer の特定のプロパティのうち、formatter オブジェクトを介して制御できるのは、水平方向の字揃え、フォント、そして左マージンの字下げです。 
任意の、非排他的なスタイル設定を writer に提供するためのメカニズムも提供されています。 
さらに、段落分割のように、可逆でない書式化イベントの機能を提供するインタフェースもあります。 writer オブジェクトはデバイスインタフェースをカプセル化します。 
ファイル形式のような抽象デバイスも物理デバイス同様にサポートされています。 
ここで提供されている実装内容はすべて抽象デバイス上で動作します。 
デバイスインタフェースは formatter オブジェクトが管理しているプロパティを設定し、データを出力端に書き込めるようにします。 
3.3.3 拡張型における弱参照 
ほとんどのコンピュータはいわゆるIEEE-754標準に準拠した浮動小数点演算 
(上の例は多くのプラットホームで動作します。 
SIGFPEを生成するように切り替え、適切なシグナルハンドラを設定します。 
浮動小数点例外のデフォルトの処理に再設定します。 
turnon_sigfpe()が実行された後に、IEEE-754例外であるDivision by Zero、OverflowまたはInvalid operationの一つを発生する浮動小数点演算は、次にこの標準Python例外を発生します。 
注意:This module is unneeded: everything here couldbe done via the % string interpolation operator. fpformat モジュールは浮動小数点数の表示を 100% 純粋に Python だけで行うための関数を定義しています。 
注意:このモジュールは必要ありません: このモジュールのすべてのことは、% を使って、文字列の補間演算により可能です。 
fpformat モジュールは次にあげる関数と例外を定義しています。 
x を [-]ddd.ddd の形にフォーマットします。 小数点の後ろに digs 桁と、小数点の前に少なくとも1桁です。 
vardigs = 0 の場合、小数点以下は切り捨てられます。 
x を [-]d.dddE[+-]ddd の形にフォーマットします。 小数点の後ろに digs 桁と、小数点の前に1桁だけです。 
vardigs = 0 の場合、1桁だけ残され、小数点以下は切り捨てられます。 
fix() や sci() にパラメータとして渡された文字列 x が数字として認識できなかった場合、例外が発生します。 標準の例外が文字列の場合、この例外は ValueError のサブクラスです。 
例外値は、例外を発生させた不適切にフォーマットされた文字列です。 
このモジュールではFTPクラスと、それに関連するいくつかの項目を定義しています。 FTPクラスは、FTPプロトコルのクライアント側の機能を備えています。 
モジュールもFTPを使うURLを操作するのにこのクラスを使っています。 
FTP (File Transfer Protocol)についての詳しい情報はInternet RFC 959を参照して下さい。 ftplibモジュールを使ったサンプルを以下に示します: 
from ftplib import FTP ftp = FTP('ftp.cwi.nl') # ホストのデフォルトポートへ接続 ftp.login() # ユーザ名 anonymous、パスワード anonyumous@ ftp.retrlines('LIST') # ディレクトリの内容をリストアップtotal 24418drwxrwsr-x 5 ftp-usr pdmaint 1536 Mar 20 09:48 .dr-xr-srwt 105 ftp-usr pdmaint 1536 Mar 21 14:32 ..-rw-r--r-- 1 ftp-usr pdmaint 5305 Mar 20 09:48 INDEX... ftp.retrbinary('RETR README', open('README', 'wb').write)'226 Transfer complete.' ftp.quit() 
このモジュールは以下の項目を定義しています: 
クラスFTP 
FTPクラスの新しいインスタンスを返します。 
hostが与えられると、connect(host)メソッドが実行されます。 
userが与えられると、さらにlogin(user, passwd, aracct)メソッドが実行されます(このpasswdとacctは指定されなければデフォルトでは空文字列です)。 
FTPインスタンスのメソッドの結果、FTP接続で(プログラミングのエラーと考えられるメソッドの実行によって)発生する全ての例外(タプル形式)。 
この例外には以下の4つのエラーはもちろん、socket.errorとIOErrorも含まれます。 
サーバから想定外の応答があった時に発生する例外。 
400-499の範囲のエラー応答コードを受け取った時に発生する例外。 
500-599の範囲のエラー応答コードを受け取った時に発生する例外。 
1-5の数字で始まらない応答コードをサーバから受け取った時に発生する例外。 
.netrcファイルフォーマットのパーザ。 
.netrcファイルは、FTPクライアントがユーザにプロンプトを出す前に、ユーザ認証情報をロードするのによく使われます。 . 
PythonのソースディストリビューションのTools/scripts/ftpmirror.py 
__future__ は実際にモジュールであり、3つの役割があります。 
import ステートメントを解析する既存のツールを混乱させるのを避け、そのステートメントがインポートしようとしているモジュールを見つけられるようにするため。 
いつ互換でない変化が導入され、いつ強制的になる - あるいは、なった - のか文書化するため。 
これは実行できる形式で書かれたドキュメントでなので、__future__ をインポートし、その中身を調べるようプログラムすれば確かめられます。 
__future__.py の各ステートメントは次のような形をしています: 
ここで、普通は、OptionalRelease は MandatoryRelease より小さく、2つともsys.version_info と同じフォーマットの5つのタプルからなります。 
CompilerFlag は動的にコンパイルされるコードでその機能を有効にするために、組み込み関数 compile() の第4引数に渡されなければならない(ビットフィールド)フラグです。 
このフラグは _Future インスタンスの compilier_flag 属性に保存されています。 __future__ で解説されている機能のうち、削除されたものはまだありません。 
gcモジュールは、インタプリタのビルドオプションで循環ガベージコレクタを有効にした場合のみ使用することができます(デフォルトで有効)。 
もし無効になっている場合にこのモジュールをインポートすると、ImportErrorが発生します。 
このモジュールは、循環ガベージコレクタの無効化・検出頻度の調整・デバッグオブションの設定などを行うインターフェースを提供します。 
また、検出した到達不能オブジェクトのうち、解放する事ができないオブジェクトを参照する事もできます。 
循環ガベージコレクタはPyhonの参照カウントを補うためのものですので、もしプログラム中で循環参照が発生しない事が明らかな場合には検出をする必要はありません。 
自動検出は、gc.disable()で停止する事ができます。 
メモリリークをデバッグするときには、gc.set_debug(gc.DEBUG_LEAK)とします。 gcモジュールは、以下の関数を提供しています。 
自動ガベージコレクションを有効にします。 
自動ガベージコレクションを無効にします。 
自動ガベージコレクションが有効なら真を返します。 
全ての検出を行います。 
全ての世代を検査し、検出した到達不可オブジェクトの数を返します。 
ガベージコレクションのデバッグフラグを設定します。 デバッグ情報はsys.stderrに出力されます。 
デバッグフラグは、下の値の組み合わせを指定する事ができます。 
現在のデバッグフラグを返します。 
現在、追跡しているオブジェクトのリストを返します。 
ガベージコレクションの閾値(検出頻度)を指定します。 
threshold0を0にすると、検出は行われません。 GCは、オブジェクトを、走査された回数に従って3世代に分類します。 
新しいオブジェクトは最も若い(0世代)に分類されます。 
もし、そのオブジェクトがガベージコレクションで削除されなければ、次に古い世代に分類されます。 
もっとも古い世代は2世代で、この世代に属するオブジェクトは他の世代に移動しません。 
ガベージコレクタは、最後に検出を行ってから生成・削除したオブジェクトの数をカウントしており、この数によって検出を開始します。 
オブジェクトの生成数 - 削除数 がthreshold0より大きくなると、検出を開始します。 
最初は0世代のオブジェクトのみが検査されます。 
0世代の検査がthreshold1回実行されると、1世代のオブジェクトの検査を行います。 
同様に、1世代がthreshold2回検査されると、2世代の検査を行います。 
現在の検出閾値を、(threshold0, threshold1,threshold2)のタプルで返します。 
objsで指定したオブジェクトのいずれかを参照しているオブジェクトのリストを返します。 
有効なオブジェクトのみを取得する場合、get_referrers()の前にcollect()を呼び出してください。 get_referrers()から返されるオブジェクトは作りかけや利用できない状態である場合があるので、利用する際には注意が必要です。 
get_referrers()をデバッグ以外の目的で利用するのは避けてください。 
引数で指定したオブジェクトのいずれかから参照されている、全てのオブジェクトのリストを返します。 
参照先のオブジェクトは、引数で指定したオブジェクトのCレベルメソッドtp_traverseで取得し、全てのオブジェクトが直接到達可能な全てのオブジェクトを返すわけではありません。 tp_traverseはガベージコレクションをサポートするオブジェクトのみが実装しており、ここで取得できるオブジェクトは循環参照の一部となる可能性のあるオブジェクトのみです。 
従って、例えば整数オブジェクトが直接到達可能であっても、このオブジェクトは戻り値には含まれません。 
到達不能であることが検出されたが、解放する事ができないオブジェクトのリスト(回収不能オブジェクト)。 
デフォルトでは、__del__()メソッドを持つオブジェクトのみが格納されます。 
__del__()メソッドを持つオブジェクトが循環参照に含まれている場合、その循環参照全体と、循環参照からのみ到達する事ができるオブジェクトは回収不能となります。 
このような場合には、Pythonは安全に__del__()を呼び出す順番を決定する事ができないため、自動的に解放することはできません。 
もし安全な解放順序がわかるのであれば、garbageリストを参照して循環参照を破壊する事ができます。 
循環参照を破壊した後でも、そのオブジェクトはgarbageリストから参照されているため、解放されません。 
解放するためには、循環参照を破壊した後、del gc.garbage[:]のようにgarbageからオブジェクトを削除する必要があります。 
一般的には__del__()を持つオブジェクトが循環参照の一部とはならないように配慮し、garbageはそのような循環参照が発生していない事を確認するために利用する方が良いでしょう。 DEBUG_SAVEALLが設定されている場合、全ての到達不能オブジェクトは解放されずにこのリストに格納されます。 
以下はset_debug()に指定することのできる定数です。 
検出中に統計情報を出力します。 
この情報は、検出頻度を最適化する際に有益です。 
回収不能オブジェクトは、garbadeリストに追加されます。 
DEBUG_COLLECTABLEかDEBUG_UNCOLLECTABLEが設定されている場合、見つかったインスタンスオブジェクトの情報を出力します。 
DEBUG_COLLECTABLEかDEBUG_UNCOLLECTABLEが設定されている場合、見つかったインスタンスオブジェクト以外のオブジェクトの情報を出力します。 
設定されている場合、全ての到達不能オブジェクトは解放されずにgarbageに追加されます。 
これはプログラムのメモリリークをデバッグするときに便利です。 
...持つオブジェクトのみが格納されます。 
Python 2.2より前のバージョンでは、__del__()メソッドを持つオブジェクトだけでなく、全ての到達不能オブジェクトが格納されていた。 ) 
このモジュールは 
モジュールによく似ていますが、gdbm を使っていくつかの追加機能を提供しています。 
I/O エラーのような gdbm 特有のエラーで送出されます。 誤ったキーの指定のように、一般的なマップ型のエラーに対してはKeyError が送出されます。 
gdbm データベースを開いて gdbm オブジェクトを返します。 
'f' -- データベースを高速モードで開きます。 
このモードではデータベースへの書き込みはファイルシステムと同期されません。 
's' -- 同期モードで開きます。 
データベースへの変更はファイルに即座いに書き込まれます。 
'u' -- データベースをロックしません。 
全てのバージョンの gdbm で全てのフラグが有効とは限りません。 
モジュール定数 open_flags はサポートされているフラグ文字からなる文字列です。 
無効なフラグが指定された場合、例外 errorが送出されます。 オプションの mode 引数は、新たにデータベースを作成しなければならない場合に使われる Unix のファイルモードです。 
標準の値は 8 進数の0666 です。 
辞書型形式のメソッドに加えて、gdbm オブジェクトには以下のメソッドがあります: 
このメソッドと next() メソッドを使って、データベースの全てのキーにわたってループ処理を行うことができます。 
探索は gdbm の内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。 
データベースの順方向探索において、key よりも後に来るキーを返します。 
以下のコードはデータベース db について、キー全てを含むリストをメモリ上に生成することなく全てのキーを出力します: 
大量の削除を実行した後、gdbm ファイルの占めるスペースを削減したい場合、このルーチンはデータベースを再組織化します。 
この再組織化を使う以外に gdbm はデータベースファイルの大きさを短くすることはありません; そうでない場合、削除された部分のファイルスペースは保持され、新たな (キー、値の) ペアが追加される際に再利用されます。 
データベースが高速モードで開かれていた場合、このメソッドはディスクにまだ書き込まれていないデータを全て書き込ませます。 
gensuitemodule モジュールは AppleScript 辞書によって特定のアプリケーションに実装されている AppleScript 群のためのスタブコードを実装した Python パッケージを作成します。 このモジュールは、通常は PythonIDE からユーザによって起動されますが、コマンドラインからスクリプトとして実行する(オプションとしてヘルプに --help を与えてみてください)こともできますし、Python コードでインポートして利用する事もできます。 
使用例として、どのようにして標準ライブラリに含まれているスタブパッケージを生成するか、 Mac/scripts/genallsuites.py にあるソースを見てください。 このモジュールは次の関数を定義しています。 
application としてパス名を与えたアプリケーションがスクリプト可能でありそうな場合、真を返します。 
返り値はやや不確実な場合があります。 Internet Explorer はスクリプト不可能なように見えてしまいますが、実際はスクリプト可能です。 
パス名として渡された application のためのスタブパッケージを作成します。 
dump にはファイルオブジェクトを与えます、これを指定するとリソースを読取った後に停止して processfile がコード化した用語リソースの Python 表現をダンプします。 
verbose にもまたファイルオブジェクトを与え、これを指定すると processfile の行なっている処理の詳細を出力します。 processfile_fromresource 
この関数は、用語リソースを得るのに異なる方法を使用する以外は、processfile と同じです。 
この関数では、リソースファイルとして application を開き、このファイルから "aete" および "aeut" リソースをすべて読み込む事で、AppleScript 用語リソース読み込みを行ないます。 
3番目の引数(省略可能)を設定することで、GNUのソフトウェアでサポートされているような長形式のオプションも利用することができます。 このモジュールは1つの関数と例外を提供しています: 
コマンドラインオプションとパラメータのリストを構文解析します。 argsは構文解析の対象になる引数リストです。 
これは先頭のプログラム名を除いたもので、通常"sys.argv[1:]"で与えられます。 options はスクリプトで認識させたいオプション文字と、引数が必要な場合にはコロン(":")をつけます。 
つまりUnixのgetopt()と同じフォーマットになります。 
注意:GNUの getopt()とは違って、オプションでない引数の後は全てオプションではないと判断されます。 これは GNUでない、Unixシステムの挙動に近いものです。 
long_optionsは長形式のオプションの名前を示す文字列のリストです。 
名前には、先頭の'- 
-'は含めません。 
引数が必要な場合には名前の最後に等号("=")を入れます。 
長形式のオプションだけを受けつけるためには、optionsは空文字列である必要があります。 
長形式のオプションは、該当するオプションを一意に決定できる長さまで入力されていれば認識されます。 
-long-option')となり、引数が2番目の要素になります。 
引数をとらない場合には空文字列が入ります。 
オプションは見つかった順に並んでいて、複数回同じオプションを指定することができます。 
長形式と短形式のオプションは混在させることができます。 
この関数はデフォルトでGNUスタイルのスキャンモードを使う以外はgetopt()と同じように動作します。 
つまり、オプションとオプションでない引数とを混在させることができます。 
getopt()関数はオプションでない引数を見つけると解析をやめてしまいます。 オプション文字列の最初の文字が '+'にするか、環境変数POSIXLY_CORRECTを設定することで、オプションでない引数を見つけると解析をやめるように振舞いを変えることができます。 
引数リストの中に認識できないオプションがあった場合か、引数が必要なオプションに引数が与えられなかった場合に発生します。 
例外の引数は原因を示す文字列です。 
バージョン 1.6 で 変更 された仕様:GetoptError はerrorの別名として導入されました。 
GetoptErrorへのエイリアスです。 後方互換性のために残されています。 
Unixスタイルのオプションを使った例です: 
長形式のオプションを使っても同様です: 
スクリプト中での典型的な使い方は以下のようになります: 
import getopt, sysdef main():try:opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])except getopt.GetoptError:# ヘルプメッセージを出力して終了usage()sys.exit(2)output = Noneverbose = Falsefor o, a in opts:if o == "-v":verbose = Trueif o in ("-h", "--help"):usage()sys.exit()if o in ("-o", "--output"):output = a# ...if __name__ == "__main__":main() 
よりオブジェクト指向的なコマンドラインオプションのパーズを提供します。 . 
The getpass module provides two functions:getpassモジュールは二つの機能を提供します: 
エコーなしでユーザーにパスワードを入力させるプロンプト。 
ユーザーはpromptの文字列をプロンプトに使えます、デフォルトは'Password:'です。 利用できるシステム: Machintosh, Unix, Windows 
ユーザーの ``ログイン名''を返します。 
有効性:Unix、Windowsこの関数は環境変数LOGNAME USER LNAME USERNAMEの順序でチェックして、最初の空ではない文字列が設定された値を返します。 
もし、なにも設定されていない場合はpwdモジュールが提供するシステム上のパスワードデータベースから返します。 
それ以外は、例外が上がります。 
gettext モジュールは、 Python によるモジュールやアプリケーションの国際化 (I18N, I-nternationalizatio-N) および地域化 (L10N, L-ocalizatio-N) サービスを提供します。 このモジュールは GNU gettext メッセージカタログへの API と、より高レベルで Python ファイルに適しているクラスに基づいた API の両方をサポートしてます。 
以下で述べるインタフェースを使うことで、モジュールやアプリケーションのメッセージをある自然言語で記述しておき、翻訳されたメッセージのカタログを与えて他の異なる自然言語の環境下で動作させることができます。 
ここでは Python のモジュールやアプリケーションを地域化するためのいくつかのヒントも提供しています。 
6.28.2.1 NullTranslations クラス 
6.28.2.2 GNUTranslations クラス 
6.28.2.3 Solaris メッセージカタログ機構のサポート 
6.28.2.4 Catalog コンストラクタ 
6.28.3.1 モジュールを地域化する 
6.28.3.2 アプリケーションを地域化する 
6.28.3.3 動作中 (on the fly) に言語を切り替える 
6.28.3.4 翻訳処理の遅延解決 
このモジュールにはSilicon GraphicsのGraphics Libraryで使われるCのヘッダーファイルgl/gl.hの定数が定義されています。 詳しくはモジュールのソースファイルをご覧ください。 
このモジュールはSilicon GraphicsのGraphics Libraryへのアクセスを提供します。 Silicon Graphicsマシン上だけで利用可能です。 
警告:GLライブラリの不適切な呼び出しによっては、Pythonインタープリタがコアを吐き出すことがあります。 特に、GLのほとんどの関数では最初のウィンドウを開く前に呼び出すのは安全ではありません。 
このモジュールはとても大きいので、ここに全てを記述することはできませんが、以下の説明で出発点としては十分でしょう。 Cの関数のパラメータは、以下のような決まりに従ってPythonに翻訳されます: 
全て(short、long、unsigned)の整数値(int)はPythonの整数に相当します。 
全ての浮動小数点数と倍精度浮動小数点数はPythonの浮動小数点数に相当します。 たいていの場合、Pythonの整数も使えます。 
全ての配列はPythonの一次元のリストに相当します。 たいていの場合、タプルも使えます。 
全ての文字列と文字の引数は、Pythonの文字列に相当します。 例えば、winopen('Hi There!')とrotate(900, 'z')。 
配列である引数の長さを特定するためだけに使われる全て(short、long、unsigned)の整数値の引数あるいは返り値は、無視されます。 例えば、Cの呼び出しで、 
これはPythonでは、こうなります。 
これはPythonではこうなります。 
以下の関数は一般的でないか、引数に特別な決まりを持っています: 
座標は(マニュアルページにあるように)必要であれば z = 0.0と仮定して、常に3次元の精密な座標に変換され、各座標についてv3d()が呼び出されます。 
各座標と各法線は(x, y, z)からなるタプルでなければなりません。 3つの座標が渡されなければなりません。 
浮動小数点数と整数を混合して使えます。 各ペアについて、法線に対してn3f()が呼び出され、座標に対してv3f()が呼び出されます。 
nvarray()と似ていますが、各ペアは始めに座標を、2番目に法線を持っています。 
nurbs(非均一有理Bスプライン)曲面を定義します。 
ctl[][]の次元は以下のように計算されます:[len(s_k) - s_ord]、[len(t_k) - t_ord]。 
nurbs(非均一有理Bスプライン)曲線を定義します。 ctlpointsの長さは、len(knots) - order 
区分線形曲線(piecewise-linear curve)を定義します。 pointsは座標のリストです。 
typeはN_STでなければなりません。 
これらの関数はただ一つの引数を取り、pick/selectに使うバッファのサイズを設定します。 
これらの関数は引数を取りません。 
pick/selectに使われているバッファの大きさを示す整数のリストを返します。 バッファがあふれているのを検出するメソッドはありません。 
小さいですが完全なPythonのGLプログラムの例をここに挙げます: 
PyOpenGL: PythonのOpenGLとの結合 
へのインターフェースが利用できます;詳しくはPyOpenGL 
プロジェクトhttp://pyopengl.sourceforge.net/から情報を入手できます。 
これは、SGIのハードウェアが1996年頃より前である必要がないので、OpenGLの方が良い選択かもしれません。 
glob モジュールはUnix シェルで使われているルールに従って指定されたパターンにマッチするすべてのパス名を見つけ出します。 
チルダ展開は使えませんが、*、 ?と []で表される文字範囲には正しくマッチします。 
(チルダ展開とシェル変数展開を利用したければ、os.path.expantion() とos.path.expandvars()を使ってください。 
結果には(シェルと同じく)壊れたシンボリックリンクも含まれます。 
たとえば、次のファイルだけがあるディレクトリを考えてください: 1.gif、2.txt、 and card.gif。 glob()は次のような結果になります。 
パスに接頭するどの部分が保たれているかに注意してください。 
シェル形式の(パスではない)ファイル名展開. 
このモジュールでは、gopher プロトコルのクライアント側について最小限の実装を提供しています。 
このモジュールは 
モジュールでgopher プロトコルを使う URL を扱うために用いられます。 このモジュールでは以下の関数を定義しています: 
selector 文字列を host および port(標準の値は 70 です) の gopher サーバに送信します。 
返信されたドキュメントデータを読み出すための、開かれた状態のファイルオブジェクトを返します。 
selector 文字列、および query 文字列を host および port (標準の値は 70 です) の gopher サーバに送信します。 
返信されたドキュメントデータを読み出すための、開かれた状態のファイルオブジェクトを返します。 
gopher サーバから返されるデータは任意の形式であり、セレクタ (selector)文字列の最初の文字に依存するので注意してください。 
データがテキスト(セレクタの最初の文字が "0") の場合、各行は CRLF で終端され、データ全体は "." 一個だけからなる行で終端されます。 ".." で始まる行の先頭は "." に置き換えられます。 
ディレクトリリスト (セレクタの最初の文字が "1") の場合にも、同じプロトコルで転送されます。 
グループ名 
(暗号化された) グループパスワード; しばしば空文字列になります 
数字のグループ ID 
グループメンバの全てのユーザ名 
gid は整数、名前およびパスワードは文字列、そしてメンバリストは文字列からなるリストです。 (ほとんどのユーザは、パスワードデータベースで自分が入れられているグループのメンバとしてグループデータベース内では明示的に列挙されていないので注意してください。 
完全なメンバ情報を取得するには両方のデータベースを調べてください。 )このモジュールでは以下の内容を定義しています: 
与えられたグループ ID に対するグループデータベースエントリを返します。 要求したエントリが見つからなかった場合、KeyError が送出されます。 
与えられたグループ名に対するグループデータベースエントリを返します。 要求したエントリが見つからなかった場合、KeyError が送出されます。 
全ての入手可能なグループエントリを返します。 順番は決まっていません。 
このモジュールと類似の、ユーザデータベースへのインタフェース。 . 
gzip や gunzip プログラムで解凍できる、compress や pack による他の形式の圧縮ファイルはこのモジュールではサポートされていないので注意してください。 このモジュールでは以下の項目を定義しています: 
クラスGzipFile 
GzipFile クラスのコンストラクタです。 GzipFile オブジェクトは readinto() と truncate() メソッドを除くほとんどのファイルオブジェクトのメソッドをシミュレートします。 
値はデフォルトでは None で、ファイルオブジェクトを生成するために filename を開きます。 gzip ファイルヘッダ中には、ファイルが解凍されたときの元のファイル名を収めることができますが、fileobj が None でない場合、引数 filename がファイル名として認識できる文字列であれば、filename はファイルヘッダに収めるためだけに使われます。 
デフォルトの値は 9 です。 圧縮したデータの後ろにさらに何か追記したい場合もあるので、GzipFile オブジェクトの close() メソッド呼び出しは fileobj をクローズしません。 
この機能によって、書き込みのためにオープンした StringIO オブジェクトをfileobj として渡し、(GzipFile を close() した後に)StringIO オブジェクトの getvalue() メソッドを使って書き込んだデータの入っているメモリバッファを取得することができます。 
compresslevel) の短縮形です。 
引数 filename は必須です。 デフォルトで mode は'rb' に、compresslevel は 9 に設定されています。 
gzip ファイル形式のサポートを行うために必要な基本ライブラリモジュール。 . 
このモジュールではヒープキューアルゴリズムの一実装を提供しています。 
優先度キューアルゴリズムとしても知られています。 
ヒープとは、全ての k に対して、ゼロから要素を数えていった際に、 
heap[0] が常に最小の要素になることです。 
以下の API は教科書におけるヒープアルゴリズムとは 2 つの側面で異なっています: (a) ゼロベースのインデクス化を行っています。 
これにより、ノードに対するインデクスとその子ノードのインデクスの関係がやや明瞭でなくなりますが、Python はゼロベースのインデクス化を使っているのでよりしっくりきます。 
(b) われわれの pop メソッドは最大の要素ではなく最小の要素 (教科書では "min heap:最小ヒープ" と呼ばれています;教科書では並べ替えをインプレースで行うのに適した "max heap:最大ヒープ" が一般的です)。 これらの 2 点によって、ユーザに戸惑いを与えることなく、ヒープを通常の Python リストとして見ることができます: 
heap[0] が最小の要素となり、 
heap.sort() はヒープを不変なままに保ちます!ヒープを作成するには、[] に初期化されたリストを使うか、heapify() を用いて要素の入ったリストを変換します。 以下の関数が提供されています: 
item を heap に push します。 ヒープを不変に保ちます。 
pop を行い、heap から最初の要素を返します。 ヒープは不変に保たれます。 
ヒープが空の場合、IndexError が送出されます。 
リスト x をインプレース処理し、線形時間でヒープに変換します。 
heap から最小の要素を pop して返し、新たに item をpush します。 
返される値は item よりも大きくなるかもしれないので気をつけてください! これにより、このルーチンの合理的な利用法は条件つき置換の一部として使われることに制限されています。 
使用例を以下に示します: 
このモジュールではさらに2つのヒープに基く汎用関数を提供します。 
iterableで定義されるデータセットのうち、最大値から降順にn個の値のリストを返します。 
以下のコードと同等です: sorted(iterable, reverse=True)[:n] バージョン 2.4 で 新たに追加 された仕様です。 
iterableで定義されるデータセットのうち、最小値から昇順にn個の値のリストを返します。 
以下のコードと同等です: sorted(iterable)[:n] 
どちらの関数もnの値が小さな場合に最適な動作をします。 
大きな値の時にはsorted()関数の方が効率的です。 
さらに、n==1の時にはmin()およびmax() 関数の方が効率的です。 
このモジュールでは RFC 2104 で記述されている HMAC アルゴリズムを実装しています。 
新たな hmac オブジェクトを返します。 
標準では 
モジュールになっています。 
HMAC オブジェクトは以下のメソッドを持っています: 
hmac オブジェクトを文字列 msg で更新します。 
繰り返し呼び出しを行うと、それらの引数を全て結合した引数で単一の呼び出しをした際と同じに等価になります: すなわち m.update(a); m.update(b) は m.update(a + b) と等価です。 
これまで update() メソッドに渡された文字列のダイジェスト値を返します。 
個の値は 16 バイトの文字列 ( 
の場合) か、20 バイトの文字列 ( 
の場合) で、NULL バイトを含む非 ASCII 文字が含まれることがあります。 
digest() と似ていますが、ダイジェスト値が 
のときで長さ 32 文字 ( 
のときで 40文字) の 16進数字のみを含む文字列で返されます。 
この値は電子メールやその他の非バイナリ環境で値をやり取りする際に使うことができます。 
hmac オブジェクトの (``クローン'' の) コピーを返します。 
このコピーは最初の部分文字列が共通になっている文字列のダイジェスト値を効率よく計算するために使うことができます。 
10.8 拡張 
このモジュールは _hotshot C モジュールへのより良いインターフェースを提供します。 Hotshot は既存の 
に置き換わるものです。 
その大半が C で書かれているため、 
に比べパフォーマンス上の影響がはるかに少なく済みます。 hotshotプロファイラはまだスレッド環境ではうまく動作しません。 
測定したいコード上でプロファイラを実行するためにスレッドを使わない版のスクリプトを使う方法が有用です。 
クラスProfile 
プロファイラ・オブジェクト。 
引数 logfile はプロファイル・データのログを保存するファイル名です。 
引数 lineevents はソースコードの1 行ごとにイベントを発生させるか、関数の呼び出し/リターンのときだけ発生させるかを指定します。 
デフォルトの値は 0 (関数の呼び出し/リターンのときだけログを残す)です。 
引数 linetimings は時間情報を記録するかどうかを指定します。 
デフォルトの値は 1 (時間情報を記録する)です。 
このモジュールは hotshot プロファイル・データを標準の pstatsオブジェクトにロードします。 
filename から hotshot データを読み込み、pstats.Stats クラスのインスタンスを返します。 
profile モジュールの Stats クラス. 
このモジュールではentitydefs、codepoint2name、entitydefsの三つの辞書を定義しています。 entitydefsは 
モジュールで HTMLParser クラスのentitydefs メンバを定義するために使われます。 
このモジュールでは XHTML 1.0 で定義された全てのエンティティを提供しており、Latin-1 キャラクタセット (ISO-8859-1)の簡単なテキスト置換を行う事ができます。 
各 XHTML 1.0 エンティティ定義について、ISO Latin-1 における置換テキストへの対応付けを行っている辞書です。 
HTMLのエンティティ名をUnicodeのコードポイントに変換するための辞書です。 
バージョン 2.3 で 新たに追加 された仕様です。 codepoint2name 
A dictionary that maps Unicode codepoints to HTML entity names.UnicodeのコードポイントをHTMLのエンティティ名に変換するための辞書です。 バージョン 2.3 で 新たに追加 された仕様です。 
このモジュールでは、ハイパーテキスト記述言語 (HTML, HyperText Mark-up Language) 形式で書式化されたテキストファイルを解析するための基盤として役立つクラスを定義しています。 
このクラスは I/O と直接的には接続されません -- このクラスにはメソッドを介して文字列形式の入力を提供する必要があり、出力を生成するには ``フォーマッタ (formatter)''オブジェクトのメソッドを何度か呼び出さなくてはなりません。 
HTMLParser クラスは、機能を追加するために他のクラスの基底クラスとして利用するように設計されており、ほとんどのメソッドが拡張したり上書きしたりできるようになっています。 
さらにこのクラスは 
モジュールで定義されている SGMLParser クラスから導出されており、その機能を拡張しています。 
HTMLParser の実装は、RFC 1866で解説されている HTML 2.0 記述言語をサポートします。 
formatter では 2 つのフォーマッタオブジェクト実装が提供されています; フォーマッタのインタフェースについての情報は 
モジュールのドキュメントを参照してください。 
以下は sgmllib.SGMLParser で定義されているインタフェースの概要です: 
インスタンスにデータを与えるためのインタフェースは feed()メソッドで、このメソッドは文字列を引数に取ります。 
このメソッドに一度に与えるテキストは必要に応じて多くも少なくもできます; というのは "p.feed(a);p.feed(b)" は "p.feed(a+b)" と同じ効果を持つからです。 
与えられたデータが完全な HTML マークアップ文を含む場合、それらの文は即座に処理されます; 不完全なマークアップ構造はバッファに保存されます。 
全ての未処理データを強制的に処理させるには、 close() メソッドを呼び出します。 例えば、ファイルの全内容を解析するには: 
parser.feed(open('myfile.html').read())parser.close() のようにします。 
HTML タグに対して意味付けを定義するためのインタフェースはとても単純です: サブクラスを導出して、start_tag()、end_tag()、あるいは do_tag()といったメソッドを定義するだけです。 
パーザはこれらのメソッドを適切なタイミングで呼び出します: start_tag 
や do_tag() は tag ... の形式の開始タグに遭遇した時に呼び出されます;end_tag() は tag の形式の終了タグに遭遇した時に呼び出されます。 
H1 ... /H1 のように開始タグが終了タグと対応している必要がある場合、クラス中でstart_tag() が定義されていなければなりません;P のように終了タグが必要ない場合、クラス中ではdo_tag() を定義しなければなりません。 
このモジュールではパーザクラスと例外を一つづつ定義しています: 
基底となる HTML パーザクラスです。 
XHTML 1.0 仕様 (http://www.w3.rog/TR/xhtml1) 勧告で要求されている全てのエンティティ名をサポートしています。 
HTMLParser クラスがパーズ処理中にエラーに遭遇した場合に送出する例外です。 
バージョン 2.4 で 新たに追加 された仕様です。 
抽象化された書式イベントの流れをwriter オブジェクト上の特定の出力イベントに変換するためのインターフェース。 
HTML パーザのひとつです。 やや低いレベルでしか入力を扱えませんが、XHTML を扱うことができるように設計されています。 
``広く知られている HTML (HTML as deployed)'' では使われておらずかつ XHTML では正しくないとされる SGML 構文のいくつかは実装されていません。 . 
XHTML 1.0 エンティティに対する置換テキストの定義。 
HTMLParser の基底クラス。 
このモジュールでは HTTP および HTTPS プロトコルのクライアント側を実装しているクラスを定義しています。 
通常、このモジュールは直接使いません -- 
モジュールがHTTP や HTTPS を使った URL を扱う上でこのモジュールを使います。 
注意:HTTPS のサポートは、SSL をサポートするように 
このモジュールでは以下のクラスを提供しています: 
クラスHTTPConnection 
HTTPConnection インスタンスは、HTTP サーバとの一回のトランザクションを表現します。 
インスタンスの生成はホスト名とオプションのポート番号を与えて行います。 ポート番号を指定しなかった場合、ホスト名文字列が 
の形式であれば、ホスト名からポート番号を導き、そうでない場合には標準の HTTP ポート番号 (80) を使います。 
例えば、以下の呼び出しは全て同じサーバの同じポートに接続するインスタンスを生成します: 
クラスHTTPSConnection 
HTTPConnection のサブクラスで、セキュアなサーバと通信するために SSL を使います。 
標準のポート番号は 443です。 key_fileには、秘密鍵を格納したPEM形式ファイルのファイル名を指定します。 
このモジュールにおける他の例外クラスの基底クラスです。 
Exception のサブクラスです。 
HTTPException サブクラスです。 
HTTPException のサブクラスです。 ポート番号を指定したものの、その値が数字でなかったり空のオブジェクトであった場合に送出されます。 
HTTPException のサブクラスです。 
ImproperConnectionState のサブクラスです。 
HTTPException のサブクラスです。 
サーバが理解できない HTTP 状態コードで応答した場合に送出されます。 
このモジュールで定義されている定数は以下の通りです: 
HTTP プロトコルの標準のポート (通常は 80) です。 
HTTPS プロトコルの標準のポート (通常は 443) です。 
また、整数の状態コードについて以下の定数が定義されています: 
11.6.1 HTTPConnection オブジェクト 
このモジュールでは、Macintoshのインターネット設定 (Internet Config) パッケージへのアクセスを提供しています。 
このパッケージにはインターネットプログラムの設定、例えばメールアドレス、デフォルトのホームページなどが収録されています。 
それ以外にも、インターネット設定には Macintosh のクリエータ/タイプとファイル名の拡張子との対応付けや、ファイルの転送方法 (バイナリ、アスキーなど) に関する情報が収められています。 
MacOS 9 以降では、このモジュールは「インターネット」という名前のコントロールパネルになりました。 
このモジュールには、icglue という低水準の関連モジュールがあり、インターネット設定への基本的なアクセス機能を提供しています。 
icモジュール内部でエラーが生じたときに送出される例外です。 
icモジュールは以下のクラスと関数を定義しています: 
クラスIC 
インターネット設定オブジェクトを作成します。 
signatureは、IC の設定に影響を及ぼす可能性のある現在のアプリケーションを表す4文字のクリエータコード (デフォルトは'Pyth') です。 
オプションの引数ic は低水準モジュールであらかじめ作成しておいたicglue.icinstanceで、別の設定ファイルなどから設定を得る場合に便利です。 
これらの関数は、後述する同名のメソッドへの「ショートカット」です。 
icopen をインポートすると、組込み open() を新しいファイル用にファイルタイプおよびクリエーターを設定するために InternetConfigを使用するバージョンに置き換えます。 
imageopモジュールは画像に関する便利な演算がふくまれています。 Python文字列に保存されている8または32ビットのピクセルから構成される画像を操作します。 
これはgl.lrectwrite()と 
モジュールが使用しているものと同じフォーマットです。 モジュールは次の変数と関数を定義しています: 
この例外はピクセル当りの未知のビット数などのすべてのエラーで発生させられます。 
imageはwidth×heightの大きさで、psizeバイトのピクセルから構成されなければなりません。 
x0、y0、x1およびy1はgl.lrectread()パラメータと同様です。 すなわち、境界は新画像に含まれます。 
新しい境界は画像の内部である必要はありません。 
旧画像の外側になるピクセルは値をゼロに設定されます。 
x0がx1より大きければ、新画像は鏡像反転されます。 
y軸についても同じことが適用されます。 
そのため、コンピュータで作った画像やディザ処理された画像は伸縮した後見た目が良くありません。 
垂直ローパスフィルタ処理を画像全体に行います。 
それぞれの目標ピクセルを垂直に並んだ二つの元ピクセルから計算することで行います。 
このルーチンの主な用途としては、画像がインターレース走査のビデオ装置に表示された場合に極端なちらつきを抑えるために用います。 そのため、この名前があります。 
全ピクセルを二値化することによって、深さ8ビットのグレースケール画像を深さ1ビットの画像へ変換します。 
処理後の画像は隙間なく詰め込まれ、おそらくmono2grey()の引数としてしか使い道がないでしょう。 
(ばかばかしいほど単純な)ディザ処理アルゴリズムを用いて、8ビットグレースケール画像を1ビットのモノクロ画像に変換します。 
1ビットモノクロが象画像を8ビットのグレースケールまたはカラー画像に変換します。 入力で値ゼロの全てのピクセルは出力では値p0を取り、値0の入力ピクセルは出力では値p1を取ります。 
白黒のモノクロ画像をグレースケールへ変換するためには、値0と255をそれぞれ渡してください。 
ディザ処理を行わずに、8ビットグレースケール画像を4ビットグレースケール画像へ変換します。 
ディザ処理を行わずに、8ビットグレースケール画像を2ビットグレースケール画像に変換します。 
ディザ処理を行い、8ビットグレースケール画像を2ビットグレースケール画像へ変換します。 
dither2mono()については、ディザ処理アルゴリズムは現在とても単純です。 
4ビットグレースケール画像を8ビットグレースケール画像へ変換します。 
2ビットグレースケール画像を8ビットグレースケール画像へ変換します。 
0 にセットすると、このモジュールの関数は、リトルエンディアンのシステムで以前のバージョンと互換性のない方法でマルチバイトピクセル値を表現するようになります。 
このモジュールでは三つのクラス、IMAP4, IMAP4_SSL と IMAP4_streamを定義します。 これらのクラスは IMAP4 サーバへの接続をカプセル化し、RFC 2060 に定義されている IMAP4rev1 クライアントプロトコルの大規模なサブセットを実装しています。 
このクラスは IMAP4 (RFC 1730) 準拠のサーバと後方互換性がありますが、"STATUS" コマンドは IMAP4 ではサポートされていないので注意してください。 imaplib モジュール内では三つのクラスを提供しており、IMAP4 は基底クラスとなります: 
クラスIMAP4 
このクラスは実際の IMAP4 プロトコルを実装しています。 
例外は IMAP4 クラスの属性として定義されています: 
何らかのエラー発生の際に送出される例外です。 
例外の理由は文字列としてコンストラクタに渡されます。 
IMAP4 サーバのエラーが生じると、この例外が送出されます。 
この例外は IMAP4.error のサブクラスです。 
通常、インスタンスを閉じ、新たなインスタンスを再び生成することで、この例外から復旧できます。 
この例外は書き込み可能なメイルボックスの状態がサーバによって変更された際に送出されます。 
この例外は IMAP4.error のサブクラスです。 
他の何らかのクライアントが現在書き込み権限を獲得しており、メイルボックスを開きなおして書き込み権限を再獲得する必要があります。 
このモジュールではもう一つ、安全 (secure) な接続を使ったサブクラスがあります: 
クラスIMAP4_SSL 
IMAP4 から導出されたサブクラスで、SSL 暗号化ソケットを介して接続を行います (このクラスを利用するためには SSL サポート付きでコンパイルされた socket モジュールが必要です) 。 
host が指定されていない場合、 '' (ローカルホスト) が用いられます。 
port が省略された場合、標準の IMAP4-over-SSL ポート番号 (993) が用いられます。 
keyfile および certfile もオプションです - これらはSSL 接続のための PEM 形式の秘密鍵 (private key) と認証チェイン (certificate chain) ファイルです。 
さらにもう一つのサブクラスは、子プロセスで確立した接続を使用する場合に使用します。 
クラスIMAP4_stream 
IMAP4 から導出されたサブクラスで、commandをos.popen2()に渡して作成される stdin/stdoutディスクリプタと接続します。 
バージョン 2.3 で 新たに追加 された仕様です。 
以下のユーティリティ関数が定義されています: 
IMAP4 INTERNALDATE 文字列を標準世界時 (Coordinated Universal Time)に変換します。 
モジュール形式のタプルを返します。 
整数を [A .. P] からなる文字集合を用いて表現した文字列に変換します。 
IMAP4 "FLAGS" 応答を個々のフラグからなるタプルに変換します。 
モジュールタプルを IMAP4 "INTERNALDATE"表現形式に変換します。 
文字列形式: "DD-Mmm-YYYY HH:MM:SS +HHMM" (二重引用符含む) を返します。 
IMAP4 メッセージ番号は、メイルボックスに対する変更が行われた後には変化します; 特に、 "EXPUNGE" 命令はメッセージの削除を行いますが、残ったメッセージには再度番号を振りなおします。 
従って、メッセージ番号ではなく、 UID 命令を使い、その UID を利用するよう強く勧めます。 モジュールの末尾に、より拡張的な使用例が収められたテストセクションがあります。 
プロトコルに関する記述、およびプロトコルを実装したサーバのソースとバイナリは、全て ワシントン大学の IMAP Information Center(http://www.cac.washington.edu/imap/) にあります。 
imgfile モジュールは、Python プログラムが SGI imglib 画像ファイル (.rgb ファイルとしても知られています) にアクセスできるようにします。 
このモジュールは完全なものにはほど遠いですが、その機能はある状況で十分役に立つものなので、ライブラリで提供されています。 
現在、カラーマップ形式のファイルはサポートされていません。 このモジュールでは以下の変数および関数が定義されています: 
この例外は、サポートされていないファイル形式の場合のような全てのエラーで送出されます。 
この関数はタプル (x, y, z) を返します。 x および y は画像のサイズをピクセルで表したもので、z はピクセルあたりのバイト長です。 
3 バイトの RGB ピクセルと1 バイトのグレイスケールピクセルのみが現在サポートされています。 
この関数は指定されたファイル上の画像を読み出して復号化し、Python 文字列として返します。 
この文字列は 1 バイトのグレイスケールピクセルか、4 バイトの RGBA ピクセルによるものです。 
左下のピクセルが文字列中の最初のピクセルになります。 
これは gl.lrectwrite()に渡すのに適した形式です。 
この関数は read と同じですが、x および y のサイズにスケールされた画像を返します。 
filter および blur パラメタが省略された場合、単にピクセルデータを捨てたり複製したりすることによってスケール操作が行われるので、処理結果は、特に計算機上で合成した画像の場合にはおよそ完璧とはいえないものになります。 そうする代わりに、スケール操作後に画像を平滑化するために用いるフィルタを指定することができます。 
サポートされているフィルタの形式は 'impulse'、'box'、 'triangle'、'quadratic'、および 'gaussian' です。 
フィルタを指定する場合、blur はオプションのパラメタで、フィルタの不明瞭化度を指定します。 
標準の値は 1.0 です。 
readscaled() は正しいアスペクト比をまったく維持しようとしないので、それはユーザの責任になります。 
この関数は画像のスキャンラインの読み書きを下から上に向かって行う (フラグがゼロの場合で、SGI GL 互換です) か、上から下に向かって行う (フラグが 1 の場合で、X 互換です) かを決定する大域的なフラグを設定します。 
この関数は data 中の RGB またはグレイスケールのデータを画像ファイル file に書き込みます。 
x および y には画像のサイズを与え、z は 1 バイトグレイスケール画像の場合には 1 で、RGB 画像の場合には 3 (4 バイトの値として記憶され、下位 3 バイトが使われます) です。 これらは gl.lrectread()が返すデータの形式です。 
imghdrモジュールはファイルやバイトストリームに含まれる画像の形式を決定します。 imghdrモジュールは次の関数を定義しています: 
filenameという名前のファイル内の画像データをテストし、画像形式を表す文字列を返します。 
オプションのhが与えられた場合は、filenameは無視され、テストするバイトストリームを含んでいるとhは仮定されます。 
以下にwhat()からの戻り値とともにリストするように、次の画像形式が認識されます: 
この変数に追加することで、あなたはimghdrが認識できるファイル形式のリストを拡張できます: 
個別のテストを行う関数のリスト。 
この 
モジュールはimport文を実装するために使われているメカニズムへのインターフェイスを提供します。 
次の定数と関数が定義されています: 
バイトコンパイルされたコードファイル(.pycファイル)を認識するために使われるマジック文字列値を返します。 
(この値はPythonの各バージョンで異なります。 
三つ組みのリストを返します。 
それぞれはモジュールの特定の型を説明しています。 
各三つ組みは形式(suffix, mode, type)を持ちます。 ここで、suffixは探すファイル名を作るためにモジュール名に追加する文字列です。 
検索パスpath上でモジュールnameを見つけようとします。 
pathがディレクトリ名のリストならば、上のget_suffixes()が返す拡張子のいずれかを伴ったファイルを各ディレクトリの中で検索します。 
リスト内の有効でない名前は黙って無視されます(しかし、すべてのリスト項目は文字列でなければならない)。 
pathが省略されるかNoneならば、sys.pathのディレクトリ名のリストが検索されます。 
他の例外は引数または環境に問題があることを示唆します。 この関数は階層的なモジュール名(ドットを含んだ名前)を扱いません。 
P.M、すなわち、パッケージPのサブモジュールMを見つけるためには、パッケージPを見つけてロードするためにfind_module()とload_module()を使い、それから 
P.__path__に設定されたpath引数とともにfind_module()を使ってください。 
P自身がドット名のときは、このレシピを再帰的に適用してください。 
find_module()を使って(あるいは、互換性のある結果を作り出す検索を行って)以前見つけたモジュールをロードします。 
name引数は(これがパッケージのサブモジュールならばパッケージ名を含む)完全なモジュール名を示します。 
file引数はオープンしたファイルで、filenameは対応するファイル名です。 モジュールがファイルからロードされようとしていないとき、これらはそれぞれNoneと''であっても構いません。 
重要: file引数がNoneでなければ、例外が発生した時でさえ呼び出し側にはそれを閉じる責任があります。 
これを行うには、try ... finally文をつかうことが最も良いです。 
nameという名前の新しい空モジュールオブジェクトを返します。 
このオブジェクトはsys.modulesに挿入されません。 
言い換えると、元のスレッドがそのインポート(および、もしあるならば、それによって引き起こされるインポート)の途中で構築した不完全なモジュールオブジェクトを、他のスレッドが見られないようにします。 acquire_lock 
実行中のスレッドでインタープリタのインポートロックを取得します。 
スレッドセーフなインポートフックでは、インポート時にこのロックを取得します。 スレッドのないプラットホームではこの関数は何もしません。 
バージョン 2.3 で 新たに追加 された仕様です。 release_lock 
整数値をもつ次の定数はこのモジュールの中で定義されており、find_module()の検索結果を表すために使われます。 
ソースファイルとしてモジュールが発見された。 
コンパイルされたコードオブジェクトファイルとしてモジュールが発見された。 
動的にロード可能な共有ライブラリとしてモジュールが発見された。 
モジュールがMacintoshリソースとして発見された。 
この値はMacintoshでのみ返される。 
パッケージディレクトリとしてモジュールが発見された。 
モジュールが組み込みモジュールとして発見された。 
モジュールがフリーズされたモジュールとして発見された(init_frozen()を参照)。 
使われていません。 
nameという名前の組み込みモジュールを初期化し、そのモジュールオブジェクトを返します。 
モジュールが既に初期化されている場合は、再度初期化されます。 
いくつかのモジュールは二度初期化することができません。 -- これを再び初期化しようとすると、ImportError例外が発生します。 
nameという名前の組み込みモジュールがない場合は、Noneを返します。 
nameという名前のフリーズされたモジュールを初期化し、モジュールオブジェクトを返します。 
nameという名前のフリーズされたモジュールがない場合は、Noneを返します。 
(フリーズされたモジュールはPythonで書かれたモジュールで、そのコンパイルされたバイトコードオブジェクトがPythonのfreezeユーティリティを使ってカスタムビルトPythonインタープリタへ組み込まれています。 差し当たり、Tools/freeze/を参照してください。 
nameという名前の再度初期化できる組み込みモジュールがある場合は、1を返します。 
nameという名前の再度初期化できない組み込みモジュールがある場合は、-1を返します(init_builtin()を参照してください)。 
nameという名前の組み込みモジュールがない場合は、0を返します。 is_frozen 
nameという名前のフリーズされたモジュール(init_frozen()を参照)がある場合は、Trueを返します。 または、そのようなモジュールがない場合は、Falseを返します。 
バイトコンパイルされたコードファイルとして実装されているモジュールをロードして初期化し、そのモジュールオブジェクトを返します。 
モジュールが既に初期化されている場合は、再度初期化されます。 
name引数はモジュールオブジェクトを作ったり、アクセスするために使います。 
pathname引数はバイトコンパイルされたコードファイルを指します。 
file引数はバイトコンパイルされたコードファイルで、バイナリモードでオープンされ、先頭からアクセスされます。 現在は、ユーザ定義のファイルをエミュレートするクラスではなく、実際のファイルオブジェクトでなければなりません。 
動的ロード可能な共有ライブラリとして実装されているモジュールをロードして初期化します。 
モジュールが既に初期化されている場合は、再度初期化します。 
いくつかのモジュールではそれができずに、例外を発生するかもしれません。 
pathname引数は共有ライブラリを指していなければなりません。 
name引数は初期化関数の名前を作るために使われます。 共有ライブラリの"initname()"という名前の外部C関数が呼び出されます。 
オプションのfile引数は無視されます。 
(注意: 共有ライブラリはシステムに大きく依存します。 
Pythonソースファイルとして実装されているモジュールをロードして初期化し、モジュールオブジェクトを返します。 
モジュールが既に初期化されている場合は、再度初期化します。 
name引数はモジュールオブジェクトを作成したり、アクセスしたりするために使われます。 
pathname引数はソースファイルを指します。 
file引数はソースファイルで、テキストとして読み込むためにオープンされ、先頭からアクセスされます。 現在は、ユーザ定義のファイルをエミュレートするクラスではなく、実際のファイルオブジェクトでなければなりません。 
(拡張子.pycまたは.pyoをもつ)正しく対応するバイトコンパイルされたファイルが存在する場合は、与えられたソースファイルを構文解析する代わりにそれが使われることに注意してください。 
3.10.1 演算子から関数への対応表 
inspectは、モジュール・クラス・メソッド・関数・トレースバック・フレームオブジェクト・コードオブジェクトなどのオブジェクトから情報を取得する関数を定義しており、クラスの内容を調べる、メソッドのソースコードを取得する、関数の引数リストを取得して整形する、トレースバックから必要な情報だけを取得して表示する、などの処理を行う場合に利用します。 
このモジュールの機能は、型チェック・ソースコードの取得・クラス/関数から情報を取得・インタープリタのスタック情報の調査、の4種類に分類する事ができます。 
5.14.3 不変に自動変換するためのプロトコル 
このモジュールではイテレータを構築する部品を実装しています。 プログラム言語HaskellとSMLからアイデアを得ていますが、Pythonに適した形に修正されています。 
このモジュールは、高速でメモリ効率に優れ、単独でも組み合わせても使用することのできるツールを標準化したものです。 
標準化により、多数の個人が、それぞれの好みと命名規約で、それぞれ少しだけ異なる実装を行う為に発生する可読性と信頼性の問題を軽減する事ができます。 
ここで定義したツールは簡単に組み合わせて使用することができるようになっており、アプリケーション固有のツールを簡潔かつ効率的に作成する事ができます。 例えば、SMLの作表ツールtabulate(f)はf(0), f(1), ...のシーケンスを作成します。 
このツールボックスではimap()とcount()を用意しており、この二つを組み合わせてimap(f, count())とすれば同じ結果を得る事ができます。 同様に、 
このjpegモジュールはIndependent JPEG Group 
(IJG)によって書かれたJEPG圧縮及び展開アルゴリズムを提供します。 
JPEG形式は写真等の画像圧縮で標準的に利用され、ISO 10918で定義されてます。 
JPEG、あるいはIndependent JPEG Groupソフトウェアの詳細は、標準JPEG、若しくは提供されるソフトウェアのドキュメントを参照してください。 JPEGファイルを扱うポータブルなインタフェースはFredrik LundhによるPython Imaging Library (PIL)があります。 
また、PILの情報はhttp://www.pythonware.com/products/pil/で見つけることができます。 
モジュールjpegでは、一つの例外といくつかの関数を定義しています。 
関数compress()またはdecompress()のエラーで上げられる例外です。 
イメージファイルの幅w、高さh、1ピクセルあたりのバイト数bを引数として扱います。 
データはSGI GL順になっていて、最初のピクセルは左下端になります。 
形式のイメージが含まれた文字列を返します。 
データは圧縮されたJFIF 
形式のイメージが含まれた文字列で、この関数はタプル(data, width, height,bytesperpixel)を返します。 
また、そのデータはgl.lrectwrite()を通過します。 
compress()とdecompress()を呼ぶための様々なオプションをセットします。 
次のオプションが利用できます: 
オプション 
効果 
入力がRGBでも強制的にグレースケールを出力します。 
圧縮後イメージの品質を0から100の間の値で指定します(デフォルトは75です)。 
これは圧縮にのみ影響します。 
ハフマンテーブルを最適化します。 
時間がかかりますが、高圧縮になります。 
これは圧縮にのみ影響します。 
圧縮されていないイメージ上でインターブロックスムーシングを行います。 
低品質イメージに役立ちます。 
これは展開にのみ影響します。 
このモジュールでは、Pythonプログラムで文字列がキーワードか否かをチェックする機能を提供します。 
sがPythonのキーワードであれば真を返します。 
インタープリタで定義している全てのキーワードのシーケンス。 
特定の__future__宣言がなければ有効ではないキーワードでもこのリストには含まれます。 
linecache モジュールは、キャッシュ(一つのファイルから何行も読んでおくのが一般的です)を使って、内部で最適化を図りつつ、任意のファイルの任意の行を取得するのを可能にします。 
このモジュールは 
モジュールで、インクルードしたソースをフォーマットされたトレースバックで復元するのに使われています。 linecache モジュールでは次の関数が定義されています: 
filename という名前のファイルから lineno 行目を取得します。 
、つまり、 sys.path でそのファイルを探します。 
キャッシュをクリアします。 
それまでに getline() を使って読み込んだファイルの行が必要でなくなったら、この関数を使ってください。 
キャッシュが有効かチェックします。 
キャッシュしたファイルにディスク上で変更があったかもしれなくて、更新が必要なときにこの関数を使ってください。 
もしfilenameがなければ、全てのキャッシュエントリをチェックします。 
サンプル: 
locale モジュールは POSIX ロケールデータベースおよびロケール関連機能へのアクセスを提供します。 
POSIX ロケール機構を使うことで、プログラマはソフトウェアが実行される各国における詳細を知らなくても、アプリケーション上で特定の地域文化に関係する部分を扱うことができます。 locale モジュールは、_locale 
を被うように実装されており、ANSI C ロケール実装を使っている_locale が利用可能なら、こちらを先に使うようになっています。 locale モジュールでは以下の例外と関数を定義しています: 
setlocale() が失敗したときに送出される例外です。 
locale を指定する場合、文字列、(language code, encoding)、からなるタプル、またはNone をとることができます。 locale がタプルのの場合、ロケール別名解決エンジンによって文字列に変換されます。 
locale が与えられていて、かつ None でない場合、setlocale() は category の設定を変更します。 
変更することのできるカテゴリは以下に列記されており、値はロケール設定の名前です。 
空の文字列を指定すると、ユーザの環境における標準設定になります。 
ロケールの変更に失敗した場合、Error が送出されます。 
成功した場合、新たなロケール設定が返されます。 locale が省略されたり None の場合、category の現在の設定が返されます。 
setlocale() はほとんどのシステムでスレッド安全ではありません。 
これは全てのカテゴリをユーザの環境における標準設定 (大抵は環境変数 LANG で指定されています)に設定します。 
その後複数スレッドを使ってロケールを変更したりしない限り、問題は起こらないはずです。 
バージョン 2.0 で 変更 された仕様:引数 locale の値としてタプルをサポートしました。 
地域的な慣行のデータベースを辞書として返します。 辞書は以下の文字列をキーとして持っています: 
キー名 
カテゴリ 
小数点を表す文字です。 
'thousands_sep' が来るかもしれない場所を相対的に表した数からなる配列です。 
配列が CHAR_MAX で終端されている場合、それ以上の桁では桁数字のグループ化を行いません。 
配列が 0で終端されている場合、最後に指定したグループが反復的に使われます。 
桁グループ間を区切るために使われる文字です。 
国際通貨を表現する記号です。 
地域的な通貨を表現する記号です。 
金額表示の際に使われる小数点です。 
金額表示の際に桁区切り記号です。 
'grouping' と同じで、金額表示の際に使われます。 
正の値の金額表示に使われる記号です。 
負の値の金額表示に使われる記号です。 
金額を地域的な方法で表現する際の小数点以下の桁数です。 
金額を国際的な方法で表現する際の小数点以下の桁数です。 
'p_sign_posn' および 'n_sing_posn' の取り得る値は以下の通りです。 
説明 
通貨記号および値は丸括弧で囲われます。 
符号は値と通貨記号より前に来ます。 
符号は値と通貨記号の後に続きます。 
符号は値の直前に来ます。 
符号は値の直後に来ます。 
このロケールでは特に指定しません。 
ロケール特有の情報を文字列として返します。 
この関数は全てのシステムで利用可能なわけではなく、指定できる option もプラットフォーム間で大きく異なります。 
引数として使えるのは、locale モジュールで利用可能なシンボル定数を表す数字です。 
標準のロケール設定を取得しようと試み、結果をタプル(language code, encoding) の形式で返します。 POSIXによると、setlocale(LC_ALL, '') を呼ばなかったプログラムは、移植可能な 'C' ロケール設定を使います。 
setlocale(LC_ALL, '') を呼ぶことで、LANG 変数で定義された標準のロケール設定を使うようになります。 
Python では現在のロケール設定に干渉したくないので、上で述べたような方法でその挙動をエミュレーションしています。 他のプラットフォームとの互換性を維持するために、環境変数 LANGだけでなく、引数 envvars で指定された環境変数のリストも調べられます。 
envvars は標準では GNU gettext で使われているサーチパスになります; パスには必ず変数名 "LANG" が含まれているからです。 
与えられたロケールカテゴリに対する現在の設定を、language code、 encoding を含むシーケンスで返します。 
テキストデータをエンコードする方法を、ユーザの設定に基づいて返します。 
与えたロケール名を規格化したロケールコードを返します。 
返されるロケールコードは setlocale() で使うために書式化されています。 
category のロケールを標準設定にします。 
現在の LC_COLLATE 設定に従って二つの文字列を比較します。 
他の比較を行う関数と同じように、string1 が string2 に対して前に来るか、後に来るか、あるいは二つが等しいかによって、それぞれ負の値、正の値、あるいは 0 を返します。 
文字列を組み込み関数 cmp() 
で使える形式に変換し、かつロケールに則した結果を返します。 
この関数は同じ文字列が何度も比較される場合、例えば文字列からなるシーケンスを順序付けて並べる際に使うことができます。 
数値 val を現在の LC_NUMERIC の設定に基づいて書式化します。 
書式は % 演算子の慣行に従います。 
浮動小数点数については、必要に応じて浮動小数点が変更されます。 
groupingが真なら、ロケールに配慮した桁数の区切りが行われます。 
浮動小数点数を str(float) と同じように書式化しますが、ロケールに配慮した小数点が使われます。 
文字列を LC_NUMERIC で設定された慣行に従って浮動小数点に変換します。 
文字列を LC_NUMERIC で設定された慣行に従って整数に変換します。 
文字タイプ関連の関数のためのロケールカテゴリです。 
このカテゴリの設定に従って、モジュール 
における関数の振る舞いが変わります。 
文字列を並べ替えるためのロケールカテゴリです。 
localeモジュールの関数 strcoll() および strxfrm() が影響を受けます。 
時刻を書式化するためのロケールカテゴリです。 
time.strftime() はこのカテゴリに設定されている慣行に従います。 
設定可能なオプションは関数 localeconv() で得ることができます。 
メッセージ表示のためのロケールカテゴリです。 
現在 Python はアプリケーション毎にロケールに対応したメッセージを出力する機能はサポートしていません。 
os.strerror() が返すような、オペレーティングシステムによって表示されるメッセージはこのカテゴリによって影響を受けます。 
数字を書式化するためのロケールカテゴリです。 
関数 format()、atoi()、 atof() および locale モジュールの str() が影響を受けます。 
他の数値書式化操作は影響を受けません。 
全てのロケール設定を総合したものです。 
ロケールを変更する際にこのフラグが使われた場合、そのロケールにおける全てのカテゴリを設定しようと試みます。 
一つでも失敗したカテゴリがあった場合、全てのカテゴリにおいて設定変更を行いません。 
このフラグを使ってロケールを取得した場合、全てのカテゴリにおける設定を示す文字列が返されます。 
この文字列は、後に設定を元に戻すために使うことができます。 
localeconv() の返す特別な値のためのシンボル定数です。 
関数 nl_langinfo は以下のキーのうち一つを受理します。 ほとんどの記述は GNU C ライブラリ中の対応する説明から引用されています。 
選択されたロケールで用いられている文字エンコーディングの名前を文字列で返します。 
時刻および日付をロケール特有の方法で表現するために、 strftime(3) の書式化文字列として用いることのできる文字列を返します。 
日付をロケール特有の方法で表現するために、 strftime(3) の書式化文字列として用いることのできる文字列を返します。 
時刻をロケール特有の方法で表現するために、 strftime(3) の書式化文字列として用いることのできる文字列を返します。 
時刻を 午前/午後の書式で表現するために、 strftime(3) の書式化文字列として用いることのできる文字列を返します。 返される値は 
1 週間中の n 番目の曜日名を返します。 
警告:ロケール US における、DAY_1 を日曜日とする慣行に従っています。 国際的な (ISO 8601)月曜日を週の初めとする慣行ではありません。 
1 週間中の n 番目の曜日名を略式表記で返します。 
n 番目の月の名前を返します。 
n 番目の月の名前を略式表記で返します。 
基数点 (小数点ドット、あるいは小数点コンマ、等) を返します。 
1000 単位桁区切り (3 桁ごとのグループ化) の区切り文字を返します。 
肯定/否定で答える質問に対する肯定回答を正規表現関数で認識するために利用できる正規表現を返します。 
警告:表現は C ライブラリの regex() 関数に合ったものでなければならず、これは 
で使われている構文とは異なるかもしれません。 
肯定/否定で答える質問に対する否定回答を正規表現関数で認識するために利用できる正規表現を返します。 
通貨シンボルを返します。 シンボルを値の前に表示させる場合には"-" 、値の後ろに表示させる場合には "+" 、シンボルを基数点と置き換える場合には "." を前につけます。 
現在のロケールで使われている年代を表現する値を返します。 
ほとんどのロケールではこの値を定義していません。 この値を設定しているロケールの例は日本です。 
返される文字列の様式は決められていないので、異なるシステム間で様式に関する同じ知識が使えると期待してはいけません。 
返される値はロケールでの現年代の年値です。 
返される値は strftime で日付および時間をロケール固有の年代に基づいた方法で表現するための書式化文字列として使うことができます。 
返される値は strftime で日付をロケール固有の年代に基づいた方法で表現するための書式化文字列として使うことができます。 
返される値は 0 から 99 までの 100 個の値の表現です。 
各インスタンスは名前をもち、ドット (ピリオド) を区切り文字として表記することで、概念的には名前空間中の階層構造に配置されることになります。 
簡便性のために、Logger の適切なメソッド群を呼ぶことで、ログに記録されたメッセージの重要性を指定することができます。 
それらのメソッドとは、デフォルトのレベルを反映する形で、debug()、 info()、 warning()、error() および critical() となっています。 
これらのレベルを指定するにあたって制限はありません: Logger のより汎用的なメソッドで、明示的なレベル指定のための引数を持つlog() を使って自分自身でレベルを定義したり使用したりできます。 
レベルもロガーに関連付けることができ、デベロッパが設定することも、保存されたログ記録設定を読み込む際に設定することもできます。 ロガーに対してログ記録メソッドが呼び出されると、ロガーは自らのレベルとメソッド呼び出しに関連付けられたレベルを比較します。 
ロガーのレベルがメソッド呼び出しのレベルよりも高い場合、実際のログメッセージは生成されません。 
ハンドラは Handlerクラスのサブクラスのインスタンスで、ログ記録された (LogRecord形式の) メッセージが、そのメッセージの伝達対象となる相手 (エンドユーザ、サポートデスクのスタッフ、システム管理者、開発者) に行き着くようにする役割を持ちます。 
ハンドラには特定の行き先に方向付けられた LogRecord インスタンスが渡されます。 
ほとんどのユーザ定義の Handler のサブクラスで、この emit()をオーバライドする必要があるでしょう。 基底クラスとなる Handler クラスに加えて、多くの有用なサブクラスが提供されています: 
StreamHandler のインスタンスはストリーム (ファイル様オブジェクト) にエラーメッセージを送信します。 
FileHandler のインスタンスはディスク上のファイルにエラーメッセージを送信します。 
BaseRotatingHandler はログファイルをある時点で交替させるハンドラの基底クラスです。 
直接インスタンス化するためのクラスではありません。 
RotatingFileHandler やTimeRotatingFileHandler を使うようにしてください。 
RotatingFileHandler のインスタンスは最大ログファイルのサイズ指定とログファイルの交替機能をサポートしながら、ディスク上のファイルにエラーメッセージを送信します。 
TimeRotatingFileHandler のインスタンスは、ログファイルを一定時間間隔ごとに交替しながら、ディスク上のファイルにエラーメッセージを送信します。 
SocketHandler のインスタンスは TCP/IP ソケットにエラーメッセージを送信します。 
DatagramHandler のインスタンスは UDP ソケットにエラーメッセージを送信します。 
SMTPHandler のインスタンスは指定された電子メールアドレスにエラーメッセージを送信します。 
SysLogHandler のインスタンスは遠隔を含むマシン上の syslog デーモンにエラーメッセージを送信します。 
NTEventLogHandler のインスタンスは Windows NT/2000/XP イベントログにエラーメッセージを送信します。 
MemoryHandler のインスタンスはメモリ上のバッファにエラーメッセージを送信し、指定された条件でフラッシュされるようにします。 
HTTPHandler のインスタンスは "GET" か "POST"セマンティクスを使って HTTP サーバにエラーメッセージを送信します。 
StreamHandler および FileHandler クラスは、中核となるログ化機構パッケージ内で定義されています。 
他のハンドラはサブモジュール、logging.handlers で定義されています。 
(サブモジュールにはもうひとつ logging.config があり、これは環境設定機能のためのものです。 
)ログ記録されたメッセージは Formatter クラスのインスタンスを介し、表示用に書式化されます。 
これらのインスタンスは % 演算子と辞書を使うのに適した書式化文字列で初期化されます。 
いずれかのフィルタが偽となる値を返した場合、メッセージの処理は行われません。 基本的な Filter 機能では、指定されたロガー名でフィルタを行えるようになっています。 
この機能が利用された場合、名前付けされたロガーとその下位にあるロガーに送られたメッセージがフィルタを通過できるようになり、その他のメッセージは捨てられます。 上で述べたクラスに加えて、いくつかのモジュールレベルの関数が存在します。 
指定された名前のロガーを返します。 
名前が指定されていない場合、ロガー階層のルート (root) にあるロガーを返します。 
name を指定する場合には、通常は "a", "a.b", あるいは "a.b.c.d" といったようなドット区切りの階層的な名前にします。 名前の付け方はログ機能を使う開発者次第です。 
与えられた名前に対して、この関数はどの呼び出しでも同じロガーインスタンスを返します。 従って、ロガーインスタンスをアプリケーションの各部でやりとりする必要はなくなります。 
標準のLogger クラスか、最後にsetLoggerClass() に渡したクラスを返します。 
この関数は、新たに定義するクラス内で呼び出し、カスタマイズしたLogger クラスのインストールを行うときに既に他のコードで適用したカスタマイズを取り消そうとしていないか確かめるのに使います。 
レベル DEBUG のメッセージをルートロガーで記録します。 msg はメッセージの書式化文字列で、args は msg に取り込むための引数です。 
キーワード文字列 kwargs からは exc_info のみが調べられ、この値の評価値が偽でない場合、例外情報をログメッセージに追加します。 
(sys.exc_info の返す形式の) 例外情報を表すタプルが与えられていれば、それをメッセージに使います。 それ以外の場合には、sys.exc_info を呼び出して例外情報を取得します。 
レベル INFO のメッセージをルートロガーで記録します。 引数は debug() と同じように解釈されます。 
レベル WARNING のメッセージをルートロガーで記録します。 引数は debug() と同じように解釈されます。 
レベル ERROR のメッセージをルートロガーで記録します。 引数は debug() と同じように解釈されます。 
レベル CRITICAL のメッセージをルートロガーで記録します。 引数は debug() と同じように解釈されます。 
例外情報はログメッセージに追加されます。 
このメソッドは例外ハンドラからのみ呼び出されます。 
レベル level のメッセージをルートロガーで記録します。 その他の引数は debug() と同じように解釈されます。 
全てのロガーに対して、ロガー自体のレベルに優先するような上書きレベルlvl を与えます。 
アプリケーション全体にわたって一時的にログ出力の頻度を押し下げる必要が生じた場合にはこの関数が有効です。 
使われるレベル対する唯一の制限は、レベルは正の整数でなくてはならず、メッセージの深刻さが上がるに従ってレベルの数も上がらなくてはならないということです。 
ログ記録レベル lvl のテキスト表現を返します。 
レベルが定義済みのレベル CRITICAL、ERROR、WARNING、 INFO、あるいは DEBUGのいずれかである場合、対応する文字列が返されます。 
addLevelName() を使ってレベルに名前を関連づけていた場合、lvl に関連付けられていた名前が返されます。 
定義済みのレベルに対応する数値を指定した場合、レベルに対応した文字列表現を返します。 
そうでない場合、文字列 "Level %s" % lvl を返します。 
attrdict で属性を定義した、新しい LogRecord インスタンスを返します。 
この関数は、逆 pickle 化された LogRecord 属性辞書を socket 越しに受け取り、受信端で LogRecord インスタンスに再構築する場合に有用です。 
デフォルトのフォーマッタ (formatter) を持つ StreamHandler を生成してルートロガーに追加し、ログ記録システムの基本的な環境設定を行います。 
関数 debug()、info()、warning()、error()、および critical() は、ルートロガーにハンドラが定義されていない場合に自動的に basicConfig() を呼び出します。 
ログ記録システムに対して、バッファのフラッシュを行い、全てのハンドラを閉じることで順次シャットダウンを行うように告知します。 
ログ記録システムに対して、ロガーをインスタンス化する際にクラスklass を使うように指示します。 
指定するクラスは引数として名前だけをとるようなメソッド __init__() を定義していなければならず、__init__() では Logger.__init__()を呼び出さなければなりません。 
典型的な利用法として、この関数は自作のロガーを必要とするようなアプリケーションにおいて、他のロガーがインスタンス化される前にインスタンス化されます。 
本機能を Python 標準ライブラリに含めるよう記述している提案書。 
この logging パッケージのオリジナル 
オリジナルのloggingパッケージ。 
このサイトにあるバージョンのパッケージは、標準でloggingパッケージを含まないPython 1.5.2 と 2.1.x、2.2.xでも使用できます 
このモジュールは、標準モジュール os でサポートされるのと同様の機能を、Mac OS 9 オペレーティングシステムに依存した機能として実装しています。 
このモジュールを利用する一番良い使い方は posix モジュール経由で使うことです。 
このモジュールは MacPython-OS9 にのみ存在し、MacPython-OSX 上では posix を利用します。 
このモジュールでは次の関数が使えます。 chdir()、close()、dup()、fdopen()、getcwd()、lseek()、listdir()、mkdir()、open()、read()、rename()、rmdir()、stat()、sync()、unlink()、write()、そして例外 error も定義されています。 
stat() により返される時間は浮動小数点数で、 MacPython-OS9 で使われる他の時間の値と同様です。 
macerrors は、MacOS エラーコードを意味する定数定義を含みます。 
リリース 2.3 で撤廃されました。 macfsモジュールは旧式のものです。 
FSSpec、FSRef、Alias の操作には、Carbon.Fileまたは 
モジュールを、ファイルダイアログには 
を使ってください。 
また、このモジュールはUFSパーティションでは正確には動作しないことがわかっています。 
このモジュールでは、MacintoshのFSSpec の操作、エイリアスマネージャ、finderエイリアス、および標準ファイルパッケージへのアクセスを提供しています。 
関数やメソッドがfile 引数をとるようになっている場合、引数は常に次の 3 つ、(1) Macintosh のフルパス名あるいは部分パス名、(2) FSSpec オブジェクト、(3) Inside Macintosh: Files で解説されている 3 要素のタプル(wdRefNum, parID, name)のうちのいずれかになります。 
FSSpec は、実在しないファイルでも、実在するフォルダの下に配置されていることになっている限り表現できます。 MacPython ではパス名も同じように扱えますが、 unix ベースの Python ではパス名とFSRefsの挙動が異なるため扱えません。 
詳しくは Apple のドキュメントを参照してください。 エイリアスと標準ファイルパッケージの詳細も Apple のドキュメントに書かれています。 
指定したファイルに対するFSSpecオブジェクトを作成します。 
FSSpec の C 構造体の生データが入った文字列からFSSpecオブジェクトを作成します。 
主にFSSpec構造体をネットワーク経由で得る場合に便利です。 
Alias の C 構造体の生データが入った文字列からAliasオブジェクトを作成します。 
主にAlias構造体をネットワーク経由で得る場合に便利です。 
ゼロで埋めたFInfoオブジェクトを作成します。 
エイリアスファイルを解決します (オリジナルのファイルとの対応を取ります)。 
標準的イアログ 「入力ファイルを開く」をユーザに提示します。 
オプションとして、ユーザが選択できるファイルを制限するために4 文字の文字列で表されたファイルタイプ指定子を 4 つまで渡せます。 
この関数は、FSSpecオブジェクトとユーザがキャンセルしないでダイアログを閉じたかどうかを示すフラグを返します。 
StandardGetFile() とほぼ同じですが、ダイアログの一番上に表示されるプロンプトを指定できます。 
この関数は、FSSpecオブジェクトとユーザがキャンセルしないでダイアログを閉じたかどうかを示すフラグを返します。 
非標準的ダイアログ「ディレクトリを選ぶ」をユーザに提示します。 
このダイアログでは、選択したいディレクトリを開いておいてから、``select current directory'' ボタンをクリックします。 prompt はプロンプト文字列で、ダイアログの一番上に表示されます。 
この関数は、FSSpecオブジェクトとユーザがキャンセルしないでダイアログを閉じたかどうかを示すフラグを返します。 
ファイル選択ダイアログを提示する時に最初に表示されるフォルダを設定します。 fsspec には、フォルダそのものではなく、フォルダ内のファイルを指定します (実在しないファイルでもかまいません)。 
引数を渡さない場合は、フォルダはカレントディレクトリ、つまり os.getcwd()で返されるディレクトリに設定されます。 
System 7.5 以降では、ユーザは「一般設定」コントロールパネルで標準ファイルパッケージの振る舞いを変更でき、設定によってはこの関数の呼び出しが無効化されるので注意してください。 
ゴミ箱や初期設定フォルダなど、Mac OS が管理している「特別な」フォルダの位置を検索します。 where は検索したいディスク、which は検索したいフォルダを指定する4文字の文字列です。 
create を設定すると、該当するフォルダが存在しない場合に新たに生成します。 
(vrefnum, dirid) からなるタプルを返します。 where とwhich に指定できる定数は、標準モジュールCarbon.Foldersにあります。 
与えられたファイルを指す最小限のaliasオブジェクトを返します。 ファイルはフルパス名で与えなければなりません。 
これは存在しないファイルを指すAliasを作成する唯一の方法です。 
4 文字のクリエータコードcreator を持ったアプリケーションの位置を探し出します。 
この関数はアプリケーションを指すFSSpecオブジェクトを返します。 
2.3.1 FSSpec オブジェクト 
このモジュールには、Macintosh 上でのファイル操作を便利にするためのルーチンがいくつか入っています。 
全てファイルパラメタは,パス名かFSRef またはFSSpec オブジェクトで指定できます。 
このモジュールは、リソースフォークつきファイル (forked file) をサポートするファイルシステムを想定しているので、UFSパーティションに使ってはなりません. macostools モジュールでは以下の関数を定義しています。 
ファイルsrcをdstへコピーします。 
カスタムアイコン、コメント、アイコン位置はコピーされません。 
srcからdstへ再帰的にファイルのツリーをコピーします。 必要に応じてフォルダを作成してゆきます.srcとdstはパス名で指定しなければなりません。 
srcを示すファインダエイリアスdstを作成します。 
ファイルdstのクリエータやタイプなどのファインダ情報が変わったことをファインダに知らせます。 
ファイルはパス名かFSSpecで指定できます。 
この呼び出しは,ファインダにアイコンを再描画させるよう命令します。 
copyに用いるバッファサイズで、デフォルトは 1 メガバイトです。 
Apple のドキュメントでは,ファインダエイリアスの作成プロセスを規定していません.そのため,mkalias() で作成したエイリアスが互換性のない振る舞いをする可能性があるので注意してください。 
このモジュールは os.path モジュールの Macintosh 実装です。 
このモジュールで、os.path 
への最も汎用性のあるアクセスができます。 
を参照してください。 
次の関数がこのモジュールで利用できます。 normcase()、normpath()、isabs()、join()、split()、isdir()、isfile()、walk()、exists()。 
os.path で利用できる他の関数については、ダミーの関数として相当する物が利用できます。 
macresource はスクリプトが MacPython 上や MacPython アプレットおよび OSX Python 上で起動されている時、特別な処理をせずにダイアログやメニューなどのようなリソースを見つけるためのヘルパースクリプトです。 
このモジュールでは (Unixの) メイルボックス内のメイルに簡単かつ一様な方法でアクセスできるようにするクラスを定義しています。 
クラスUnixMailbox 
全てのメッセージが単一のファイルに収められ、"From " ("From_" として知られています) 行によって分割されているような、旧来の Unix形式のメイルボックスにアクセスします。 
ファイルオブジェクト fp はメイルボックスファイルを指します。 
オプションの factory パラメタは新たなメッセージオブジェクトを生成するような呼び出し可能オブジェクトです。 factory は、メイルボックスオブジェクトに対して next() メソッドを実行した際に、単一の引数、fp を伴って呼び出されます。 
この引数の標準の値は rfc822.Message クラスです( 
モジュール - および以下 - を参照してください)。 
注意:このモジュールの実装上の理由により、fp オブジェクトはバイナリモードで開くようにしてください。 
特にWindows上では注意が必要です。 
可搬性を最大限にするために、Unix形式のメイルボックス内にあるメッセージは、正確に 'From ' (末尾の空白に注意してください) で始まる文字列が、直前の正しく二つの改行の後にくるような行で分割されます。 
現実的には広範なバリエーションがあるため、それ以外のFrom_ 行について考慮すべきではないのですが、現在の実装では先頭の二つの改行をチェックしていません。 
これはほとんどのアプリケーションでうまく動作します。 UnixMailbox クラスでは、ほぼ正確に From_ デリミタにマッチするような正規表現を用いることで、より厳密に From_ 行のチェックを行うバージョンを実装しています。 
UnixMailbox ではデリミタ行が"From name time 
" の行に分割されるものと考えます。 
可搬性を最大限にするためには、代わりに PortableUnixMailbox クラスを使ってください。 
このクラスは UnixMailbox と同じですが、個々のメッセージは "From " 行だけで分割されるものとみなします。 より詳細な情報については、 
クラスPortableUnixMailbox 
厳密性の低い UnixMailbox のバージョンで、メッセージを分割する行は "From " のみであると見なします。 
実際に見られるメイルボックスのバリエーションに対応するため、 From 行における``name time'' 部分は無視されます。 
メイル処理ソフトウェアはメッセージ中の 'From ' で始まる行をクオートするため、この分割はうまく動作します。 
クラスMmdfMailbox 
全てのメッセージが単一のファイルに収められ、4 つの control-A 文字によって分割されているような、MMDF 形式のメイルボックスにアクセスします。 
ファイルオブジェクト fp はメイルボックスファイルをさします。 オプションの factory は UnixMailbox クラスにおけるのと同様です。 
クラスMHMailbox 
数字で名前のつけられた別々のファイルに個々のメッセージを収めたディレクトリである、MH メイルボックスにアクセスします。 メイルボックスディレクトリの名前は dirname で渡します。 
factory は UnixMailbox クラスにおけるのと同様です。 
クラスMaildir 
Qmail メイルディレクトリにアクセスします。 
dirname で指定された全ての新規および現在のメッセージにアクセスできます。 
クラスBabylMailbox 
MMDF メイルボックスと似ている、Babyl メイルボックスにアクセスします。 
Babyl 形式では、各メッセージは二つのヘッダからなるセット、original ヘッダおよび visible ヘッダをを持っています。 
original ヘッダは '*** EOOH ***' (End-Of-Original-Headers) だけを含む行の前にあり、visible ヘッダは EOOH 行の後にあります。 
Babyl 互換のメイルリーダは visible ヘッダのみを表示し、 BabylMailbox オブジェクトは visible ヘッダのみを含むようなメッセージを返します。 
メイルメッセージは EOOH 行で始まり、'037014' だけを含む行で終わります。 
factory は UnixMailbox クラスにおけるのと同様です。 
モジュールが撤廃されたことにより、 
パッケージを使ってメイルボックスからメッセージオブジェクトを生成するよう推奨されているので注意してください。 
(デフォルトの設定は以前のバージョンとの互換性のために変更されていません。 
) 安全に移行を行うには、以下のちょっとしたコードを使います: 
上のラッパはメイルボックス内にある不正な形式の MIME メッセージに対して防御性がある反面、メイルボックスの next() メソッドが空文字列を渡す場合に備えなければなりません。 
逆に、もしメイルボックス内には正しい形式の MIME メッセージしか入っていないと分かっているのなら、単に以下のようにします: 
伝統的な ``mbox'' メイルボックス形式に関する記述です。 
``maildir'' メイルボックス形式の記述です。 
メイルボックスファイルに記録されている Content-Length: ヘッダに依存した場合に発生する問題についての記述です。 
mailcap ファイルは、メイルリーダや Web ブラウザのような MIME 対応のアプリケーションが、異なる MIME タイプのファイルにどのように反応するかを設定するために使われます(``mailcap'' の名前は ``mail capability'' から取られました)。 
例えば、ある mailcap ファイルに "video/mpeg; xmpeg %s" のような行が入っていたとします。 
ユーザが email メッセージや Web ドキュメント上でその MIME タイプ video/mpeg に遭遇すると、"%s" はファイル名 (通常テンポラリファイルに属するものになります)に置き換えられ、ファイルを閲覧するために xmpeg プログラムが自動的に起動されます。 mailcap の形式は RFC 1524, ``A User AgentConfiguration Mechanism For Multimedia Mail Format Information'' で文書化されていますが、この文書はインターネット標準ではありません。 
しかしながら、 mailcap ファイルはほとんどの Unix システムでサポートされています。 
2 要素のタプルを返します; 最初の要素は文字列で、実行すべきコマンド (os.system() に渡されます) が入っています。 
二つめの要素は与えられた MIME タイプに対する mailcap エントリです。 
一致する MIME タイプが見つからなかった場合、(None, None) が返されます。 
key は desired フィールドの値で、実行すべき動作のタイプを表現します; ほとんどの場合、単にMIME 形式のデータ本体を見たいと思うので、標準の値は 'view' になっています。 
与えられた MIME 型をもつ新たなデータ本体を作成した場合や、既存のデータ本体を置き換えたい場合には、'view' の他に'compose' および 'edit' を取ることもできます。 
これらフィールドの完全なリストについては RFC 1524 を参照してください。 
filename はコマンドライン中で "%s" に代入されるファイル名です; 標準の値は '/dev/null' で、たいていこの値を使いたいわけではないはずです。 従って、ファイル名を指定してこのフィールドを上書きする必要があるでしょう。 
plist は名前付けされたパラメタのリストです; 標準の値は単なる空のリストです。 
リスト中の各エントリはパラメタ名を含む文字列、等号 ("=")、およびパラメタの値でなければなりません。 
mailcap エントリには %{foo} といったような名前つきのパラメタを含めることができ、'foo' と名づけられたパラメタの値に置き換えられます。 
例えば、コマンドライン"showpartial %{id} %{number} %{total}"が mailcap ファイルにあり、plist が ['id=1','number=2', 'total=3'] に設定されていれば、コマンドラインは'showpartial 1 2 3' になります。 
mailcap ファイル中では、 オプションの ``test'' フィールドを使って、(計算機アーキテクチャや、利用しているウィンドウシステムといった)何らかの外部条件をテストするよう指定することができます。 findmatch() はこれらの条件を自動的にチェックし、チェックが失敗したエントリを読み飛ばします。 
MIME タイプを mailcap ファイルのエントリに対応付ける辞書を返します。 
この辞書は findmatch() 関数に渡されるべきものです。 
エントリは辞書のリストとして記憶されますが、この表現形式の詳細について知っておく必要はないでしょう。 mailcap 情報はシステム上で見つかった全ての mailcap ファイルから導出されます。 
ユーザ設定の mailcap ファイル $HOME/.mailcapはシステムの mailcap ファイル /etc/mailcap、/usr/etc/mailcap、および /usr/local/etc/mailcapの内容を上書きします。 
以下に使用例を示します: 
この環境はPythonスクリプトをメインプログラムとして実行される際によく使われる``条件付きスクリプト''の一節が実行される環境です。 
6.8 ライブラリレベルのマークアップ 
6.7 モジュール特有のマークアップ この節で説明しているマークアップは、記述対象のモジュールに関する情報を提供するために使います。 
このマークアップは、モジュールを説明している節の先頭でよく使います。 
典型的な例は、以下のようになります: 
\section{\module{spam} ---SPAM 機能へのアクセス}\declaremodule{extension}{spam}\platform{Unix}\modulesynopsis{\UNIX の SPAM 機能へのアクセス手段。 }\moduleauthor{Jane Doe}{jane.doe@frobnitz.org} 
Python のパッケージ 
-- ひとまとまりの単位として記述できるようなモジュールの集合 -- は、モジュールと同じマークアップを使って解説します。 
パッケージ内のモジュール名は``完全限定 (fully qualified)'' 形式で入力せねばなりません(つまり、パッケージ名を含めねばなりません)。 
例えば、 ``bar'' というパッケージ内の ``foo'' というモジュールはmodule{bar.foo} と書き、リファレンスの先頭は以下のようになります: \section{\module{bar.foo} ---\module{bar} パッケージ内のモジュール}\declaremodule{extension}{bar.foo}\modulesynopsis{\module{bar} パッケージ内の小さなモジュール}\moduleauthor{Jane Doe}{jane.doe@frobnitz.org} 
パッケージの名前もまた、module でマークします。 
二つのパラメタ: モジュールの種類 ("standard"、"builtin"、"extension"、または" 
") と、モジュールの名前を必要とします。 この節にリンクを張ったり参照を行ったりするための ``キー'' によっては、オプションのパラメタを指定せねばなりません。 
``キー'' は、モジュールの名前にアンダースコアが入っている場合にのみ用い、モジュール名からアンダースコアを取り除いた名前でなければなりません。 type パラメタは上に述べた値のいずれかでなければならず、そうでない値を指定するとエラーが出力されるので注意してください。 
パッケージに入っているようなモジュールの場合、name パラメタには完全限定形式の名前を指定せねばなりません。 
このマクロはモジュールを紹介するsection の先頭に置かねばなりません。 
} モジュールの可搬性について述べるために使います。 
specifier はモジュールを利用できるようなプラットフォームを指定するキーをコンマで区切ったリストです。 
キーは短い識別子にします; 実際に使われている例には"IRIX"、"Mac"、"Windows"、"Unix" があります。 
あるプラットフォームを表す場合、すでに使われているキーがあるなら、それを使うようにするのが重要です。 
この情報は、モジュール索引や、HTML形式、GNU info 形式の出力における注釈情報に使われます。 
} text はモジュールの短い ``一行の'' 説明で、各章の紹介の一部として使われることがあります。 
このマクロは declaremoduleの後ろに配置せねばなりません。 モジュールの概要は、localmoduletable マクロによって挿入される一覧表の内容を構築する際に使われます。 
マークアップを行った場所では何のテキストも生成されません。 
このマクロはモジュールの作者についての情報を符号化するために使われます。 
現在は出力生成に使われていませんが、モジュールの起源を判断する際に役立つはずです。 
6.8 ライブラリレベルのマークアップ ご意見やご指摘をお寄せになりたい方は、 
このモジュールには Python 値をバイナリ形式で読み書きできるような関数が含まれています。 
このバイナリ形式は Python 特有のものですが、マシンアーキテクチャ非依存のものです (つまり、Python の値を PC 上でファイルに書き込み、Sun に転送し、そこで読み戻すことができます)。 
バイナリ形式の詳細がドキュメントされていないのは故意によるものです; この形式は (稀にしかないことですが) Python のバージョン間で変更される可能性があるからです。 
このモジュールは汎用の ``永続化 (persistence)'' モジュールではありません。 
汎用的な永続化や、RPC 呼び出しを通じたPython オブジェクトの転送については、モジュール 
marshal モジュールは主に、``擬似コンパイルされた (pseudo-compiled)'' コードの .pyc ファイルへの読み書きをサポートするために存在します。 
従って、 Python のメンテナは、必要が生じれば marshal 形式を後方互換性のないものに変更する権利を有しています。 
Python オブジェクトを直列化および非直列化したい場合には、pickle モジュールを使ってください。 
警告: marshalモジュールは、誤ったデータや悪意を持って作成されたデータに対する安全性を考慮していません。 
信頼できない、もしくは認証されていない出所からのデータを非直列化してはなりません。 
全ての Python オブジェクト型がサポートされているわけではありません;一般的には、どの起動中の Python 上に存在するかに依存しないオブジェクトだけがこのモジュールで読み書きできます。 
以下の型:None、整数、長整数、浮動小数点数、文字列、Unicode オブジェクト、タプル、リスト、辞書、タプルとして解釈されるコードオブジェクト、がサポートされています。 リストと辞書は含まれている要素もサポートされている型であるもののみサポートされています; 再帰的なリストおよび辞書は書き込んではなりません (無限ループを引き起こしてしまいます)。 
補足説明: C 言語の long int が (DEC Alpha のように) 32 ビットよりも長いビット長を持つ場合、32 ビットよりも長い Python 整数を作成することが可能です。 そのような整数が整列化された後、C 言語の long int のビット長が 32 ビットしかないマシン上で読み戻された場合、通常整数の代わりにPython 長整数が返されます。 
型は異なりますが、数値は同じです。 
(この動作は Python 2.2 で新たに追加されたものです。 
開かれたファイルに値を書き込みます。 
値はサポートされている型でなくてはなりません。 
ファイルは sys.stdout か、open() や posix.popen() が返すようなファイルオブジェクトでなくてはなりません。 
またファイルはバイナリモード('wb' または 'w+b') で開かれていなければなりません。 値 (または値のオブジェクトに含まれるオブジェクト) がサポートされていない型の場合、ValueError 例外が送出されます -- が、同時にごみのデータがファイルに書き込まれます。 
このオブジェクトはload() で適切に読み出されることはないはずです。 
バージョン 2.4 で 新たに追加 された仕様:dumpsで、データフォーマットを表すversion 引数を利用するべきです。 
開かれたファイルから値を一つ読んで返します。 
有効な値が読み出せなかった場合、EOFError、ValueError、またはTypeError を送出します。 
ファイルはバイナリモード('rb' または 'r+b') で開かれたファイルオブジェクトでなければなりません. 
警告:サポートされない型を含むオブジェクトが dump() で整列化されている場合、load() は整列化不能な値を None で置き換えます。 
dump(value, file) でファイルに書き込まれるような文字列を返します。 
値はサポートされている型でなければなりません。 
値がサポートされていない型 (またはサポートされていない型のオブジェクトを含むような) オブジェクトの場合、ValueError 例外が送出されます。 
データ文字列を値に変換します。 
有効な値が見つからなかった場合、EOFError、 ValueError、またはTypeError が送出されます。 
文字列中の他の文字は無視されます。 
これに加えて、以下の定数が定義されています: 
モジュールが利用するバージョンを表します。 
バージョン0 は歴史的なフォーマットです。 バージョン1(Python 2.4で追加されました)は文字列の再利用をします。 
現在のバージョンは1です。 
...変更される可能性があるからです。 
このモジュールの名前は (特に) Modula-3 の設計者の間で使われていた用語の一つに由来しています。 彼らはデータを自己充足的な形式で輸送する操作に ``整列化 (marshalling)'' という用語を使いました。 
厳密に言えば、``整列させる (to marshal)'' とは、あるデータを(例えば RPC バッファのように) 内部表現形式から外部表現形式に変換することを意味し、``非整列化 (unmarshalling)'' とはその逆を意味します。 
このモジュールはいつでも利用できます。 
モジュールにある同じ名前の関数を使ってください。 
ほとんどのユーザーは複素数を理解するのに必要なだけの数学を勉強したくないので、複素数に対応した関数と対応していない関数の区別がされています。 
明示的な注記のない限り、戻り値は全て浮動小数点数になります。 以下は整数論および数表現にまつわる関数です: 
x の天井値 (ceil)、すなわちx 以上の最も小さい整数をfloat型で返します。 
x の絶対値を返します。 
x の床値 (floor)、すなわちx 以下の最も大きい整数をfloat型で返します。 
プラットフォームの C ライブラリで定義されているfmod(x, y) を返します。 Python の 
という式は必ずしも同じ結果を返さないということに注意してください。 
C 標準の要求では、fmod は除算の結果が x と同じ符号になり、大きさがabs(y) より小さくなるような整数 n についてはfmod(x, y) が厳密に(数学的に、つまり限りなく高い精度で) 
と等価であるよう求めています。 
Python の 
は、y と同じ符号の結果を返し、浮動小数点の引数に対して厳密な解を出せないことがあります。 例えば、 fmod(-1e-100, 1e100) は -1e-100 ですが、Python の-1e-100 % 1e100 は 1e100-1e-100 になり、浮動小数点型で厳密に表現できず、ややこしいことに1e100 に丸められます。 
このため、一般には浮動小数点の場合には関数 fmod()、整数の場合には 
を使う方がよいでしょう。 
x の仮数と指数を (m, e)のペアとして返します。 
x がゼロの場合は、 (0.0, 0)を返し、それ以外の場合は、0.5 = abs(m) 1 を返します。 
これは浮動小数点型の内部表現を可搬性を保ったまま "分解する (pick apart)" するためです。 
xの小数部分と整数部分を返します。 
両方の結果は xの符号を受け継ぎます。 整数部はfloat型で返されます。 
通常、Python の浮動小数点型は 53 ビット以上の精度をもたない (プラットフォームにおける C double 型と同じ) ので、結果的にabs(x) = 2**52 であるような浮動小数点型x は小数部分を持たなくなるのです。 以下は指数および対数関数です: 
を返します。 
base を底とした x の対数を返します。 
base を省略した場合x の自然対数を返します。 バージョン 2.3 で 変更 された仕様:base argument added 
x の10を底とした対数を返します。 
x の平方根を返します。 
以下は三角関数です: 
x の逆余弦を返します。 
x の逆正弦を返します。 
x 逆正接を返します。 
atan(y / x) の逆正接をラジアンで返します。 
x の余弦を返します。 
ユークリッド距離(sqrt(x*x + y*y))を返します。 
xの正弦を返します。 
x の正接を返します。 
以下は角度に関する関数です: 
角 x をラジアンから度数に変換します。 
角 x を度数からラジアンに変換します。 
以下は双曲線関数です: 
xの双曲線正弦を返します。 
このモジュールでは以下の 2つの数学定数も定義しています: 
数学定数 pi。 
数学定数 e。 
注意: math モジュールは、ほとんどが実行プラットフォームにおけるC 言語の数学ライブラリ関数に対する薄いラッパでできています。 
例外的な場合での挙動は、 C 言語標準ではおおさっぱにしか定義されておらず、さらに Python は数学関数におけるエラー報告機能の挙動をプラットフォームのC 実装から受け継いでいます。 
その結果として、エラーの際 (およびなんらかの引数がとにかく例外的であると考えられる場合) に送出される特定の例外については、プラットフォーム間やリリースバージョン間を通じて有意なものとなっていません。 
例えば、math.log(0) が -Inf を返すか ValueError または OverflowError を送出するかは不定であり、math.log(0) が OverflowError を送出する場合においてmath.log(0L) が ValueError を送出するときもあります。 
このモジュールは RSA 社の MD5 メッセージダイジェスト アルゴリズムへのインタフェースを実装しています。 
(Internet RFC 1321 も参照してください)。 
利用方法は極めて単純です。 まず md5 オブジェクトを new() を使って生成します。 
後は update() メソッドを使って、生成されたオブジェクトに任意の文字列データを入力します。 オブジェクトに入力された文字列データ全体の digest (``fingerprint'' として知られる強力な 128-bit チェックサム) は digest() を使っていつでも調べることができます。 
例えば、文字列 'Nobody inspects the spammish repetition' のダイジェストを得るためには以下のようにします: 
もっと詰めて書くと以下のようになります: 
以下の値はモジュールの中で定数として与えられており、new()で返される md5 オブジェクトの属性としても与えられます: 
digest_size 返されるダイジェスト値のバイト数で表した長さ。 
常に 16 です。 
md5 クラスオブジェクトは以下のメソッドをサポートします: 
新たな md5 オブジェクトを返します。 
もし arg が存在するなら、update(arg) を呼び出します。 
下位互換性のために、new() の別名として提供されています。 
md5 オブジェクトは以下のメソッドをサポートします: 
文字列 arg を入力として md5 オブジェクトを更新します。 
このメソッドを繰り返して呼び出す操作は、それぞれの呼び出し時の引数arg を結合したデータを引数として一回の呼び出す操作と同等になります: つまり、m.update(a); m.update(b) はm.update(a+b) と同等です。 
これまで update() で与えてきた文字列入力のダイジェストを返します。 
返り値は 16 バイトの文字列で、null バイトを含む非 ASCII 文字が入っているかもしれません。 
digest() に似ていますが、ダイジェストは長さ 32 の文字列になり、16 進表記文字しか含みません。 
この文字列は電子メールやその他のバイナリを受け付けない環境でダイジェストを安全にやりとりするために使うことができます。 
md5 オブジェクトのコピー (``クローン'') を返します。 
冒頭の部分文字列が共通な複数の文字列のダイジェストを効率よく計算する際に使うことができます。 
Secure Hash Algorithm (SHA) を実装した類似のモジュール。 
SHA アルゴリズムはより安全なハッシュアルゴリズムだと考えられています。 . 
mhlib モジュールは MH フォルダおよびその内容に対する Python インタフェースを提供します。 このモジュールには、あるフォルダの集まりを表現する MH、単一のフォルダを表現する Folder、単一のメッセージを表現する Message、の 3 つのクラスが入っています。 
クラスMH 
MH は MH フォルダの集まりを表現します。 クラスFolder 
Folder クラスは単一のフォルダとフォルダ内のメッセージ群を表現します。 
クラスMessage 
Message オブジェクトはフォルダ内の個々のメッセージを表現します。 
メッセージクラスは mimetools.Message から導出されています。 
12.6.1 Message オブジェクトの追加メソッド 
パッケージを mimetoolsモジュールより優先して使うべきです。 
このモジュールは、下位互換性維持のためにのみ存在しています。 
このモジュールは、 
モジュールのMessage クラスのサブクラスと、マルチパートMIME や符合化メッセージの操作に役に立つ多くのユーティリティ関数を定義しています。 これには以下の項目が定義されています: 
Message クラスの新しいインスタンスを返します。 
これは、rfc822.Message クラスのサブクラスで、いくつかの追加のメソッドがあります(以下を参照のこと)。 
seekable 引数は、 rfc822.Messageのものと同じ意味を持ちます。 
パートの境界として使うことができる見込みが高いユニークな文字列を返します。 
その文字列は、 'hostipaddr.uid.pid.timestamp.random'の形をしています。 
オープンしたファイルオブジェクト input から、許される MIME encodingを使って符号化されたデータを読んで、オープンされたファイルオブジェクトoutput に復号化されたデータを書きます。 
encoding に許される値は、'base64', 'quoted-printable', 'uuencode','x-uuencode', 'uue', 'x-uue', '7bit', および'8bit'です。 
'7bit' あるいは '8bit' で符号化されたメッセージを復号化しても何も効果がありません。 
入力が出力に単純にコピーされるだけです。 
オープンしたファイルオブジェクト input からデータを読んで、それを許される MIME encoding を使って符号化して、オープンしたファイルオブジェクト output に書きます。 encoding に許される値は、[methoddecode()のものと同じです。 
オープンしたファイル inputから行を EOF まで読んで、それらをオープンしたファイル output に書きます。 
オープンしたファイル inputからブロックを EOF まで読んで、それらをオープンしたファイル output に書きます。 
ブロックの大きさは現在 8192 に固定されています。 
MIME データのような、別個のパーツを含むファイルの読み込みをサポート。 
MIME でよく訊ねられる質問。 
MIMEの概要に関しては、この文書の Part 1 の質問 1.1 への答えを見ること。 
mimetypes モジュールは、ファイル名あるいは URL と、ファイル名拡張子に関連付けられた MIME 型とを変換します。 
たとえモジュールが初期化されていなくても、もしこれらの関数が、init() がセットアップする情報に依存していれば、これらの関数は、init() を呼びます。 
filename で与えられるファイル名あるいは URL に基づいて、ファイルの型を推定します。 
戻り値は、タプル (type,encoding) です、ここで typeは、もし型が(拡張子がないあるいは未定義のため)推定できない場合は、None を、あるいは、MIME content-type: ヘッダ 
に利用できる、'type/subtype'の形の文字列です。 
符号化方式のサフィックスは大/小文字を区別します;データ型サフィックスは、最初大/小文字を区別して試し、それから大/小文字を区別せずに試します。 省略可能な strictは、既知の MIME 型のリストとして認識されるものが、IANAとして登録された正式な型のみに限定されるかどうかを指定するフラグです。 
strict が true (デフォール)の時は、IANA 型のみがサポートされます;strict が false のときは、いくつかの追加の、非標準ではあるが、一般的に使用される MIME 型も認識されます。 
type で与えられる MIME 型に基づいてファイルの拡張子を推定します。 
戻り値は、先頭のドット (".")を含む、可能なファイル拡張子すべてを与える文字列のリストです。 
拡張子と特別なデータストリームとの関連付けは保証されませんが、guess_type()によって MIME型 type とマップされます。 省略可能な strict は guess_type() 関数のものと同じ意味を持ちます。 
戻り値は、先頭のドット (".")を含む、ファイル拡張子を与える文字列のリストです。 
拡張子と特別なデータストリームとの関連付けは保証されませんが、guess_type()によって MIME型 type とマップされます。 
もし typeに対して拡張子が推定できない場合は、 Noneが返されます。 省略可能な strict は guess_type() 関数のものと同じ意味を持ちます。 
モジュールの動作を制御するために、いくつかの追加の関数とデータ項目が利用できます。 
内部のデータ構造を初期化します。 
もし files が与えられていれば、これはデフォールトの型のマップを増やすために使われる、一連のファイル名でなければなりません。 
もし省略されていれば、使われるファイル名は knownfilesから取られます。 
file あるいは knownfiles 内の各ファイル名は、それ以前に現れる名前より優先されます。 繰り返し init() を呼び出すことは許されています。 
ファル filename で与えられた型のマップが、もしあればロードします。 
型のマップは、先頭の dot (".") を含むファイル名拡張子を、'type/subtype'の形の文字列にマッピングする辞書として返されます。 
もしファイル filename が存在しないか、読み込めなければ、None が返されます。 
mime型 type からのマッピングを拡張子 ext に追加します。 
拡張子がすでに既知であれば、新しい型が古いものに置き替わります。 
その型がすでに既知であれば、その拡張子が、既知の拡張子のリストに追加されます。 strictがある時は、そのマッピングは正式なMIME型に、そうでなければ、非標準のMIME型に追加されます。 
グローバルなデータ構造が初期化されているかどうかを示すフラグ。 
これは init() により true に設定されます。 
共通にインストールされた型マップファイル名のリスト。 
これらのファイルは、普通 mime.typesという名前であり、パッケージごとに異なる場所にインストールされます。 
これは、符号化方式と型が同一拡張子で示される符号化ファイルが認識できるように使用されます。 
例えば、.tgz 拡張子は、符号化と型が別個に認識できるように .tar.gzにマップされます。 
ファイル名拡張子を符号化方式型にマッピングする辞書 
ファイル名拡張子をMIME型にマップする辞書 
ファイル名拡張子を非標準ではあるが、一般に使われているMIME型にマップする辞書 
MimeTypes クラスは、1つ以上のMIME-型 データベースを必要とするアプリケーションに役に立つでしょう。 
クラスMimeTypes 
このクラスは、MIME-型データベースを表現します。 
デフォールトでは、このモジュールの他のものと同じデータベースへのアクセスを提供します。 
初期データベースは、このモジュールによって提供されるもののコピーで、追加の mime.types-形式のファイルを、read() あるいは readfp()メソッドを使って、データベースにロードすることで拡張されます。 
マッピング辞書も、もしデフォールトのデータが望むものでなければ、追加のデータをロードする前にクリアされます。 省略可能な filenamesパラメータは、追加のファイルを、デフォールトデータベースの"トップに"ロードさせるのに使うことができます。 
12.7.1 Mime型 オブジェクト 
リリース 2.3 で撤廃されました。 mimify モジュールを使うよりも 
パッケージを使うべきです。 
このモジュールは以前のバージョンとの互換性のために保守されているにすぎません。 
mimify モジュールでは電子メイルメッセージから MIME へ、および MIME から電子メイルメッセージへの変換を行うための二つの関数を定義しています。 
電子メイルメッセージは単なるメッセージでも、MIME 形式でもかまいません。 各パートは個別に扱われます。 
メッセージ (の一部) の MIME 化 (mimify) の際、7 ビット ASCII文字を使って表現できない何らかの文字が含まれていた場合、メッセージのquoted-printable への符号化が伴います。 
メッセージが送信される前に編集しなければならない場合、MIME 化および非 MIME 化は特に便利です。 
典型的な使用法は以下のようになります: 
モジュールでは以下のユーザから呼び出し可能な関数と、ユーザが設定可能な変数を定義しています: 
infile を outfile にコピーします。 
decode_base64 引数が与えられており、その値が真である場合、base64 符号で符号化されているパートも同様に復号化されます。 
line 内の符号化されたヘッダ行が復号化されたものを返します。 
ISO 8859-1 文字セット (Latin-1) だけをサポートします。 mime_encode_header 
line 内のヘッダ行が MIME 符号化されたものを返します。 
標準では、非 ASCII 文字 (8 ビット目がセットされている文字) を含むか、MAXLEN 文字 (標準の値は 200 です) よりも長い部分は quoted-printable 形式で符号化されます。 
文字セットがメイルヘッダで指定されていない場合指定しなければなりません。 
使われている文字セットを表す文字列は CHARSETに記憶されます。 標準の値は ISO-8859-1 (Latin1 (latin-one) としても知られています)。 
このモジュールはコマンドラインから利用することもできます。 
以下のような使用法: 
復号化の際に -b オプションが与えられていれば、base64 パートも同様に復号化されます。 
MIME quoted-printable 形式ファイルのエンコードおよびデコード。 . 
mkcwproject は Metrowerks CodeWarrior 開発環境用のプロジェクトファイルを作成します。 
これは distutils のためのヘルパーモジュールですが、より多くの制御のために独立して利用できます。 
メモリにマップされたファイルオブジェクトは、文字列とファイルオブジェクトの両方のように振舞います。 
しかし通常の文字列オブジェクトとは異なり、これらは可変です。 
文字列が期待されるほとんどの場所でmmapオブジェクトを利用できます。 例えば、メモリマップファイルを探索するためにreモジュールを使うことができます。 
それらは可変なので、 obj[index] = 'a' のように文字を変換できますし、スライスを使うことでobj[i1:i2] = '...' のように部分文字列を変換することができます。 
現在のファイル位置をデータの始めとする読込みや書込み、ファイルの異なる位置へseek()することもできます。 メモリマップファイルはUnix上とWindows上とでは異なるmmap()関数によって作られます。 
いずれの場合も、開いたファイルのディスクリプタを、更新のために提供しなければなりません。 すでに存在するPythonファイルオブジェクトをマップしたい場合は、filenoパラメータのための現在値を手に入れるために、fileno()メソッドを使用して下さい。 
そうでなければ、ファイル・ディスクリプタを直接返すos.open()関数(呼び出すときにはまだファイルが閉じている必要があります)を使って、ファイルを開くことができます。 
accessが指定されない場合、Windowsのmmapは書き込み可能マップを返します。 
3つのアクセス型すべてに対する初期メモリ値は、指定されたファイルから得られます。 
ACCESS_READを割り当てたメモリマップはTypeError例外を送出します。 
ACCESS_WRITEを割り当てたメモリマップはメモリと元のファイルの両方に影響を与えます。 
ACCESS_COPYを割り当てたメモリマップはメモリに影響を与えますが、元のファイルを更新することはありません。 
(Windows)バージョンはファイルハンドルfilenoによって指定されたファイルからlengthバイトをマップして、mmapオブジェクトを返します。 
lengthが現在のファイルサイズより大きな場合、ファイルサイズはlengthを含む大きさにまで拡張されます。 
lengthが0の場合、マップの最大の長さはWindowsが空ファイルで例外を起こす(Windowsでは空のマップを作成することができません。 )ことを除いては、mmap()が呼ばれたときのファイルサイズになります。 
tagnameは、None以外で指定された場合、マップのタグ名を与える文字列となります。 
Windowsは同じファイルに対する様々なマップを持つことを可能にします。 
既存のタグの名前を指定すればそのタグがオープンされ、そうでなければこの名前の新しいタグが作成されます。 
もしこのパラメータを省略したりNoneを与えたりしたならば、マップは名前なしで作成されます。 
タグ・パラメータの使用の回避は、あなたのコードをUnixとWindowsの間で移植可能にしておくのを助けてくれるでしょう。 
(Unix)バージョンは、ファイル・ディスクリプタ filenoによって指定されたファイルからlengthバイトをマップし、mmapオブジェクトを返します。 
デフォルトはMAP_SHAREDです。 
accessはオプションのキーワード・パラメータとして、flagsとprotの代わりに指定してもかまいません。 
flags,protとaccessの両方を指定することは間違っています。 
このパラメーターを使用法についての情報は、accessの記述を参照してください。 
メモリマップフィイルオブジェクトは以下のメソッドをサポートしています: 
この呼出しの後にオブジェクトの他のメソッドの呼出すことは、例外の送出を引き起こすでしょう。 
オブジェクト内で部分文字列stringが見つかった場所の最も小さいインデックスを返します。 失敗したとき-1を返します。 
startは探索を始めたい場所のインデックスで、デフォルトは0です。 
ファイルのメモリコピー内での変更をディスクへフラッシュします。 この呼出しを使わなかった場合、オブジェクトが破壊される前に変更が書き込まれる保証はありません。 
もしoffsetとsizeが指定された場合、与えられたバイトの範囲の変更だけがディスクにフラッシュされます。 指定されない場合、マップ全体がフラッシュされます。 
オフセットsrcからインデックスdestへcountバイトだけコピーします。 
もしmmapがACCESS_READで作成されていた場合、TypeError例外を送出します。 
) 現在のファイル位置からnumバイトの文字列を返します。 
ファイル位置は返したバイトの分だけ後ろの位置へ更新されます。 
現在のファイル位置から長さ1の文字列を返します。 ファイル位置は1だけ進みます。 
現在のファイル位置から次の新しい行までの、1行を返します。 
もしmmapがACCESS_READまたはACCESS_COPYで作成されたならば、マップのリサイズはTypeError例外を送出します。 
ファイルの現在位置をセットします。 
whence引数はオプションであり、デフォルトは0(絶対位置)です。 その他の値として、1(現在位置からの相対位置)と2(ファイルの終わりからの相対位置)があります。 
ファイルの長さを返します。 メモリマップ領域のサイズより大きいかもしれません。 
ファイル・ポインタの現在位置を返します。 
メモリ内のファイル・ポインタの現在位置からstringのバイト列を書き込みます。 
ファイル位置はバイト列が書き込まれた後の位置へ更新されます。 もしmmapがACCESS_READで作成されていた場合、書き込み時にTypeError例外が送出されるでしょう。 
このモジュールの関数は、 Windows プラットフォームの便利な機能のいくつかに対するアクセス機構を提供しています。 
高レベルモジュールのいくつかは、提供するサービスを Windows で実装するために、これらの関数を使っています。 
例えば、 
モジュールは関数 getpass() を実装するためにこのモジュールの関数を使います。 
ここに挙げた関数の詳細なドキュメントについては、プラットフォーム APIドキュメントで見つけることができます。 
MultiFile オブジェクトはテキストファイルを区分したものをファイル類似の入力オブジェクトとして扱えるようにし、指定した区切り文字(delimiter) パタンに遭遇した際に '' が返されるようにします。 
このクラスの標準設定は MIME マルチパートメッセージを解釈する上で便利となるように設計されていますが、サブクラス化を行って幾つかのメソッドを上書きすることで、簡単に汎用目的に対応させることができます。 
ます。 クラスMultiFile 
マルチファイル (multi-file) を生成します。 
このクラスはopen() が返すファイルオブジェクトのような、MultiFile インスタンスが行データを取得するための入力となるオブジェクトを引数としてインスタンス化を行わなければなりません。 
MultiFile は入力オブジェクトの readline() 、seek()、および tell() メソッドしか参照せず、後者の二つのメソッドは個々の MIME パートにランダムアクセスしたい場合にのみ必要です。 
MultiFile を seek できないストリームオブジェクトで使うには、オプションの seekable 引数の値を偽にしてください; これにより、入力オブジェクトの seek()および tail() メソッドを使わないようになります。 
MultiFile の視点から見ると、テキストは三種類の行データ:データ、セクション分割子、終了マーカ、からなることを知っていると約に立つでしょう。 
MultiFile は、多重入れ子構造になっている可能性のある、それぞれが独自のセクション分割子および終了マーカのパターンを持つメッセージパートをサポートするように設計されています。 
網羅的な電子メイル操作パッケージ; multifile モジュールに取って代わります。 
mutex モジュールでは、ロック (lock) の獲得と解除によって排他制御を可能にするクラスを定義しています。 
排他制御はスレッドやマルチタスクを使う上で便利かもしれませんが、このクラスがそうした機能を必要として (いたり、想定して) いるわけではありません。 mutexモジュールでは以下のクラスを定義しています: 
mutex には 2 つの状態変数 -- ``ロック'' ビット (locked bit) とキュー (queue) があります。 
mutex がロックされていなければ、キューは空です。 
function(argument) を呼び出します。 これによって、先頭にあったエントリが新たなロックを獲得します。 
当然のことながらマルチスレッドの制御には利用できません - というのも、lock() が、ロックを獲得したら関数を呼び出すという変なインタフェースだからです。 
バージョン 1.5.2 で 新たに追加 された仕様です。 
netrc クラスは、Unix ftp プログラムや他のFTP クライアントで用いられる netrc ファイル形式を解析し、カプセル化(encapsulate) します。 
クラスnetrc 
netrc のインスタンスやサブクラスのインスタンスは netrcファイルのデータをカプセル化します。 
初期化の際の引数が存在する場合、解析対象となるファイルの指定になります。 
引数がない場合、ユーザのホームディレクトリ下にある .netrc が読み出されます。 
解析エラーが発生した場合、ファイル名、行番号、解析を中断したトークンに関する情報の入った NetrcParseError を送出します。 
ソースファイルのテキスト中で文法エラーに遭遇した場合に netrc クラスによって送出される例外です。 
この例外のインスタンスは 3 つのインスタンス変数を持っています: msg はテキストによるエラーの説明で、filename はソースファイルの名前、そして lineno はエラーが発見された行番号です。 
newモジュールはインタプリタオブジェクト作成関数へのインターフェイスを与えます。 
新しいオブジェクトを``魔法を使ったように''作り出す必要がある、通常の作成関数が使えないときに、これは主にマーシャル型関数で使われます。 
この関数は__init__()コンストラクタを呼び出さずに辞書dictをもつclassのインスタンスを作り出します。 
dictが省略されるか、Noneである場合は、新しいインスタンスのために新しい空の辞書が作られます。 
オブジェクトがいつもと同じ状態であるという保証はないことに注意してください。 
この関数はinstanceに束縛されたメソッドオブジェクトか、あるいはinstanceがNoneの場合に束縛されていないメソッドオブジェクトを返します。 functionは呼び出し可能でなければなりません。 
与えられたコードとグローバル変数をもつ(Python)関数を返します。 
nameを与えるならば、文字列かNoneでなければならない。 
文字列の場合は、関数は与えられた名前をもつ。 
そうでなければ、関数名は code.co_nameから取られる。 
argdefsを与える場合はタプルでなければならず、パラメータのデフォルト値を決めるために使われます。 
この関数はPyCode_New()というC関数へのインターフェイスです。 
この関数はnameという名前の新しいモジュールオブジェクトを返します。 
nameは文字列でなければならない。 
この関数は新しいクラスオブジェクトを返します。 そのクラスオブジェクトは(クラスのタプルであるべき)baseclassesから派生し、名前空間dictを持ち、nameという名前です。 
UNIXプラットフォームで利用できます。 
match(key, mapname)==value となる key を value に対応付ける辞書を返します。 
辞書内のキーと値は共に任意のバイト列なので注意してください。 mapname は他の名前の別名になっていないか最初にチェックされます。 
有効なマップのリストを返します。 
nis モジュールは以下の例外を定義しています: 
NIS 関数がエラーコードを返した場合に送出されます。 
このモジュールでは、 クラス NNTP を定義しています。 
このクラスは NNTP プロトコルのクライアント側を実装しています。 このモジュールを使えば、ニュースリーダや記事投稿プログラム、または自動的にニュース記事を処理するプログラムを実装することができます。 
NNTP (Network News TransferProtocol、ネットニュース転送プロトコル) の詳細については、インターネット RFC 977 を参照してください。 以下にこのモジュールの使い方の小さな例を二つ示します。 
ニュースグループに関する統計情報を列挙し、最新 10 件の記事を出力するには以下のようにします: 
ファイルから記事を投稿するには、以下のようにします(この例では記事番号は有効な番号を指定していると仮定しています): 
このモジュール自体では以下の内容を定義しています: 
クラスNNTP 
ホスト host 上で動作し、ポート番号 port で要求待ちをしている NNTP サーバとの接続を表現する新たな NNTP クラスのインスタンスを返します。 
標準のport は 119 です。 
オプションのuser および password が与えられているか、または/.netrcに適切な認証情報が指定されていてusenetrcが真 (デフォルト) の場合、"AUTHINFO USER" および "AUTHINFO PASS" 命令を使ってサーバに対して身元証明および認証を行います。 
オプションのフラグreadermode が真の場合、認証の実行に先立って "mode reader" 命令が送信されます。 
reader モードは、ローカルマシン上の NNTP サーバに接続していて、"group" のような reader 特有の命令を呼び出したい場合に便利なことがあります。 
バージョン 2.4 で 変更 された仕様:usenetrc 引数を追加しました 
クラスNNTPError 
標準の例外 Exception から導出されており、nntplibモジュールが送出する全ての例外の基底クラスです。 
クラスNNTPReplyError 
期待はずれの応答がサーバから返された場合に送出される例外です。 
以前のバージョンとの互換性のために、error_reply はこのクラスと等価になっています。 
クラスNNTPTemporaryError 
エラーコードの範囲が 400-499 のエラーを受信した場合に送出される例外です。 
以前のバージョンとの互換性のために、error_temp はこのクラスと等価になっています。 
クラスNNTPPermanentError 
エラーコードの範囲が 500-599 のエラーを受信した場合に送出される例外です。 
以前のバージョンとの互換性のために、error_perm はこのクラスと等価になっています。 
クラスNNTPProtocolError 
サーバから返される応答が 1-5 の範囲の数字で始まっていない場合に送出される例外です。 
以前のバージョンとの互換性のために、error_proto はこのクラスと等価になっています。 
クラスNNTPDataError 
応答データ中に何らかのエラーが存在する場合に送出される例外です。 
以前のバージョンとの互換性のために、error_data はこのクラスと等価になっています。 
nsremote は Netscape の OSA モジュールのラッパーであり、好きなブラウザに対して URL を簡単に送ることができます。 
Macintoshモジュールリファレンス 
operator モジュールは、Python 固有の各演算子に対応しているC 言語で実装された関数セットを提供します。 
例えば、operator.add(x, y) は式 x+y と等価です。 
これらは a および b の大小比較を行います。 
特に、lt(a, b) は 
、le(a, b) は 
、eq(a, b) は 
、ne(a, b) は 
、gt(a, b) は 
a b 、そしてge(a, b) は 
と等価です。 
組み込み関数 cmp() と違って、これらの関数はどのような値を返してもよく、ブール代数値として解釈できてもできなくてもかまいません。 
大小比較の詳細については 
を参照してください。 バージョン 2.2 で 新たに追加 された仕様です。 
論理演算もまた全てのオブジェクトに対して適用することができ、真値テスト、同一性テストおよびブール演算をサポートします: 
not o の結果を返します。 
(オブジェクトのインスタンスには __not__() メソッドは適用されないので注意してください;この操作を定義しているのはインタプリタコアだけです。 
結果は__nonzero__() および __len__() メソッドによって影響されます。 ) 
o が真の場合 True を返し、そうでない場合 False を返します。 
この関数はboolのコンストラクタ呼び出しと同等です。 
を返します。 
演算子で最も多いのは数学演算およびビット単位の演算です: 
o の絶対値を返します。 
数値 a および b について a + b を返します。 
a と b の論理積を返します。 
__future__.division が有効でない場合には a / bを返します。 
``古い(classic)'' 除算としても知られています。 
a // b を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
o のビット単位反転を返します。 
o と同じです。 
a の b ビット左シフトを返します。 
a % b を返します。 
数値 a および b について a * bを返します。 
o の符号反転を返します。 
a と b の論理和を返します。 
o の符号非反転を返します。 
数値 a および b について a ** bを返します。 バージョン 2.3 で 新たに追加 された仕様です。 
a の b ビット右シフトを返します。 
a - b を返します。 
__future__.division が有効な場合 a / b を返します。 
除算としても知られています。 バージョン 2.2 で 新たに追加 された仕様です。 
a および b の排他的論理和を返します 
シーケンスを扱う演算子には以下のようなものがあります: 
シーケンス a および b について a + b を返します。 
b in a を調べた結果を返します。 演算子が反転しているので注意してください。 
関数名__contains__() は Python 2.0 で追加されました。 
a の中に b が出現する回数を返します。 
a でインデクスが b の要素を削除します。 
a でインデクスが b から c 
-1 のスライス要素を削除します。 
a でインデクスが b の要素を削除します。 
-1 のスライス要素を返します。 
a で最初に b が出現する場所のインデクスを返します。 
シーケンス a と整数 b について a * bを返します。 
リリース 2.0 で撤廃されました。 contains() を使ってください。 
contains() の別名です。 
a でインデクスが b の要素の値を c に設定します。 
operator モジュールでは、オブジェクトの型を調べるための述語演算子も定義しています。 
注意:これらの関数が返す結果について誤って理解しないよう注意してください; インスタンスオブジェクトに対して常に信頼できる値を返すのは isCallable() だけです。 
例えば以下のようになります: 
リリース 2.0 で撤廃されました。 callable() を使ってください。 
オブジェクト o を関数のように呼び出すことができる場合真を返し、それ以外の場合 false を返します。 
関数、バインドおよび非バインドメソッド、クラスオブジェクト、および __call__() メソッドをサポートするインスタンスオブジェクトは真を返します。 
オブジェクト o がマップ型インタフェースをサポートする場合に真を返します。 辞書および全てのインスタンスオブジェクトに対しては、この値は真になります。 
警告:インタフェース自体が誤った定義になっているため、あるインスタンスが完全なマップ型プロトコルを備えているかを調べる信頼性のある方法は存在しません。 
このため、この関数によるテストはさほど便利ではありません。 
オブジェクト o が数値を表現している場合に真を返します。 
C で実装された全ての数値型、およびそれらのインスタンスオブジェクト全て対して、この値は真になります。 
警告:インタフェース自体が誤った定義になっているため、あるインスタンスが完全な数値型のインタフェースをサポートしているかを調べる信頼性のある方法は存在しません。 
o がシーケンス型プロトコルをサポートする場合に真を返します。 シーケンス型メソッドを C で定義している全てのオブジェクトに対して、この値は真になります。 
警告:インタフェース自体が誤った定義になっているため、あるインスタンスが完全なシーケンス型のインタフェースをサポートしているかを調べる信頼性のある方法は存在しません。 
このため、この関数によるテストはさほど便利ではありません。 
例: 0 から 255 までの序数を文字に対応付ける辞書を構築します。 
operator モジュールはアトリビュートとアイテムの汎用的な検索のための道具も定義しています。 
map(), sorted(), itertools.groupby(), や関数を引数に取るその他の関数に対して高速にフィールドを抽出する際に引数として使うと便利です。 
例: 
optparse モジュールは、getopt よりも簡便で、柔軟性に富み、かつ強力なコマンドライン解析ライブラリです。 optparse では、より明快なスタイルのコマンドライン解析手法、すなわちOptionParser のインスタンスを作成してオプションを追加してゆき、そのインスタンスでコマンドラインを解析するという手法をとっています。 
optparse を使うと、GNU/POSIX 構文でオプションを指定できるだけでなく、使用法やヘルプメッセージの生成も行えます。 optparse を使った簡単なスクリプト例を以下に示します: 
このようにわずかな行数のコードによって、スクリプトのユーザはコマンドライン上で例えば以下のような 「よくある使い方」 を実行できるようになります: 
コマンドライン解析の中で、optparse はユーザの指定したコマンドライン引数値に応じてparse_args() の返すoptions の属性値を設定してゆきます。 
parse_args() がコマンドライン解析から処理を戻したとき、options.filename は"outfile" に、options.verboseは False になっているはずです。 
optparse は長い形式と短い形式の両方のオプション表記をサポートしており、短い形式は結合して指定できます。 また、様々な形でオプションに引数値を関連付けられます。 
従って、以下のコマンドラインは全て上の例と同じ意味になります: 
さらに、ユーザが 
のいずれかを実行すると、optparse はスクリプトのオプションについて簡単にまとめた内容を出力します: 
6.21.1.2 オプションとは何か 
6.21.1.3 固定引数とは何か 
6.21.2.1 オプション・アクションを理解する 
6.21.2.2 store アクション 
6.21.2.3 ブール値 (フラグ) オプションの処理 
6.21.2.4 その他のアクション 
6.21.2.5 デフォルト値 
6.21.2.6 ヘルプの生成 
6.21.2.7 バージョン番号の出力 
6.21.2.8 optparse のエラー処理法 
6.21.2.9 全てをつなぎ合わせる 
6.21.3.1 パーザへのオプション追加 
6.21.3.2 オプションの定義 
6.21.3.3 標準的なオプション・アクション 
6.21.3.5 オプション解析器への問い合わせと操作 
6.21.3.6 オプション間の衝突 
6.21.4.1 callbackオプションの定義 
6.21.4.2 コールバック関数はどのように呼び出されるか 
6.21.4.3 コールバック中で例外を送出する 
6.21.4.4 コールバックの例 1: ありふれたコールバック 
6.21.4.5 コールバックの例 2: オプションの順番をチェックする 
6.21.4.6 コールバックの例 3: オプションの順番をチェックする (汎用的) 
6.21.4.7 コールバックの例 4: 任意の条件をチェックする 
6.21.4.8 コールバックの例5: 固定引数 
6.21.4.9 コールバックの例6: 可変個の引数 
このモジュールでは、オペレーティングシステム依存の機能を利用する方法として、 
や nt といったオペレーティングシステム依存の組み込みモジュールを import するよりも可搬性の高い手段を提供しています。 このモジュールは、mac や 
のような、オペレーティングシステム依存の組み込みモジュールから関数やデータを検索して、見つかったものを取り出し (export) ます。 
Python における組み込みのオペレーティングシステム依存モジュールは、同じ機能を利用することができる限り、同じインタフェースを使います; たとえば、os.stat(path) は path についての stat 情報を(たまたま POSIX インタフェースに起源する) 同じ書式で返します。 特定のオペレーティングシステム固有の拡張も os を介して利用することができますが、これらの利用はもちろん、可搬性を脅かします!最初の 
関数がシステム関連のエラー(引数の型違いや他のありがちなエラーではない)を返した場合この例外が発生します。 これは OSError として知られる組み込み例外でもあります。 
付属する値は errno からとった数値のエラーコードと、エラーコードに対応する、C 関数perror() により出力されるのと同じ文字列からなるペアです。 
背後のオペレーティングシステムで定義されているエラーコード名が収められている 
を参照してください。 例外がクラスの場合、この例外は二つの属性、errno とstrerror を持ちます。 
前者の属性は C の errno 変数の値、後者は strerror() による対応するエラーメッセージの値を持ちます。 
(chdir() や unlink() のような)ファイルシステム上のパスを含む例外に対しては、この例外インスタンスは 3 つめの属性、filename を持ち、関数に渡されたファイル名となります。 
import されているオペレーティング・システム依存モジュールの名前です。 
現在次の名前が登録されています: 'posix', 'nt' 、'dos' 、 'mac' 、 'os2' 、 'ce' 、'java' 、 'riscos' 。 
posixpath や macpath のように、システムごとに対応付けられているパス名操作のためのシステム依存の標準モジュールです。 
すなわち、正しく import が行われるかぎり、os.path.split(file) は posixpath.split(file)と等価でありながらより汎用性があります。 
このモジュール自体がimport 可能なモジュールでもあるので注意してください。 
として直接 import してもかまいません。 
このモジュールには、パス名を操作する便利な関数が定義されています。 
警告:これらの関数の多くはWindowsの一律命名規則(UNCパス名)を正しくサポートしていません。 splitunc()とismount()は正しくUNCパス名を操作できます。 
パス名pathの末尾のファイル名を返します。 
これはsplit(path)で返されるペアの2番目の要素です。 
この関数が返す値はUnixの basenameとは異なります;Unixのbasenameは'/foo/bar/'に対して'bar'を返しますが、basename()は空文字列('')を返します。 
パスのlistの中の共通する最長のプレフィックスを(パス名の1文字1文字を判断して)返します。 
もしlistが空なら、空文字列('')を返します。 
これは一度に1文字を扱うため、不正なパスを返すことがあるかもしれませんので注意して下さい。 
パスpathのディレクトリ名を返します。 
これはsplit(path)で返されるペアの最初の要素です。 
pathが存在するなら、Trueを返します。 壊れたシンボリッックリンクについてはFalseを返します。 
path が存在するパスならTrue を返す。 壊れたシンボリッックリンクについてはTrueを返します。 
os.lstat()がない環境ではexists()と同じです。 
バージョン 2.4 で 新たに追加 された仕様です。 
与えられた引数の最初の"~"または"~user 
"を、userのホームディレクトリのパスに置き換えて返します。 
最初が"~"なら、環境変数のHOMEの値に置き換えられます;"~user 
"なら、ビルトインモジュール 
を使ってパスワードディレクトリから該当するものを検索します。 
もし置き換えに失敗したり、引数のパスがチルダで始まっていなかったら、パスをそのまま返します。 
Macintoshではpathをそのまま返します。 
引数のパスを環境変数に展開して返します。 
引数の中の"$name 
"または"${name}"の文字列が環境変数のnameに置き換えられます。 
不正な変数名や存在しない変数名の場合には変換されず、そのまま返します。 
Macintoshではpathをそのまま返します。 
pathに最後にアクセスした時刻を、エポック( 
モジュールを参照)からの経過時間を示す秒数で返します。 
ファイルが存在しなかったりアクセスできない場合はos.errorを発生します。 
pathの最終更新時刻を、エポック( 
システムによって、ファイルの最終変更時刻 (Unix のような システム) や作成時刻 (Windows のようなシステム) をシステムの ctime で返します。 
戻り値はエポック( 
モジュールを参照)からの経過秒数を示す数値です。 
ファイルpathのサイズをバイト数で返します。 
pathが絶対パス(スラッシュで始まる)なら、Trueを返します。 
pathが存在する正しいファイルなら、Trueを返します。 
シンボリックリンクの場合にはその実体をチェックするので、同じパスに対してislink()とisfile()の両方がTrueを返すことがあります。 
pathが存在するなら、Trueを返します。 
シンボリックリンクの場合にはその実体をチェックするので、同じパスに対してislink()とisfile()の両方がTrueを返すことがあります。 
pathがシンボリックリンクなら、Trueを返します。 
シンボリックリンクがサポートされていないプラットフォームでは、常にFalseを返します。 
パス名pathがマウントポイントmount point(ファイルシステムの中で異なるファイルシステムがマウントされているところ)なら、Trueを返します:この関数はpathの親ディレクトリである 
path/..がpathと異なるデバイス上にあるか、あるいは 
path/..とpathが同じデバイス上の同じi-nodeを指しているかをチェックします--これによって全てのUnixとPOSIX標準でマウントポイントが検出できます。 
パスに1つあるいはそれ以上のパスの要素をうまく結合します。 
付け加える要素に絶対パスがあれば、それより前の要素は全て破棄され、以降の要素を結合します。 
戻り値はpath1と省略可能なpath2以降を結合したもので、path2が空文字列でないなら、ディレクトリの区切り文字(os.sep)が各要素の間に挿入されます。 
Windowsでは各ドライブに対してカレントディレクトリがあるので、os.path.join("c:", "foo")によって、c:fooではなく、ドライブC:上のカレントディレクトリからの相対パス(c:foo)が返されます。 
パス名の大文字、小文字をシステムの標準にします。 
Unixではそのまま返します。 大文字、小文字を区別しないファイルシステムではパス名を小文字に変換します。 
Windowsでは、スラッシュをバックスラッシュに変換します。 
パス名を標準化します。 
余分な区切り文字や上位レベル参照を削除します。 
例えば、A//B、A/./B、A/foo/../Bは全てA/Bになります。 
大文字、小文字は標準化しません(それにはnormcase()を使って下さい)。 
Windowsでは、スラッシュをバックスラッシュに変換します。 
パスがシンボリックリンクを含んでいるかによって意味が変わることに注意してください。 
2つの引数であるパス名が同じファイルあるいはディレクトリを指していれば(同じデバイスナンバーとi-nodeナンバーで示されていれば)、Trueを返します。 どちらかのパス名でos.stat()の呼び出しに失敗した場合には、例外が発生します。 
利用可能:Macintosh、Unix 
fp1とfp2が同じファイルオブジェクトを指していたら、Trueを返します。 
2つのファイルオブジェクトが異なるファイルディスクリプタを示すこともあります。 利用可能:Macintosh、Unix 
statタプルstat1とstat2が同じファイルを指していたら、Trueを返します。 
これらのタプルはfstat()、lstat()やstat()で返されたものでかまいません。 
この関数は、samefile()とsameopenfile()で使われるのと同様なものを背後に実装しています。 利用可能:Macintosh、Unix 
パス名pathを(headとtail)のペアに分割します。 
tailはパスの構成要素の末尾で、headはそれより前の部分です。 tailはスラッシュを含みません;もしpathの最後にスラッシュがあれば、tailは空文字列になります。 
もしpathにスラッシュがなければ、headは空文字列になります。 
pathが空文字列なら、headとtailのどちらも空文字列になります。 
headの末尾のスラッシュは、headがルートディレクトリ(1つ以上のスラッシュのみ)でない限り、取り除かれます。 
ほとんど全ての場合、join(head, tail)の結果がpathと等しくなります(ただ1つの例外は、複数のスラッシュがheadとtailを分けている時です)。 
パス名pathを(drive,tail)のペアに分割します。 driveはドライブ名か、空文字列です。 
ドライブ名を使用しないシステムでは、driveは常に空文字列です。 
全ての場合に 
はpathと等しくなります。 バージョン 1.3 で 新たに追加 された仕様です。 
パス名pathを(root, ext)のペアにします。 
になります。 extは空文字列か1つのピリオドで始まり、多くても1つのピリオドを含みます。 
pathをルートとする各ディレクトリに対して(もしpathがディレクトリならpathも含みます)、(arg, dirname, names)を引数として関数visitを呼び出します。 
引数dirnameは訪れたディレクトリを示し、引数namesはそのディレクトリ内のファイルのリスト(os.listdir(dirname)で得られる)です。 
関数visitによってnamesを変更して、dirname以下の対象となるディレクトリのセットを変更することもできます。 例えば、あるディレクトリツリーだけ関数を適用しないなど。 
(namesで参照されるオブジェクトは、delあるいはスライスを使って正しく変更しなければなりません。 
) 注意:ディレクトリへのシンボリックリンクはサブディレクトリとして扱われないので、walk()による操作対象とはされません。 
注意:新たに追加された 
.walk() ジェネレータを使用すれば、同じ処理をより簡単に行う事ができます。 
バージョン 2.3 で 新たに追加 された仕様です。 
Linux, FreeBSDプラットフォームで利用できます。 
このモジュールを使うとOSS (Open Sound System) オーディオインターフェースにアクセスできます。 
OSSはオープンソースあるいは商用のUnixで広く利用でき、Linux (カーネル2.4まで) とFreeBSDで標準のオーディオインターフェースです。 
OSS C API の公式ドキュメント 
このモジュールではOSSデバイスドライバーが提供している多くの定数を定義しています; 定数のリストについては Linux や FreeBSDのsys/soundcard.hを参照してください。 
ossaudiodev では以下の変数と関数を定義しています: 
何らかのエラーのときに送出される例外です。 
引数は何が誤っているかを示す文字列です。 (ossaudiodev がopen()、write()、ioctl() などのシステムコールからエラーを受け取った場合には IOError を送出します。 
オーディオデバイスを開き、OSSオーディオデバイスオブジェクトを返します。 
このオブジェクトはread()、write()、fileno()といったファイル類似オブジェクトのメソッドを数多くサポートしています。 (とはいえ、伝統的な Unix の read/write における意味づけと OSS デバイスの read/write との間には微妙な違いがあります)。 
また、オーディオ特有の多くのメソッドがあります;メソッドの完全なリストについては下記を参照してください。 
deviceは使用するオーディオデバイスファイルネームです。 
もしこれが指定されないなら、このモジュールは使うデバイスとして最初に環境変数AUDIODEVを参照します。 
見つからなければ/dev/dspを参照します。 
mode は読み出し専用アクセスの場合には 'r'、書き込み専用 (プレイバック) アクセスの場合には 'w'、読み書きアクセスの場合には 'rw' にします.多くのサウンドカードは一つのプロセスが一度にレコーダとプレーヤのどちらかしか開けないようにしているため,必要な操作に応じたデバイスだけを開くようにするのがよいでしょう。 
また,サウンドカードには半二重 (half-duplex) 方式のものがあります: こうしたカードでは,デバイスを読み出しまたは書き込み用に開くことはできますが,両方同時には開けません.呼び出しの文法が普通と異なることに注意してください:最初の引数は省略可能で、2番目が必須です。 
これはossaudiodevにとってかわられた古いlinuxaudiodevとの互換性のためという歴史的な産物です。 
ミキサデバイスを開き、OSSミキサデバイスオブジェクトを返します。 deviceは使用するミキサデバイスのファイル名です。 
deviceを指定しない場合、モジュールはまず環境変数AUDIODEVを参照して使用するデバイスを探します。 
見つからなければ、/dev/mixerを参照します。 
14.11.1 オーディオデバイスオブジェクト 
parserモジュールはPythonの内部パーサとバイトコード・コンパイラへのインターフェイスを提供します。 
このインターフェイスの第一の目的は、PythonコードからPythonの式の解析木を編集したり、これから実行可能なコードを作成したりできるようにすることです。 
このモジュールについて注意すべきことが少しあります。 それは作成したデータ構造を利用するために重要なことです。 
この文書はPythonコードの解析木を編集するためのチュートリアルではありませんが、parserモジュールを使った例をいくつか示しています。 もっとも重要なことは、内部パーサが処理するPythonの文法についてよく理解しておく必要があるということです。 
言語の文法に関する完全な情報については、 
Python言語リファレンス 
標準のPythonディストリビューションに含まれるファイルGrammar/Grammarの中で定義されている文法仕様から、パーサ自身は作成されています。 
このモジュールが作成するASTオブジェクトの中に格納される解析木は、下で説明するexpr()またはsuite()関数によって作られるときに内部パーサから実際に出力されるものです。 
sequence2ast()が作るASTオブジェクトは忠実にこれらの構造をシミュレートしています。 
言語の形式文法が改訂されるために、``正しい''と考えられるシーケンスの値がPythonのあるバージョンから別のバージョンで変化することがあるということに注意してください。 
しかし、Pythonのあるバージョンから別のバージョンへテキストのソースのままコードを移せば、目的のバージョンで正しい解析木を常に作成できます。 ただし、インタープリタの古いバージョンへ移行する際に、最近の言語コンストラクトをサポートしていないことがあるという制限だけがあります。 
ソースコードが常に前方互換性があるのに対して、一般的に解析木はあるバージョンから別のバージョンへの互換性がありません。 ast2list()またはast2tuple()から返されるシーケンスのそれぞれの要素は単純な形式です。 
文法の非終端要素を表すシーケンスは常に一より大きい長さを持ちます。 
最初の要素は文法の生成規則を識別する整数です。 
これらの整数はCヘッダファイルInclude/graminit.hとPythonモジュール 
の中の特定のシンボル名です。 
シーケンスに付け加えられている各要素は、入力文字列の中で認識されたままの形で生成規則の構成要素を表しています: これらは常に親と同じ形式を持つシーケンスです。 
この構造の注意すべき重要な側面は、if_stmtの中のキーワードifのような親ノードの型を識別するために使われるキーワードがいかなる特別な扱いもなくノードツリーに含まれているということです。 
例えば、ifキーワードはタプル(1, 'if')と表されます。 ここで、1は、ユーザが定義した変数名と関数名を含むすべてのNAMEトークンに対応する数値です。 
上記のifキーワードの例が代表的なものです。 
終端記号のいろいろな型は、CヘッダファイルInclude/token.hとPythonモジュール 
で定義されています。 ASTオブジェクトはこのモジュールの機能をサポートするために必要ありませんが、三つの目的から提供されています: アプリケーションが複雑な解析木を処理するコストを償却するため、Pythonのリストやタプル表現に比べてメモリ空間を保全する解析木表現を提供するため、解析木を操作する追加モジュールをCで作ることを簡単にするため。 
ASTオブジェクトを使っていることを隠すために、簡単な``ラッパー''クラスをPythonで作ることができます。 parserモジュールは二、三の別々の目的のために関数を定義しています。 
もっとも重要な目的はASTオブジェクトを作ることと、ASTオブジェクトを解析木とコンパイルされたコードオブジェクトのような他の表現に変換することです。 
しかし、ASTオブジェクトで表現された解析木の型を調べるために役に立つ関数もあります。 
解析木の内部ノードを表す便利な定数。 
便利な解析木の葉のノードを表す定数とノード値をテストするための関数。 
18.1.6.1 compile()のエミュレーション 
18.1.6.2 情報発見 
(条件付き)ブレークポイントの設定やソース行レベルでのシングルステップ実行、スタックフレームのインスペクション、ソースコードリスティングおよびいかなるスタックフレームのコンテキストにおける任意のPythonコードの評価をサポートしています。 
現在これについてのドキュメントはありませんが、ソースを読めば簡単に理解できます。 
拡張インターフェースはモジュールbdb 
(ドキュメントなし)と 
他のスクリプトをデバッグするために、pdb.pyをスクリプトとして呼び出すこともできますせます。 
スクリプトとして pdb を起動すると、デバッグ中のプログラムが異常終了した時に pdb が自動的に検死デバッグモードに入ります。 
クラッシュしたプログラムを調べるための典型的な使い方は: 
モジュールは以下の関数を定義しています。 それぞれが少しづつ違った方法でデバッガに入ります: 
デバッガに制御された状態で(文字列として与えられた)statementを実行します。 
オプションのglobalsとlocals引数はコードを実行する環境を指定します。 デフォルトでは、モジュール 
の辞書が使われます。 
(exec文またはeval()組み込み関数の説明を参照してください。 ) 
デバッガの制御もとで(文字列として与えられる)expressionを評価します。 
runeval()がリターンしたとき、式の値を返します。 
その他の点では、この関数はrun()を同様です。 
function(関数またはメソッドオブジェクト、文字列ではありません)を与えられた引数とともに呼び出します。 
runcall()がリターンしたとき、関数呼び出しが返したものは何でも返します。 
デバッガプロンプトは関数に入るとすぐに現れます。 
スタックフレームを呼び出したところでデバッガに入ります。 
たとえコードが別の方法でデバッグされている最中でなくても(例えば、アサーションが失敗するとき)、これはプログラムの所定の場所でブレークポイントをハードコードするために役に立ちます。 
与えられたtracebackオブジェクトの事後解析デバッギングに入ります。 
sys.last_tracebackのトレースバックの事後解析デバッギングに入ります。 
3.14.1 他の Python モジュールとの関係 
pickle モジュールでは、Python オブジェクトデータ構造を直列化 (serialize) したり非直列化 (de-serialize) するための基礎的ですが強力なアルゴリズムを実装しています。 
``Pickle 化 (Pickling)'' は Python のオブジェクト階層をバイトストリームに変換する過程を指します。 
``非 Pickle 化 (unpickling)''はその逆の操作で、バイトストリームをオブジェクト階層に戻すように変換します。 
このドキュメントでは pickle モジュールおよび 
モジュールの両方について記述します。 
モジュールと間違えないように注意してください 
3.14.1 他の Python モジュールとの関係 
3.14.5.1 通常のクラスインスタンスの pickle 化および unpickle 化 
3.14.5.2 拡張型の pickle 化および unpickle 化 
3.14.5.3 外部オブジェクトの pickle 化および unpickle 化 
pipes モジュールでは、'pipeline' の概念 -- あるファイルを別のファイルに変換する機構の直列接続 -- を抽象化するためのクラスを定義しています。 
このモジュールは /bin/sh コマンドラインを利用するため、os.system() および os.popen() のための POSIX 準拠のシェル、または互換のシェルが必要です。 
pipes モジュールでは、以下のクラスを定義しています: 
クラスTemplate 
パイプラインを抽象化したクラス。 
使用例: 
このモジュールは次の単一の関数を提供します。 
パッケージを構成するモジュールのサーチパスを拡張します。 
パッケージの __init__.py で次のように書くことを意図したものです。 from pkgutil import extend_path__path__ = extend_path(__path__, __name__) 
上記はパッケージの __path__ に sys.path の全ディレクトリのサブディレクトリとしてパッケージ名と同じ名前を追加します。 
これは1つの論理的なパッケージの異なる部品を複数のディレクトリに分けて配布したいときに役立ちます。 同時に *.pkg の * の部分が name 引数に指定された文字列に一致するファイルの検索もおこないます。 
この機能は import で始まる特別な行がないことを除き *.pth ファイルに似ています( 
の項を参照)。 
)入力パスがリストでない場合(フリーズされたパッケージのとき)は何もせずにリターンします。 
入力パスが変更されていなければ、アイテムを末尾に追加しただけのコピーを返します。 
sys.path はシーケンスであることが前提になっています。 
sys.path の要素の内、実在するディレクトリを指す(ユニコードまたは8ビットの)文字列となっていないものは無視されます。 
ファイル名として使ったときにエラーが発生する sys.path のユニコード要素がある場合、この関数(os.path.isdir() を実行している行)で例外が発生する可能性があります。 
6.30.3.1 Win95/98 固有 
6.8.3.6 popen2.* を置き換える 
6.9.1 Popen3 および Popen4 
にある関数はこのモジュールにおけるファクトリ関数と同じ名前を持ちますが、戻り値に関する取り決めは 
の関数の方がより直感的です。 このモジュールで提供されている第一のインタフェースは 3 つのファクトリ関数です。 
これらの関数のいずれも、bufsize を指定した場合、 I/O パイプのバッファサイズを決定します。 mode を指定する場合、文字列'b' または 't' でなければなりません; Windows では、ファイルオブジェクトをバイナリあるいはテキストモードのどちらで開くかを決めなければなりません。 
cmdが文字列の場合、(os.system()のように)シェルに渡されます。 
子プロセスからのリターンコードを取得するには、Popen3および Popen4 クラスの poll() あるいはwait() メソッドを使うしかありません; これらの機能はUnixでしか利用できません。 
この情報は popen2()、popen3()、および popen4() 関数、あるいは 
モジュールにおける同等の関数の使用によっては得ることができません。 ( 
モジュールの関数から返されるタプルはpopen2モジュールの関数から返されるものとは違う順序です。 
cmd をサブプロセスとして実行します。 
ファイルオブジェクト(child_stdout, child_stdin) を返します。 
ファイルオブジェクト(child_stdout, child_stdin, child_stderr)を返します。 
ファイルオブジェクト(child_stdout_and_stderr, child_stdin).バージョン 2.0 で 新たに追加 された仕様です。 
Unixでは、ファクトリ関数によって返されるオブジェクトを定義しているクラスも利用することができます。 
これらのオブジェクトは Windows 実装で使われていないため、そのプラットフォーム上で使うことはできません。 
クラスPopen3 
このクラスは子プロセスを表現します。 
通常、 Popen3インスタンスは上で述べた popen2() および popen3() ファクトリ関数を使って生成されます。 Popen3 オブジェクトを生成するためにいずれかのヘルパー関数を使っていないのなら、cmd パラメタは子プロセスで実行するシェルコマンドになります。 
capturestderr フラグが真であれば、このオブジェクトが子プロセスの標準エラー出力を捕獲しなければならないことを意味します。 標準の値は偽です。 
bufsize パラメタが存在する場合、子プロセスへの/からの I/O バッファのサイズを指定します。 
クラスPopen4 
Popen3 に似ていますが、標準エラー出力を標準出力と同じファイルオブジェクトで捕獲します。 
このモジュールは、 POP3 クラスを定義します。 これはPOP3サーバへの接続と、 RFC 1725 に定められたプロトコルを実装します。 
POP3 クラスはminimalとoptinalという2つのコマンドセットをサポートします。 
幾つも実装されているPOP3サーバーの品質は、貧弱なものが多数を占めています。 
もし、お使いのメールサーバーがIMAPをサポートしているなら、 
poplib モジュールでは、ひとつのクラスが提供されています。 
クラスPOP3 
このクラスが、実際にPOP3プロトコルを実装します。 
インスタンスが初期化されるときに、コネクションが作成されます。 port が省略されると、POP3標準のポート(110)が使われます。 
クラスPOP3_SSL 
POP3 クラスのサブクラスで、SSLでカプセル化されたソケットによるPOPサーバへの接続を提供します。 
port が指定されていない場合、POP3-over-SSL標準の995番ポートが使われます。 
keyfile と certfile もオプションで - SSL接続に使われるPEMフォーマットの秘密鍵と信頼された##を含みます。 
1つの例外が、 poplib モジュールのアトリビュートとして定義されています。 
例外は、すべてのエラーで発生します。 
例外の理由は文字列としてコンストラクタに渡されます。 
このモジュールはオペレーティングシステムの機能のうち、C 言語標準および POSIX 標準 (Unix インタフェースをほんの少し隠蔽した)で標準化されている機能に対するアクセス機構を提供します。 
このモジュールを直接 import しないで下さい。 
その代わりに、移植性のあるインタフェースを提供している 
をインポートしてください。 
Unixでは、 
モジュールが提供するインタフェースは posix の内容を内包しています。 
非 Unix オペレーティングシステムでは posix モジュールを使うことはできませんが、その部分的な機能セットは、たいてい 
インタフェースを介して利用することができます。 
は、一度 import してしまえば posix の代わりであることによるパフォーマンス上のペナルティは 全くありません。 
その上、 
は os.environ の内容が変更された際に自動的に putenv() を呼ぶなど、いくつかの追加機能を提供しています。 
一方、システムコールから報告されたエラーは以下に述べるようにerror (標準例外 OSError と同義です) を送出します。 
リリース 1.5 で撤廃されました。 このモジュールが提供しているよりもうまく処理ができ、可搬性も高いロック操作が 
.lockf() で提供されています。 
このモジュールでは、組み込みのファイルオブジェクトの上にいくつかの追加機能を実装しています。 
特に、このオブジェクトはファイルのロック機構、ファイルフラグへの操作、およびファイルオブジェクトを複製するための簡単なインタフェースを実装しています。 
オブジェクトは全ての標準ファイルオブジェクトのメソッドに加え、以下に述べるメソッドを持っています。 
このモジュールはファイルのロック機構に fcntl.fcntl() を用いるため、ある種の Unixでしか動作しません。 
posixfile オブジェクトをインスタンス化するには、 posixfileモジュールの open() 関数を使います。 
生成されるオブジェクトは標準ファイルオブジェクトとだいたい同じルック フィールです。 posixfile モジュールでは、以下の定数を定義しています: 
オフセットをファイルの先頭から計算します。 
オフセットを現在のファイル位置から計算します。 
オフセットをファイルの末尾から計算します。 
posixfile モジュールでは以下の関数を定義しています: 
指定したファイル名とモードで新しい posixfile オブジェクトを作成します。 
filename、mode および bufsize 引数は組み込みの open() 関数と同じように解釈されます。 
指定した標準ファイルオブジェクトで新しい posixfile オブジェクトを作成します。 作成されるオブジェクトは元のファイルオブジェクトと同じファイル名およびモードを持っています。 
posixfile オブジェクトでは以下の追加メソッドを定義しています: 
ファイルオブジェクトが参照しているファイルの指定部分にロックをかけます。 
指定の書式は下のテーブルで説明されています。 
len 引数にはロックする部分の長さを指定します。 
標準の値は 0です。 start にはロックする部分の先頭オフセットを指定し、その標準値は 0 です。 
whence 引数はオフセットをどこからの相対位置にするかを指定します。 
この値は定数 SEEK_SET、SEEK_CUR、または SEEK_END のいずれかになります。 
標準の値は SEEK_SET です。 
引数についてのより詳しい情報はシステムの 
fcntl(2) マニュアルページを参照してください。 
ファイルオブジェクトが参照しているファイルに指定したフラグを設定します。 
新しいフラグは特に指定しない限り以前のフラグと OR されます。 
指定書式は下のテーブルで説明されています。 
flags 引数なしの場合、現在のフラグを示す文字列が返されます ("?" 修飾子と同じです) 。 
フラグについてのより詳しい情報はシステムの 
ファイルオブジェクトと、背後のファイルポインタおよびファイル記述子を複製します。 
返されるオブジェクトは新たに開かれたファイルのように振舞います。 
新たなオブジェクトは指定したファイル記述子を持ちます。 それ以外の点では、返されるオブジェクトは新たに開かれたファイルのように振舞います。 
posixfile オブジェクトが参照している標準ファイルオブジェクトを返します。 
この関数は標準ファイルオブジェクトを使うよう強制している関数を使う場合に便利です。 
全てのメソッドで、要求された操作が失敗した場合には IOErrorが送出されます。 lock() の書式指定文字には以下のような意味があります: 
書式指定 
指定領域のロックを解除します 
指定領域の読み出しロックを要求します 
指定領域の書き込みロックを要求します 
これに加え、以下の修飾子を書式に追加できます: 
修飾子 
ロック操作が処理されるまで待ちます 
要求されたロックと衝突している第一のロックを返すか、衝突がない場合には None を返します。 
注釈: 
返されるロックは (mode, len,start, whence, pid) の形式で、mode はロックの形式を表す文字 ('r' または 'w') です。 
この修飾子はロック要求の許可を行わせません; すなわち、問い合わせの目的にしか使えません。 
flags() の書式指定文字には以下のような意味があります: 
追記のみ (append only) フラグ 
実行時クローズ (close on exec) フラグ 
無遅延 (no delay) フラグ (非ブロック (non-blocking) フラグとも呼ばれます) 
同期 (synchronization) フラグ 
指定したフラグを通常の 'オン' にせず 'オフ' にします 
フラグを標準の 'OR' 操作ではなく置換します。 
設定されているフラグを表現する文字からなる文字列を返します。 
"!" および "=" 修飾子は互いに排他の関係にあります。 
この文字列が表すフラグは同じ呼び出しによってフラグが置き換えられた後のものです。 
以下に例を示します: 
pprintモジュールを使うと、Pythonの任意のデータ構造をインタープリタへの入力で使われる形式にして``pretty-print''できます。 
フォーマット化された構造の中にPythonの基本的なタイプではないオブジェクトがあるなら、表示できないかもしれません。 
Pythonの定数として表現できない多くの組み込みオブジェクトと同様、ファイル、ソケット、クラスあるいはインスタンスのようなオブジェクトが含まれていた場合は出力できません。 可能であればオブジェクトをフォーマット化して1行に出力しますが、与えられた幅に合わないなら複数行に分けて出力します。 
無理に幅を設定したいなら、PrettyPrinterオブジェクトを作成して明示してください。 pprintモジュールには1つのクラスが定義されています: 
クラスPrettyPrinter 
PrettyPrinterインスタンスを作ります。 
このコンストラクタにはいくつかのキーワードパラメータを設定できます。 
streamキーワードで出力ストリームを設定できます;このストリームに対して呼び出されるメソッドはファイルプロトコルのwrite()メソッドだけです。 
もし設定されなければ、PrettyPrinterはsys.stdoutを使用します。 
さらに3つのパラメータで出力フォーマットをコントロールできます。 
そのキーワードはindent、depthとwidthです。 
再帰的なレベルごとに加えるインデントの量はindentで設定できます;デフォルト値は1です。 
他の値にすると出力が少しおかしく見えますが、ネスト化されたところが見分け易くなります。 
出力されるレベルはdepthで設定できます;出力されるデータ構造が深いなら、指定以上の深いレベルのものは"..."で置き換えられて表示されます。 
デフォルトでは、オブジェクトの深さを制限しません。 
widthパラメータを使うと、出力する幅を望みの文字数に設定できます;デフォルトでは80文字です。 
もし指定した幅にフォーマットできない場合は、できるだけ近づけます。 
PrettyPrinterクラスにはいくつかの派生する関数が提供されています: 
objectをフォーマット化してstreamに出力し、最後に改行します。 
streamが省略されたら、sys.stdoutに出力します。 
バージョン 2.4 で 変更 された仕様:引数 indent、 widthと、depthが追加されました 
再帰的なオブジェクトに対しては常にfalseを返します。 
objectが再帰的な表現かどうかを返します。 
さらにもう1つ、関数が定義されています: 
objectの文字列表現を、再帰的なデータ構造から保護した形式で返します。 
もしobjectの文字列表現が再帰的な要素を持っているなら、再帰的な参照は"Recursion on typename with id=number"で表示されます。 
出力は他と違ってフォーマット化されません。 
preferences モジュールを使うと、ユーザの環境設定をシステム全体の環境設定フォルダ中に保存できます。 このとき、ユーザの環境設定にアプリケーション自体のデフォルト設定を持たせたり、特定の状況で環境設定をオーバライドさせたりできます。 
10.4 決定論的プロファイリングとは何か? 
プロファイラのプライマリ・エントリ・ポイントはグローバル関数 profile.run() です。 
通常、プロファイル情報の作成に使われます。 
情報は pstats.Stats クラスのメソッドを使って整形や出力をおこないます。 
以下はすべての標準エントリポイントと関数の解説です。 
さらにいくつかのコードの詳細を知りたければ、「プロファイラの拡張」を読んでください。 派生クラスを使ってプロファイラを``改善''する方法やモジュールのソースコードの読み方が述べられています。 
この関数はオプション引数として exec 文に渡すファイル名を指定できます。 
このルーチンは必ず最初の引数の exec を試み、実行結果からプロファイル情報を収集しようとします。 
ファイル名が指定されていないときは、各行の標準名(standard name)文字列(ファイル名/行数/関数名)でソートされた、簡単なレポートが表示されます。 
以下はその出力例です。 
最初の行はこのプロファイルが profile.run('main()') の呼び出しによって生成されたものであり、実行された文字列は 'main()' であることを示しています。 
2行目は2706回の関数呼出しがあったことを示しています。 
このうち2004回はプリミティブなものです。 
呼出し回数 
この関数が消費した時間の合計(サブ関数呼出しの時間は除く) 
tottime を ncalls で割った値 
サブ関数を含む関数の(実行開始から終了までの)消費時間の合計。 
この項目は再帰的な関数においても正確に計測されます。 
cumtime をプリミティブな呼び出し回数で割った値 
その関数のファイル名、行番号、関数名 
("43/3" など)最初の欄に2つの数字が表示されている場合、最初の値は呼出し回数、2番目はプリミティブな呼び出しの回数を表しています。 
関数が再帰していない場合はどちらの回数も同じになるため、1つの数値しか表示されません。 
この関数は profile.run() に似ていますが、command 文字列用にグローバル辞書とローカル辞書の引数を追加しています。 
プロファイラ・データの分析は pstats モジュールを使っておこないます。 クラスStats 
このコンストラクタは filename で指定した(単一または複数の)ファイルから``統計情報オブジェクト''のインスタンスを生成します。 
Stats オブジェクトはレポートを出力するメソッドを通じて操作します。 上記コンストラクタで指定するファイルは、使用する Stats に対応したバージョンの profile で作成されたものでなければなりません。 
将来のバージョンのプロファイラとの互換性は保証されておらず、(旧バージョンのものなど)他のプロファイラとの互換性もないことに注意してください。 複数のファイルを指定した場合、同一の関数の統計情報はすべて合算され、複数のプロセスで構成される全体をひとつのレポートで検証することが可能になります。 
既存の Stats オブジェクトに別のファイルの情報を追加するときは、add() メソッドを使用します。 
IRIX, Linuxプラットフォームで利用できます。 
ptyモジュールは擬似端末(他のプロセスを実行してその制御をしている端末をプログラムで読み書きする)を制御する操作を定義しています。 擬似端末の制御はプラットフォームに強く依存するので、SGIとLinux用のコードしか存在していません。 
forkします。 
子プロセスの制御端末を擬似端末に接続します。 返り値は(pid, fd)です。 
子プロセスはpidとして0、、fdとしてinvalid をそれぞれ受けとります。 
親プロセスはpidとして子プロセスのPID、fdとして子プロセスの制御端末(子プロセスの標準入出力に接続されている)のファイルディスクリプタを受けとります。 
新しい擬似端末のペアを開きます。 
利用できるならos.openpty()を使い、利用できなければSGIと一般的なUnixシステム用のエミュレーションコードを使います。 マスター、スレーブそれぞれのためのファイルディスクリプタ、(master, slave)のタプルを返します。 
プロセスを生成して制御端末を現在のプロセスの標準入出力に接続します。 
これは制御端末を読もうとするプログラムをごまかすために利用されます。 master_readとstdin_readにはファイルディスクリプタから読み込む関数を指定してください。 
デフォルトでは呼ばれるたびに1024バイトずつ読み込もうとします。 
このモジュールはUnixのユーザアカウントとパスワードのデータベースへのアクセスを提供します。 
全てのUnix系OSで利用できます。 パスワードデータベースの各エントリはタプルのようなオブジェクトで提供され、それぞれの属性はpasswd構造体のメンバに対応しています(下の属性欄については、pwd.hを見てください)。 
インデックス 
ログイン名 
暗号化されたパスワード(optional)) 
ユーザID(UID) 
グループID(GID) 
実名またはコメント 
ホームディレクトリ 
シェル 
UIDとGIDは整数で、それ以外は全て文字列です。 検索したエントリが見つからないとKeyErrorが発生します。 
注意:伝統的なUnixでは、pw_passwdフィールドはDES由来のアルゴリズムで暗号化されたパスワード( 
モジュールをごらんください)が含まれています。 
しかし、近代的なUNIX系OSではシャドウパスワードとよばれる仕組みを利用しています。 
この場合にはpw_passwdフィールドにはアスタリスク('*')か、"x"という一文字だけが含まれており、暗号化されたパスワードは、一般には見えない/etc/shadowというファイルに入っています。 
このモジュールでは以下のものが定義されています: 
与えられたUIDに対応するパスワードデータベースのエントリを返します。 
与えられたユーザ名に対応するパスワードデータベースのエントリを返します。 
パスワードデータベースの全てのエントリを、任意の順番で並べたリストを返します。 
このモジュールに似た、グループデータベースへのアクセスを提供するモジュール。 . 
このpyclbrはモジュールで定義されたクラス、メソッド、およびトップレベルの関数について、限られた量の情報を定義するのに使われます。 
このクラスによって提供される情報は、伝統的な 3 ペイン形式のクラスブラウザーを実装するのに十分なだけの量になります。 
情報はモジュールのインポートによらず、ソースコードから抽出します。 このため、このモジュールは信用できないソースコードに対して利用しても安全です。 
この制限から、多くの標準モジュールやオプションの拡張モジュールを含む、Python で実装されていないモジュールに対して利用することはできません。 
モジュールを読み込み、辞書マッピングクラスを返し、クラス記述オブジェクトに名前をつけます。 
パラメタmoduleはモジュール名を表す文字列でなくてはなりません;パッケージ内のモジュール名でもかまいません。 
path パラメタはシーケンス型でなくてはならず、 モジュールのソースコードがある場所を特定する際に sys.path の値に補完する形で使われます。 
readmodule() に似ていますが、返される辞書は、クラス名からクラス記述オブジェクトへの対応付けに加えて、トップレベル関数から関数記述オブジェクトへの対応付けも行っています。 
さらに、読み出し対象のモジュールがパッケージの場合、返される辞書はキー '__path__' を持ち、その値はパッケージの検索パスが入ったリストになります。 
18.7.2 関数記述オブジェクト (Function Descriptor 
py_compileモジュールには、ソースファイルからバイトコードファイルを作る関数と、モジュールのソースファイルがスクリプトとして呼び出される時に使用される関数が定義されています。 頻繁に必要となるわけではありませんが、共有ライブラリとしてモジュールをインストールする場合や、特にソースコードのあるディレクトリにバイトコードのキャッシュファイルを書き込む権限がないユーザがいるときには、この関数は役に立ちます。 
ファイルをコンパイル中にエラーが発生すると、PyCompileError例外が送出されます。 
ソースファイルをバイトコードにコンパイルして、バイトコードのキャッシュファイルに書き出します。 
ソースコードはファイル名fileで渡します。 
バイトコードはファイルcfileに書き込まれ、デフォルトではfile 
+ 'c'(使用しているインタープリタで最適化が可能なら'o')です。 
もしdfileが指定されたら、fileの代わりにソースファイルの名前としてエラーメッセージの中で使われます。 
doraise = Trueの場合、コンパイル中にエラーが発生するとPyCompileErrorを送出します。 
doraise = Falseの場合(デフォルト)はエラーメッセージはsys.stderrに出力し、例外は送出しません。 
いくつか複数のソースファイルをコンパイルします。 
argsで(あるいはargsで指定されなかったらコマンドラインで)指定されたファイルをコンパイルし、できたバイトコードを通常の方法で保存します。 
この関数はソースファイルの存在するディレクトリを検索しません;指定されたファイルをコンパイルするだけです。 
このモジュールがスクリプトとして実行されると、main()がコマンドラインで指定されたファイルを全てコンパイルします。 
ディレクトリツリー内のPythonソースファイルを全てコンパイルするライブラリ。 . 
pydocモジュールは、Pythonモジュールから自動的にドキュメントを生成します。 
pydocをPythonインタプリタからはなく、オペレーティングシステムのコマンドプロンプトから起動した場合でも、同じテキスト形式のドキュメントを見ることができます。 例えば、以下をshellから実行すると 
モジュールのドキュメントを、Unix のmanコマンドのような形式で表示させることができます。 
pydocの引数として与えることができるのは、関数名・モジュール名・パッケージ名、また、モジュールやパッケージ内のモジュールに含まれるクラス・メソッド・関数へのドット"."形式での参照です。 
pydoc -p 1234とすると、HTTPサーバーをポート1234に起動します。 これで、お好きなWeb browserを使ってhttp://localhost:1234/からドキュメントを見ることができます。 
pydocでドキュメントを生成する場合、その時点での環境とパス情報に基づいてモジュールがどこにあるのか決定されます。 
そのため、pydoc spamを実行した場合につくられるドキュメントは、Pythonインタプリタを起動して"import spam"と入力したときに読み込まれるモジュールに対するドキュメントになります。 コアモジュールのドキュメントはhttp://www.python.org/doc/current/lib/ にあると仮定されています。 
これは、ライブラリリファレンスマニュアルを置いている異なるURLかローカルディレクトリを 環境変数PYTHONDOCSに設定することでオーバーライドすることができます。 
このモジュールは BuildApplet と BuildApplication のヘルパーモジュールとして主に利用されています。 
コンパイル済みの Python コードに 'PYC' リソースを付加できます。 
このモジュールは Python インタプリタの初期設定の読み込みや書き込みを行えるように 
モジュールを特化したものです。 
quietconsole を使うと、バッファの stdio 出力を表示せずに (あるいは、EditPythonPrefsで設定されていれば、stdout ウィンドウを全く表示しないで) 保存できます。 保存されるのは、 stdin から読み込みを始めるか、バッファリングを止めるかするまでの間で、その時点で全ての出力は今度はウィンドウに送られることになります。 
グラフィカルユーザインターフェース(GUI)プログラムで、クラッシュ時の出力を表示したい場合に便利です。 
このモジュールは RFC 1521: ``MIME (Multipurpose Internet MailExtensions) Part One: Mechanisms for Specifying and Describing theFormat of Internet Message Bodies'' で定義されている quoted-printableによる伝送のエンコードおよびデコードを行います。 
quoted-printable 円コーディングは比較的印字不可能な文字の少ないデータのために設計されています; 画像ファイルを送るときのように印字不可能な文字がたくさんある場合には、 
モジュールで利用できる base64エンコーディングのほうがよりコンパクトになります。 
オプション引数 header が存在し、かつその値が真である場合、アンダースコアは空白文字にデコードされます。 
これは RFC 1522: ``MIME (Multipurpose Internet Mail Extensions)Part Two: Message Header Extensions for Non-ASCII Text''で記述されているところの ``Q''-エンコードされたヘッダをデコードするのに使われます。 
input.readline() が空文字列を返すまで読みつづけられます。 
quotetabs はデータ中に埋め込まれた空白文字やタブを変換するかどうか制御するフラグです; この値が真なら、それらの空白をエンコードします。 偽ならエンコードせずそのままにしておきます。 
行末のスペースやタブは RFC 1521 に従って常に変換されるので注意してください。 
decode() に似ていますが、文字列を入力として受け取り、デコードされた文字列を返します。 
Python は中心となる乱数生成器として Mersenne Twister を使います。 
これは 53 ビットの浮動小数点を生成し、周期が 2**19937-1、本体は C で実装されていて、高速でスレッドセーフです。 
Mersenne Twister は、現存する中で、最も大規模にテストされた乱数生成器のひとつです。 
しかし、完全に決定論的であるため、この乱数生成器は全ての目的に合致しているわけではなく、暗号化の目的には全く向いていません。 このモジュールで提供されている関数は、実際には random.Random クラスの隠蔽されたインスタンスのメソッドにバインドされています。 
内部状態を共有しない生成器を取得するため、自分で Random のインスタンスを生成することができます。 
サブクラス化の例として、random モジュールは WichmannHill クラスを提供します。 このクラスは Python だけで書かれた代替生成器を実装しています。 
このクラスは、乱数生成器に Wichmann-Hill 法を使っていた古いバージョンの Python から得られた結果を再現するための、後方互換の手段になります。 バージョン 2.3 で 変更 された仕様:MersenneTwister を Wichmann-Hill の代わりに使う 
保守関数: 
基本乱数生成器を初期化します。 
オプション引数 x はハッシュ可能な任意のオブジェクトをとり得ます。 
x が省略されるか None の場合、現在のシステム時間が使われます; 現在のシステム時間はモジュールが最初にインポートされた時に乱数生成器を初期化するためにも使われます。 
乱数の発生源をオペレーティングシステムが提供している場合、システム時刻の代わりにその発生源が使われます(詳細については os.urandom()関数を参照)。 
乱数生成器の現在の内部状態を記憶したオブジェクトを返します。 
このオブジェクトを setstate() に渡して内部状態を復帰することができます。 バージョン 2.1 で 新たに追加 された仕様です。 
内部状態を、現在の状態から、非常に離れているであろう状態に変更します。 
n は非負の整数です。 
これはマルチスレッドのプログラムが複数の Random クラスのインスタンスと結合されている場合に非常に便利です: setstate()や seed() は全てのインスタンスを同じ内部状態にするのに使うことができ、その後 jumpahead() を使って各インスタンスの内部状態を引き離すことができます。 バージョン 2.1 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:n ステップ先の特定の状態になるのではなく、 jumpahead(n) は何ステップも離れているであろう別の状態にする 
整数用の関数: 
range(start、stop、step) の要素からランダムに選ばれた要素を返します。 
この関数は choice(range(start, stop, step))と等価ですが、実際には range オブジェクトを生成しません。 バージョン 1.5.2 で 新たに追加 された仕様です。 
であるようなランダムな整数 N を返します。 
空でないシーケンス seq からランダムに要素を返します。 + seq が空のときは、 IndexError が送出されます。 
オプションの引数 random は、値域が [0.0, 1.0) のランダムな浮動小数点数を返すような引数を持たない関数です; 標準では、この関数は random() です。 
かなり小さい len(x) であっても、x の順列はほとんどの乱数生成器の周期よりも大きくなるので注意してください;このことは長いシーケンスに対してはほとんどの順列は生成されないことを意味します。 
母集団のシーケンスから選ばれた長さ k の一意な要素からなるリストを返します。 
値の置換を行わないランダムサンプリングに用いられます。 バージョン 2.3 で 新たに追加 された仕様です。 
母集団自体を変更せずに、母集団内の要素を含む新たなリストを返します。 
返されたリストは選択された順に並んでいるので、このリストの部分スライスもランダムなサンプルになります。 これにより、くじの当選者を1等賞と2等賞(の部分スライス)に分けるといったことも可能です。 
母集団の要素はハッシュ可能でなくても、ユニークでなくても、かまいません。 
母集団が繰り返しを含む場合、返されたリストの各要素はサンプルから選択可能な要素になります。 整数の並びからサンプルを選ぶには、引数に xrange を使いましょう。 
特に、巨大な母集団からサンプルを取るとき、速度と空間効率が上がります。 sample(xrange(10000000), 60) 
以下の関数は特殊な実数値分布を生成します。 関数パラメタは対応する分布の公式において、数学的な慣行に従って使われている変数から取られた名前がつけられています; これらの公式のほとんどは多くの統計学のテキストに載っています。 
値域 [0.0, 1.0) の次のランダムな浮動小数点数を返します。 
ベータ分布です。 
引数の満たすべき条件は 
alpha -1 および 
beta -1 です。 0 から 1 の値を返します。 
指数分布です。 lambd は平均にしたい値で 1.0 を割ったものです。 
(このパラメタは ``lambda'' と呼ぶべきなのですが、Python の予約語なので使えません。 
) 返される値の範囲は 0 から正の無限大です。 
ガンマ分布です。 
(ガンマ関数 ではありません !) 引数の満たすべき条件は 
alpha 0 および 
beta 0です。 
ガウス分布です。 mu は平均であり、 sigma は標準偏差です。 
この関数は後で定義する関数 normalvariate() より少しだけ高速です。 
対数正規分布です。 
この分布を自然対数を用いた分布にした場合、平均 mu で標準偏差 sigma の正規分布になるでしょう。 mu は任意の値を取ることができ、 sigma はゼロより大きくなければなりません。 
正規分布です、mu は平均で、sigma は標準偏差です。 
mu は平均の角度で、0 から 2*pi までのラジアンで表されます。 kappa は濃度パラメタで、ゼロまたはそれ以上でなければなりません。 
kappa がゼロに等しい場合、この分布は範囲 0 から 2*pi の一様でランダムな角度の分布に退化します。 
パレート分布です。 alpha は形状パラメタです。 
ワイブル分布です。 alpha はスケールパラメタで、beta は形状パラメタです。 
代替の乱数生成器 
クラスWichmannHill 
乱数生成器として Wichmann-Hill アルゴリズムを実装するクラスです。 
Random クラスと同じメソッド全てと、下で説明する whseed メソッドを持ちます。 
このクラスは、Python だけで実装されているので、スレッドセーフではなく、呼び出しと呼び出しの間にロックが必要です。 
また、周期が 6,953,607,871,644 と短く、独立した2つの乱数列が重複しないように注意が必要です。 
取り得る内部状態の個数が 2**24 以下になる場合もあります。 クラスSystemRandom 
オペレーティングシステムの提供する発生源によって乱数を生成するos.urandom()関数を使うクラスです。 
getstate() と+setstate() メソッドが呼び出されると、例外NotImplementedErrorが送出されます。 
参考: 
このモジュールでは、Perl で見られるものと同様な正規表現マッチング操作を提供しています。 
正規表現のパターン文字列にはヌルバイトを含められませんが、number 
記法を使えばヌルバイトを指定できます。 
パターンと検索対象文字列の両方について、 8 ビット文字列と Unicode 文字列を同じように扱えます。 
re モジュールはいつでも利用できます。 正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さずにその特殊な文字を使えるようにするために、バックスラッシュ文字("") を使います。 
通常、 Python コード中では、パターンをこの raw string 記法を使って表現します。 
Mastering Regular Expressions 詳説 正規表現 
Jeffrey Friedl 著、O'Reilly 刊の正規表現に関する本です。 
この本の第2版ではPyhonについては触れていませんが、良い正規表現パターンの書き方を非常にくわしく説明しています。 
readline モジュールでは、補完をしやすくしたり、ヒストリファイルを Python インタプリタから読み書きできるようにするためのいくつかの関数を定義しており、これらは直接使うことも 
モジュールを介して使うこともできます。 readline モジュールでは以下の関数を定義しています: 
readline 初期化ファイルの行を一行解釈して実行します。 
行編集バッファの現在の内容を返します。 
コマンドラインにテキストを挿入します。 
readline 初期化ファイルを解釈します。 標準のファイル名設定は最後に使われたファイル名です。 
readline ヒストリファイルを読み出します。 標準のファイル名設定は ~/.history です。 
readline ヒストリファイルを保存します。 標準のファイル名設定は ~/.history です。 
現在のヒストリをクリアします。 
(注意:インストールされている GNU readlineがサポートしていない場合、この関数は利用できません)バージョン 2.4 で 新たに追加 された仕様です。 
ヒストリファイルに必要な長さを返します。 
負の値はヒストリファイルのサイズに制限がないことを示します。 
ヒストリファイルに必要な長さを設定します。 この値はwrite_history_file() がヒストリを保存する際にファイルを切り詰めるために使います。 
負の値はヒストリファイルのサイズを制限しないことを示します。 
現在のヒストリ行数を返します(この値はget_history_length()で取得する異なります。 
get_history_length()はヒストリファイルに書き出される最大行数を返します)。 
現在のヒストリから、index 番目の項目を返します。 
バージョン 2.3 で 新たに追加 された仕様です。 remove_history_item 
指定した位置にあるヒストリを、指定した line で置き換えます。 バージョン 2.4 で 新たに追加 された仕様です。 
画面の表示を、現在のヒストリ内容によって更新します。 
startup_hook 関数を設定または除去します。 
function が指定されていれば、新たな startup_hook 関数として用いられます; 省略されるか None になっていれば、現在インストールされているフック関数は除去されます。 
startup_hook 関数は readline が最初のプロンプトを出力する直前に引数なしで呼び出されます。 
pre_input_hook 関数を設定または除去します。 
function が指定されていれば、新たな pre_input_hook 関数として用いられます; 省略されるか None になっていれば、現在インストールされているフック関数は除去されます。 
pre_input_hook 関数は readline が最初のプロンプトを出力した後で、かつ readline が入力された文字を読み込み始める直前に引数なしで呼び出されます。 
completer 関数を設定または除去します。 
function が指定されていれば、新たな completer 関数として用いられます; 省略されるか None になっていれば、現在インストールされている completer 関数は除去されます。 
completer 関数は 
function(text, state)の形式で、関数が文字列でない値を返すまで state を0, 1, 2, ..., にして呼び出します。 
この関数は text から始まる文字列の補完結果として可能性のあるものを返さなくてはなりません。 
completer 関数を取得します。 
completer 関数が設定されていなければNoneを返します。 
readline タブ補完スコープの先頭のインデクスを取得します。 
readline タブ補完スコープの末尾のインデクスを取得します。 
タブ補完のための readline 単語区切り文字を設定します。 
タブ補完のための readline 単語区切り文字を取得します。 
1 行をヒストリバッファに追加し、最後に打ち込まれた行のようにします。 
対話的プロンプトで Python 識別子を補完する機能。 
クラスRepr 
組み込みクラスrepr()によく似た関数を実装するために役に立つ書式化サービスを提供します。 過度に長い表現を作り出さないように、異なるオブジェクト型に対する大きさの制限が追加されます。 
これは下で説明されるrepr()関数を提供するために使われるReprのインスタンスです。 
このオブジェクトの属性を変更すると、repr()とPythonデバッガが使うサイズ制限に影響します。 
これはaReprのrepr()メソッドです。 
同じ名前の組み込み関数が返す文字列と似ていますが、最大サイズに制限のある文字列を返します。 
下に述べる関数は、背後にあるシステムコールが予期せず失敗した場合、このエラーを送出するかもしれません。 
警告:このドキュメントは、rexecモジュールを使用している古いコードを読む際の参照用として残されています。 
警告: rexec モジュールは、下記のように動作するべく設計されてはいますが、注意深く書かれたコードなら利用できてしまうかもしれない、既知の脆弱性がいくつかあります。 
従って、``製品レベル'' のセキュリティを要する状況では、rexec の動作をあてにするべきではありません。 
製品レベルのセキュリティを求めるなら、サブプロセスを介した実行や、あるいは処理するコードとデータの両方に対する非常に注意深い ``浄化'' が必要でしょう。 
上記の代わりに、rexec の既知の脆弱性に対するパッチ当ての手伝いも歓迎します。 
注意: RExec クラスは、プログラムコードによるディスクファイルの読み書きや TCP/IP ソケットの利用といった、安全でない操作の実行を防ぐことができます。 
しかし、プログラムコードよる非常に大量のメモリや処理時間の消費に対して防御することはできません。 
クラスRExec 
RExec クラスのインスタンスを返します。 
その代わり、あらかじめ RHooks クラスに渡しておいたり、コンストラクタで生成された RHooks インスタンスのメソッドを呼び出します。 
(実際には、RExec オブジェクトはこれらを呼び出しません -- 呼び出しは、RExec オブジェクトの一部であるモジュールローダオブジェクトによって行われます。 
例えば、RHooks オブジェクトを置き換えて、ILU のようなある種の RPC メカニズムを介することで、全てのファイルシステムの要求をどこかにあるファイルサーバに渡すことができます。 
Grail のアプレットローダは、アプレットを URL からディレクトリ上にimport する際にこの機構を使っています。 もし verboseが true であれば、追加のデバッグ出力が標準出力に送られます。 
制限された環境で実行するコードも、やはり sys.exit() 関数を呼ぶことができることを知っておくことは大事なことです。 
制限されたコードがインタプリタから抜けだすことを許さないためには、いつでも、制限されたコードが、SystemExit 例外をキャッチするtry/except 文とともに実行するように、呼び出しを防御します。 
制限された環境から sys.exit()関数を除去するだけでは不十分です -制限されたコードは、やはり raise SystemExit を使うことができてしまいます。 
SystemExitを取り除くことも、合理的なオプションではありません;いくつかのライブラリコードはこれを使っていますし、これが利用できなくなると中断してしまうでしょう。 
Grail のホームページ 
Grail はすべて Python で書かれた Web ブラウザです。 
これは、rexecモジュールを、Python アプレットをサポートするのに使っていて、このモジュールの使用例として使うことができます。 
リリース 2.3 で撤廃されました。 rfc822 モジュールを使うよりも 
パッケージを使うべきです。 
このメッセージはメッセージヘッダ群とメッセージボディの集まりからなります。 
このモジュールではまた、ヘルパークラス RFC 2822 アドレス群を解釈するための AddressList クラスを定義しています。 
RFC 2822 メッセージ固有の構文に関する情報は RFC を参照してください。 
モジュールでは、多くのエンドユーザメイルプログラムによって生成されるメイルボックスを読み出すためのクラスを提供しています。 
Message インスタンスは入力オブジェクトをパラメタに与えてインスタンス化します。 
入力オブジェクトのメソッドのうち、Message が依存するのは readline() だけです; 通常のファイルオブジェクトは適格です。 
インスタンス化を行うと、入力オブジェクトからデリミタ行 (通常は空行 1 行) に到達するまでヘッダを読み出し、それらをインスタンス中に保持します。 
ヘッダの後のメッセージ本体は読み出しません。 このクラスは readline() メソッドをサポートする任意の入力オブジェクトを扱うことができます。 
入力オブジェクトが seek およびtell できる場合、 rewindbody() メソッドが動作します。 また、不正な行データを入力ストリームにプッシュバックできます。 
入力オブジェクトが seek できない一方で、入力行をプッシュバックするunread() メソッドを持っている場合、Messageは不正な行データにこのプッシュバックを使います。 
こうして、このクラスはバッファされているストリームから来るメッセージを解釈するのに使うことができます。 オプションの seekable 引数は、lseek() システムコールが動作しないと分かるまでは tell() がバッファされたデータを無視するような、ある種の stdio ライブラリで回避手段として提供されています。 
例えば、 m['From']、 
m['from']、および 
m['FROM'] は全て同じ結果になります。 
クラスAddressList 
RFC 2833 アドレスをカンマで区切ったものとして解釈される単一の文字列パラメタを使って、AddressList ヘルパークラスをインスタンス化することができます。 
(パラメタ None は空のリストを表します。 ) 
str 中のバックスラッシュが 2 つのバックスラッシュに置き換えられ、二重引用符がバックスラッシュ付きの二重引用符に置き換えられた、新たな文字列を返します。 
str の 逆クオートされた 新たな文字列を返します。 str が二重引用符で囲われていた場合、二重引用符を剥ぎ取ります。 
同様に、 str が三角括弧で囲われていた場合にも剥ぎ取ります。 
parseaddr() の逆で、(realname, email_address) 形式の 2 要素のタプルをとり、To: や Cc: ヘッダに適した文字列値を返します。 
pair の最初の要素が真値をとらない場合、二つ目の要素をそのまま返します。 
日付の解析に成功した場合、parsedate() は time.mktime() にそのまま渡すことができるような 9 要素のタプルを返します; そうでない場合にはNone を返します。 
結果のフィールド 6、7、および 8 は有用な情報ではありません。 
parsedate() と同じ機能を実現しますが、None または10 要素のタプルを返します; 最初の 9 要素は time.mktime()に直接渡すことができるようなタプルで、 10 番目の要素はその日のタイムゾーンにおける UTC (グリニッチ標準時の公式名称) からのオフセットです。 
(タイムゾーンオフセットの符号は、同じタイムゾーンにおける time.timezone 変数の符号と反転しています; 後者の変数が POSIX 標準に従っている一方、このモジュールは RFC 2822 に従っているからです。 
) 入力文字列がタイムゾーン情報を持たない場合、タプルの最後の要素は Noneになります。 
parsedata_tz() が返す 10 要素のタプルを UTC タイムスタンプに変換します。 
タプル内のタイムゾーン要素が None の場合、地域の時刻を表しているものと家庭します。 
些細な欠陥: この関数はまず最初の8 要素を地域における時刻として変換し、次にタイムゾーンの違いに対する補償を行います; これにより、夏時間の切り替え日前後でちょっとしたエラーが生じるかもしれません。 
通常の利用に関しては心配ありません。 
:モジュール 
網羅的な電子メイル処理パッケージです; rfc822 モジュールを代替します。 . 
エンドユーザのメイルプログラムによって生成される、様々な mailbox 形式を読み出すためのクラス群。 
MIME エンコードされたメッセージを処理する rfc822.Message のサブクラス。 
このモジュールはもともと RFC 822 に適合していたので、そういう名前になっています。 
その後、RFC 2822 が RFC 822 に対する更新としてリリースされました。 
このモジュールは RFC 2822 適合であり、特にRFC 822 からの構文や意味付けに対する変更がなされています。 
rgbimgモジュールを使うと、Pythonプログラムから SGI imglib 画像ファイル (.rgb としても知られています) にアクセスできます。 
このモジュールは完全とはいえませんが、ちょっとした用途には十分な機能を持っているため提供されています。 
現在のところカラーマップファイルはサポートされていません。 
注意:このモジュールはデフォルトでは32ビットプラットフォーム上でしか構築されません。 他のシステムでは適切に動作しそうにないからです。 
このモジュールでは以下の変数と関数を定義しています: 
ファイル形式がサポートされていない場合など、全てのエラーに対して送出される例外です。 
指定したファイル上の画像を読み込んでデコードし、Python文字列にして返します。 
文字列は4バイトRGBピクセル形式です。 左下のピクセルが文字列の先頭になります。 
この形式は、例えばgl.lrectwrite() に渡すといった用途に適しています。 
data の RGBAデータを画像ファイルfile に書き込みます。 
xとyは画像の大きさを表します。 画像を 1 バイトのz はグレイスケールで保存する場合には 1 、3バイトのRGBデータの場合は 3 です、4バイトのRGBA データの場合には 4 になります。 
入力データは常にピクセル当たり 4 バイトにせねばなりません。 gl.lrectread() の返す形式と同じです。 
画像のスキャンラインを下端から上端に向かって読み書きする (flag はゼロ、SGI GL 互換の方法) か、上端から下端に向かって読み書きする (flag は 1、 X 互換の方法) かを決めるグローバルなフラグです。 
デフォルト値はゼロです。 
rlcompleterモジュールではPythonの識別子やキーワードを定義した 
モジュール向けの補完関数を定義しています。 
モジュールがUnix依存なのでこのモジュールもUnixに依存しています。 rlcompleterモジュールはCompleterクラスを定義しています。 
使用例: 
rlcompleterモジュールは Pythonの対話モードで利用する為にデザインされています。 
ユーザは以下の命令を初期化ファイル(環境変数PYTHONSTARTUPによって定義されます)に書き込むことで、Tabキーによる補完を利用できます: 
このモジュールでは単一のクラス、RobotFileParser を提供します。 
このクラスは、特定のユーザエージェントが robots.txt ファイルを公開している Web サイトのある URL を取得可能かどうかの質問に答えます。 
robots.txt ファイルの構造に関する詳細はhttp://www.robotstxt.org/wc/norobots.htmlを参照してください。 
クラスRobotFileParser 
robots.txt ファイルを参照するための URL を設定します。 
robots.txt URL を読み出し、パーザに入力します。 
引数 lines の内容を解釈します。 
解釈された robots.txt ファイル中に記載された規則に従ったとき、useragent が url を取得してもよい場合には True を返します。 
robots.txt ファイルを最後に取得した時刻を返します。 
この値は、定期的に新たな robots.txt をチェックする必要がある、長時間動作する Web スパイダープログラムを実装する際に便利です。 
robots.txt ファイルを最後に取得した時刻を現在の時刻に設定します。 
以下にRobotFileParser クラスの利用例を示します。 
schedモジュールは一般的な目的のためのイベントスケジューラを実装するクラスを定義します: クラスscheduler 
schedulerクラスはイベントをスケジュールするための一般的なインターフェースを定義します。 
それは``外部世界''を実際に扱うための2つの関数を必要とします -- timefuncは引数なしで呼出し可能であるべきで、そして数(それは``time''です, どんな単位でもかまいません)を返すようにします。 
delayfuncは1つの引数(timefuncの出力と互換)で呼出し可能であり、その時間だけ遅延しなければいけません。 
各々のイベントが、マルチスレッドアプリケーションの中で他のスレッドが実行する機会の許可を実行した後に、delayfuncは引数0で呼ばれるでしょう。 
このモジュールでは、ほとんどのオペレーティングシステムで利用可能なselect() および poll() 関数へのアクセス機構を提供します。 
Windows の上ではソケットに対してしか動作しないので注意してください; その他のオペレーティングシステムでは、他のファイル形式でも (特に Unixではパイプにも) 動作します。 
通常のファイルに対して適用し、最後にファイルを読み出した時から内容が増えているかを決定するために使うことはできません。 このモジュールでは以下の内容を定義しています: 
エラーが発生したときに送出される例外です。 
エラーに付属する値は、 errno からとったエラーコードを表す数値とそのエラーコードに対応する文字列からなるペアで、C 関数のperror() が出力するものと同様です。 
(全てのオペレーティングシステムでサポートされているわけではありません。 
) ポーリングオブジェクトを返します。 このオブジェクトはファイル記述子を登録したり登録解除したりすることができ、ファイル記述子に対する I/O イベント発生をポーリングすることができます; ポーリングオブジェクトが提供しているメソッドについては下記の7.3.1 節を参照してください。 
Unix の select() システムコールに対する直接的なインタフェースです。 
最初の 3 つの引数は `待機可能なオブジェクト'からなるシーケンスです: ファイル記述子を表す整数値、または引数を持たず、整数を返すメソッド fileno() を持つオブジェクトです。 
待機可能なオブジェクトの 3 つのシーケンスはそれぞれ入力、出力、そして `例外状態' に対応します。 
いずれかに空のシーケンスを指定してもかまいませんが、3 つ全てを空のシーケンスにしてもよいかどうかはプラットフォームに依存します (Unix では動作し、Windows では動作しないことが知られています)。 
オプションの timeout 引数にはタイムアウトまでの秒数を浮動小数点数型で指定します。 
timeout 引数が省略された場合、関数は少なくとも一つのファイル記述子が何らかの準備完了状態になるまでブロックします。 
タイムアウト値ゼロは、ポーリングを行いブロックしないことを示します。 戻り値は準備完了状態のオブジェクトからなる 3 つのリストです:従ってこのリストはそれぞれ関数の最初の 3 つの引数のサブセットになります。 
ファイル記述子のいずれも準備完了にならないままタイムアウトした場合、3 つの空のリストが返されます。 
シーケンスの中に含めることのできるオブジェクトは Python ファイルオブジェクト (すなわち sys.stdin, あるいは open() やos.popen() が返すオブジェクト)、socket.socket()が返すソケットオブジェクト です。 
wrapper クラスを自分で定義することもできます。 この場合、適切な (単なる乱数ではなく本当のファイル記述子を返す)fileno() メソッドを持つ必要があります 
注意: select はWindows のファイルオブジェクトを受理しませんが、ソケットは受理します 
setsモジュールは、ユニークな要素の順序なしコレクションを構築し、操作するためのクラスを提供します。 
帰属関係のテストやシーケンスから重複を取り除いたり、積集合・和集合・差集合・対称差集合のような標準的な数学操作などを含みます。 他のコレクションのように、 
をサポートします。 
順序なしコレクションは、挿入の順序や要素位置を記録しません。 
従って、インデックス・スライス・他のシーケンス的な振舞いをサポートしません。 ほとんどの集合のアプリケーションは、__hash__()を除いてすべての集合のメソッドを提供するSetクラスを使用します。 
ハッシュを要求する高度なアプリケーションについては、ImmutableSetクラスが__hash__()メソッドを加えているが、集合の内容を変更するメソッドは省略されます。 
SetとImmutableSetは、何が集合(isinstance(obj, BaseSet))であるか決めるのに役立つ抽象クラスBaseSetから派生します。 集合クラスは辞書を使用して実装されます。 
その結果、集合はリストや辞書のような変更可能な要素を含むことができません。 しかしそれらは、タプルやImmutableSetのインスタンスのような不変コレクションを含むことができます。 
集合の集合の実装中の便宜については、内部集合が自動的に変更不可能な形式に変換されます。 
例えば、Set([Set(['dog'])])はSet([ImmutableSet(['dog'])])へ変換されます。 クラスSet 
新しい空のSetオブジェクトを構築します。 
もしオプションiterableが与えられたら、イタレータから得られた要素を備えた集合として更新します。 
iterable中の全ての要素は、変更不可能であるか、または5.14.3で記述されたプロトコルを使って変更不可能なものに変換可能であるべきです。 クラスImmutableSet 
新しい空のImmutableSetオブジェクトを構築します。 
もしオプションiterableが与えられたら、イタレータから得られた要素を備えた集合として更新します。 
iterable中の全ての要素は、変更不可能であるか、または5.14.3で記述されたプロトコルを使って変更不可能なものに変換可能であるべきです。 ImmutableSetオブジェクトは__hash__()メソッドを備えているので、集合要素または辞書キーとして使用することができます。 
ImmutableSetオブジェクトは要素を加えたり取り除いたりするメソッドを持っていません。 
したがって、コンストラクタが呼ばれたとき要素はすべて知られていなければなりません。 
このモジュールでは SGML (Standard Generalized Mark-up Language:汎用マークアップ言語標準) で書式化されたテキストファイルを解析するための基礎として働く SGMLParser クラスを定義しています。 
実際には、このクラスは完全な SGML パーザを提供しているわけではありません-- このクラスは HTML で用いられているような SGML だけを解析し、モジュール自体も 
モジュールの基礎にするためだけに存在しています。 
XHTML をサポートし、少し異なったインタフェースを提供しているもう一つの HTML パーザは、 
モジュールで使うことができます。 
クラスSGMLParser 
SGMLParser クラスは引数無しでインスタンス化されます。 このパーザは以下の構成を認識するようにハードコードされています: 
"tag attr="value" ..." と"/tag" で表されるタグの開始部と終了部。 
"#name;" 形式をとる文字の数値参照。 
"name;" 形式をとるエンティティ参照。 
"!-text-" 形式をとる SGML コメント。 
末尾の "" とその直前にある "-" の間にはスペース、タブ、改行を入れることができます。 
例外が以下のように定義されます: 
SGMLParserクラスで構文解析中にエラーに出逢うとこの例外が発生します。 バージョン 2.1 で 新たに追加 された仕様です。 
SGMLParser インスタンスは以下のメソッドを持っています: 
このメソッドはインスタンス生成時に非明示的に呼び出されます。 
タグの処理を停止します。 
以降の入力をリテラル入力 (CDATA) として扱います。 
(この機能は HTML タグ PAINTEXT を実装できるようにするためだけに提供されています) 
リテラルモード (CDATA モード) に移行します。 
テキストをパーザに入力します。 
入力は完全なエレメントから成り立つ場合に限り処理されます; 不完全なデータは追加のデータが入力されるか、close() が呼び出されるまでバッファに蓄積されます。 
バッファに蓄積されている全てのデータについて、直後にファイル終了記号が来た時のようにして強制的に処理します。 
このメソッドは導出クラスで再定義して、入力の終了時に追加の処理行うよう定義することができますが、このメソッドの再定義されたバージョンでは常に close() を呼び出さなければなりません。 
もっとも最近開かれた開始タグのテキストを返します。 
通常、構造化されたデータの処理をする上でこのメソッドは必要ありませんが、``広く知られている (as deployed)'' HTML を扱ったり、入力を最小限の変更で再生成 (属性間の空白をそのままにする、など) したりする場合に便利なことがあります。 
このメソッドは start_tag() か do_tag()のどちらかのメソッドが定義されている開始タグを処理するために呼び出されます。 
name は小文字に変換され、 value 内の二重引用符とバックスラッシュも変換されます。 例えば、タグ A HREF="http://www.cwi.nl/" を処理する場合、このメソッドは"unknown_starttag('a', [('href', 'http://www.cwi.nl/')])"として呼び出されます。 
基底クラスの実装では、単に method を単一の引数 attributes と共に呼び出します。 
このメソッドは end_tag() メソッドの定義されている終了タグを処理するために呼び出されます。 
tag 引数はタグの名前で、小文字に変換されており、method 引数は終了タグの意味解釈をサポートするために使われるバインドされたメソッドです。 
end_tag() メソッドが終了エレメントとして定義されていない場合、ハンドラは一切呼び出されません。 
基底クラスの実装では単に method を呼び出します。 
このメソッドは何らかのデータを処理するために呼び出されます。 
このメソッドは "#ref;" 形式の文字参照(character reference) を処理するために呼び出されます。 
基底クラスの実装では、ref は 0-255 の範囲の 10 進数でなければなりません。 
このメソッドは文字を ASCII に変換し、 その文字を引数として handle_data() を呼び出します。 
ref が無効な値か、範囲を超えた値である場合、エラーを処理するために unknown_charref(ref) が呼び出されます。 
名前づけされた文字エンティティをサポートするためにはこのメソッドをサブクラスで上書きしなければなりません。 
このメソッドは ref を一般エンティティ参照として、"ref;" 形式のエンティティ参照を処理するために呼び出されます。 
このメソッドは、エンティティ名を対応する変換文字に対応付けているインスタンス (またはクラス) 変数である entitydefs 中でref を探します。 
変換が見つかった場合、変換された文字を引数にして handle_data() を呼び出します; そうでない場合、unknown_entityref(ref) を呼び出します。 標準では entitydefs はamp;、 apos、 gt;、 lt;、およびquot; の変換を定義しています。 
comment引数は文字列で、"!-" and "-" デリミタ間の、デリミタ自体を除いたテキストが収められています。 
例えば、コメント"!-text-" があると、このメソッドは引数 'text' で呼び出されます。 
基底クラスの実装では何も行いません。 
実際には、DOCTYPE は HTML だけに見られる宣言ですが、パーザは宣言間の相違 (や誤った宣言) を判別しません。 
DOCTYPEの内部サブセット宣言はサポートされていません。 
decl パラメタは !... 記述内の宣言内容全体になります。 
基底クラスの実装では何も行いません。 
個のメソッドは対応する開始エレメントのない終了タグが発見された時に呼び出されます。 
未知の開始タグを処理するために呼び出されるメソッドです。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
This method is called to process an unknown end tag. 未知の終了タグを処理するために呼び出されるメソッドです。 
このメソッドは解決不能な文字参照数値を処理するために呼び出されます。 
標準で何が処理可能かは handle_charref() を参照してください。 
導出クラスで上書きするためのメソッドです; 基底クラスの実装では何も行いません。 
未知のエンティティ参照を処理するために呼び出されるメソッドです。 
上に挙げたメソッドを上書きしたり拡張したりするのとは別に、導出クラスでは以下の形式のメソッドを定義して、特定のタグを処理することもできます。 
入力ストリーム中のタグ名は大小文字の区別に依存しません; メソッド名中の tag は小文字でなければなりません: 
このメソッドは開始タグ tag を処理するために呼び出されます。 
do_tag() よりも高い優先順位があります。 
attributes 引数は上の handle_starttag() で記述されているのと同じ意味です。 
このメソッドは対応する終了タグのない開始タグ tag を処理するために呼び出されます。 
attributes 引数は上の handle_starttag() で記述されているのと同じ意味です。 
このメソッドは終了タグ tag を処理するために呼び出されます。 
パーザは開始されたエレメントのうち、終了タグがまだ見つかっていないもののスタックを維持しているので注意してください。 
start_tag() で処理されたタグだけがスタックにプッシュされます。 
are pushed on this stack. Definition of anそれらのタグに対する end_tag() メソッドの定義はオプションです。 
do_tag() や unknown_tag()で処理されるタグについては、end_tag() を定義してはいけません; 定義されていても使われることはありません。 あるタグに対して start_tag 
および do_tag() メソッドの両方が存在する場合、start_tag() が優先されます。 
このモジュールは、 
SHA-1 はオリジナルの SHA ハッシュアルゴリズムを改善したバージョンです。 md5 
モジュールと同じように使用します。 
: sha オブジェクトを生成するために new() を使い、update() メソッドを使って、このオブジェクトに任意の文字列を入力し、それまでに入力した文字列全体の digest をいつでも調べることができます。 
SHA-1 のダイジェストは MD5 の 128 bit とは異なり、160 bit です。 
新たな sha オブジェクトを返します。 
もし string が存在するなら、update(string) を呼び出します。 
以下の値はモジュールの中で定数として与えられており、new() で返される sha オブジェクトの属性としても与えられます: 
ハッシュ関数に入力されるブロックのサイズ。 
このサイズは常に 1 です。 
このサイズは、任意の文字列をハッシュできるようにするために使われます。 
digest_size 返されるダイジェスト値をバイト数で表した長さ。 
常に 20 です。 
sha オブジェクトには md5 オブジェクトと同じメソッドがあります。 
文字列 arg を入力として sha オブジェクトを更新します。 
このメソッドを繰り返し呼び出す(操作は、それぞれの呼び出し時の引数を結合したデータを引数として一回の呼び出す操作と同等になります。 
つまり、m.update(a); m.update(b) は m.update(a+b) と同等です。 
これまで update() メソッド で与えてきた文字列のダイジェストを返します。 
戻り値は 20 バイトの文字列で、nullバイトを含む非 ASCII 文字が入っているかもしれません。 
digits() と似ていますが、ダイジェストは長さ40の文字列になり、16進表記数字しか含みません。 
電子メールやその他のバイナリを受け付けない環境で安全に値をやりとりするために使うことができます。 
sha オブジェクトのコピー(``クローン'')を返します。 
参考: セキュアハッシュスタンダード 
セキュアハッシュアルゴリズムは NIST のドキュメント FIPS PUB 180-2 で定義されています。 
セキュアハッシュスタンダード 
, 2002年8月出版。 
暗号ツールキット (セキュアハッシュ) 
NISTからはられているセキュアハッシュに関するさまざまな情報へのリンク 
``シェルフ (shelf, 棚)'' は辞書に似た永続性を持つオブジェクトです。 
``dbm'' データベースとの違いは、シェルフの値 (キーではありません!)は実質上どんな Python オブジェクトにも -- 
モジュールが扱えるなら何でも -- できるということです。 
これにはほとんどのクラスインスタンス、再帰的なデータ型、沢山の共有されたサブオブジェクトを含むオブジェクトが含まれます。 
キーは通常の文字列です。 
永続的な辞書を開きます。 
指定された filename は、根底にあるデータベースの基本ファイル名となります。 
副作用として、filenameには拡張子がつけられる場合があり、ひとつ以上のファイルが生成される可能性もあります。 
デフォルトでは、根底にあるデータベースファイルは読み書き可能なように開かれます。 
オプションの flag パラメタは anydbm.open における flag パラメタと同様に解釈されます。 
デフォルトでは、値を整列化する際にはバージョン 0 の pickle 化が用いられます。 
pickle 化プロトコルのバージョンは protocolパラメタで指定することができます。 
バージョン 2.3 で 変更 された仕様:protocolパラメタが追加されました。 
binary パラメタは撤廃され、以前のバージョンとの互換性のためにのみ提供されています 
デフォルトでは、永続的な辞書の可変エントリに対する変更をおこなっても、自動的にファイルには書き戻されません。 
オプションの writebackパラメタが True に設定されていれば、アクセスされたすべてのエントリはメモリ上にキャッシュされ、ファイルを閉じる際に書き戻されます;この機能は永続的な辞書上の可変の要素に対する変更を容易にしますが、多数のエントリがアクセスされた場合、膨大な量のメモリがキャッシュのために消費され、アクセスされた全てのエントリを書き戻す (アクセスされたエントリが可変であるか、あるいは実際に変更されたかを決定する方法は存在しないのです) ために、ファイルを閉じる操作を非常に低速にしてしまいます。 
shelve オブジェクトは辞書がサポートする全てのメソッドをサポートしています。 
これにより、辞書ベースのスクリプトから永続的な記憶媒体を必要とするスクリプトに容易に移行できるようになります。 
3.17.1 制限事項 
5.20.2 shlex オブジェクト 
5.20.1 モジュールの内容 
shutilモジュールはファイルやファイルの収集に関する多くの高レベルな操作方法を提供します。 
特にファイルのコピーや削除のための関数が用意されています。 
注意: MacOSにおいてはリソースフォークや他のメタデータは取り扱うことができません。 
つまり、ファイルをコピーする際にこれらのリソースは失われたり、ファイルタイプや作成者コードは正しく認識されないことを意味します。 
srcで指定されたファイル内容をdstで指定されたファイルへとコピーします。 
キャラクタやブロックデバイス、パイプ等の特別なファイルはこの関数ではコピーできません。 srcとdstにはパス名を文字列で与えられます。 
ファイル形式のオブジェクトfsrcの内容をfdstへコピーします。 
整数値lengthはバッファサイズを表します。 
特に負のlengthはチャンク内のソースデータを繰り返し操作することなくコピーします。 つまり標準ではデータは制御不能なメモリ消費を避けるためにチャンク内に読み込まれます。 
srcからdstへパーミッションをコピーします。 
ファイル内容や所有者、グループは影響を受けません。 srcとdstには文字列としてパス名を与えられます。 
srcからdstへパーミッション最終アクセス時間、最終更新時間をコピーします。 
ファイル内容や所有者、グループは影響を受けません。 srcとdstには文字列としてパス名を与えられます。 
ファイルsrcをファイルまたはディレクトリdistへコピーします。 
もし、dstがディレクトリであればファイル名はsrcと同じものが指定されたディレクトリ内に作成(または上書き)されます。 パーミッションはコピーされます。 
srcとdstには文字列としてパス名を与えられます。 
copy()と類似していますが、最終アクセス時間や最終更新時間も同様にコピーされます。 
これは Unix コマンドの cp -pと同様の働きをします。 
srcを起点としてディレクトリツリー全体を再帰的にコピーします。 
dstで指定されたディレクトリは既存のものではなく新規に作成されるものでなくてはなりません。 
個々のファイルはcopy2()によってコピーされます。 
この関数のソースコードは道具としてよりも使用例として捉えられるべきでしょう。 バージョン 2.3 で 変更 された仕様:コピー中にエラーが発生した場合、メッセージを出力するのではなく例外を引き起こすように変更。 
ディレクトリツリー全体を削除します。 
もしignore_errorsが真であれば削除に失敗したことによるエラーは無視され、偽が与えられたり省略された場合はこれらのエラーはonerrorで与えられたハンドラを呼び出して処理され、これが省略された場合は例外を引き起こします。 onerrorが与えられた場合、それは3つのパラメータfunction,pathおよびexcinfoを受け入れて呼び出し可能のものでなくてはなりません。 
最初のパラメータfunctionは例外を引き起こす関数でos.listdir()、os.remove()またはos.rmdir()が用いられるでしょう。 
二番目のパラメータはpathはfunctionへ渡らせるパス名です。 
三番目のパラメータexcinfoはsys.exc_info()で返されるような例外情報になるでしょう。 
onerrorが引き起こす例外はキャッチできません。 
再帰的にファイルやディレクトリを別の場所へ移動します。 
もし移動先が現在のファイルシステム上であれば単純に名前を変更します。 そうでない場合はコピーを行い、その後コピー元は削除されます。 
この例外は複数ファイルの操作を行っているときに生じる例外をまとめたものです。 
copytreeに対しては例外の引数は3つのタプル(srcname,dstname, exception)からなるリストです。 
6.26.1 使用例 
このモジュールでは Python でシグナルハンドラを使うための機構を提供します。 
クリティカルセクションから一時的にシグナルを``ブロック''することはできません。 この機能をサポートしないUnix系システムも存在するためです。 
Python のシグナルハンドラは Python のユーザが望む限り非同期で呼び出されますが、呼び出されるのは Python インタプリタの ``原子的な (atomic)'' 命令実行単位の間です。 
従って、(巨大なサイズのテキストに対する正規表現の一致検索のような) 純粋に C 言語のレベルで実現されている時間のかかる処理中に到着したシグナルは、不定期間遅延する可能性があります。 
シグナルが I/O 操作中に到着すると、シグナルハンドラが処理を返した後に I/O 操作が例外を送出する可能性があります。 これは背後にある Unix システムが割り込みシステムコールにどういう意味付けをしているかに依存します。 
C 言語のシグナルハンドラは常に処理を返すので、SIGFPEや SIGSEGV のような同期エラーの捕捉はほとんど意味がありません。 
Python は標準でごく小数のシグナルハンドラをインストールしています:SIGPIPE は無視されます (従って、パイプやソケットに対する書き込みで生じたエラーは通常の Python 例外として報告されます)SIGINT は KeyboardInterrupt 例外に変換されます。 
これらはどれも上書きすることができます。 
シグナルとスレッドの両方を同じプログラムで使用する場合にはいくつか注意が必要です。 
シグナルとスレッドを同時に利用する上で基本的に注意すべきことは: 常に signal() 命令は主スレッド (main thread)の処理中で実行するということです。 
どのスレッドも alarm()、getsignal()、あるいは pause() を実行することができます; しかし、主スレッドだけが新たなシグナルハンドラを設定することができ、従ってシグナルを受け取ることができるのは主スレッドだけです (これは、背後のスレッド実装が個々のスレッドに対するシグナル送信をサポートしているかに関わらず、Python signal モジュールが強制している仕様です)。 
従って、シグナルをスレッド間通信の手段として使うことはできません。 
代わりにロック機構を使ってください。 
以下に signal モジュールで定義されている変数を示します: 
二つある標準シグナル処理オプションのうちの一つです; 単にシグナルに対する標準の関数を実行します。 
例えば、ほとんどのシステムでは、SIGQUIT に対する標準の動作はコアダンプと終了で、SIGCLD に対する標準の動作は単にシグナルの無視です。 
もう一つの標準シグナル処理オプションで、単に受け取ったシグナルを無視します。 
全てのシグナル番号はシンボル定義されています。 
例えば、ハングアップシグナルは signal.SIGHUP で定義されています; 変数名はC 言語のプログラムで使われているのと同じ名前で、signal.hにあります。 `signal()' に関する Unix マニュアルページでは、システムで定義されているシグナルを列挙しています(あるシステムではリストは 
signal(2) に、別のシステムでは 
signal(7) に列挙されています)。 全てのシステムで同じシグナル名のセットを定義しているわけではないので注意してください; このモジュールでは、システムで定義されているシグナル名だけを定義しています。 
最も大きいシグナル番号に 1 を足した値です。 
signal モジュールでは以下の関数を定義しています: 
time がゼロでない値の場合、この関数は time 秒後頃にSIGALRM をプロセスに送るように要求します。 それ以前にスケジュールしたアラームはキャンセルされます (常に一つのアラームしかスケジュールできません)。 
この場合、戻り値は以前に設定されたアラームシグナルが通知されるまであと何秒だったかを示す値です。 time がゼロの場合、アラームは一切スケジュールされず、現在スケジュールされているアラームがキャンセルされます。 
戻り値は以前にスケジュールされたアラームが通知される予定時刻までの残り時間です。 
戻り値がゼロの場合、現在アラームがスケジュールされていないことを示します。 
(Unix マニュアルページ 
alarm(2)を参照してください)。 利用可能: Unix。 
シグナル signalnum に対する現在のシグナルハンドラを返します。 戻り値は呼び出し可能な Python オブジェクトか、signal.SIG_IGN、signal.SIG_DFL、および None といった特殊な値のいずれかです。 
ここで signal.SIG_IGN は以前そのシグナルが無視されていたことを示し、signal.SIG_DFL は以前そのシグナルの標準の処理方法が使われていたことを示し、None はシグナルハンドラがまだ Python によってインストールされていないことを示します。 
シグナルを受け取るまでプロセスを一時停止します; その後、適切なハンドラが呼び出されます。 
戻り値はありません。 
Windows では利用できません。 
signal(2) を参照してください。 ) 
シグナル signalnum に対するハンドラを関数 handler にします。 handler は二つの引数 (下記参照) を取る呼び出し可能な Python オブジェクトにするか、signal.SIG_IGN あるいはsignal.SIG_DFL といった特殊な値にすることができます。 
以前に使われていたシグナルハンドラが返されます(上記の getsignal() の記述を参照してください)。 
(Unix マニュアルページ signal(2) を参照してください。 
)複数スレッドの使用が有効な場合、この関数は主スレッドからのみ呼び出すことができます; 主スレッド以外のスレッドで呼び出そうとすると、例外ValueError が送出されます。 handler は二つの引数: シグナル番号、および現在のスタックフレーム(None またはフレームオブジェクト; フレームオブジェクトについての記述はリファレンスマニュアルの標準型の階層 か、 
モジュールの属性の説明を参照してください)、とともに呼び出されます。 
前部と後部からなる最大で四つまでのディレクトリを作成することから始めます。 
前部には、sys.prefixとsys.exec_prefixを使用します。 
空の前部は省略されます。 
後部には、(MacintoshやWindowsでは)空文字列を使用し、(Unixでは)最初にlib/python2.4/site-packagesを使ってからlib/site-pythonを使います。 
別個の前部-後部の組み合わせのそれぞれに対して、それが存在するディレクトリを参照しているかどうかを調べ、もしそうならばsys.pathへ追加します。 
そして、設定ファイルを新しく追加されたパスからも検索します。 
パス設定ファイルは package.pthという形式の名前をもつファイルで、上の4つのディレクトリのひとつにあります。 
その内容はsys.pathに追加される追加項目(一行に一つ)です。 
存在しない項目はsys.pathへは決して追加されませんが、項目が(ファイルではなく)ディレクトリを参照しているかどうかはチェックされません。 
項目がsys.pathへ二回以上追加されることはありません。 
空行と#で始まる行は読み飛ばされます。 
importで始まる行は実行されます。 
例えば、sys.prefixとsys.exec_prefixが/usr/localに設定されていると仮定します。 
そのときPython 2.4 ライブラリは/usr/local/lib/python2.4にインストールされています(ここで、sys.versionの最初の三文字だけがインストールパス名を作るために使われます)。 
ここにはサブディレクトリ/usr/local/lib/python2.4/site-packagesがあり、その中に三つのサブディレクトリfoo、barおよびspamと二つのパス設定ファイルfoo.pthとbar.pthをもつと仮定します。 
foo.pthには以下のものが記載されていると想定してください: 
また、bar.pthには: 
という名前のモジュールをインポートしようします。 そのモジュールは任意のサイト固有のカスタマイゼーションを行うことができます。 
のインポートはそのときでも試みられます。 
このモジュールでは、 SMTP サーバを実装するためのクラスをいくつか提供しています。 
一つは何も行わない、オーバライドできる汎用のサーバで、その他の二つでは特定のメール送信ストラテジを提供しています。 
smtplibモジュールは、SMTPまたはESMTPのリスナーデーモンを備えた任意のインターネット上のホストにメイルを送るために使用することができるSMTPクライアント・セッション・オブジェクトを定義します。 
SMTPおよびESMTPオペレーションの詳細は、RFC 821 (Simple Mail Transfer Protocol) や RFC 1869(SMTP Service Extensions)を調べてください。 
クラスSMTP 
SMTPインスタンスはSMTPコネクションをカプセル化し、SMTPとESMTPの命令をサポートをします。 
オプションであるhostとportを与えた場合は、SMTPクラスのインスタンスが作成されると同時に、connect()メソッドを呼び出し初期化されます。 
また、ホストから応答が無い場合は、SMTPConnectErrorが上げられます。 普通に使う場合は、初期化と接続を行ってから、sendmail()とquit()メソッドを呼びます。 
使用例は先の方で記載しています。 
このモジュールの例外には次のものがあります: 
このモジュールの例外クラスのベースクラスです。 
この例外はサーバが突然コネクションを切断するか、もしくはSMTPインスタンスを生成する前にコネクションを張ろうとした場合に上げられます。 
SMTPのエラーコードを含んだ例外のクラスです。 これらの例外はSMTPサーバがエラーコードを返すときに生成されます。 
エラーコードはsmtp_code属性に格納されます。 また、smtp_error属性にはエラーメッセージが格納されます。 
送信者のアドレスが弾かれたときに上げられる例外です。 
全てのSMTPResponseException例外に、SMTPサーバが弾いた`sender'アドレスの文字列がセットされます。 
全ての受取人アドレスが弾かれたときに上げられる例外です。 
各受取人のエラーは属性recipientsによってアクセス可能で、SMTP.sendmail()が返す辞書と同じ並びの辞書になっています。 
SMTPサーバが、メッセージのデータを受け入れることを拒絶した時に上げられる例外です。 
サーバへの接続時にエラーが 発生した時に上げられる例外です。 
サーバーが"HELO"メッセージを弾いた時に上げられる例外です。 
SMTP のプロトコル定義です。 
このドキュメントでは SMTP のモデル、操作手順、プロトコルの詳細についてカバーしています。 
SMTP に対する ESMTP 拡張の定義です。 
このドキュメントでは、新たな命令による SMTP の拡張、サーバによって提供される命令を動的に発見する機能のサポート、およびいくつかの追加命令定義について記述しています。 
sndhdrモジュールには、ファイルに保存されたサウンドデータの形式を識別するのに便利な関数が定義されています。 
どんな形式のサウンドデータがファイルに保存されているのか識別可能な場合、これらの関数は(type、sampling_rate、channels、frames、bits_per_sample)のタプルを返します。 
typeはデータの形式を示す文字列で、'aifc'、'aiff'、'au'、'hcom'、'sndr'、'sndt'、'voc'、'wav'、'8svx'、'sb'、'ub'、'ul'のうちの一つです。 
sampling_rateは実際のサンプリングレート値で、未知の場合や読み取ることが出来なかった場合は0です。 
同様に、channelsはチャンネル数で、識別できない場合や読み取ることが出来なかった場合は0です。 
framesはフレーム数で、識別できない場合は-1です。 
タプルの最後の要素bits_per_sampleはサンプルサイズを示すビット数ですが、A-LAW 
なら'A'、u-LAW 
なら'U'です。 
whathdr()を使って、ファイルfilenameに保存されたサウンドデータの形式を識別します。 
識別可能なら上記のタプルを返し、識別できない場合はNoneを返します 。 
ファイルのヘッダ情報をもとに、保存されたサウンドデータの形式を識別します。 
ファイル名はfilenameで渡されます。 
識別可能なら上記のタプルを返し、識別できない場合はNoneを返します。 
Unix Programmer's Manual,Supplementary Documents 1(PS1:7章 PS1:8章)。 
ソケットの詳細については、各プラットフォームのソケット関連システムコールに関するドキュメント(Unixでは マニュアルページ、WindowsではWinSock(またはWinSock2)仕様書)も参照してください。 
各種ソケット関連のシステムコールは、socket()関数で生成するソケット オブジェクト のメソッドとして実装されています。 
後方互換性のため、socketモジュールのメソッドではsin6_flowinfoとsin6_scope_idを省略する事ができますが、scopeidを省略するとスコープを持ったIPv6アドレスの処理で問題が発生する場合があります。 
IPv4/v6ソケットのhost部にホスト名を指定すると、処理結果が一定ではない場合があります。 これはPythonはDNSから取得したアドレスのうち最初のアドレスを使用するので、DNSの処理やホストの設定によって異なるIPv4/6アドレスを取得する場合があるためです。 
常に同じ結果が必要であれば、hostに数値のアドレスを指定してください。 エラー時には例外が発生します。 
socketモジュールでは、以下の定数と関数を提供しています。 
この例外は、ソケット関連のエラーが発生した場合に送出されます。 例外の値は障害の内容を示す文字列か、またはos.errorと同様な(errno, string)のペアとなります。 
オペレーティングシステムで定義されているエラーコードについては 
を参照してください。 
この例外は、C APIのgethostbyname_ex()やgethostbyaddr()などで、h_errnoのようなアドレス関連のエラーが発生した場合に送出されます。 例外の値は(h_errno, string)のペアで、ライブラリの呼び出し結果を返します。 
stringはC関数hstrerror()で取得した、h_errnoの意味を示す文字列です。 
errorの値は、このモジュールで定義される EAI_* 定数の何れかとなります。 
この例外は、あらかじめ settimeout() を呼び出してタイムアウトを有効にしてあるソケットでタイムアウトが生じた際に送出されます。 
例外に付属する値は文字列で、その内容は現状では常に ``timed out''となります。 バージョン 2.3 で 新たに追加 された仕様です。 
アドレス(およびプロトコル)ファミリを示す定数で、socket()の最初の引数に指定することができます。 
AF_UNIXファミリをサポートしないプラットフォームでは、AF_UNIXは未定義となります。 
ソケットタイプを示す定数で、socket()の2番目の引数に指定することができます。 
Unixのソケット・IPプロトコルのドキュメントで定義されている各種定数。 ソケットオブジェクトのsetsockopt()やgetsockopt()で使用します。 
ほとんどのシンボルはUnixのヘッダファイルに従っています。 一部のシンボルには、デフォルト値を定義してあります。 
現在のプラットフォームでIPv6がサポートされているか否かを示す真偽値。 バージョン 2.3 で 新たに追加 された仕様です。 
hostとport に空文字列かNone を指定すると C APIにNULLを渡せます。 
getattrinfo() 関数は以下の構造をとる 5 要素のタプルを返します: 
モジュールなどのソースを参考にしてください。 バージョン 2.2 で 新たに追加 された仕様です。 
nameの完全修飾ドメイン名を返します。 
nameが空または省略された場合、ローカルホストを指定したとみなします。 
完全修飾ドメイン名の取得にはまずgethostbyaddr()でチェックし、次に可能であればエイリアスを調べ、名前にピリオドを含む最初の名前を値として返します。 
完全修飾ドメイン名を取得できない場合、ホスト名を返します。 バージョン 2.0 で 新たに追加 された仕様です。 
ホスト名を'100.50.200.5'のようなIPv4形式のアドレスに変換します。 
ホスト名としてIPv4アドレスを指定した場合、その値は変換せずにそのまま返ります。 
Pythonインタープリタを現在実行中のマシンのホスト名を示す文字列を取得します。 
ソケットアドレスsockaddrから、(host, port)のタプルを取得します。 flagsの設定に従い、hostは完全修飾ドメイン名または数値形式アドレスとなります。 
同様に、portは文字列のポート名または数値のポート番号となります。 バージョン 2.2 で 新たに追加 された仕様です。 
'icmp'のようなインターネットプロトコル名を、socket()の第三引数として指定する事ができる定数に変換します。 
これは主にソケットを``raw''モード(SOCK_RAW)でオープンする場合には必要ですが、通常のソケットモードでは第三引数に0を指定するか省略すれば正しいプロトコルが自動的に選択されます。 
インターネットサービス名とプロトコルから、そのサービスのポート番号を取得します。 
省略可能なプロトコル名として、'tcp'か'udp'のどちらかを指定することができます。 指定がなければどちらのプロトコルにもマッチします。 
インターネットポート番号とプロトコル名から、サービス名を取得します。 
アドレスファミリ、ソケットタイプ、プロトコル番号を指定してソケットを作成します。 
アドレスファミリにはAF_INET(デフォルト値)・AF_INET6・AF_UNIXを指定することができます。 
ソケットタイプにはSOCK_STREAM(デフォルト値)・SOCK_DGRAM・または他の"SOCK_"定数の何れかを指定します。 
プロトコル番号は通常省略するか、または0を指定します。 
ソケットsockによるSSL接続を初期化します。 
keyfileには、PEMフォーマットのプライベートキーファイル名を指定します。 certfileには、PEMフォーマットの認証チェーンファイル名を指定します。 
処理が成功すると、新しいSSLObjectが返ります。 
警告:証明書の認証は全く行いません。 
指定されたアドレスファミリ、ソケットタイプ、プロトコル番号から、接続されたソケットのペアを作成します。 
アドレスファミリ、ソケットタイプ、プロトコル番号は socket()関数と同様に指定します。 デフォルトのアドレスファミリは、プラットフォームで定義されていればAF_UNIX、そうでなければAF_INETが使われます。 
利用可能: Unix. バージョン 2.4 で 新たに追加 された仕様です。 
既存のファイルディスクリプタ(ファイルオブジェクトのfileno()で返る整数)から、ソケットオブジェクトを構築します。 
アドレスファミリとプロトコル番号はsocket()と同様に指定します。 
ファイルディスクリプタはソケットを指していなければなりませんが、実際にソケットであるかどうかのチェックは行っていません。 このため、ソケット以外のファイルディスクリプタを指定するとその後の処理が失敗する場合があります。 
この関数が必要な事はあまりありませんが、Unixのinetデーモンのようにソケットを標準入力や標準出力として使用するプログラムで使われます。 
この関数で使用するソケットは、ブロッキングモードと想定しています。 利用可能:Unix 
32ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイトオーダに変換します。 
ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。 それ以外の場合は4バイトのスワップを行います。 
16ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイトオーダに変換します。 
ホストバイトオーダとネットワークバイトオーダが一致するマシンでは、この関数は何もしません。 それ以外の場合は2バイトのスワップを行います。 
32ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイトオーダに変換します。 
16ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイトオーダに変換します。 
ドット記法によるIPv4アドレス('123.45.67.89'など)を32ビットにパックしたバイナリ形式に変換し、長さ4の文字列として返します。 
この関数が返す値は、標準Cライブラリのstruct in_addr型を使用する関数に渡す事ができます。 
IPv4アドレス文字列が不正であれば、socket.errorが発生します。 
このチェックは、この関数で使用しているCの実装 inet_aton()で行われます。 inet_aton()は、IPv6をサポートしません。 
IPv4/v6のデュアルスタックをサポートする場合はgetnameinfo()を使用します。 inet_ntoa 
32ビットにパックしたバイナリ形式のIPv4アドレスを、ドット記法による文字列('123.45.67.89'など)に変換します。 
この関数が返す値は、標準Cライブラリのstruct in_addr型を使用する関数に渡す事ができます。 この関数に渡す文字列の長さが4バイト以外であれば、socket.errorが発生します。 
inet_ntoa()は、IPv6をサポートしません。 
IPv4/v6のデュアルスタックをサポートする場合はgetnameinfo()を使用します。 inet_pton 
利用可能: Unix (サポートしていないプラットフォームもあります)バージョン 2.3 で 新たに追加 された仕様です。 
パックしたIPアドレス(数文字の文字列)を、'7.10.0.5'や'5aef:2b::8'などの標準的な、アドレスファミリ固有の文字列形式に変換します。 
inet_ntop()でエラーとなると、socket.errorが発生します。 利用可能: Unix (サポートしていないプラットフォームもあります)バージョン 2.3 で 新たに追加 された仕様です。 
新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動小数点形式の秒数で返します。 
ソケットオブジェクトの型を示す型オブジェクト。 
type(socket(...))と同じです。 
ネットワークサーバの開発を省力化するためのクラス群。 
stat モジュールでは、os.stat()、os.lstat() および os.fstat() (存在すれば) の返す内容を解釈するための定数や関数を定義しています。 
stat()、fstat()、および lstat() の関数呼び出しについての完全な記述はシステムのドキュメントを参照してください。 
stat モジュールでは、特殊なファイル型を判別するための以下の関数を定義しています: 
ファイルのモードがディレクトリの場合にゼロでない値を返します。 
ファイルのモードがキャラクタ型の特殊デバイスファイルの場合にゼロでない値を返します。 
ファイルのモードがブロック型の特殊デバイスファイルの場合にゼロでない値を返します。 
ファイルのモードが通常ファイルの場合にゼロでない値を返します。 
ファイルのモードが FIFO (名前つきパイプ) の場合にゼロでない値を返します。 
ファイルのモードがシンボリックリンクの場合にゼロでない値を返します。 
ファイルのモードがソケットの場合にゼロでない値を返します。 
より一般的なファイルのモードを操作するための二つの関数が定義されています: 
os.chmod() で設定することのできる一部のファイルモード-- すなわち、ファイルの許可ビット (permission bits) に加え、(サポートされているシステムでは) スティッキービット (sticky bit)、実行グループ ID 設定 (set-group-id) および 実行ユーザ ID 設定 (set-user-id) ビット -- を返します。 
ファイルの形式を記述しているファイルモードの一部 (上記の S_IS*() 関数で使われます) を返します。 
os.path で扱うことのできないファイルの情報を調べる際にも便利です。 
I ノードの保護モード。 
I ノード番号。 
I ノードが存在するデバイス。 
該当する I ノードへのリンク数。 
ファイルの所持者のユーザ ID。 
ファイルの所持者のグループ ID。 
通常ファイルではバイトサイズ; いくつかの特殊ファイルでは処理待ちのデータ量。 
最後にアクセスした時刻。 
最後に変更された時刻。 
オペレーティングシステムから返される``ctime''。 
あるOS(Unixなど)では最後にメタデータが更新された時間となり、別のOS(Windowsなど)では作成時間となります(詳細については各プラットフォームのドキュメントを参照してください)。 
``ファイルサイズ'' の解釈はファイルの型によって異なります。 
通常のファイルの場合、サイズはファイルの大きさをバイトで表したものです。 
他のキャラクタ型およびブロック型デバイスにおけるサイズフィーるの意味はさらに異なっていて、背後のシステムコールの実装によります。 
リリース 2.2 で撤廃されました。 キャッシュを使わずに 
.stat() を直接使ってください; キャッシュはそれを使うアプリケーションに非常に高いレベルの脆弱性をもたらし、キャッシュ管理のサポートを追加することでアプリケーションのソースコードを難解にしてしまいます。 
statcache モジュールは os.stat() を最後に呼び出した際の値を記憶することによる最適化機能を提供します。 
statcache モジュールでは以下の関数を定義しています: 
このモジュールの主要なエントリポイントです。 
os.stat() と同じですが、将来同じ呼び出しが行われたときの為に結果を記憶しておきます。 
その他の関数はキャッシュやその一部を消去するために用いられます。 
キャッシュを消去します: これまでの全ての stat() 呼び出しによる結果を忘却します。 
stat(path) のキャッシュが存在すれば、それを忘却します。 
prefix で始まる path に対する stat(path) の結果をすべて忘却します。 
prefix で始まる path に対する stat(path) の結果を、stat(prefix) も含めてすべて忘却します。 
forget_prefix() に似ていますが、prefix で 始まらない 全ての path について忘却します。 
statvfs モジュールでは、os.statvfs() の返す値を解釈するための定数を定義しています。 
os.statvfs() は ``マジックナンバ'' を記憶せずにタプルを生成して返します。 
このモジュールで定義されている各定数は os.statvfs() が返すタプルにおいて、特定の情報が収められている各エントリへの インデクス です。 
選択されているファイルシステムのブロックサイズです。 
ファイルシステムの基本ブロックサイズです。 
ブロック数の総計です。 
空きブロック数の総計です。 
非スーパユーザが利用できる空きブロック数です。 
ファイルノード数の総計です。 
空きファイルノード数の総計です。 
非スーパユーザが利用できる空きノード数です。 
フラグで、システム依存です: statvfs() マニュアルページを参照してください。 
ファイル名の最大長です。 
string モジュールには便利な定数やクラスが数多く入っています。 また、現在は文字列のメソッドとして利用できる、すでに撤廃された古い関数もは言っています。 
正規表現に関する文字列操作の関数は 
を参照してください。 
(ホスト名のような) インターネット上にある存在に識別名をつける際、しばしば識別名間の ``等価性'' 比較を行う必要があります。 
厳密には、例えば大小文字の区別をするかしないかいったように、比較をどのように行うかはアプリケーションの領域に依存します。 
また、例えば ``印字可能な'' 文字で構成された識別名だけを許可するといったように、可能な識別名を制限することも必要となるかもしれません。 
RFC 3454 では、インターネットプロトコル上で Unicode 文字列を``調製 (prepare)'' するためのプロシジャを定義しています。 
文字列は通信路に載せられる前に調製プロシジャで処理され、その結果ある正規化された形式になります。 
RFC ではあるテーブルの集合を定義しており、それらはプロファイルにまとめられています。 
各プロファイルでは、どのテーブルを使い、stringprep プロシジャのどのオプション部分がプロファイルの一部になっているかを定義しています。 
stringprep プロファイルの一つの例は nameprep で、国際化されたドメイン名に使われます。 stringprep は RFC 3453 のテーブルを公開しているに過ぎません。 
これらのテーブルは辞書やリストとして表 現するにはバリエーションが大きすぎるので、このモジュールでは Unicode 文字データベースを内部的に利用しています。 
モジュールソースコード自体は mkstringprep.py ユーティリティを使って生成されました。 その結果、これらのテーブルはデータ構造体ではなく、関数として公開されています。 
RFC には 2 種類のテーブル: 集合およびマップ、が存在します。 
集合については、stringprep は``特性関数 (characteristic function)'' 、すなわち引数が集合の一部である場合に真を返す関数を提供します。 
マップに対しては、マップ関数: キーが与えられると、それに関連付けられた値を返す関数、を提供します。 
以下はこのモジュールで利用可能な全ての関数を列挙したものです。 
code がテーブル A.1 (Unicode 3.2 における未割り当てコード点: unassigned code point) かどうか判定します。 
code がテーブル B.1 (一般には何にも対応付けられていない:commonly mapped to nothing) かどうか判定します。 
テーブル B.2 (NFKC で用いられる大小文字の対応付け) に従って、 code に対応付けられた値を返します。 
テーブル B.3 (正規化を伴わない大小文字の対応付け) に従って、 code に対応付けられた値を返します。 
code がテーブル C.1.1 (ASCII スペース文字) かどうか判定します。 
code がテーブル C.1.2 (非 ASCII スペース文字) かどうか判定します。 
code がテーブル C.1 (スペース文字、C.1.1 および C.1.2 の和集合) かどうか判定します。 
code がテーブル C.2.1 (ASCII 制御文字)かどうか判定します。 
code がテーブル C.2.2 (非 ASCII 制御文字)かどうか判定します。 
code がテーブル C.2 (制御文字、C.2.1 および C.2.2 の和集合) かどうか判定します。 
code がテーブル C.3 (プライベート利用) かどうか判定します。 
code がテーブル C.4 (非文字コード点: non-character code points)かどうか判定します。 
code がテーブル C.5 (サロゲーションコード) かどうか判定します。 
code がテーブル C.6 (平文:plain text として不適切) かどうか判定します。 
code がテーブル C.7 (標準表現:canonical representation として不適切) かどうか判定します。 
code がテーブル C.8 (表示プロパティの変更または撤廃) かどうか判定します。 
code がテーブル C.9 (タグ文字) かどうか判定します。 
code がテーブル D.1 (双方向プロパティ ``R'' または ``AL'' を持つ文字) かどうか判定します。 
code がテーブル D.2 (双方向プロパティ ``L'' を持つ文字) かどうか判定します。 
このモジュールは、 Python の値と Python 上で文字列データとして表されるC の構造体データとの間の変換を実現します。 
このモジュールでは、C 構造体のレイアウトおよび Python の値との間で行いたい変換をコンパクトに表現するために、フォーマット文字列 を使います。 
このモジュールは特に、ファイルに保存されたり、ネットワーク接続を経由したバイナリデータを扱うときに使われます。 このモジュールは以下の例外と関数を定義しています: 
様々な状況で送出された例外です; 引数は何が問題かを記述する文字列です。 
値 
v1, v2, ... が与えられたフォーマットで含まれる文字列データを返します。 
引数は指定したフォーマットが要求する型と正確に一致していなければなりません。 
(おそらく pack(fmt, ...) でパックされた) 文字列データを、与えられた書式に従ってアンパックします。 
値が一つしかない場合を含め、結果はタプルで返されます。 
文字列データにはフォーマットが要求するだけのデータが正確に含まれていなければなりません(len(string) が calcsize(fmt) と一致しなければなりません)。 
与えられたフォーマットに対応する構造体のサイズ (すなわち文字列データのサイズ) を返します。 
フォーマット文字 (format character) は以下の意味を持っています; C と Python の間の変換では、値は正確に以下に指定された型でなくてはなりません: 
フォーマット 
C での型 
長さ 1 の文字列 
整数型 (integer) 
整数型 
long 整数型 
浮動小数点型 
文字列 
注意事項: 
フォーマット文字 "q" および "Q" は、プラットフォームの C コンパイラが C の long long 型、Windows では __int64 をサポートする場合にのみ、プラットフォームネイティブの値との変換を行うモードだけで利用することができます。 
バージョン 2.2 で 新たに追加 された仕様です。 
フォーマット文字の前に整数をつけ、繰り返し回数 (count) を指定することができます。 
例えば、フォーマット文字列 '4h' は 'hhhh' と全く同じ意味です。 フォーマット文字間の空白文字は無視されます; count とフォーマット文字の間にはスペースを入れてはいけません。 
このデータの先頭の 1 バイトには文字列の長さか255 のうち、小さい方の数が収められます。 
その後に文字列のバイトデータが続きます。 
pack() に渡された Pascal 文字列の長さが長すぎた (count-1よりも長い) 場合、先頭の count-1 バイトが書き込まれます。 
文字列がcount-1 よりも短い場合、指定した count バイトに達するまでの残りの部分はヌルで埋められます。 
NULL ポインタは常に Python 整数型の 0 になります。 
ポインタ型のサイズを持った値をパックする際には、Python 整数型 およびlong 整数型オブジェクトを使うことができます。 
バイトオーダ 
サイズおよびアラインメント 
ネイティブ 
標準 
リトルエンディアン 
ビッグエンディアン 
ネットワークバイトオーダ (= ビッグエンディアン) 
フォーマット文字列の最初の文字が上のいずれかでない場合、"@" であるとみなされます。 ネイティブのバイトオーダはビッグエンディアンかリトルエンディアンで、ホスト計算機に依存します。 
"=" を指定した場合、ホスト計算機のバイトオーダに基づいてリトルエンディアンとビッグエンディアンのどちらを使うかを決めます。 
struct モジュールはこの設定をネイティブのオーダ設定として解釈しないので、"P" を使うことはできません。 以下に例を示します (この例は全てビッグエンディアンのマシンで、ネイティブのバイトオーダ、サイズおよびアラインメントの場合です): 
ヒント: 特定の型によるアラインメント要求に従うように構造体の末端をそろえるには、count をゼロにした特定の型でフォーマットを終端します。 
例えば、フォーマット 'llh0l' は、 long 型が 4 バイトを境界としてそろえられていると仮定して、末端に 2 バイトをパディングします。 
この機能は変換対象がネイティブのサイズおよびアラインメントの場合にのみ働きます; 標準に型サイズおよびアラインメントの設定ではいかなるアラインメントも行いません。 
一様なデータ型からなるバイナリ記録データのパック. 
XDR データのパックおよびアンパック。 . 
6.8.1 subprocess モジュールを使う 
subprocess モジュールは、新しくプロセスを開始したり、それらの標準入出力/エラー出力に対してパイプで接続したり、それらの終了ステータスを取得したりします。 
このモジュールは以下のような古いいくつかのモジュールを置き換えることを目的としています: 
これらのモジュールや関数の代わりに、subprocess モジュールをどのように使うかについては以下の節で説明します。 
6.8.1.1 便利な関数 
6.8.1.2 例外 
6.8.1.3 セキュリティ 
6.8.3.1 /bin/sh シェルのバッククォートを置き換える 
6.8.3.2 シェルのパイプラインを置き換える 
6.8.3.3 os.system() を置き換える 
6.8.3.4 os.spawn* を置き換える 
6.8.3.5 os.popen* を置き換える 
6.8.3.6 popen2.* を置き換える 
sunauモジュールは、Sun AUサウンドフォーマットへの便利なインターフェースを提供します。 
このモジュールは、 
モジュールや 
モジュールと互換性のあるインターフェースを備えています。 オーディオファイルはヘッダとそれに続くデータから構成されます。 
ヘッダのフィールドは以下の通りです: 
4バイト文字列 ".snd"。 
infoを含むヘッダのサイズをバイト数で示したもの。 
データの物理サイズをバイト数で示したもの。 
オーディオサンプルのエンコード形式。 
サンプリングレート。 
サンプルのチャンネル数。 
オーディオファイルについての説明をASCII文字列で示したもの(null バイトで埋められます)。 
fileが文字列ならその名前のファイルを開き、そうでないならファイルのようにシーク可能なオブジェクトとして扱います。 modeは以下のうちのいずれかです。 
読み込みのみのモード。 
書き込みのみのモード。 
読み込み/書き込み両方のモードで開くことはできないことに注意して下さい。 'r'のmodeはAU_readオブジェクトを返し、'w'と'wb'のmodeはAU_writeオブジェクトを返します。 
open()と同義。 後方互換性のために残されています。 
sunauモジュールは以下の例外を定義しています: 
Sun AUの仕様や実装に対する不適切な操作により何か実行不可能となった時に発生するエラー。 
sunauモジュールは以下のデータアイテムを定義しています: 
big-endianで保存された正規のSun AUファイルは全てこの整数で始まります。 
これは文字列".snd"を整数に変換したものです。 
AUヘッダのencodingフィールドの値で、このモジュールでサポートしているものです。 
AUヘッダのencodingフィールドの値のうち既知のものとして追加されているものですが、このモジュールではサポートされていません。 
14.4.1 AU_read オブジェクト 
SunOSプラットフォームで利用できます。 
これは 
に付随するモジュールで、MIN_GAIN、MAX_GAIN、SPEAKERなどの便利なシンボル定数を定義しています。 
定数の名前はCのincludeファイルsun/audioio.hのものと同じで、初めの文字列 "AUDIO_"を除いたものです。 
このモジュールを使うと、Sunのオーディオインターフェースにアクセスできます。 
完全な説明文書はマニュアルページ 
audio(7I)にあります。 モジュール 
には、このモジュールで使われる定数が定義されています。 このモジュールには、以下の変数と関数が定義されています: 
この例外は、全てのエラーについて発生します。 
引数は誤りを説明する文字列です。 
この関数はオーディオデバイスを開き、Sunオーディオデバイスのオブジェクトを返します。 
こうすることで、オブジェクトがI/Oに使用できるようになります。 
パラメータmodeは次のうちのいずれか一つで、録音のみには'r'、再生のみには'w'、録音と再生両方には'rw'、コントロールデバイスへのアクセスには'control'です。 
レコーダーやプレーヤーには同時に1つのプロセスしかアクセスが許されていないので、必要な動作についてだけデバイスをオープンするのがいい考えです。 詳しくは 
audio(7I)を参照してください。 
マニュアルページにあるように、このモジュールは環境変数AUDIODEVの中のベースオーディオデバイスファイルネームを初めに参照します。 
見つからない場合は/dev/audioを参照します。 
コントロールデバイスについては、ベースオーディオデバイスに``ctl''を加えて扱われます。 
このモジュールは解析木の内部ノードの数値を表す定数を提供します。 
ほとんどのPython定数とは違い、これらは小文字の名前を使います。 
言語の文法のコンテキストにおける名前の定義については、PythonディストリビューションのファイルGrammar/Grammarを参照してください。 
名前がマップする特定の数値はPythonのバージョン間で変わります。 このモジュールには、データオブジェクトも一つ付け加えられています: 
ディクショナリはこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。 
:モジュール 
モジュールの二番目の例で、symbolモジュールの使い方を示しています。 . 
このモジュールでは、インタープリタで使用・管理している変数や、インタープリタの動作に深く関連する関数を定義しています。 このモジュールは常に利用可能です。 
Pythonスクリプトに渡されたコマンドライン引数のリスト。 argv[0]はスクリプトの名前となりますが、フルパス名かどうかは、オペレーティングシステムによって異なります。 
コマンドライン引数に-cを付けてPythonを起動した場合、argv[0]は文字列'-c'となります。 
引数なしでPythonを起動した場合、argvは長さ0のリストになります。 
プラットフォームのバイト順を示します。 
ビッグエンディアン(最上位バイトが先頭)のプラットフォームでは'big'、リトルエンディアン(最下位バイトが先頭)では'little'となります。 バージョン 2.0 で 新たに追加 された仕様です。 
コンパイル時にPythonインタープリタに組み込まれた、全てのモジュール名のタプル(この情報は、他の手段では取得することができません。 
Pythonインタープリタの著作権を表示する文字列。 
Python DLLのハンドルを示す整数。 利用可能: Windows 
valueがNone以外の場合、valueをsys.stdoutに出力して__builtin__._に保存します。 
sys.displayhookは、Pythonの対話セッションで入力された式が評価されたときに呼び出されます。 
対話セッションの出力をカスタマイズする場合、sys.displayhookに引数の数が一つの関数を指定します。 
) 指定したトレースバックと例外をsys.stderrに出力します。 
例外が発生し、その例外が捕捉されない場合、インタープリタは例外クラス・例外インスタンス・トレースバックオブジェクトを引数としてsys.excepthookを呼び出します。 
対話セッション中に発生した場合はプロンプトに戻る直前に呼び出され、Pythonプログラムの実行中に発生した場合はプログラムの終了直前に呼び出されます。 
このトップレベルでの例外情報出力処理をカスタマイズする場合、sys.excepthookに引数の数が三つの関数を指定します。 
それぞれ、起動時のdisplayhookとexcepthookの値を保存しています。 
この値は、displayhookとexcepthookに不正なオブジェクトが指定された場合に、元の値に復旧するために使用します。 
この関数は、現在処理中の例外を示す三つの値のタプルを返します。 
この値は、現在のスレッド・現在のスタックフレームのものです。 
現在のスタックフレームが例外処理中でない場合、例外処理中のスタックフレームが見つかるまで次々とその呼び出し元スタックフレームを調べます。 
例外が発生している場合、(type, value,traceback)を返します。 
exc_clear()が呼び出されると、現在のスレッドで他の例外が発生するか、又は別の例外を処理中のフレームに実行スタックが復帰するまで、exc_info()は三つのNoneを返します。 
警告:例外処理中に戻り値のtracebackをローカル変数に代入すると循環参照が発生し、関数内のローカル変数やトレースバックが参照している全てのオブジェクトは解放されなくなります。 
特にトレースバック情報が必要ではなければexctype, value = sys.exc_info()[:2]のように例外型と例外オブジェクトのみを取得するようにして下さい。 
もしトレースバックが必要な場合には、処理終了後にdeleteして下さい。 このdeleteは、try... finally ...で行うと良いでしょう。 
注意:Python 2.2 以降では、ガベージコレクションが有効であればこのような到達不能オブジェクトは自動的に削除されます。 しかし、循環参照を作らないようにしたほうが効率的です。 
この関数は、現在のスレッドで処理中、又は最後に発生した例外の情報を全てクリアします。 
この関数を呼び出すと、現在のスレッドで他の例外が発生するか、又は別の例外を処理中のフレームに実行スタックが復帰するまで、exc_info()は三つのNoneを返します。 この関数が必要となることは滅多にありません。 
ロギングやエラー処理などで最後に発生したエラーの報告を行う場合などに使用します。 
また、リソースを解放してオブジェクトの終了処理を起動するために使用することもできますが、オブジェクトが実際にされるかどうかは保障の限りではありません。 バージョン 2.3 で 新たに追加 された仕様です。 
リリース 1.5 で撤廃されました。 
例外処理中でない場合、exc_typeの値はNoneとなり、exc_valueとexc_tracebackは未定義となります。 
exec_prefix Pythonのプラットフォーム依存なファイルがインストールされているディレクトリ名(サイト固有)。 
デフォルトでは、この値は'/usr/local'ですが、ビルド時にconfigureの--exec-prefix引数で指定することができます。 
全ての設定ファイル(pyconfig.hなど)はexec_prefix + '/lib/pythonversion/config'に、共有ライブラリはexec_prefix + '/lib/pythonversion/lib-dynload'にインストールされます(但しversionはversion[:3])。 
Pythonインタープリタの実行ファイルの名前を示す文字列。 このような名前が意味を持つシステムでは利用可能。 
Pythonを終了します。 
exit()はSystemExitを送出するので、tryステートメントのfinally節に終了処理を記述したり、上位レベルで例外を捕捉してexit処理を中断したりすることができます。 
オプション引数argには、終了ステータスとして整数(デフォルトは0)または整数以外の型のオブジェクトを指定することができます。 
整数を指定した場合、シェル等は0は``正常終了''、0以外の整数を``異常終了''として扱います。 
多くのシステムでは、有効な終了ステータスは0-127で、これ以外の値を返した場合の動作は未定義です。 
システムによっては特定の終了コードに個別の意味を持たせている場合がありますが、このような定義は僅かしかありません。 Unixプログラムでは文法エラーの場合には2を、それ以外のエラーならば1を返します。 
argにNoneを指定した場合は、数値の0を指定した場合と同じです。 それ以外のオブジェクトを指定すると、そのオブジェクトがsys.stderrに出力され、終了コードをして1を返します。 
エラー発生時にはsys.exit("エラーメッセージ")と書くと、簡単にプログラムを終了することができます。 
この値はモジュールに存在しませんが、ユーザプログラムでプログラム終了時に呼び出される終了処理関数として、引数の数が0の関数を設定することができます。 
この関数は、インタープリタ終了時に呼び出されます。 
exitfuncに指定することができる終了処理関数は一つだけですので、複数のクリーンアップ処理が必要な場合は 
モジュールを使用してください。 
注意:プログラムがシグナルでkillされた場合,Python内部で致命的なエラーが発生した場合,os._exit()が呼び出された場合には,終了処理関数は呼び出されません。 
リリース 2.4 で撤廃されました。 
を使ってください. 
インタプリタの ``チェックインターバル (check interval)'' を返します; setcheckinterval() を参照してください。 バージョン 2.3 で 新たに追加 された仕様です。 
現在のUnicode処理のデフォルトエンコーディング名を返します。 バージョン 2.0 で 新たに追加 された仕様です。 
dlopen()で指定されるフラグを返します。 
このフラグは 
とDLFCNで定義されています。 利用可能: Unix.バージョン 2.2 で 新たに追加 された仕様です。 
Unicodeファイル名をシステムのファイル名に変換する際に使用するエンコード名を返します。 
システムのデフォルトエンコーディングを使用する場合にはNoneを返します。 
Windows 9xでは、エンコーディングは ``mbcs'' となります。 
OS Xでは、エンコーディングは ``utf-8'' となります。 
Unixでは、エンコーディングはユーザのnl_langinfo(CODESET)の設定となります。 nl_langinfo(CODESET)が失敗するとNoneを返します。 
Windows NT+では、Unicodeをファイル名として使用できるので変換の必要はありません。 getfilesystemencoding は ``mbcs''を返しますが,これはある Unicode 文字列をバイト文字列に明示的に変換して,ファイル名として使うと同じファイルを指すようにしたい場合に,アプリケーションが使わねばならないエンコーディングです. 
objectの参照数を返します。 
objectは(一時的に)getrefcount()からも参照されるため、参照数は予想される数よりも1多くなります。 
現在の最大再帰数を返します。 
最大再帰数は、Pythonインタープリタスタックの最大の深さです。 
この制限はPythonプログラムが無限に再帰し、Cスタックがオーバーフローしてクラッシュすることを防止するために設けられています。 
この値はsetrecursionlimit()で指定することができます。 
コールスタックからフレームオブジェクトを取得します。 
オプション引数depthを指定すると、スタックのトップからdepthだけ下のフレームオブジェクトを取得します。 
depthがコールスタックよりも深ければ、ValueErrorが発生します。 
depthのデフォルト値は0で、この場合はコールスタックのトップのフレームを返します。 この関数は、内部的な、特殊な用途にのみ利用することができます。 
実行中のWindowsのバージョンを示す、以下の値のタプルを返します:major, minor, build, platform, text。 
textは文字列、それ以外の値は整数です。 
platformは、以下の値となります: 
整数にエンコードされたバージョン番号。 
この値は新バージョン(正規リリース以外であっても)ごとにかならず増加します。 
例えば、Python 1.5.2以降でのみ動作するプログラムでは、以下のようなチェックを行います。 
"hexversion"はhex()で16進数に変換しなければ値の意味がわかりません。 
より読みやすいバージョン番号が必要な場合にはversion_infoを使用してください。 
通常は定義されておらず、捕捉されない例外が発生してインタープリタがエラーメッセージとトレースバックを出力した場合にのみ設定されます。 
この値は、対話セッション中にエラーが発生したとき、デバッグモジュールをロード(例:"import pdb; pdb.pm()"など。 
対話セッションを実行するスレッドは常に一つだけなので、exc_typeのようにスレッドに関する問題は発生しません。 
Pythonの整数型でサポートされる、最大の整数。 
この値は最低でも2**31-1です。 
最大の負数は-maxint-1となります。 正負の最大数が非対称ですが、これは2の補数計算を行うためです。 
Unicode文字の最大のコードポイントを示す整数。 
この値は、オプション設定でUnicode文字の保存形式としてUSC-2とUCS-4のいずれを指定したかによって異なります。 
ロード済みモジュールのモジュール名とモジュールオブジェクトの辞書。 
強制的にモジュールを再読み込みする場合などに使用します。 
この辞書からモジュールを削除するのは、reload() 
の呼び出しと等価ではありません。 
スクリプトのディレクトリがない(インタープリタで対話セッションで起動された時や、スクリプトを標準入力から読み込む場合など)場合、path[0]には空文字列となり、Pythonはカレントディレクトリからモジュールの検索を開始します。 
スクリプトディレクトリは、PYTHONPATHで指定したディレクトリの前に挿入されますので注意が必要です。 必要に応じて、プログラム内で自由に変更することができます。 
バージョン 2.3 で 変更 された仕様:Unicode 文字列が無視されなくなりました 
プラットフォームを識別する文字列(例: 'sunos5', 'linux1'等)。 
pathにプラットフォーム別のサブディレクトリを追加する場合などに利用します。 
サイト固有の、プラットフォームに依存しないファイルを格納するディレクトリを示す文字列。 デフォルトでは'/usr/local'になります。 
この値はビルド時にconfigureスクリプトの--prefix引数で指定する事ができます。 
Pythonライブラリの主要部分はprefix + '/lib/pythonversion'にインストールされ、プラットフォーム非依存なヘッダファイル(pyconfig.h以外)はprefix + '/include/pythonversion'に格納されます(但しversionはversion[:3])。 
インタープリタの一次プロンプト、二次プロンプトを指定する文字列。 
対話モードで実行中のみ定義され、初期値は' 'と'... 'です。 
文字列以外のオブジェクトを指定した場合、インタープリタが対話コマンドを読み込むごとにオブジェクトのstr()を評価します。 
この機能は、動的に変化するプロンプトを実装する場合に利用します。 
インタープリタの``チェック間隔''を示す整数値を指定します。 
この値はスレッドスイッチやシグナルハンドラのチェックを行う周期を決定します。 
デフォルト値は100で、この場合 100 の仮想命令を実行するとチェックを行います。 この値を大きくすればスレッドを利用するプログラムのパフォーマンスが向上します。 
この値が=0以下の場合、全ての仮想命令を実行するたびにチェックを行い、レスポンス速度と最大になりますがオーバヘッドもまた最大となります。 
現在のUnicode処理のデフォルトエンコーディング名を設定します。 
nameに一致するエンコーディングが見つからない場合、LookupErrorが発生します。 
この関数は、 
モジュールの実装が、sitecustomizeモジュールから使用するためだけに定義されています。 
から呼び出された後、この関数はsysから削除されます。 バージョン 2.0 で 新たに追加 された仕様です。 
インタープリタが拡張モジュールをロードする時、dlopen()で使用するフラグを設定します。 
sys.setdlopenflags(0)とすれば、モジュールインポート時にシンボルの遅延解決を行う事ができます。 
シンボルを拡張モジュール間で共有する場合には、sys.setdlopenflags(dl.RTLD_NOW | dl.RTLD_GLOBAL)と指定します。 
フラグの定義名は 
かDLFCNで定義されています。 
DLFCNが存在しない場合、h2pyスクリプトを使って/usr/include/dlfcn.hから生成することができます。 利用可能: Unix.バージョン 2.2 で 新たに追加 された仕様です。 
システムのプロファイル関数を登録します。 
プロファイル関数は、Pythonのソースコードプロファイルを行う関数で、Pythonで記述することができます。 
詳細は10を参照してください。 
プロファイル関数はトレース関数(settrace()参照)と似ていますが、ソース行が実行されるごとに呼び出されるのではなく、関数の呼出しと復帰時のみ呼び出されます(例外が発生している場合でも、復帰時のイベントは発生します)。 
Pythonインタープリタの、スタックの最大の深さをlimitに設定します。 
この制限はPythonプログラムが無限に再帰し、Cスタックがオーバーフローしてクラッシュすることを防止するために設けられています。 
limitの最大値はプラットフォームによって異なります。 
深い再帰処理が必要な場合にはプラットフォームがサポートしている範囲内でより大きな値を指定することができますが、この値が大きすぎればクラッシュするので注意が必要です。 
システムのトレース関数を登録します。 
トレース関数はPythonのソースデバッガを実装するために使用することができます。 
9.2の``How It Works,''を参照してください。 
トレース関数はスレッド毎に設定することができますので、デバッグを行う全てのスレッドでsettrace()を呼び出し、トレース関数を登録してください。 
注意: settrace() 関数は,デバッガ,プロファイラ,カバレッジツール等で使うためだけのものです.この関数の挙動は言語定義よりも実装プラットフォームの分野の問題で,全ての Python 実装で利用できるとは限りません. 
インタープリタの標準入力・標準出力・標準エラー出力に対応するファイルオブジェクト。 stdinはスクリプトの読み込みを除く全ての入力処理で使用され、input() 
インタープリタのプロンプトは(ほとんど)stderrに出力されます。 stdoutとstderrは必ずしも組み込みのファイルオブジェクトである必要はなく、write()メソッドを持つオブジェクトであれば使用することができます。 
stdoutとstderrを別のオブジェクトに置き換えても、os.popen()・os.system() ・ 
のexec*()などから起動されたプロセスが使用する標準I/Oストリームは変更されません。 
それぞれ起動時のstdin・stderr・stdoutの値を保存します。 
終了処理時や、不正なオブジェクトが指定された場合に元の値に復旧するために使用します。 
捕捉されない例外が発生した時、出力されるトレースバック情報の最大レベル数を指定する整数値(デフォルト値は1000)。 
0以下の値が設定された場合、トレースバック情報は出力されず例外型と例外値のみが出力されます。 
Pythonインタープリタのバージョンとビルド番号・使用コンパイラなどの情報を示す文字列で、'バージョン(#ビルド番号,ビルド日付, ビルド時間)[コンパイラ]'となります。 
先頭の三文字は、バージョンごとのインストール先ディレクトリ内を識別するために使用されます。 
例: 
使用中のインタープリタのC APIバージョン。 
Pythonと拡張モジュール間の不整合をデバッグする場合などに利用できます。 
バージョン番号を示す5つの値のタプル:major, minor,micro, releaselevel, serial releaselevel以外は全て整数です。 
releaselevelの値は、'alpha', 'beta','candidate', or 'final'の何れかです。 Python 2.0のversion_infoは、(2, 0, 0, 'final', 0)となります。 
バージョン 2.0 で 新たに追加 された仕様です。 
を参照してください。 
Windowsプラットフォームで、レジストリのキーとなるバージョン番号。 Python DLLの文字列リソース 1000に設定されています。 
通常、この値はversionの先頭三文字となります。 
このモジュールでは Unix syslog ライブラリルーチン群へのインタフェースを提供します。 
syslog の便宜レベルに関する詳細な記述は Unix マニュアルページを参照してください。 このモジュールでは以下の関数を定義しています: 
文字列 message をシステムログ機構に送信します。 
末尾の改行文字は必要に応じて追加されます。 
各メッセージは facility およびlevel からなる優先度でタグ付けされます。 
オプションのpriority 引数はメッセージの優先度を定義します。 標準の値は LOG_INFO です。 
priority 中に、便宜レベルが (LOG_INFO | LOG_USER のように) 論理和を使ってコード化されていない場合、openlog() を呼び出した際の値が使われます。 
標準以外のログオプションは、syslog() の呼び出しに先立ってopenlog() でログファイルを開く際、明示的に設定することができます。 
標準の値は (通常) indent = 'syslog'、logopt = 0、facility = LOG_USER です。 
ident 引数は全てのメッセージの先頭に付加する文字列です。 
オプションの logopt 引数はビットフィールドの値になります -とりうる組み合わせ値については以下を参照してください。 
オプションの facility 引数は、便宜レベルコードの設定が明示的になされていないメッセージに対する、標準の便宜レベルを設定します。 
ログファイルを閉じます。 
優先度マスクを maskpri に設定し、以前のマスク値を返します。 
maskpri に設定されていない優先度レベルを持った syslog()の呼び出しは無視されます。 
標準では全ての優先度をログ出力します。 
関数 LOG_MASK(pri) は個々の優先度 pri に対する優先度マスクを計算します。 
関数 LOG_UPTO(pri) は優先度pri までの全ての優先度を含むようなマスクを計算します。 
このモジュールでは以下の定数を定義しています: 
優先度 (高い優先度順): 
LOG_EMERG、 LOG_ALERT、 LOG_CRIT、LOG_ERR、 LOG_WARNING、 LOG_NOTICE、LOG_INFO、 LOG_DEBUG。 
便宜レベル: 
LOG_KERN、 LOG_USER、 LOG_MAIL、LOG_DAEMON、 LOG_AUTH、 LOG_LPR、LOG_NEWS、 LOG_UUCP、 LOG_CRON、およびLOG_LOCAL0 から LOG_LOCAL7。 
ログオプション: 
syslog.h で定義されている場合、LOG_PID、 LOG_CONS、 LOG_NDELAY、LOG_NOWAIT、および LOG_PERROR。 
差し当たり、このモジュールはスクリプトとして呼び出すことを意図しています。 しかし、IDE上にインポートして下で説明する関数check()を使うことができます。 
警告:このモジュールが提供するAPIを将来のリリースで変更する確率が高いです。 このような変更は後方互換性がないかもしれません。 
file_or_dirがディレクトリであってシンボリックリンクでないときに、file_or_dirという名前のディレクトリツリーを再帰的に下って行き、この通り道に沿ってすべての.pyファイルを変更します。 
file_or_dirが通常のPythonソースファイルの場合には、問題のある空白をチェックします。 
診断メッセージはprint文を使って標準出力に書き込まれます。 
冗長なメッセージをプリントするかどうかを示すフラグ。 スクリプトとして呼び出された場合は、-vオプションによって増加します。 
スクリプトとして呼び出された場合は、-qオプションによって真に設定されます。 
あいまいなインデントを検出した場合にtokeneater()によって発生させられます。 check()で捕捉され処理されます。 
この関数は関数tokenize.tokenize()へのコールバックパラメータとしてcheck()によって使われます。 
Pythonソースコードの字句解析器。 . 
tarfile モジュールは、tar アーカイブを読んで作成することができるようにします。 いくつかの事実と外観: 
gzip と bzip2 で圧縮されたアーカイブを読み書きします。 
POSIX 1003.1-1990 準拠あるいは GNU tar 互換のアーカイブを作成します。 
GNU tar 拡張機能 長い名前、 longlink およびsparse を読みます。 
GNU tar 拡張機能を使って、無制限長さのパス名を保存します。 
ディレクトリ、普通のファイル、ハードリンク、シンボリックリンク、fifo、キャラクタデバイスおよびブロックデバイスを処理します。 また、タイムスタンプ、アクセス許可およびオーナーのようなファイル情報の取得および保存が可能です。 
テープデバイスを取り扱うことができます。 
パス名 nameに TarFile オブジェクトを返します。 TarFile オブジェクトに関する詳細な情報については、TarFile オブジェクト (セクション 7.19.1)を見て下さい。 
mode は 'filemode[:compression]' の形式をとる文字列でなければなりません.デフォルトの値は 'r' です.以下にmodeのとりうる組み合わせ全てを示します. 
動作 
透過な圧縮つきで読み込むためにオープンします(推奨)。 
圧縮なしで排他的に読み込むためにオープンします。 
gzip 圧縮で読み込むためにオープンします。 
bzip2 圧縮で読み込むためにオープンします。 
'a' または 'a:' 
圧縮なしで追加するためにオープンします。 
'w' または 'w:' 
非圧縮で書き込むためにオープンします。 
gzip 圧縮で書き込むためにオープンします。 
bzip2 圧縮で書き込むためにオープンします。 
'a:gz' あるいは 'a:bz2'は可能ではないことに注意して下さい。 もし modeが、ある(圧縮した)ファイルを読み込み用にオープンするのに、適していないなら、ReadErrorが発生します。 
これを防ぐにはmode 'r' を使って下さい。 
もし圧縮メソッドがサポートされていなければ、CompressionError が発生します。 もし fileobjが指定されていれば、それは nameでオープンされたファイルオブジェクトの代替として使うことができます。 
特別な目的のために、modeの2番目の形式:'ファイルモード|[圧縮]' があります。 
この形式を使うと,openが返すのはデータをブロックからなるストリームとして扱うTarFile オブジェクトになります.この場合,ファイルに対してランダムな seek を行えなくなります.fileobj を指定する場合,read()およびwrite() メソッドを持つ任意のオブジェクトにできます.bufsize にはブロックサイズを指定します.デフォルトは20 * 512 バイトです。 
sys.stdin ,ソケットファイルオブジェクト,テーブデバイスと組み合わせる場合にはこの形式を使ってください.ただし,このようなTarFile オブジェクトにはランダムアクセスを行えないという制限があります.例 (セクション 7.19.3)を参照してください。 
現在可能なモードは: 
モード 
非圧縮 tar ブロックの ストリーム を読み込みにオープンします。 
gzip 圧縮 ストリームを読み込みにオープンします。 
bzip2 圧縮 ストリーム を読み込みにオープンします。 
非圧縮 ストリームを書き込みにオープンします。 
gzip 圧縮 ストリーム を書き込みにオープンします。 
bzip2 圧縮 ストリームを書き込みにオープンします。 
tar アーカイブを読んだり、書いたりするためのクラスです。 
このクラスを直接使わず,代わりに open() を使ってください.TarFile オブジェクト (7.19.1 節) を参照してください. 
もし nameが tar アーカイブファイルであり,tarfileモジュールで読み出せる場合にTrueを返します. 
クラスTarFileCompat 
非圧縮 tar アーカイブのための定数。 
圧縮 tar アーカイブのための定数。 
すべての tarfile 例外のための基本クラスです。 
tar アーカイブがオープンされた時、tarfile モジュールで操作できないか、あるいは何か無効であるとき発生します。 
圧縮方法がサポートされていないか、あるいはデータを正しくデコードできない時に発生します。 
ストリーム風の TarFile オブジェクトで典型的な制限のために発生します。 
extract()を使った時、もしTarFile.errorlevel 
== 2の フェータルでない エラーに対してだけ発生します。 
参考: zipfile 
標準モジュールのドキュメント。 
GNU tar マニュアル、標準セクション 
GNU tar 拡張機能を含む、tar アーカイブファイルのためのドキュメント。 
7.19.1 TarFile オブジェクト 
telnetlib モジュールでは、Telnet プロトコルを実装しているTelnet クラスを提供します。 
Telnet プロトコルについての詳細はRFC 854 を参照してください。 
加えて、このモジュールでは Telnetプロトコルにおける制御文字 (下を参照してください) と、telnet オプションに対するシンボル定数を提供しています。 
telnet オプションに対するシンボル名は arpa/telnet.h の TELOPT_ がない状態での定義に従います。 
伝統的に arpa/telnet.h に含められていない telnet オプションのシンボル名については、このモジュールのソースコード自体を参照してください。 telnet コマンドのシンボル定数は、IAC、DONT、DO、WONT、WILL、SE(サブネゴシエーション終了)、NOP (何もしない)、DM (データマーク)、BRK (ブレーク)、IP (プロセス割り込み)、AO (出力中断)、AYT (応答確認)、EC (文字削除)、EL (行削除)、GA (進め)、SB (サブネゴシエーション開始) です。 
クラスTelnet 
Telnet は Telnet サーバへの接続を表現します。 
標準では、Telnet クラスのインスタンスは最初はサーバに接続していません; 接続を確立するには open() を使わなければなりません。 
詳しくは下記の個々の説明を参照してください。 
RFC 854, Telnet プロトコル仕様 (Telnet Protocol Specification) 
Telnet プロトコルの定義。 
11.14.1 Telnet オブジェクト 
6.21.4.9 コールバックの例6: 可変個の引数 
このモジュールを使うと、一時的なファイルやディレクトリを生成できます。 
このモジュールはサポートされている全てのプラットフォームで利用可能です。 バージョン 2.3 の Python では、このモジュールに対してセキュリティを高める為の見直しが行われました。 
現在では新たに 3 つの関数、NamedTemporaryFile()、 mkstemp()、およびmkdtemp() が提供されており、安全でない mktemp を使いつづける必要をなくしました。 
このモジュールで生成される一時ファイルはもはやプロセス番号を含みません; その代わり、6 桁のランダムな文字からなる文字列が使われます。 また、ユーザから呼び出し可能な関数は全て、一時ファイルの場所や名前を直接操作できるようにするための追加の引数をとるようになりました。 
もはや変数 tempdir および template を使う必要はありません。 
以前のバージョンとの互換性を維持するために、引数の順番は多少変です; 明確さのためにキーワード引数を使うことをお勧めします。 このモジュールではユーザから呼び出し可能な以下の関数を定義しています: 
一時的な記憶領域として使うことができるファイル (またはファイル類似の) オブジェクトを返します。 
ファイルは mkstemp を使って生成されます。 
このファイルは閉じられると (オブジェクトがガーベジコレクションされた際に、暗黙のうちに閉じられる場合を含みます)すぐに消去されます。 
Unix環境では、ファイルが生成されるとすぐにそのファイルのディレクトリエントリは除去されてしまいます。 
一方、他のプラットフォームではこの機能はサポートされていません; 従って、コードを書くときには、この関数で作成した一時ファイルをファイルシステム上で見ることができる、あるいはできないということをあてにすべきではありません。 生成されたファイルを一旦閉じなくてもファイルを読み書きできるようにするために、mode パラメタは標準で 'w+b' に設定されています。 
この関数はファイルがファイルシステム上で見ることができるよう保証されている点を除き、TemporaryFile() と全く同じに働きます。 
(Unixでは、ディレクトリ エントリはunlinkされません)ファイル名はファイルオブジェクトの name メンバから取得することができます。 
可能な限り最も安全な手段で一時ファイルを生成します。 
使用するプラットフォームでos.open() の O_EXCLフラグが正しく実装されている限り、ファイルの生成で競合条件が起こることはありません。 
このファイルは、ファイルを生成したユーザのユーザID からのみ読み書き可能です。 
使用するプラットフォームにおいて、ファイルを実行可能かどうかを示す許可ビットが使われている場合、ファイルは誰からも実行不可なように設定されます。 
mkstemp() は開かれたファイルを扱うための OS レベルの値とファイルの絶対パス名が順番に並んだタプルを返します。 
バージョン 2.3 で 新たに追加 された仕様です。 
可能な限り安全な方法で一時ディレクトリを作成します。 ディレクトリの生成で競合条件は発生しません。 
mkdtemp() は新たに生成されたディレクトリの絶対パス名を返します。 
バージョン 2.3 で 新たに追加 された仕様です。 mkdtemp 
リリース 2.3 で撤廃されました。 Use mkstemp() instead. 
一時ファイルの絶対パス名を返します。 このパス名は少なくともこの関数が呼び出された時点ではファイルシステム中に存在しなかったパス名です。 
prefix、prefix、 suffix、および dir引数は mkstemp() のものと同じです。 
警告:この関数を使うとプログラムのセキュリティホールになる可能性があります。 
この関数が返したファイル名を返した後、あなたがそのファイル名を使って次に何かをしようとする段階に至る前に、誰か他の人間があなたにパンチをくらわせてしまうかもしれません。 
このモジュールでは、一時的なファイル名の作成方法を指定する 2 つのグローバル変数を使います。 
これらの変数は上記のいずれかの関数を最初に呼び出した際に初期化されます。 
関数呼び出しをおこなうユーザはこれらの値を変更することができますが、これはお勧めできません;その代わりに関数に適切な引数を指定してください。 
この値が None 以外に設定された場合、このモジュールで定義されている関数全てのdir 引数に対する標準の設定値となります。 tempdir が設定されていないか None の場合、上記のいずれかの関数を呼び出した際は常に、Python は標準的なディレクトリ候補のリストを検索し、関数を呼び出しているユーザの権限でファイルを作成できる最初のディレクトリ候補を tempdir に設定します。 
リストは以下のようになっています: 
環境変数 TMPDIR で与えられているディレクトリ名。 
環境変数 TEMP で与えられているディレクトリ名。 
環境変数 TMP で与えられているディレクトリ名。 
プラットフォーム依存の場所: 
Macintosh では Temporary Items フォルダ。 
RiscOS では環境変数 Wimp$ScrapDir で与えられているディレクトリ名。 
その他の全てのプラットフォームでは、/tmp、/var/tmp、および /usr/tmp の順。 
最後の手段として、現在の作業ディレクトリ。 
現在選択されている、テンポラリファイルを作成するためのディレクトリを返します。 tempdir が None でない場合、単にその内容を返します; そうでない場合には上で記述されている検索が実行され、その結果が返されます。 
リリース 2.0 で撤廃されました。 代わりに gettempprefix() を使ってください。 
この値に None 以外の値を設定した場合、mktemp()が返すファイル名のディレクトリ部を含まない先頭部分 (プレフィクス) を定義します。 
ファイル名を一意にするために、 6 つのランダムな文字および数字がこのプレフィクスの後に追加されます。 
Windows では、標準のプレフィクスは~T です; 他のシステムではtmp です。 
このモジュールの古いバージョンでは、os.fork() を呼び出した後に template を None に設定することが必要でした; この仕様はバージョン 1.5.2 からは必要なくなりました。 
一時ファイルを生成する際に使われるファイル名の先頭部分を返します。 
この先頭部分にはディレクトリ部は含まれません。 
変数 template を直接読み出すよりもこの関数を使うことを勧めます。 バージョン 1.5.2 で 新たに追加 された仕様です。 
このモジュールでは端末 I/O 制御のための POSIX 準拠の関数呼び出しインタフェースを提供します。 
これら呼び出しのための完全な記述については、POSIX または Unix マニュアルページを参照してください。 
POSIX termios 形式の端末制御をサポートする Unix のバージョンで (かつインストール時に指定した場合に) のみ利用可能です。 このモジュールの関数は全て、ファイル記述子 fd を最初の引数としてとります。 
ファイル記述子 fd の端末属性を含むリストを返します。 その形式は:[ 
端末設定フラグおよび端末速度の解釈、および配列 cc のインデクス検索は、termios で定義されているシンボル定数を使って行わなければなりません。 
ファイル記述子 fd の端末属性を attributes から取り出して設定します。 attributes は tcgetattr() が返すようなリストです。 
引数 when は属性がいつ変更されるかを決定します:TCSANOW は即時変更を行い、TCSAFLUSH は現在キューされている出力を全て転送し、全てのキューされている入力を無視した後に変更を行います。 
ファイル記述子 fd にブレークを送信します。 
duration をゼロにすると、 0.25-0.5 秒間のブレークを送信します; duration の値がゼロでない場合、その意味はシステム依存です。 
ファイル記述子 fd に書き込まれた全ての出力が転送されるまで待ちます。 
ファイル記述子 fd にキューされたデータを無視します。 
どのキューかはqueue セレクタで指定します: TCIFLUSH は入力キュー、 TCOFLUSH は出力キュー、TCIOFLUSH は両方のキューです。 
ファイル記述子 fd の入力または出力をサスペンドしたりレジュームしたりします。 
引数 action は出力をサスペンドする TCOOFF、出力をレジュームする TCOON 、入力をサスペンドするTCIOFF 、入力をレジュームする TCION をとることができます。 
一般的な端末制御操作のための便利な関数。 
5.4.1 testパッケージのためのユニットテストを書く 
test パッケージには、Python 用の全ての回帰テストと、test.test_supportおよびtest.regrtest モジュールが入っています。 
test.test_support はテストを充実させるために使い、test.regtest はテストスイートを駆動するのに使います。 
testパッケージ内の各モジュールのうち、名前が"test_"で始まるものは、特定のモジュールや機能に対するテストスイートです。 
新しいテストはすべてunittestモジュールを使って書くようにしてください; 必ずしもunittest を使う必要はないのですが、unittest はテストをより柔軟にし、メンテナンスをより簡単にします。 
古いテストのいくつかはdoctest を利用しており、``伝統的な'' テスト形式になっています。 
これらのテスト形式をカバーする予定はありません。 
PyUnit 回帰テストを書く。 
ドキュメンテーション文字列に埋め込まれたテスト。 
5.4.2 test.regrtestを使ってテストを実行する 5.4.3 test.test_support --テストのためのユーティリティ関数 
5.4.2 test.regrtestを使ってテストを実行する 
5.4.3 test.test_support --テストのためのユーティリティ関数 test.test_support モジュールでは、 Python の回帰テストに対するサポートを提供しています。 
このモジュールは次の例外を定義しています: 
テストが失敗したとき送出される例外です。 
test.test_support モジュールでは、以下の定数を定義しています: 
冗長な出力が有効な場合はTrue です。 実行中のテストについてのより詳細な情報が欲しいときにチェックします。 
verbose は test.regrtest によって設定されます。 
have_unicode ユニコードサポートが利用可能ならばTrue になります。 
実行中のインタプリタが Jython ならばTrue になります。 
一時ファイルを作成するパスに設定されます。 作成した一時ファイルは全て閉じ、unlink (削除) せねばなりません。 
test.test_support モジュールでは、以下の関数を定義しています: 
モジュール名module_nameをsys.modulesから取り除き、モジュールのバイトコンパイル済みファイルを全て削除します。 
resource が有効で利用可能ならばTrueを返します。 利用可能なリソースのリストは、test.regrtestがテストを実行している間のみ設定されます。 
resource が利用できなければ、ResourceDeniedを送出します。 
filenameという名前のファイルへのパスを返します。 
渡された unittest.TestCase サブクラスを実行します。 この関数は名前が "test_" で始まるメソッドを探して、テストを個別に実行します。 
この方法をテストの実行方法として推奨しています。 run_suite 
unittest.TestSuite のインスタンス suiteを実行します。 オプション引数testclass はテストスイート内のテストクラスの一つを受け取り、指定するとテストスイートが存在する場所についてさらに詳細な情報を出力します。 
textwrapモジュールでは、二つの簡易関数wrap()とfill()、そして作業のすべてを行うクラスTextWrapperとユーティリティ関数 dedent() を提供しています。 
単に一つや二つのテキスト文字列の折り返しまたは詰め込みを行っているならば、簡易関数で十分間に合います。 そうでなければ、効率のためにTextWrapperのインスタンスを使った方が良いでしょう。 
text(文字列)内の段落を一つだけ折り返しを行います。 したがって、すべての行が高々width文字の長さになります。 
text内の段落を一つだけ折り返しを行い、折り返しが行われた段落を含む一つの文字列を返します。 fill()は 
"\n".join(wrap(text, ...)) の省略表現です。 
特に、fill()はwrap()とまったく同じ名前のキーワード引数を受け取ります。 
wrap()とfill()の両方ともがTextWrapperインスタンスを作成し、その一つのメソッドを呼び出すことで機能します。 
クラスTextWrapper 
TextWrapperコンストラクタはたくさんのオプションのキーワード引数を受け取ります。 
それぞれの引数は一つのインスタンス属性に対応します。 したがって、例えば、 
と同じです。 
あなたは同じTextWrapperオブジェクトを何回も再利用できます。 
また、使用中にインスタンス属性へ代入することでそのオプションのどれでも変更できます。 
TextWrapperインスタンス属性(とコンストラクタのキーワード引数)は以下の通りです: 
(デフォルト: 70) 折り返しが行われる行の最大の長さ。 
入力行にwidthより長い単一の語が無い限り、TextWrapperはwidth文字より長い出力行が無いことを保証します。 
(デフォルト: True) もし真ならば、そのときはtext内のすべてのタブ文字はtextのexpand_tabs()メソッドを用いて空白に展開されます。 
(デフォルト: True) もし真ならば、タブ展開の後に残る(string.whitespaceに定義された)空白文字のそれぞれが一つの空白と置き換えられます。 
(デフォルト: '') 折り返しが行われる出力の一行目の先頭に付けられる文字列。 
一行目の折り返しの長さになるまで含められます。 
(デフォルト: '') 一行目以外の折り返しが行われる出力のすべての行の先頭に付けられる文字列。 
一行目以外の各行が折り返しの長さまで含められます。 
(デフォルト: False) もし真ならば、TextWrapperは文の終わりを見つけようとし、確実に文がちょうど二つの空白で常に区切られているようにします。 
これは一般的に固定スペースフォントのテキストに対して望ましいです。 
しかし、文の検出アルゴリズムは完全ではありません: 文の終わりには、後ろに空白がある"."、"!"または"?"の中の一つ、ことによると"""あるいは"'"が付随する小文字があると仮定しています。 
これに伴う一つの問題は 
の``Dr.''と 
の``Spot.''の間の差異を検出できないアルゴリズムです。 
fix_sentence_endingsはデフォルトで偽です。 
文検出アルゴリズムは``小文字''の定義のためにstring.lowercaseに依存し、同一行の文を区切るためにピリオドの後に二つの空白を使う慣習に依存しているため、英文テキストに限定されたものです。 
(デフォルト: True) もし真ならば、そのときwidthより長い行が確実にないようにするために、widthより長い語は切られます。 
偽ならば、長い語は切られないでしょう。 そして、widthより長い行があるかもしれません。 
(widthを超える分を最小にするために、長い語は単独で一行に置かれるでしょう。 ) 
TextWrapperはモジュールレベルの簡易関数に類似した二つの公開メソッドも提供します: 
text(文字列)内の段落を一つだけ折り返しを行います。 したがって、すべての行は高々width文字です。 
すべてのラッピングオプションはTextWrapperインスタンスのインスタンス属性から取られています。 最後に改行の無い出力された行のリストを返します。 
text内の段落を一つだけ折り返しを行い、折り返しが行われた段落を含む一つの文字列を返します。 
このモジュールはマルチスレッド(別名 軽量プロセス(light-weight processes)またはタスク(tasks))に用いられる低レベルプリミティブを提供します-- グローバルデータ空間を共有するマルチスレッドを制御します。 
同期のための単純なロック(別名 mutexesまたはバイナリセマフォ(binary semaphores))が提供されています。 
このモジュールはオプションです。 
Windows, Linux, SGI IRIX, Solaris 2.x、そして同じようなPOSIXスレッド(別名``pthread'')実装のシステム上でサポートされます。 
threadを使用することのできないシステムでは、 
はこのモジュールと同じインターフェースを持ち、置き換えて使用することができます。 
定数と関数は以下のように定義されています: 
スレッド特有のエラーで送出されます。 
これはロックオブジェクトのタイプです。 
新しいスレッドを開始して、そのIDを返します。 
スレッドは引数リストargs(タプルでなければなりません)の関数functionを実行します。 
オプション引数kwargsはキーワード引数の辞書を指定します。 関数が戻るとき、スレッドは黙って終了します。 
サブスレッドはこの関数を使ってメインスレッドに割り込みをかけることができます。 バージョン 2.3 で 新たに追加 された仕様です。 
SystemExit例外を送出します。 
それが捕えられないときは、黙ってスレッドを終了させます。 
新しいロックオブジェクトを返します。 
ロックのメソッドはこの後に記述されます。 
ロックは初期状態としてアンロック状態です。 
現在のスレッドの`スレッドID'を返します。 
これは0でない整数です。 
この値は直接の意味を持っていません;例えばスレッド特有のデータの辞書に索引をつけるためのような、マジッククッキーとして意図されています。 
スレッドが終了し、他のスレッドが作られたとき、スレッドIDは再利用されるかもしれません。 
ロックオブジェクトは次のようなメソッドを持っています: 
オプションの引数なしで使用すると、このメソッドは他のスレッドがロックしているかどうかにかかわらずロックを獲得し、None を返します。 
ただし他のスレッドがすでにロックしている場合には解除されるまで待ってからロックを獲得します (同時にロックを獲得できるスレッドはひとつだけであり、これこそがロックの存在理由です)。 
なお、引数を与えた場合、ロックを獲得するとTrue、できなかったときには False を返します。 
ロックを解放します。 
そのロックは既に獲得されたものでなければなりませんが、しかし同じスレッドによって獲得されたものである必要はありません。 
ロックの状態を返します: 同じスレッドによって獲得されたものならTrue、違うのならFalseを返します。 
スレッドは割り込みと奇妙な相互作用をします:KeyboardInterrupt例外は任意のスレッドによって受け取られます。 
モジュールが利用可能なとき、割り込みは常にメインスレッドへ行きます。 
) sys.exit()を呼び出す、あるいはSystemExit例外を送出することは、exit()を呼び出すことと同じです。 
I/O待ちをブロックするかもしれない全ての組込み関数が、他のスレッドの走行を許すわけではありません。 
(ほとんどの一般的なもの (time.sleep(), 
file.read(),select.select())は期待通りに働きます。 ) 
ロックのacquire()メソッドに割り込むことはできません-- KeyboardInterrupt例外は、ロックが獲得された後に発生します。 
メインスレッドが終了したとき、他のスレッドが生き残るかどうかは、システムが定義します。 
ネイティブスレッド実装を使うSGI IRIXでは生き残ります。 
その他の多くのシステムでは、try ... finally節を実行せずに殺されたり、デストラクタを実行せずに殺されたりします。 
メインスレッドが終了したとき、それの通常のクリーンアップは行なわれず(try ... finally節が尊重されることは除きます)、標準I/Oファイルはフラッシュされません。 
このモジュールでは、高水準のスレッドインタフェースをより低水準な 
モジュールの上に構築しています。 
また、 
現在のアクティブなThreadオブジェクトの数を返します。 この数は enumerate() の返すリストの長さと同じです。 
新しい条件変数 (condition variable) オブジェクトを返すファクトリ関数です。 条件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで待機させられます。 
関数を呼び出している処理のスレッドに対応する Thread オブジェクトを返します。 
関数を呼び出している処理のスレッドが threading モジュールで生成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクトを返します。 
現在アクティブな Thread オブジェクト全てのリストを返します。 リストには、デーモンスレッド (daemonic thread)、currentThread() の生成するダミースレッドオブジェクト、そして主スレッドが入ります。 
終了したスレッドとまだ開始していないスレッドは入りません。 
新たなイベントオブジェクトを返すファクトリ関数です。 
イベントは set() メソッドを使うと True に、clear() メソッドを使うと False にセットされるようなフラグを管理します。 
wait() メソッドは、全てのフラグが真になるまでブロックするようになっています。 
スレッドローカルデータ (thread-local data) を表現するためのクラスです。 
スレッドローカルデータとは、値が各スレッド固有になるようなデータです。 
スレッドローカルデータを管理するには、local (またはlocalのサブクラス) のインスタンスを作成して、その属性に値を代入します: 
インスタンスの値はスレッドごとに違った値になります。 詳細と例題については、_threading_local モジュールのドキュメンテーション文字列を参照してください。 
新しいプリミティブロック (primitive lock) オブジェクトを返すファクトリ関数です。 
スレッドが一度プリミティブロックを獲得すると、それ以後のロック獲得の試みはロックが解放されるまでブロックします。 どのスレッドでもロックを解放できます。 
新しいセマフォ (semaphore) オブジェクトを返すファクトリ関数です。 
セマフォは、release()を呼び出した数からacquire()を呼び出した数を引き、初期値を足した値を表すカウンタを管理します。 acquire()メソッドは、カウンタの値を負にせずに処理を戻せるまで必要ならば処理をブロックします。 
value を指定しない場合、デフォルトの値は 1 になります。 
新しい有限セマフォ (bounded semaphore) オブジェクトを返すファクトリ関数です。 
有限セマフォは、現在の値が初期値を超過しないようチェックを行います。 
超過を起こした場合、ValueError を送出します。 
たいていの場合、セマフォは限られた容量のリソースを保護するために使われるものです。 
従って、あまりにも頻繁なセマフォの解放はバグが生じているしるしです。 
value を指定しない場合、デフォルトの値は 1 になります。 
処理中のスレッドを表すクラスです。 
このクラスは制限のある範囲内で安全にサブクラス化できます。 
指定時間経過後に関数を実行するスレッドです。 
func は各スレッドのrun() を呼び出す前にスレッドのsys.settrace() に渡されます。 バージョン 2.3 で 新たに追加 された仕様です。 
func は各スレッドのrun() を呼び出す前にスレッドのsys.settrace() に渡されます。 バージョン 2.3 で 新たに追加 された仕様です。 
オブジェクトの詳細なインターフェースを以下に説明します。 
このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。 とはいえ、Java がロックと条件変数を全てのオブジェクトの基本的な挙動にしているのに対し、 Python ではこれらを別個のオブジェクトに分けています。 
Python の Thread クラスがサポートしているのは Java の Thread クラスの挙動のサブセットにすぎません; 現状では、優先度 (priority)やスレッドグループがなく、スレッドの破壊 (destroy)、中断 (stop)、一時停止 (suspend)、復帰 (resume)、割り込み (interrupt) は行えません。 
このモジュールでは、時刻に関するさまざまな関数を提供します。 
ほとんどの関数が利用可能ですが、全ての関数が全てのプラットフォームで利用可能なわけではありません。 
このモジュールで定義されているほとんどの関数は、プラットフォーム上の同名の C ライブラリ関数を呼び出します。 
これらの関数に対する意味付けはプラットフォーム間で異なるため、プラットフォーム提供のドキュメントを読んでおくと便利でしょう。 まずいくつかの用語の説明と慣習について整理します。 
エポック(epoch) 
は、時刻の計測がはじまった時点のことです。 
その年の 1 月 1 日の午前 0 時に``エポックからの経過時間'' が 0 になるように設定されます。 
Unixではエポックは 1970 年です。 
エポックがどうなっているかを知るには、gmtime(0) の値を見るとよいでしょう。 
このモジュールの中の関数は、エポック以前あるいは遠い未来の日付や時刻を扱うことができません。 
将来カットオフ(関数が正しく日付や時刻を扱えなくなる)が起きる時点は、C ライブラリによって決まります。 Unixではカットオフは通常 2038 
2000年問題 (Y2K): 
Python はプラットフォームの C ライブラリに依存しています。 C ライブラリは日付および時刻をエポックからの経過秒で表現するので、一般的に 2000 年問題を持ちません。 
時刻を表現するstruct_time(下記を参照してください)を入力として受け取る関数は一般的に 4 桁表記の西暦年を要求します。 
こうして、PYTHONY2K を空文字列でない文字列に設定することで、西暦年の入力がすべて 4 桁の西暦年でなければならないようにすることができます。 
2桁の西暦年が入力された場合には、POSIX または X/Open 標準に従って変換されます: 69-99 の西暦年は 1969-1999 となり、0-68 の西暦年は 2000-2068 になります。 100-1899 は常に不正な値になります。 
この仕様は Python 1.5.2(a2) から新たに追加された機能であることに注意してください;それ以前のバージョン、すなわち Python 1.5.1 および 1.5.2a1 では、1900以下の年に対して 1900 を足します。 
は協定世界時 (Coordinated Universal Time) のことです 
(以前はグリニッジ標準時 
または GMTとして知られていました)。 
UTC の頭文字の並びは誤りではなく、英仏の妥協によるものです。 
DST は夏時間 (Daylight Saving Time) 
のことで、一年のうち部分的に 1 時間タイムゾーンを修正することです。 
DST のルールは不可思議で (局所的な法律で定められています)、年ごとに変わることもあります。 
C ライブラリはローカルルールを記したテーブルを持っており (柔軟に対応するため、たいていはシステムファイルから読み込まれます)、この点に関しては唯一の真実の知識の源です。 
多くの現時刻を返す関数 (real-time functions) の精度は、値や引数を表現するのに使う単位から想像されるよりも低いかも知れません。 
例えば、ほとんどの Unix システムで、クロックの一刹那 (ticks) の精度は 1 秒 の 50 から 100 分の 1 に過ぎません。 また、Mac では時刻は秒きっかりのとき以外正確ではありません。 
反対に、time() および sleep() は Unix の同等の関数よりましな精度を持っています: 時刻は浮動小数点で表され、time() は可能なかぎり最も正確な時刻を (Unix のgettimeofday() があればそれを使って) 返します。 また sleep() にはゼロでない端数を与えることができます(Unix の select() があれば、それを使って実装しています)。 
gmtime()、localtime()、strptime()が返す時刻値、 および asctime()、mktime()、strftime() に与える時刻値はどちらも 9 つの整数からなるシーケンスです。 
(例えば 1993) 
[1,12] の間の数 
[1,31] の間の数 
[0,23] の間の数 
[0,59] の間の数 
[0,61] の間の数 strftime() の説明にある (1) を読んで下さい 
[0,6] の間の数、月曜が 0 になります 
[1,366] の間の数 
0, 1 または -1; 以下を参照してください 
C の構造体と違って、月の値が 0-11 でなく 1-12 であることに注意してください。 
西暦年の値は上の ''2000年問題 (Y2K) '' で述べたように扱われます。 
夏時間フラグを -1 にして mktime() に渡すと、たいていは正確な夏時間の状態を実現します。 struct_time を引数とする関数に正しくない長さのstruct_timeや要素の型が正しくないstruct_timeを与えた場合には、TypeErrorが送出されます。 
バージョン 2.2 で 変更 された仕様:時刻値の配列はタプルからstruct_timeに変更され、それぞれのフィールドに属性名がつけられました。 
このモジュールでは以下の関数とデータ型を定義します: 
2 桁の西暦年を使えるかを指定するブール型の値です。 
標準では真ですが、環境変数 PYTHONY2K が空文字列でない値に設定されている場合には偽になります。 
実行時に変更することもできます。 
ローカルの夏時間タイムゾーンにおける UTC からの時刻オフセットで、西に行くほど増加する秒で表した値です (ほとんどの西ヨーロッパでは負になり、アメリカでは正、イギリスではゼロになります) 。 
daylight がゼロでないときのみ使用してください。 
gmtime() や localtime() が返す時刻を表現するタプル又は struct_timeを、'Sun Jun 20 23:21:05 1993' といった書式の 24 文字の文字列に変換します。 
t が与えられていない場合には、localtime() が返す現在の時刻が使われます。 asctime() はロケール情報を使いません。 
注意:同名の C の関数と違って、末尾には改行文字はありません。 
バージョン 2.1 で 変更 された仕様:tuple を省略できるようになりました。 
Unixでは、現在のプロセッサ時間秒を浮動小数点数で返します。 
時刻の精度および ``プロセッサ時間 (processor time)'' の定義そのものは同じ名前の C 関数に依存します。 
いずれにせよ、この関数は Python のベンチマーク や計時アルゴリズムに使われています。 
Windows では、最初にこの関数が呼び出されてからの経過時間を wall-clock秒で返します。 この関数は Win32 関数QueryPerformanceCounter() に基づいていて、その精度は通常 1 マイクロ秒以下です。 
エポックからの経過秒数で表現された時刻を、ローカルの時刻を表現する文字列に変換します。 
バージョン 2.4 で 変更 された仕様:secs がNone の場合に現在時刻を使うようになりました 
DST タイムゾーンが定義されている場合ゼロでない値になります。 
エポックからの経過時間で表現された時刻を、UTC におけるstruct_timeに変換します。 このとき dst フラグは常にゼロとして扱われます。 
secs を指定しない、またはNone を指定した場合、time() が返す値を現在の時刻として使います。 
秒の端数は無視されます。 
struct_timeのレイアウトについては上を参照してください。 
バージョン 2.1 で 変更 された仕様:secs を省略できるようになりました 
gmtime() に似ていますが、ローカルタイムに変換します。 
secs を指定しない、またはNone を指定した場合、time() が返す値を現在の時刻として使います。 
現在の時刻に DST が適用される場合、 dst フラグは 1 に設定されます。 バージョン 2.1 で 変更 された仕様:secs を省略できるようになりました。 
localtime() の逆を行う関数です。 
引数は struct_timeか完全な 9 つの要素全てに値の入ったタプル (dst フラグも必要です; 現在の時刻に DST が適用されるか不明の場合には -1 を使ってください) で、UTC ではなく ローカルの 時刻を指定します。 
time() との互換性のために浮動小数点数の値を返します。 
入力の値が正しい時刻で表現できない場合、例外OverflowErrorまたは ValueError が送出されます (どちらが送出されるかはPython および その下にある C ライブラリのどちらにとって無効な値が入力されたかで決まります) 。 
この関数で生成できる最も昔の時刻値はプラットフォームに依存します。 
与えられた秒数の間実行を停止します。 
また、システムが他の処理をスケジューリングするために、実行停止時間が要求した時間よりも多少長い時間になることもあります。 
gmtime() や localtime() が返す時刻値タプル又はstruct_timeを、format で指定した文字列形式に変換します。 
t が与えられていない場合、localtime() が返す現在の時刻が使われます。 format は文字列でなくてはなりません。 
t のいずれかのフィールドが許容範囲外の数値であった場合、ValueError を送出します。 バージョン 2.1 で 変更 された仕様:t を省略できるようになりました。 
バージョン 2.4 で 変更 された仕様:t のフィールド値が許容範囲外の値の場合にValueError を送出するようになりました 
format 文字列には以下の指示語 (directive) を埋め込むことができます。 これらはフィールド長や精度のオプションを付けずに表され、strftime() の結果の対応する文字列と入れ替えられます: 
ロケールにおける省略形の曜日名。 
ロケールにおける省略なしの曜日名。 
ロケールにおける省略形の月名。 
ロケールにおける省略なしの月名。 
ロケールにおける適切な日付および時刻表現。 
月の始めから何日目かを表す 10 進数 [01,31]。 %H 
(24 時間計での) 時を表す 10 進数 [00,23]。 
(12 時間計での) 時を表す 10 進数 [01,12]。 
年の初めから何日目かを表す 10 進数 [001,366]。 
月を表す 10 進数 [01,12]。 
分を表す 10 進数 [00,59]。 
ロケールにおける AM または PM に対応する文字列。 
秒を表す 10 進数 [00,61]。 
年の初めから何週目か (日曜を週の始まりとします)を表す10 進数 [00,53]。 
年が明けてから最初の日曜日までの全ての曜日は 0 週目に属すると見なされます。 
曜日を表す 10 進数 [0(日曜日),6]。 
年の初めから何週目か (日曜を週の始まりとします)を表す10 進数 [00,53]。 
年が明けてから最初の月曜日までの全ての曜日は 0 週目に属すると見なされます。 
ロケールにおける適切な日付の表現。 
ロケールにおける適切な時刻の表現。 
上 2 桁なしの西暦年を表す 10 進数 [00,99]。 
上 2 桁付きの西暦年を表す 10 進数。 
タイムゾーンの名前 (タイムゾーンがない場合には空文字列)。 
文字 "%" 自体の表現。 
注意: 
strptime() 関数で使う場合、%p ディレクティブが出力結果の時刻フィールドに影響を及ぼすのは、時刻を解釈するために%I を使ったときのみです。 
値の幅は間違いなく 0 to 61 です; これはうるう秒と、(ごく稀ですが)2 重のうるう秒のためのものです。 
strptime() 関数で使う場合、%U および %Wを計算に使うのは曜日と年を指定したときだけです。 
以下に RFC 2822 インターネット電子メール標準で定義されている日付表現と互換の書式の例を示します。 
時刻を表現する文字列をフォーマットに従って解釈します。 
返される値はgmtime() や localtime() が返すようなstruct_timeです。 
format パラメタは strftime() で使うものと同じ指示語を使います; このパラメタの値はデフォルトでは"%a %b %d %H:%M:%S %Y" で、ctime() が返すフォーマットに一致します。 
string が format に従って解釈できなかった場合、例外 ValueError が送出されます。 
解析しようとする文字列が解析後に余分なデータを持っていた場合、ValueError が送出されます。 
欠落したデータはデフォルトの値で埋められ、その値は (1900, 1, 1, 0, 0, 0, 0, 1, -1) です。 %Z 指示語へのサポートは tzname に収められている値とdaylight が真かどうかで決められます。 
このため、常に既知の(かつ夏時間でないと考えられている) UTC や GMT を認識する時以外はプラットフォーム固有の動作になります。 
gmtime()、localtime() および strptime()が返す時刻値シーケンスのタイプです。 バージョン 2.2 で 新たに追加 された仕様です。 
時刻を浮動小数点数で返します。 
単位は UTC におけるエポックからの秒数です。 
時刻は常に浮動小数点で返されますが、全てのシステムが 1 秒より高い精度で時刻を提供するとは限らないので注意してください。 
この関数が返す値は通常減少していくことはありませんが、この関数を 2 回呼び出し、呼び出しの間にシステムクロックの時刻を巻き戻して設定した場合には、以前の呼び出しよりも低い値が返ることもあります。 
(DST でない) ローカルタイムゾーンの UTC からの時刻オフセットで、西に行くほど増加する秒で表した値です (ほとんどの西ヨーロッパでは負になり、アメリカでは正、イギリスではゼロになります) 。 
二つの文字列からなるタプルです。 最初の要素は DST でないローカルのタイムゾーン名です。 
利用できるシステム: Unix。 
注意:多くの場合、環境変数 TZ を変更すると、tzset を呼ばない限り localtime のような関数の出力に影響を及ぼすため、値が信頼できなくなってしまいます。 TZ 環境変数には空白文字を含めてはなりません。 
環境変数 TZ の標準的な書式は以下です:(分かりやすいように空白を入れています) 
各値は以下のようになっています: 
std と dst 
三文字またはそれ以上の英数字で、タイムゾーンの略称を与えます。 
この値は time.tzname になります。 
オフセットは形式: hh[:mm[:ss]] をとります。 この表現は、UTC 時刻にするためにローカルな時間に加算する必要のある時間値を示します。 
'-' が先頭につく場合、そのタイムゾーンは本子午線 (Prime Meridian) より東側にあります; それ以外の場合は本子午線の西側です。 
オフセットが dst の後ろに続かない場合、夏時間は標準時より一時間先行しているものと仮定します。 
いつ DST に移動し、DST から戻ってくるかを示します。 
開始および終了日時の形式は以下のいずれかです: 
ユリウス日 (Julian day) n (1 = n = 365) を表します。 
うるう日は計算に含められないため、2 月 28 日は常に 59 で、3 月 1 日は 60 になります。 
ゼロから始まるユリウス日 (0 = n = 365) です。 
うるう日は計算に含められるため、2 月 29 日を参照することができます。 
m 月の第 n 週における d 番目の日(0 = d = 6, 1 = n = 5, 1 = m = 12)を表します。 週 5 は月における最終週の d 番目の日を表し、第 4 週か第 5 週のどちらかになります。 
週 1 は日 d が最初に現れる日を指します。 
日 0 は日曜日です。 
時間はオフセットと同じで、先頭に符号 ('-' や '+') を付けてはいけないところが違います。 
時刻が指定されていなければ、デフォルトの値02:00:00 になります。 
多くの Unix システム (*BSD, Linux, Solaris, および Darwin を含む)では、システムの zoneinfo ( 
tzfile(5)) データベースを使ったほうが、タイムゾーンごとの規則を指定する上で便利です。 
これを行うには、必要なタイムゾーンデータファイルへのパスをシステムの 'zoneinfo' タイムゾーンデータベースからの相対で表した値を環境変数 TZ に設定します。 システムの 'zoneinfo' は通常/usr/share/zoneinfo にあります。 
例えば、'US/Eastern'、 'Australia/Melbourne'、 'Egypt' ないし 'Europe/Amsterdam' と指定します。 
日付と時刻に対する、よりオブジェクト指向のインタフェースです。 
ロケールの設定は time モジュールのいくつかの関数が返す値に影響をおよぼすことがあります。 
一般的なカレンダー関連の関数。 
しかしここで実現したい時間及び分オフセットへの展開を行ってくれる %Z エスケープは全ての ANSI C ライブラリでサポートされているわけではありません。 
また、オリジナルの 1982 年に提出された RFC 822 標準は西暦年の表現を 2 桁と要求しています(%Y でなく%y )。 しかし実際には 2000 年になるだいぶ以前から 4 桁の西暦年表現に移行しています。 
4 桁の西暦年表現は RFC 2822 において義務付けられ、伴って RFC 822 での取り決めは撤廃されました。 
このモジュールは Python の小さなコード断片の時間を簡単に計測する手段を提供します。 インターフェースはコマンドラインとメソッドとして呼び出し可能なものの両方を備えています。 
また、このモジュールは実行時間の計測にあたり陥りがちな落し穴に対する様々な対策が取られています。 
詳しくは、O'Reilly の Python Cookbook、``Algorithms'' の章にある TimPeters が書いた解説を参照してください。 このモジュールには次のパブリック・クラスが定義されています。 
クラスTimer 
小さなコード断片の実行時間計測をおこなうためのクラスです。 コンストラクタは引数として、時間計測の対象となる文、セットアップに使用する追加の文、タイマ関数を受け取ります。 
文のデフォルト値は両方とも 'pass' で、タイマ関数はプラットフォーム依存(モジュールの docstring を参照)です。 
文には複数行の文字列リテラルを含まない限り、改行を入れることも可能です。 最初の文の実行時間を計測には timeit() メソッドを使用します。 
また timeit() を複数回呼び出し、その結果のリストを返す repeat() メソッドも用意されています。 
計測対象コードのトレースバックを出力するためのヘルパー。 利用例: 
t = Timer(...) # try/except の外側でtry:t.timeit(...) # または t.repeat(...)except:t.print_exc() 
timeit() を複数回呼び出します。 
このメソッドは timeit() を複数回呼び出し、その結果をリストで返すユーティリティ関数です。 
最初の引数には timeit() を呼び出す回数を指定します。 
2番目の引数は timeit() へ引数として渡す数値です。 
注意: 結果のベクトルから平均値や標準偏差を計算して出力させたいと思うかもしれませんが、それはあまり意味がありません。 
したがって、結果のうち min() だけが見るべき値となります。 
この点を押さえた上で、統計的な分析よりも常識的な判断で結果を見るようにしてください。 
メイン文の実行時間を number 回取得します。 
このメソッドはセットアップ文を1回だけ実行し、メイン文を指定回数実行するのにかかった秒数を浮動小数で返します。 
引数はループを何回実行するかの指定で、デフォルト値は100万回です。 
メイン文、セットアップ文、タイマ関数はコンストラクタで指定されたものを使用します。 
注意:デフォルトでは、 timeit() は時間計測中、一時的にガーベッジコレクションを切ります。 
このアプローチの利点は、個別の測定結果を比較しやすくなることです。 
不利な点は、GC が測定している関数のパフォーマンスの重要な一部かもしれないということです。 
そうした場合、setup 文字列の最初の文で GC を再度有効にすることができます。 
例えば : 
このモジュールは解析木の葉ノード(終端記号)の数値を表す定数を提供します。 
言語の文法のコンテキストにおける名前の定義については、PythonディストリビューションのファイルGrammar/Grammarを参照してください。 
名前がマップする特定の数値は、Pythonのバージョン間で変わります。 このモジュールは一つのデータオブジェクトといくつかの関数も提供します。 
関数はPythonのCヘッダファイルの定義を反映します。 
辞書はこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。 
終端トークンの値に対して真を返します。 
非終端トークンの値に対して真を返します。 
xが入力の終わりを示すマーカーならば、真を返します。 
tokenizeモジュールでは、Python で実装された Pythonソースコードの字句解析器を提供します。 
generate_tokens() ジェネレータは一つの引数readlineを必要とします。 この引数は呼び出し可能オブジェクトで、組み込みファイルオブジェクトにおける readline() メソッドと同じインタフェースを提供していなければなりません (2.3.9 節を参照してください)。 
後方互換性のために古いエントリポイントが残されています: 
tokenize()関数は二つのパラメータを取ります: 一つは入力ストリームを表し、もう一つはtokenize()のための出力メカニズムを与えます。 最初のパラメータ、readline は、組み込みファイルオブジェクトのreadline()メソッドと同じインタフェイスを提供する呼び出し可能オブジェクトでなければなりません (2.3.9 節を参照)。 
この関数は呼び出しのたびに入力内の一行を文字列で返さなければなりません。 二番目のパラメータtokeneaterも呼び出し可能オブジェクトでなければなりません。 
この関数は各トークンに対して一度だけ呼び出され、generate_tokens() が生成するタプルに対応する 5 つの引数をとります。 
モジュールの全ての定数はtokenize でも公開されており、これに加え、以下の二つのトークン値が tokenize()の tokeneater 関数に渡される可能性があります: 
コメントであることを表すために使われるトークン値です。 
終わりではない改行を表すために使われるトークン値。 
NEWLINEトークンはPythonコードの論理行の終わりを表します。 NLトークンはコードの論理行が複数の物理行にわたって続いているときに作られます。 
このモジュールはPythonプログラムのスタックトレースを抽出し、書式を整え、表示するための標準インターフェースを提供します。 
モジュールがスタックトレースを表示するとき、Pythonインタープリタの動作を正確に模倣します。 
インタープリタの``ラッパー''の場合のように、プログラムの制御の元でスタックとレースを表示したいと思ったときに役に立ちます。 モジュールはtracebackオブジェクトを使います -- これは変数sys.exc_traceback(非推奨)とsys.last_tracebackに保存され、sys.exc_info()から三番目の項目として返されるオブジェクト型です。 
モジュールは次の関数を定義します: 
tracebackからlimitまでスタックトレース項目を出力します。 
limitが省略されるかNoneの場合は、すべての項目が表示されます。 fileが省略されるかNoneの場合は、sys.stderrへ出力されます。 
それ以外の場合は、出力を受けるためのオープンしたファイルまたはファイルに類似したオブジェクトであるべきです。 print_exception 
例外情報とtracebackからlimitまでスタックトレース項目をfileへ出力します。 
これはprint_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)のための省略表現です。 
(非推奨の変数を使う代わりにスレッドセーフな方法で同じ情報を引き出すために、実際にはsys.exc_info()を使います。 
これは、print_exc(limit)に似ていますが、ファイルに出力するかわりに文字列を返します。 
バージョン 2.4 で 新たに追加 された仕様です。 print_last 
これはprint_exception(sys.last_type, sys.last_value, sys.last_traceback, limit, file)の省略表現です。 
この関数は呼び出された時点からのスタックトレースを出力します。 
オプションのf引数は代わりの最初のスタックフレームを指定するために使えます。 
print_exception()に付いて言えば、オプションのlimitとfile引数は同じ意味を持ちます。 
トレースバックオブジェクトtracebackからlimitまで取り出された``前処理済み''スタックトレース項目のリストを返します。 
スタックトレースの代わりの書式設定を行うために役に立ちます。 
limitが省略されるかNoneの場合は、すべての項目が取り出されます。 
``前処理済み''スタックトレース項目とは四つの部分からなる(filename, line number, function name, text)で、スタックトレースに対して通常出力される情報を表しています。 
textは前と後ろに付いている空白を取り除いた文字列です。 ソースが使えない場合はNoneです。 
現在のスタックフレームから生のトレースバックを取り出します。 
戻り値はextract_tb()と同じ形式です。 
print_stack()について言えば、オプションのfとlimit引数は同じ意味を持ちます。 
extract_tb()またはextract_stack()が返すタプルのリストが与えられると、出力の準備を整えた文字列のリストを返します。 
結果として生じるリストの中の各文字列は、引数リストの中の同じインデックスの要素に対応します。 
各文字列は末尾に改行が付いています。 その上、ソーステキスト行がNoneでないそれらの要素に対しては、文字列は内部に改行を含んでいるかもしれません。 
トレースバックの例外部分の書式を設定します。 
引数はsys.last_typeとsys.last_valueのような例外の型と値です。 
戻り値はそれぞれが改行で終わっている文字列のリストです。 
通常、リストは一つの文字列を含んでいます。 しかし、SyntaxError例外に対しては、(出力されるときに)構文エラーが起きた場所についての詳細な情報を示す行をいくつか含んでいます。 
どの例外が起きたのかを示すメッセージは、常にリストの最後の文字列です。 
スタックトレースと例外情報の書式を設定します。 
引数はprint_exception()の対応する引数と同じ意味を持ちます。 
戻り値は文字列のリストで、それぞれの文字列は改行で終わり、そのいくつかは内部に改行を含みます。 
これらの行が連結されて出力される場合は、厳密にprint_exception()と同じテキストが出力されます。 
format_list(extract_tb(tb, limit))の省略表現。 
format_list(extract_stack(f, limit))の省略表現。 
この関数はトレースバックオブジェクトに設定された現在の行番号をかえします。 
この関数は必要でした。 なぜなら、-OフラグがPythonへ渡されたとき、Pythonの2.3より前のバージョンでは 
tb.tb_linenoが正しく更新されなかったからです。 
この関数は2.3以降のバージョンでは役に立ちません。 
tty モジュールは端末を cbreak および raw モードにするための関数を定義しています。 このモジュールは 
モジュールを必要とするため、Unixでしか動作しません。 tty モジュールでは、以下の関数を定義しています: 
ファイル記述子 fd のモードを raw モードに変えます。 
when を省略すると標準の値は termios.TCSAFLUSH になり、termios.tcsetattr() に渡されます。 
ファイル記述子 fd のモードを cbreakモードに変えます。 
参考: termios 
端末制御操作で便利な定数群。 . 
turtleモジュールはオブジェクト指向と手続き指向の両方の方法でタートルグラフィックス・プリミティブを提供します。 
角度を計る単位を度にします。 
角度を計る単位をラジアンにします。 
スクリーンを消去し、ペンを中心に持って行き、変数をデフォルト値に設定します。 
スクリーンを消去します。 
トレースをon/offにします(フラグが真かどうかに応じて)。 
トレースとは、線に沿って矢印のアニメーションが付き、線がよりゆっくりと引かれることを意味します。 
distanceステップだけ前に進みます。 
distanceステップだけ後ろに進みます。 
angle単位だけ左に回ります。 
単位のデフォルトは度ですが、degrees()とradians()関数を使って設定できます。 
angle単位だけ右に回ります。 
ペンを上げます -- 線を引くことを止めます。 
ペンを下げます -- 移動したときに線を引きます。 
線幅をwidthに設定します。 
ペンの色を設定します。 
最初の形式では、色は文字列としてTkの色の仕様の通りに指定されます。 
二番目の形式は色をRGB値(それぞれは範囲[0..1])のタプルとして指定します。 
三番目の形式では、色は三つに別れたパラメータとしてRGB値(それぞれは範囲[0..1])を与えて指定しています。 
現在のペンの位置にtextを書き込みます。 
moveが真ならば、ペンはテキストの右下の角へ移動します。 
デフォルトでは、moveは偽です。 
完全な仕様はかなり複雑ですが、推奨する使い方は: 塗りつぶしたい経路を描く前にfill(1)を呼び出し、経路を描き終えたときにfill(0)を呼び出します。 
extentは円のどの部分を描くかを決定します: 与えられなければ、デフォルトで完全な円になります。 
extentが完全な円である場合は、弧の一つの端点は、現在のペンの位置です。 
radiusが正の場合、弧は反時計回りに描かれます。 
そうでなければ、時計回りです。 
座標x, yへ移動します。 
座標は二つの別個の引数か、2-タプルのどちらかで指定することができます。 
このモジュールはfrom math import *も実行します。 従って、タートルグラフィックスのために役に立つ追加の定数と関数については、 
モジュールのドキュメントを参照してください。 
モジュールをちょっとばかり試しています。 
このモジュールによって捕捉されたあらゆるエラー対して発生した例外。 
例として、demo()関数のコードを参照してください。 このモジュールは次のクラスを定義します: 
クラスPen 
ペンを定義します。 
上記のすべての関数は与えられたペンのメソッドとして呼び出されます。 
このコンストラクタは線を描くキャンバスを自動的に作成します。 
クラスRawPen 
キャンバスcanvasに描くペンを定義します。 
これは``実際の''プログラムでグラフィックスを作成するためにモジュールを使いたい場合に役に立ちます。 
このモジュールは標準のPythonインタプリタで使われているオブジェクトの型について、名前を定義しています(拡張モジュールで定義されている型を除く)。 
このモジュールは以下に列挙している以外の名前をエクスポートしないので、"from types import *"のように使っても安全です。 
このモジュールの将来のバージョンで追加される名前は、"Type"で終わる予定です。 関数での典型的な利用方法は、以下のように引数の型によって異なる動作をする場合です: 
Python 2.2以降では、int() や str()のようなファクトリ関数は、型の名前となりましたので、typesを使用する必要はなくなりました。 
上記のサンプルは、以下のように記述する事が推奨されています。 
このモジュールは以下の名前を定義しています。 
Noneの型です。 
boolのTrueとFalseの型です。 これは組み込み関数のbool()のエイリアスです。 
整数の型です(e.g. 1)。 
長整数の型です(e.g. 1L)。 
浮動小数点数の型です(e.g. 1.0)。 
複素数の型です(e.g. 1.0j)。 
Pythonが複素数のサポートなしでコンパイルされていた場合には定義されません。 
文字列の型です(e.g. 'Spam')。 
Unicode文字列の型です(e.g. u'Spam')。 
Pythonがユニコードのサポートなしでコンパイルされていた場合には定義されません。 
タプルの型です(e.g. (1, 2, 3, 'Spam'))。 
リストの型です(e.g. [0, 1, 2, 3])。 
辞書の型です(e.g. {'Bacon': 1, 'Ham': 0})。 
DictTypeの別名です。 
ユーザー定義の関数またはlambdaの型です。 
FunctionTypeの別名です。 
ジェネレータ関数の呼び出しによって生成されたイテレータオブジェクトの型です。 バージョン 2.2 で 新たに追加 された仕様です。 
ユーザー定義のクラスの型です。 
ユーザー定義のクラスのインスタンスの型です。 
ユーザー定義のクラスのインスタンスのメソッドの型です。 
MethodTypeの別名です。 
len() や sys.exit()のような組み込み関数の型です。 
BuiltinFunctionの別名です。 
モジュールの型です。 
sys.stdoutのようなopenされたファイルオブジェクトの型です。 
Ellipsisの型です。 
sys.exc_tracebackに含まれるようなトレースバックオブジェクトの型です。 
フレームオブジェクトの型です。 トレースバックオブジェクトtbのtb.tb_frameなどです。 
関数によって作られるバッファオブジェクトの型です。 
文字列型のチェックを簡単にするためのStringTypeとUnicodeTypeを含むシーケンスです。 
UnicodeTypeは実行中の版のPythonに含まれている場合にだけ含まれるので、2つの文字列型のシーケンスを使うよりこれを使う方が移植性が高くなります。 
例:isinstance(s, types.StringTypes).バージョン 2.2 で 新たに追加 された仕様です。 
このモジュールは、全ての Unicode 文字の属性を定義している Unicode 文字データベースへのアクセスを提供します。 
このデータベース内のデータは、ftp://ftp.unicode.org/ で公開されている UnicodeData.txt ファイルのバージョン 3.2.0 に基づいています。 このモジュールは、UnicodeData ファイルフォーマット 3.2.0 (http://www.unicode.org/Public/UNIDATA/UnicodeData.html を参照)で定義されているものと、同じ名前と記号を使います。 
このモジュールで定義されている関数は、以下のとおりです。 
名前に対応する文字を探します。 
その名前の文字が見つ かった場合、 その Unicode 文字が返されます。 
見つからなかった場合には、KeyError を発生させます。 
Unicode 文字 unichr に付いている名前を、文字列で返します。 
名前が定義されていない場合には default が返されますが、この引数が与えられていなければ ValueError を発生させます。 
Unicode 文字 unichr に割り当てられている十進数を、整数で返します。 
この値が定義されていない場合には default が返されますが、この引数が与えられていなければ ValueError を発生させます。 
Unicode 文字 unichr に割り当てられている二進数を、整数で返します。 
Unicode 文字 unichr に割り当てられている数値を、float 型で返します。 
この値が定義されていない場合には default が返されますが、この引 数が与えられていなければ ValueError を発生させます。 
Unicode 文字 unichr に割り当てられた、汎用カテゴリを返します。 
Unicode 文字 unichr に割り当てられた、双方向カテゴリを返します。 
そのような値が定義されていない場合、空の文字列が返されます。 
Unicode 文字 unichr に割り当てられた正規結合クラスを返します。 
結合クラス定義されていない場合、0 が返されます。 
unichr as string.ユニコード文字unichrに割り当てられたeast asian widthを文字列で返します。 バージョン 2.4 で 新たに追加 された仕様です。 
Unicode 文字 unichr に割り当てられた、鏡像化のプロパティを返します。 
その文字が双方向テキスト内で鏡像化された文字である場合には 1 を、それ以外の場合には 0 を返します。 
Unicode 文字 unichr に割り当てられた、文字分解マッピングを、文字列型で返します。 
そのようなマッピングが定義されていない場合、空の文字列が返されます。 
Unicode では、複数の方法で表現できる文字があります。 
Unicode では、一般に他の文字との統合がサポートされている文字があります。 
たとえば、U+2160 (ROMAN NUMERAL ONE) は事実上 U+0049 (LATIN CAPITAL LETTER I) と同じものです。 
正規形 KC (NFKC) は、互換分解を適用してから、標準分解を適用します。 
更に、本モジュールは以下の定数を公開します。 
このモジュールで使われている Unicode データベースのバージョン。 
5.2.12 進んだ使い方 
このPython単体テストフレームワーク は``PyUnit''とも呼ばれ、Kent Beck とErich GammaによるJUnitのPython版です。 JUnitはまたKentのSmalltalk用テストフレームワークのJava版で、どちらもそれぞれの言語で業界標準の単体テストフレームワークとなっています。 
PyUnitでは、テストの自動化・初期設定と終了処理の共有・テストの分類・テスト実行と結果レポートの分離などの機能を提供しており、unittestのクラスを使って簡単にたくさんのテストを開発できるようになっています。 
PyUnitでは、テストを以下のような構成で開発します。 
test fixture(テスト設備)とは、テスト実行のために必要な準備や終了処理を指します。 
テストケースはテストの最小単位で、各入力に対する結果をチェックします。 
テストケースを作成する場合は、PyUnitが提供するTestCaseクラスを基底クラスとして利用することができます。 
もちろん、TestCaseの派生クラスではなく、独自のテストケースを実装しても構いません。 
テストスイート 
テストスイートはテストケースとテストスイートの集まりで、同時に実行しなければならないテストをまとめる場合に使用します。 
テストランナー 
テストランナーはテストの実行と結果表示を管理するコンポーネントです。 
ランナーはグラフィカルインターフェースでもテキストインターフェースでも良いですし、何も表示せずにテスト結果を示す値を返すだけの場合もあります。 
PyUnitでは、テストケースとfixtureを、TestCaseクラスとFunctionTestCaseクラスで提供しています。 TestCaseクラスは新規にテストを作成する場合に使用し、FunctionTestCaseは既存のテストをPyUnitに組み込む場合に使用します。 
fixtureの設定処理と終了処理は、TestCaseではsetUp()メソッドとtearDown()をオーバーライドして記述し、FunctionTestCaseでは初期設定・終了処理を行う既存の関数をコンストラクタで指定します。 
テスト実行時、まずfixtureの初期設定が最初に実行されます。 
初期設定が正常終了した場合、テスト実行後にはテスト結果に関わらず終了処理が実行されます。 
TestCaseの各インスタンスが実行するテストは一つだけで、fixtureは各テストごとに新しく作成されます。 テストスイートはTestSuiteクラスで実装されており、複数のテストとテストスイートをまとめる事ができます。 
テストスイートを実行すると、スイートと子スイートに追加されている全てのテストが実行されます。 テストランナーはrun()メソッドを持つオブジェクトで、run()は引数としてTestCaseかTestSuiteオブジェクトを受け取り、テスト結果をTestResultオブジェクトで戻します。 
PyUnitではデフォルトでテスト結果を標準エラーに出力するTextTestRunnerをサンプルとして実装しています。 
これ以外のランナー(グラフィックインターフェース用など)を実装する場合でも、特定のクラスから派生する必要はありません。 
5.3.1 基礎的な例 
このモジュールはワールドワイドウェブ (World Wide Web) を介してデータを取り寄せるための高レベルのインタフェースを提供する。 
特に、関数urlopen() は組み込み関数 open() と同様に動作し、ファイル名の代わりにファイルユニバーサルリソースロケータ (URL) を指定することができます。 いくつかの制限はあります -- URL は読み出し専用でしか開けませんし、seek 操作を行うことはできません。 
このモジュールでは、以下の public な関数を定義します。 
URL で表されるネットワーク上のオブジェクトを読み込み用に開きます。 
URL がスキーム識別子を持たないか、スキーム識別子が file: である場合、ローカルシステムのファイルが (広範囲の改行サポートなしで) 開かれます。 それ以外の場合はネットワーク上のどこかにあるサーバへのソケットを開きます。 
接続を作ることができないか、サーバがエラーコードを返した場合、例外 IOError が送出されます。 
全ての処理がうまくいけば、ファイル類似のオブジェクトが返されます。 
このオブジェクトは以下のメソッド: read() 、 readline() 、readlines() 、 fileno() 、 close() 、info() そして geturl() をサポートします。 
(ですが、このオブジェクトは組み込みのファイルオブジェクトではないので、まれに真の組み込みファイルオブジェクトが必要な場所では使うことができません) info() メソッドは開いた URL に関連付けられたメタ情報を含む mimetools.Message クラスのインスタンスを返します。 
URL へのアクセスメソッドが HTTP である場合、メタ情報中のヘッダ情報はサーバが HTML ページを返すときに先頭に付加するヘッダ情報です (Content-Length および Content-Type を含みます) 。 
アクセスメソッドが FTP の場合、ファイル取得リクエストに応答してサーバがファイルの長さを返したときには (これは現在では普通になりましたが) Content-Length ヘッダがメタ情報に含められます。 
Content-type ヘッダは MIME タイプが推測可能なときにメタ情報に含められます。 
アクセスメソッドがローカルファイルの場合、返されるヘッダ情報にはファイルの最終更新日時を表す Date エントリ、ファイルのサイズを示す Content-Length エントリ、そして推測されるファイル形式の Content-Type エントリが含まれます。 
モジュールを参照してください。 geturl() メソッドはページの実際の URL を返します。 
場合によっては、HTTP サーバはクライアントの要求を他の URL に振り向け(redirect 、リダイレクト 
) します。 関数 urlopen() はユーザに対してリダイレクトを透過的に行いますが、呼び出し側にとってクライアントがどの URL にリダイレクトされたかを知りたいときがあります。 
geturl() メソッドを使うと、このリダイレクトされた URL を取得できます。 url に http: スキーム識別子を使う場合、data 引数を与えて POST 形式のリクエストを行うことができます (通常リクエストの形式は GET です)。 
引数 data は標準のapplication/x-www-form-urlencoded 形式でなければなりません;以下の urlencode() 関数を参照してください。 urlopen() 関数は認証を必要としないプロキシ (proxy) に対して透過的に動作します。 
Unix または Windows 環境では、 Python を起動する前に、環境変数 http_proxy、 ftp_proxy 、および gopher_proxy にそれぞれのプロキシサーバを指定する URL を設定してください。 
例えば ("%" はコマンドプロンプトです): 
Windows 環境では、プロキシを指定する環境変数が設定されていない場合、プロキシの設定値はレジストリの Internet Settings セクションから取得されます。 
Macintosh 環境では、urlopen() は「インターネットの設定」 (Internet Config)からプロキシ情報を取得します。 
別の方法として、オプション引数 proxies を使って明示的にプロキシを設定することができます。 
おそらく旧バージョンのドキュメントです)関数 urlopen() は明示的なプロキシ指定をサポートしていません。 
バージョン 2.3 で 変更 された仕様:proxies のサポートを追加しました。 
URL で表されるネットワーク上のオブジェクトを、必要に応じてローカルなファイルにコピーします。 
フック関数には 3 つの引数が渡されます; これまで転送されたブロック数のカウント、バイト単位で表されたブロックサイズ、ファイルの総サイズです。 
3 つ目のファイルの総サイズは、ファイル取得の際の応答時にファイルサイズを返さない古い FTP サーバでは -1 になります。 url が http: スキーム識別子を使っていた場合、オプション引数 data を与えることで POST リクエストを行うよう指定することができます (通常リクエストの形式は GET です)。 
data 引数は標準の application/x-www-form-urlencoded形式でなくてはなりません; 以下の urlencode() 関数を参照してください。 
パブリック関数 urlopen() および urlretrieve() は FancyURLopener クラスのインスタンスを生成します。 インスタンスは要求された動作に応じて使用されます。 
この機能をオーバライドするために、プログラマは URLopener または FancyURLopener のサブクラスを作り、そのクラスから生成したインスタンスを変数 urllib._urlopener に代入した後、呼び出したい関数を呼ぶことができます。 例えば、アプリケーションが URLopener が定義しているのとは異なった User-Agent: ヘッダを指定したい場合があるかもしれません。 
この機能は以下のコードで実現できます: 
以前の urlretrieve() で生成された可能性のあるキャッシュを消去します。 
例: quote('/~connolly/') は '/%7econnolly/' になります。 quote_plus 
quote() と似ていますが、加えて空白文字をプラス記号 (``+'') に置き換えます。 これは HTML フォームの値を quote 処理する際に必要な機能です。 
もとの文字列におけるプラス記号は safe に含まれていない限りエスケープ置換されます。 
上と同様に、safe のデフォルトの値は '/' です。 
"%xx" エスケープをエスケープが表す 1 文字に置き換えます。 
例: unquote('/%7Econnolly/') は '/~connolly/' になります。 unquote_plus 
unquote() と似ていますが、加えてプラス記号を空白文字に置き換えます。 これは quote 処理された HTML フォームの値を元に戻すのに必要な機能です。 
マップ型オブジェクト、または 2 つの要素をもったタプルからなるシーケンスを、 ``URL にエンコードされた (url-encoded)'' に変換して、上述の urlopen() のオプション引数 data に適した形式にします。 
この関数はフォームのフィールド値でできた辞書をPOST 型のリクエストに渡すときに便利です。 
返される文字列は 
のペアを ""で区切ったシーケンスで、key と value の双方は上のquote_plus() で quote 処理されます。 
オプションのパラメタ doseq が与えられていて、その評価結果が真であった場合、シーケンス doseq の個々の要素について 
のペアが生成されます。 2 つの要素をもったタプルからなるシーケンスが引数 query として使われた場合、各タプルの最初の値が key で、2 番目の値が value になります。 
このときエンコードされた文字列中のパラメタの順番はシーケンス中のタプルの順番と同じになります。 
モジュールでは、関数 parse_qs() およびparse_qsl() を提供しており、クエリ文字列を解析してPython のデータ構造にするのに利用できます。 
ローカルシステムにおける記法で表されたパス名 path を、URL におけるパス部分の形式に変換します。 
この関数は完全な URL を生成するわけではありません。 
返される値は常に quote() を使って quote 処理されたものになります。 
URL のパスの部分 path をエンコードされた URL の形式からローカルシステムにおけるパス記法に変換します。 
この関数は path をデコードするために unquote() を使います。 
クラスURLopener 
URL をオープンし、読み出すためのクラスの基礎クラス (base class)です。 
ここで VVVは urllib のバージョン番号です。 
実際に https: 形式の URL からリソースを取得するには両方の引数が必要です。 
クラスFancyURLopener 
FancyURLopener は URLopener のサブクラスで、以下の HTTP レスポンスコード: 301、302、303、307、および 401 を取り扱う機能を提供します。 
レスポンスコード 30x に対しては、Location: ヘッダを使って実際の URL を取得します。 
レスポンスコード 401 (認証が要求されていることを示す) に対しては、ベーシック認証 (basic HTTP authintication) が行われます。 
レスポンスコード 30x に対しては、最大でmaxtries 属性に指定された数だけ再帰呼び出しを行うようになっています。 この値はデフォルトで 10 です。 
注意: RFC 2616 によると、 POST 要求に対する 301 および 302 応答はユーザの承認無しに自動的にリダイレクトしてはなりません。 
実際は、これらの応答に対して自動リダイレクトを許すブラウザではPOST を GET に変更しており、urllib でもこの動作を再現します。 
コンストラクタに与えるパラメタは URLopener と同じです。 
注意:基本的な HTTP 認証を行う際、 FancyURLopener インスタンスはprompt_user_passwd() メソッドを呼び出します。 
このメソッドはデフォルトでは実行を制御している端末上で認証に必要な情報を要求するように実装されています。 
必要ならば、このクラスのサブクラスにおいてより適切な動作をサポートするために prompt_user_passwd() メソッドをオーバライドしてもかまいません。 
制限: 
現在のところ、以下のプロトコルだけがサポートされています: HTTP、(バージョン 0.9 および 1.0)、 Gopher (Gopher-+ を除く)、 FTP、およびローカルファイル。 
urlretrieve() のキャッシュ機能は、有効期限ヘッダ(Expiration time header) を正しく処理できるようにハックするための時間を取れるまで、無効にしてあります。 
ある URL がキャッシュにあるかどうか調べるような関数があればと思っています。 
。 後方互換性のため、 URL がローカルシステム上のファイルを指しているように見えるにも関わらずファイルを開くことができなければ、 URL はFTP プロトコルを使って再解釈されます。 
この機能は時として混乱を招くエラーメッセージを引き起こします。 
関数 urlopen() および urlretrieve() は、ネットワーク接続が確立されるまでの間、一定でない長さの遅延を引き起こすことがあります。 
このことは、これらの関数を使ってインタラクティブなWeb クライアントを構築するのはスレッドなしには難しいことを意味します。 
urlopen() または urlretrieve() が返すデータはサーバが返す生のデータです。 
このデータはバイナリデータ (例えば画像データ) 、生テキスト (plain text)、または (例えば) HTML 
でもかまいません。 
プロトコルはリプライヘッダ (reply header) にデータのタイプに関する情報を返します。 
タイプは Content-Type: ヘッダを見ることで推測できます。 Gopher 
プロトコルでは、データのタイプに関する情報は URL にエンコードされます; これを展開することは簡単ではありません。 
返されたデータが HTML であれば、 
プロトコルを扱うコードでは、ファイルとディレクトリを区別できません。 
このことから、アクセスできないファイルを指しているURL からデータを読み出そうとすると、予期しない動作を引き起こす場合があります。 
URL が/ で終わっていれば、ディレクトリを指しているものとみなして、それに適した処理を行います。 
しかし、ファイルの読み出し操作が 550 エラー (URL が存在しないか、主にパーミッションの理由でアクセスできない) になった場合、URL がディレクトリを指していて、末尾の / を忘れたケースを処理するため、パスをディレクトリとして扱います。 
このために、パーミッションのためにアクセスできないファイルをfetch しようとすると、FTP コードはそのファイルを開こうとして 550 エラーに陥り、次にディレクトリ一覧を表示しようとするため、誤解を生むような結果を引き起こす可能性があるのです。 
よく調整された制御が必要なら、ftplib モジュールを使うか、FancyURLOpener をサブクラス化するか、_urlopener を変更して目的に合わせるよう検討してください。 
このモジュールは認証を必要とするプロキシをサポートしません。 
将来実装されるかもしれません。 
urllib モジュールは URL 文字列を解釈したり構築したりする(ドキュメント化されていない) ルーチンを含んでいますが、URL を操作するためのインタフェースとしては、 
モジュールをお勧めします。 
urllib2 モジュールは基本的な認証、暗号化認証、リダイレクション、クッキー、その他の介在する複雑なアクセス環境において (大抵は HTTP で) URL を開くための関数とクラスを定義します。 urllib2 モジュールでは以下の関数を定義しています: 
URL url を開きます。 
url は文字列でも Requestオブジェクトでもかまいません 。 data は文字列で、サーバに送信する追加のデータを指定します。 
HTTP リクエストは data をサポートする唯一のリクエスト形式ですが、ここでは data は例えば urllib.urlencode()が返すような application/x-www-form-urlencoded 形式でエンコードされたバッファでなくてはなりません。 この関数は以下の 2 つのメソッドを持つファイル類似のオブジェクトを返します: 
geturl() -- 取得されたリソースの URL を返します。 
info() -- 取得されたページのメタ情報を辞書形式のオブジェクトで返します。 
エラーが発生した場合 URLError を送出します。 どのハンドラもリクエストを処理しなかった場合には None を返すことがあるので注意してください (デフォルトでインストールされるグローバルハンドラの OpenerDirector は、UnknownHandlerを使って上記の問題が起きないようにしています)。 
標準で URL を開くオブジェクトとして OpenerDirector のインスタンスをインストールします。 
与えられた順番に URL ハンドラを連鎖させる OpenerDirector のインスタンスを返します。 handler は BaseHandlerまたは BaseHandler のサブクラスのインスタンスのどちらかです (どちらの場合も、コンストラクトは引数無しで呼び出せるようになっていなければなりません) 。 
現在全てのハンドラの handler_oder は 500 ですが、例外として ProxyHandler では 100 になっています。 
状況に応じて、以下の例外が送出されます: 
ハンドラが何らかの問題に遭遇した場合、この例外 (またはこの例外から導出された例外)を送出します。 
この例外は IOErrorのサブクラスです。 
URLError のサブクラスです。 このオブジェクトは例外でないファイル類似のオブジェクトとして返り値に使うことができます(urlopen() が返すのと同じものです)。 
この機能は、例えばサーバからの認証リクエストのように、変わった HTTP エラーを処理するのに役立ちます。 
URLError のサブクラスです。 この例外は Gopher ハンドラによって送出されます。 
クラスRequest 
このクラスは URL リクエストを抽象化したものです。 
url は有効な URL を指す文字列でなくてはなりません。 
origin_req_host は、RFC 2965 で定義されている元のトランザクションにおけるリクエストホスト (request-host of theorigin transaction) です。 
デフォルトの値はcookielib.request_host(self) です。 
この値は、ユーザによって開始された元々のリクエストにおけるホスト名や IP アドレスです。 
例えば、もしリクエストがある HTML ドキュメント内の画像を指していれば、この値は画像を含んでいるページへのリクエストにおけるリクエストホストになるはずです。 
unverifiable は、RFC 2965 の定義において、該当するリクエストが証明不能 (unverifiable) であるかどうかを示します。 
デフォルトの値はFalse です。 
証明不能なリクエストとは、ユーザが受け入れの可否を選択できないような URL を持つリクエストのことです。 
例えば、リクエストがHTML ドキュメント中の画像であり、ユーザがこの画像を自動的に取得するかどうかを選択できない場合には、証明不能フラグは True になります。 
クラスOpenerDirector 
OpenerDirector クラスは、BaseHandler の連鎖的に呼び出して URL を開きます。 
このクラスはハンドラをどのように連鎖させるか、またどのようにエラーをリカバリするかを管理します。 
クラスBaseHandler 
このクラスはハンドラ連鎖に登録される全てのハンドラがベースとしているクラスです - このクラスでは登録のための単純なメカニズムだけを扱います。 
クラスHTTPDefaultErrorHandler 
HTTP エラー応答のための標準のハンドラを定義します; 全てのレスポンスに対して、例外 HTTPError を送出します。 クラスHTTPRedirectHandler 
リダイレクションを扱うクラスです。 
クラスHTTPCookieProcessor 
HTTP Cookie を扱うためのクラスです。 
クラスProxyHandler 
クラスHTTPPasswordMgr 
(realm, uri) - (user, password)の対応付けデータベースを保持します。 
クラスHTTPPasswordMgrWithDefaultRealm 
(realm, uri) - (user, password) の対応付けデータベースを保持します。 
レルム None はその他諸々のレルムを表し、他のレルムが該当しない場合に検索されます。 クラスAbstractBasicAuthHandler 
クラスHTTPBasicAuthHandler 
遠隔ホストとの間での認証を扱います。 password_mgr を与える場合、HTTPPasswordMgr と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション11.5.7 を参照してください。 
クラスProxyBasicAuthHandler 
プロキシとの間での認証を扱います。 password_mgr を与える場合、HTTPPasswordMgr と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション11.5.7 を参照してください。 
クラスAbstractDigestAuthHandler 
クラスHTTPDigestAuthHandler 
クラスProxyDigestAuthHandler 
クラスHTTPHandler 
HTTP の URL を開きます。 クラスHTTPSHandler 
HTTPS の URL を開きます。 クラスFileHandler 
ローカルファイルを開きます。 
クラスFTPHandler 
FTP の URL を開きます。 
クラスCacheFTPHandler ( 
FTP の URL を開きます。 
遅延を最小限にするために、開かれている FTP 接続に対するキャッシュを保持します。 
クラスGopherHandler 
gopher の URL を開きます。 
クラスUnknownHandler 
その他諸々のためのクラスで、未知のプロトコルの URL を開きます。 
URL を解釈して 6 つの構成要素にし、6 要素のタプル:(アドレススキーム、ネットワーク上の位置、パス、パラメタ、クエリ、フラグメント指定子) を返します。 
このタプルは URL の一般的な構造: 
以下の例: urlparse('http://www.cwi.nl:80/%7Eguido/Python.html') 
では、タプル 
('http', 'www.cwi.nl:80', '/%7Eguido/Python.html', '', '', '') になります。 
default_scheme 引数が最低されている場合、標準のアドレススキームを表し、アドレススキームを指定していない URL 文字列に対してのみ使われます。 
この引数の標準の値は空文字列です。 allow_fragments 引数がゼロの場合、URL のアドレススキームがフラグメント指定をサポートしていても指定できなくなります。 
この引数の標準の値は 1 です。 
urlparse() に似ていますが、URL から params を切り離しません。 
このメソッドは通常、URL の path 部分において、各セグメントにパラメタ指定をできるようにした最近の URL 構文 (RFC 2396 参照) の場合に、urlparse() の代わりに使われます。 
パスセグメントとパラメタを分割するためには分割用の関数が必要です。 
この関数は 5 要素のタプル:(アドレススキーム、ネットワーク上の位置、パス、クエリ、フラグメント指定子) を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
urlsplit() が返すような形式のタプル中のエレメントを組み合わせて、文字列の完全な URL にします。 バージョン 2.2 で 新たに追加 された仕様です。 
``基底 URL'' (base) と ``相対 URL'' (url) を組み合わせて、完全な URL (``絶対 URL'') を構成します。 
ぶっちゃけ、この関数は 基底 URL の要素、特にアドレススキーム、ネットワーク上の位置、およびパス (の一部) を使って、相対 URL にない要素を提供します。 
以下の例: urljoin('http://www.cwi.nl/%7Eguido/Python.html', 'FAQ.html') 
では、文字列 
'http://www.cwi.nl/%7Eguido/FAQ.html' になります。 
allow_fragments 引数は urlparse() における引数と同じ意味を持ちます。 
url がフラグメント指定子を含む場合、フラグメント指定子を持たないバージョンに修正された url と、別の文字列に分割されたフラグメント指定子を返します。 
url 中にフラグメント指定子がない場合、そのままの url と空文字列を返します。 
この RFC では絶対 URL の形式的な文法と意味付けを仕様化しています。 
この RFC には絶対 URL と相対 URL を結合するための規則がボーダケースの取扱い方を決定する ``異常な例'' つきで収められています。 
この RFC では Uniform Resource Name (URN) と Uniform Resource Locator(URL) の両方に対する一般的な文法的要求事項を記述しています。 
ポリシーとして、Pythonは起動時にユーザー毎の設定を行うコードを実行することはしません(ただし対話型セッションで環境変数PYTHONSTARTUPが設定されていた場合にはそのスクリプトを実行します。 )。 
しかしながら、プログラムやサイトによっては、プログラムが要求した時にユーザーごとの設定ファイルを実行できると便利なこともあります。 
このモジュールはそのような機構を実装しています。 
この機構を利用したいプログラムでは、以下の文を実行してください。 
userモジュールはユーザーのホームディレクトリの.pythonrc.pyファイルを探し、オープンできるならグローバル名前空間で実行します(execfile() 
を利用します)。 
この段階で発生したエラーはcatchされません。 userモジュールをimportしたプログラムに影響します。 
どのプログラムが利用しているかわからない状況で、標準のモジュールや関数のふるまいを替えることはおすすめできません。 この機構を使おうとするプログラマへの提案: あなたのパッケージ向けのオプションをユーザーが設定できるようにするシンプルな方法は、.pythonrc.pyファイルで変数を定義して、あなたのプログラムでテストする方法です。 
たとえば、spamモジュールでメッセージ出力のレベルを替える user.spam_verbose変数を参照するには以下のようにします: 
(ユーザがspam_verboseをファイル.pythonrc.py内で定義していない時にgetattr()の3引数形式は使われます。 )大規模な設定の必要があるプログラムではプログラムごとの設定ファイルを作るといいです。 
セキュリティやプライバシーに配慮するプログラムではこのモジュールをimportしないでください。 
サイト毎のカスタマイズを行う機構. 
このモジュールではファイルをuuencode形式(任意のバイナリデータをASCII文字列に変換したもの)にエンコード、デコードする機能を提供します。 引数としてファイルが仮定されている所では、ファイルのようなオブジェクトが利用できます。 
後方互換性のために、パス名を含む文字列も利用できるようにしていて、対応するファイルを開いて読み書きします。 
uuモジュールでは以下の関数を定義しています。 
in_fileをout_fileにエンコードします。 
エンコードされたファイルには、デフォルトでデコード時に利用されるnameとmodeを含んだヘッダがつきます。 
省略された場合には、in_fileから取得された名前か'-' という文字と、0666がそれぞれデフォルト値として与えられます。 
uuencode形式でエンコードされたin_fileをデコードしてvarout_fileに書き出します。 
もしout_fileがパス名でかつファイルを作る必要があるときには、 modeがパーミッションの設定に使われます。 
out_fileとmodeのデフォルト値はin_fileのヘッダから取得されます。 
しかし、ヘッダで指定されたファイルが既に存在していた場合は、uu.Errorが起きます。 
例外Error ( 
Exceptionのサブクラスで、uu.decode()によって、さまざまな状況で起きる可能性があります。 
上で紹介された場合以外にも、ヘッダのフォーマットが間違っている場合や、入力ファイルが途中で区切れた場合にも起きます。 
ASCII からバイナリへ、バイナリからASCIIへの変換をサポートするモジュール。 . 
videoreader は QuickTime ムービーを読み込み、デコードし、プログラムへ渡せます。 
このモジュールはさらにオーディオトラックをサポートしています。 
警告メッセージは一般に、ユーザに警告しておいた方がよいような状況下にプログラムが置かれているが、その状況は (通常は) 例外を送出したりそのプログラムを終了させるほどの正当な理由がないといった状況で発されます。 
例えば、プログラムが古いモジュールを使っている場合には警告を発したくなるかもしれません。 Python プログラマは、このモジュールの warn() 関数を使うことで警告を発することができます。 
(C 言語のプログラマはPyErr_Warn() を使います; 詳細は 
を参照してください)。 警告メッセージは通常 sys.stderr に出力されますが、その処理方法は、全ての警告に対する無視する処理から警告を例外に変更する処理まで、柔軟に変更することができます。 
警告の処理方法は警告カテゴリ (以下参照)、警告メッセージテキスト、そして警告を発したソースコード上の場所に基づいて変更することができます。 
filterwarnings() を呼び出して一致規則をフィルタに追加することができ、resetwarnings() を呼び出してフィルタを標準設定の状態にリセットすることができます。 警告メッセージの印字は showwarning() を呼び出して行うことができ、この関数は上書きすることができます; この関数の標準の実装では、formatwarning() を呼び出して警告メッセージを書式化しますが、この関数についても自作の実装を使うことができます。 
5.17 waste -- Apple製ではない TextEdit の置き換え 
Up: 5. 文書化されていないモジュール 
WASTEウィジェットとライブラリに関する情報サイト。 ドキュメントとダウンロードもここから行なえます。 
waveモジュールは、WAVサウンドフォーマットへの便利なインターフェイスを提供するモジュールです。 
このモジュールは圧縮/展開をサポートしていませんが、モノラル/ステレオには対応しています。 waveモジュールは、以下の関数と例外を定義しています。 
fileが文字列ならその名前のファイルを開き、そうでないならファイルのようにシーク可能なオブジェクトとして扱います。 modeは以下のうちのいずれかです。 
WAVファイルに対して読み込み/書き込み両方のモードで開くことはできないことに注意して下さい。 'r'と'rb'のmodeはWave_readオブジェクトを返し、'w'と'wb'のmodeはWave_writeオブジェクトを返します。 
modeが省略されていて、ファイルのようなオブジェクトがfileとして渡されると、 
file.modeがmodeのデフォルト値として使われます(必要であれば、さらにフラグ"b"が付け加えられます)。 
open()と同義。 後方互換性のために残されています。 
WAVの仕様を犯したり、実装の欠陥に遭遇して何か実行不可能となった時に発生するエラー。 
14.5.1 Wave_read オブジェクト 
弱参照の主な用途は、巨大なオブジェクトを保持するキャッシュやマップ型の実装において、キャッシュやマップ型にあるという理由だけオブジェクトを存続させたくない場合です。 
例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、それぞれに名前を関連付けたいとします。 
Python の辞書型を使って名前を画像に対応付けたり画像を名前に対応付けたりすると、画像オブジェクトは辞書内のキーや値に使われているため存続しつづけることになります。 
weakref モジュールが提供しているWeakKeyDictionary や WeakValueDictionary クラスはその代用で、対応付けを構築するのに弱参照を使い、キャッシュやマップ型に存在するという理由だけでオブジェクトを存続させないようにします。 
例えば、もしある画像オブジェクトが WeakValueDictionary の値になっていた場合、最後に残った画像オブジェクトへの参照を弱参照マップ型が保持していれば、ガーベジコレクションはこのオブジェクトを再利用でき、画像オブジェクトに対する弱参照内の対応付けはそのまま削除されます。 
WeakKeyDictionary や WeakValueDictionary は弱参照を使って実装されていて、キーや値がガーベジコレクションによって回収されたことを弱参照辞書に知らせるような弱参照オブジェクトのコールバック関数を設定しています。 
ほとんどのプログラムが、いずれかの弱参照辞書型を使うだけで必要を満たせるはずです --自作の弱参照辞書を直接作成する必要は普通はありません。 
list やdict など、いくつかの組み込み型は弱参照を直接サポートしませんが、以下のようにサブクラス化を行えばサポートを追加できます: 
弱参照をサポートするために拡張型を簡単に作れます。 
詳細については、3.3.3節 ``拡張型における弱参照''を読んでください。 クラスref 
objectへの弱参照を返します。 
リファレントがまだ生きているならば、元のオブジェクトは参照オブジェクトの呼び出しで取り出せす。 リファレントがもはや生きていないならば、参照オブジェクトを呼び出したときにNone を返します。 
それらはobjectが削除された後でもそれらのハッシュ値を保持します。 
objectが削除されてから初めてhash()が呼び出された場合に、その呼び出しはTypeErrorを発生させます。 弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。 
参照がまだ生きているならば、callbackに関係なく二つの参照はそれらのリファレントと同じ等価関係を持ちます。 
リファレントのどちらか一方が削除された場合、参照オブジェクトが同じオブジェクトである場合に限り、その参照は等価です。 
バージョン 2.4 で 変更 された仕様:以前はファクトリでしたが、サブクラス化可能な型になりました。 object 型から導出されています 
弱参照を使うobjectへのプロキシを返します。 
弱参照オブジェクトとともに用いられる明示的な参照外しを要求する代わりに、これはほとんどのコンテキストにおけるプロキシの利用をサポートします。 
objectが呼び出し可能かどうかに依存して、返されるオブジェクトはProxyTypeまたはCallableProxyTypeのどちらか一方の型を持ちます。 
objectを参照する弱参照とプロキシの数を返します。 
objectを参照するすべての弱参照とプロキシオブジェクトのリストを返します。 
クラスWeakKeyDictionary 
キーを弱く参照するマッピングクラス。 
もはやキーへの強い参照がなくなったときに、辞書のエントリは捨てられます。 
アプリケーションの他の部分が所有するオブジェクトへ属性を追加することもなく、それらのオブジェクトに追加データを関連づけるためにこれを使うことができます。 
これは属性へのアクセスをオーバーライドするオブジェクトに特に便利です。 
注意:注意: WeakKeyDictionary は Python 辞書型の上に作られているので、反復処理を行うときにはサイズ変更してはなりません。 
WeakKeyDictionaryの場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として)「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。 
クラスWeakValueDictionary 
値を弱く参照するマッピングクラス。 
弱参照オブジェクトのための型オブジェクト。 
呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。 
呼び出し可能なオブジェクトのプロキシのための型オブジェクト。 
プロキシのためのすべての型オブジェクトを含むシーケンス。 
これは両方のプロキシ型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単にできます。 
プロキシオブジェクトが使われても、元のオブジェクトがガーベジコレクションされてしまっているときに発生する例外。 
これは標準のReferenceError例外と同じです。 
webbrowserモジュールにはウェブベースのドキュメントを表示するための、とてもハイレベルなインターフェースが定義されています。 
このコントローラーオブジェクトは使い易く、プラットフォーム非依存です。 
たいていの環境では、このモジュールのopen()を呼び出すだけで正しく動作します。 Unixでは、X11上でグラフィカルなブラウザが選択されますが、グラフィカルなブラウザが利用できなかったり、X11が利用できない場合はテキストモードのブラウザが使われます。 
もしテキストモードのブラウザが使われたら、ユーザがブラウザから抜け出すまでプロセスの呼び出しはブロックされます。 Unixでは、環境変数BROWSERが存在するならプラットフォームのデフォルトであるブラウザのリストをオーバーライドし、コロンで区切られたリストの順にブラウザの起動を試みます。 
ブラウザのコントロールエラーが起こると発生する例外。 
以下の関数が定義されています: 
デフォルトのブラウザでurlを表示します。 
newがtrueなら、可能であればブラウザの新しいウィンドウが開きます。 
autoraiseがtrueなら、可能であればウィンドウが前面に表示されます(多くのウィンドウマネージャではこの変数の設定に関わらず、前面に表示されます)。 
可能であれば、デフォルトブラウザの新しいウィンドウでurlを開きますが、そうでない場合はブラウザのただ1つのウィンドウでurlを開きます。 
ブラウザの種類nameのコントローラーオブジェクトを返します。 
もしnameが空文字列なら、呼び出した環境に適したデフォルトブラウザのコントローラーを返します。 
ブラウザの種類nameを登録します。 
ブラウザの種類が登録されたら、get()でそのブラウザのコントローラーを呼び出すことができます。 
instanceが指定されなかったり、Noneなら、インスタンスが必要な時にはconstructorがパラメータなしに呼び出されて作られます。 
instanceが指定されたら、constructorは呼び出されないので、Noneでかまいません。 この登録は、変数BROWSERを設定するか、getを空文字列でなく、宣言したハンドラの名前と一致する引数とともに呼び出すときだけ、役に立ちます。 
いくつかの種類のブラウザがあらかじめ定義されています。 
このモジュールで定義されている、関数get()に与えるブラウザの名前と、それぞれのコントローラークラスのインスタンスを以下の表に示します。 
``Konqueror''はUnixのKDEデスクトップ環境のファイルマネージャで、KDEが動作している時にだけ意味を持ちます。 
何か信頼できる方法でKDEを検出するのがいいでしょう;変数KDEDIRでは十分ではありません。 
また、KDE 2でkonquerorコマンドを使うときにも、``kfm''が使われます -- Konquerorを動作させるのに最も良い方法が実装によって選択されます。 
Windowsプラットフォームのみ;標準拡張モジュールwin32apiとwin32conを必要とします。 
MacOSプラットフォームのみ; 
マニュアルに解説されている標準MacPythonモジュールicを必要とします。 
11.1.1 ブラウザコントローラーオブジェクト 
このモジュールに含まれる唯一の関数はあることを推測します。 つまり、与えられたファイルを開くためには、利用可能なデータベースモジュール( 
、 
)のどれを用いるべきかということです。 
ファイルが読めないか存在しないために開くことが出来ない場合はNone、ファイルの形式を推測できない場合は空の文字列('')、推測できる場合は必要なモジュール名('dbm'、'gdbm'など)を含む文字列を返します。 
リリース 2.1 で撤廃されました。 
を代りに使ってください。 
注意:Python 2.1 以前のリリースでは、このモジュールは 
モジュールの実装における一部でした。 
現在はもう使われていません。 
このモジュールを直接使わないでください; 代わりに 
を使ってください。 This module was an implementation detail of theこのモジュールは Wichmann-Hill による擬似乱数生成器クラスを実装します。 
このクラスはまた、 whrandom と名づけられています。 
このモジュールではまた、Wichmann-Hill アルゴリズムに特有の以下のメソッドを提供しています: 
整数 x、y、z から乱数生成器を初期化します。 
このモジュールが最初に取り込まれたときに、乱数は現在の時刻から取り出された値で初期化されます。 x、y、および z が省略されるか 0 の場合、乱数のシードは現在のシステム時刻から計算されます。 
引数のうち3 つ全てではなく、1 または 2 個だけが 0 の場合、ゼロに鳴っている値は 1 に置き換えられます。 
このことにより、一見して異なるシード値が同じ値になってしまい、乱数生成器から生成される擬似乱数列もこれに対応します。 
空でないシーケンス seq からランダムに要素を選んで返します。 
範囲 [0.0 ... 1.0) から次の浮動小数点数の乱数 N を返します。 
このモジュールが最初にインポートされた際、乱数は現在の時刻から取り出された値で初期化されます。 
であるようなランダムな実数 Nを返します。 
従って、N = whrandom.random() を以下のコード: 
のように書くこともできます。 乱数生成器の別々のインスタンスを使った場合、擬似乱数の列は独立になるので注意してください。 
22.3 winsound -- Windows 用の音声再生インタフェース 
A. ドキュメント化されていないモジュール 
22.3 winsound --Windows 用の音声再生インタフェース 
winsound モジュールは Windows プラットフォーム上で提供されている基本的な音声再生機構へのアクセス手段を提供します。 
このモジュールではいくつかの関数と定数が定義されています。 
システムがスピーカを鳴らすことができない場合、例外 RuntimeError が送出されます。 
注意:Windows 95 および 98 では、Windows の関数 Beep()は存在しますが役に立ちません (この関数は引数を無視します)。 
これらのケースでは、Python はポートを直接操作して Beep() をシミュレートします (バージョン 2.1 で追加されました) 。 
この機能が全てのシステムで動作するかどうかはわかりません。 
プラットフォームの API から関数 PlaySound() を呼び出します。 
引数 sound はファイル名、音声データの文字列、または Noneをとり得ます。 
sound の解釈は flags の値に依存します。 この値は以下に述べる定数をビット単位で OR して組み合わせたものになります。 
システムのエラーが発生した場合、例外 RuntimeError が送出されます。 
根底にある MessageBeep() 関数をプラットフォームの API から呼び出します。 
この関数は音声をレジストリの指定に従って再生します。 
type 引数はどの音声を再生するかを指定します; とり得る値は-1 、 MB_ICONASTERISK 、 MB_ICONEXCLAMATION 、MB_ICONHAND 、 MB_ICONQUESTION 、および MB_OK で、全て以下に記述されています。 
値 -1 は ``単純なビープ音''を再生します; この値は他の場合で音声を再生することができなかった際の最終的な代替音です。 バージョン 2.3 で 新たに追加 された仕様です。 
sound パラメタが WAV ファイル名であることを示します。 
SND_ALIAS と同時に使ってはいけません。 SND_ALIAS 
引数 sound はレジストリにある音声データに関連付けられた名前であることを示します。 
対応するコントロールパネルでの音声名 
例えば以下のように使います: 
音声データを繰り返し再生します。 
システムがブロックしないようにするため、SND_ASYNC フラグを同時に使わなくてはなりません。 
SND_MEMORY と同時に使うことはできません。 
PlaySound() の引数 sound が文字列の形式をとった WAV ファイルのメモリ上のイメージであることを示します。 
注意:このモジュールはメモリ上のイメージを非同期に再生する機能をサポートしていません。 
従って、このフラグと SND_ASYNC を組み合わせると例外 RuntimeError が送出されます。 SND_PURGE 
指定した音声の全てのインスタンスについて再生処理を停止します。 
音声を非同期に再生するようにして、関数呼び出しを即座に返します。 
指定した音声が見つからなかった場合にシステム標準の音声を鳴らさないようにします。 
現在鳴っている音声を中断させないようにします。 
サウンドドライバがビジー状態にある場合、関数がすぐ返るようにします。 
音声 SystemDefault を再生します。 
音声 SystemExclamation を再生します。 
音声 SystemHand を再生します。 
音声 SystemQuestion を再生します。 
2 つの例外クラスが同様にして定義されています。 
クラスPacker 
Packer はデータを XDR 表現にパックするためのクラスです。 
Packer クラスのインスタンス生成は引数なしで行われます。 クラスUnpacker 
Unpacker は Packer と対をなしていて、文字列バッファからXDR をアンパックするためのクラスです。 
入力バッファ dataを引数に与えてインスタンスを生成します。 
このRFC が、かつてこのモジュールが最初に書かれた当時にXDR 標準でであったデータのエンコード方法を定義していました。 
現在は RFC 1832 に更新されているようです。 
こちらが新しい方のRFCで、XDR の改訂版が定義されています。 
12.17.1 Packer オブジェクト 
文書オブジェクトモデル、または ``DOM'' は、ワールドワイドウェブコンソーシアム (World Wide Web Consortium, W3C) による、XML ドキュメントにアクセスしたり変更を加えたりするための、プログラミング言語間共通の API です。 
DOM 実装によって、XML ドキュメントはツリー構造として表現されます。 また、クライアントコード側でツリー構造をゼロから構築できるようになります。 
さらに、前述の構造に対して、よく知られたインタフェースをもつ一連のオブジェクトを通したアクセス手段も提供します。 DOM はランダムアクセスを行うアプリケーションで非常に有用です。 
SAX では、一度に閲覧することができるのはドキュメントのほんの一部分です。 
ある SAX 要素に注目している際には、別の要素をアクセスすることはできません。 
またテキストノードに注目しているときには、その中に入っている要素をアクセスすることができません。 SAX によるアプリケーションを書くときには、プログラムがドキュメント内のどこを処理しているのかを追跡するよう、コードのどこかに記述する必要があります。 
SAX 自体がその作業を行ってくれることはありません。 
さらに、XML ドキュメントに対する先読み (look ahead) が必要だとすると不運なことになります。 アプリケーションによっては、ツリーにアクセスできなければイベント駆動モデルを実現できません。 
もちろん、何らかのツリーをSAX イベントに応じて自分で構築することもできるでしょうが、DOM ではそのようなコードを書かなくてもよくなります。 
DOM は XML データに対する標準的なツリー表現なのです。 文書オブジェクトモデルは、W3C によっていくつかの段階、W3C の用語で言えば ``レベル (level)'' で定義されています。 
Python においては、DOM API への対応付け は実質的には DOM レベル2 勧告に基づいています。 
現在はドラフト形式でのみ入手できる レベル3 仕様への対応付けは、Python XML 分科会 (Special Interest Group) により、PyXML パッケージ の一部として開発中です。 
DOM レベル3 サポートの現在の状態についての情報は、PyXML パッケージに同梱されているドキュメントを参照してください。 
DOM アプリケーションは、普通は XML を DOM に解析するところから始まります。 
どのようにして解析を行うかについては DOM レベル1 では全くカバーしておらず、レベル2 では限定的な改良だけが行われました:レベル2 ではDocument を生成するメソッドを提供するDOMImplementation オブジェクトクラスがありますが、実装に依存しない方法で XML リーダ(reader)/パーザ(parser)/文書ビルダ(Document builder) にアクセスする方法はありません。 また、既存の Document オブジェクトなしにこれらのメソッドにアクセスするような、よく定義された方法もありません。 
Python では、各々の DOM 実装で getDOMImplementation() が定義されているはずです。 
DOM レベル3 ではロード(Load)/ストア(Store) 仕様が追加され、リーダのインタフェースにを定義していますが、Python 標準ライブラリではまだ利用することができません。 DOM 文書オブジェクトを生成したら、そのプロパティとメソッドを使ってXML 文書の一部にアクセスできます。 
これらのプロパティはDOM 仕様で定義されています; 本リファレンスマニュアルでは、Python において DOM 仕様がどのように解釈されているかを記述しています。 W3C から提供されている仕様は、 DOM API を Java、ECMAScript、およびOMG IDL で定義しています。 
ここで定義されている Python での対応づけは、大部分がこの仕様の IDL 版に基づいていますが、厳密な準拠は必要とされていません (実装で IDL の厳密な対応付けをサポートするのは自由ですが)。 
API への対応付けに関する詳細な議論は 13.6.3 、``適合性'' を参照してください。 
Python DOM API が準拠している W3C 勧告。 
xml.dom.minidom でサポートされている W3C の DOMに関する勧告。 
完全な機能をもったDOM 実装を必要とするユーザは PyXML パッケージを利用すべきです。 
このドキュメントでは OMG IDL から Python への対応付けを記述しています。 
13.6.1 モジュールの内容 
xml.dom.minidom は、軽量な文書オブジェクトモデルインタフェースの実装です。 
この実装では、完全な DOM よりも単純で、かつ十分に小さくなるよう意図しています。 DOM アプリケーションは典型的に、XML を DOM に解析 (parse) することで開始します。 
xml.dom.minidom では、以下のような解析用の関数を介して行います: 
parse() 関数はファイル名か、開かれたファイルオブジェクトを引数にとることができます。 
この関数はパーザの文書ハンドラを変更し、名前空間サポートを有効にします; (エンティティリゾルバ (entity resolver) のような) 他のパーザ設定は前もっておこなわなければなりません。 
XML データを文字列で持っている場合、parseString() を代わりに使うことができます: 
string を表現する Document を返します。 
このメソッドは文字列に対する StringIO オブジェクトを生成して、そのオブジェクトを parse に渡します。 
これらの関数は両方とも、文書の内容を表現する Document オブジェクトを返します。 parse() や parseString() といった関数が行うのは、XML パーザを、何らかの SAX パーザからくる解析イベント (parse event) を受け取って DOM ツリーに変換できるような ``DOM ビルダ (DOM builder)'' に結合することです。 
関数は誤解を招くような名前になっているかもしれませんが、インタフェースについて学んでいるときには理解しやすいでしょう。 
文書の解析はこれらの関数が戻るより前に完結します; 要するに、これらの関数自体はパーザ実装を提供しないということです。 ``DOM 実装'' オブジェクトのメソッドを呼び出して Document を生成することもできます。 
このオブジェクトは、 
xml.dom パッケージ、またはxml.dom.minidom モジュールの getDOMImplementation() 関数を呼び出して取得できます。 
xml.dom.minidom モジュールの実装を使うと、常にminidom 実装の Document インスタンスを返します。 
一方、 xml.dom 
版の関数では、別の実装によるインスタンスを返すかもれません (PyXML package がインストールされているとそうなるでしょう)。 
Documentを取得したら、DOM を構成するために子ノードを追加していくことができます: 
DOM 文書オブジェクトを手にしたら、XML 文書のプロパティやメソッドを使って、文書の一部にアクセスすることができます。 
これらのプロパティはDOM 仕様で定義されています。 
文書オブジェクトの主要なプロパティはdocumentElement プロパティです。 
このプロパティはXML 文書の主要な要素: 他の全ての要素を保持する要素、を与えます。 
以下にプログラム例を示します: 
DOM を使い終えたら、後片付けを行わなければなりません。 
Python のバージョンによっては、循環的に互いを参照するオブジェクトに対するガベージコレクションをサポートしていないため、この操作が必要となります。 
この制限が全てのバージョンの Python から除去されるまでは、循環参照オブジェクトが消去されないものとしてコードを書くのが無難です。 DOM を片付けるには、 unlink() メソッドを呼び出します: 
unlink() は、 DOM API に対する xml.dom.minidom 特有の拡張です。 
ノードに対して unlink() を呼び出した後は、ノードとその下位ノードは本質的には無意味なものとなります。 
xml.dom.minidom でサポートされている DOM の W3C 勧告。 
xml.dom.pulldom では、SAX イベントから、文書の文書オブジェクトモデル表現の選択された一部分だけを構築できるようにします。 
クラスPullDOM 
xml.sax.handler.ContentHandler 実装です ... 
クラスDOMEventStream 
クラスSAX2DOM 
parse() の bufsize パラメタのデフォルト値です。 
バージョン 2.1 で 変更 された仕様:この変数の値は parse() を呼び出す前に変更することができ、その場合新たな値が効果を持つようになります 
バージョン 2.0 で 新たに追加 された仕様です。 xml.parsers.expat モジュールは、検証 (validation) を行わない XML パーザ (parser, 解析器)、Expat 
へのPython インタフェースです。 
モジュールは一つの拡張型 xmlparser を提供します。 これはXMLパーザの現在の状況を表します。 
一旦 xmlparser オブジェクトを生成すると、オブジェクトの様々な属性をハンドラ関数 (handler function)に設定できます。 
その後、XML 文書をパーザに入力すると、 XML文書の文字列とマークアップに応じてハンドラ関数が呼び出されます。 
このモジュールでは、Expatパーザへのアクセスを提供するためにpyexpat 
Expat がエラーを報告したときに例外を送出します。 
Expatのエラーを解釈する上での詳細な情報は、 13.5.2 の``ExpatError Exceptions,''を参照してください。 
ExpatErrorへの別名です。 
ParserCreate() 関数から返された戻り値の型を示します。 
xml.parsers.expat モジュールには以下の 2 つの関数が収められています: 
与えられたエラー番号 errno を解説する文字列を返します。 
新しい xmlparser オブジェクトを作成し、返します。 encoding が指定されていた場合、XMLデータで使われている文字列のエンコード名でなければなりません。 
Expatは、Pythonのように多くのエンコードをサポートしておらず、またエンコーディングのレパートリを拡張することはできません; サポートするエンコードは、UTF-8, UTF-16, ISO-8859-1 (Latin1), ASCII です。 
この値は、1文字の文字列でなければなりません; 文字列が誤った長さを持つ場合には ValueError が送出されます (None は値の省略と見なされます) 名前空間の処理が可能なとき、名前空間に属する要素と属性が展開されます。 
要素のハンドラである StartElementHandler と EndElementHandler に渡された要素名は、名前空間のURI、名前空間の区切り文字、要素名のローカル部を連結したものになります。 
名前空間の区切り文字が 0 バイト (chr(0)) の場合、名前空間の URI とローカル部は区切り文字なしで連結されます。 
たとえば、 namespace_separator に空白文字(" ")がセットされ、次のような文書が解析されるとします。 
StartElementHandler は各要素ごとに次のような文字列を受け取ります。 
Expatプロジェクトのホームページ 
SAX API はコンテント・ハンドラ、DTD ハンドラ、エラー・ハンドラ、エンティティ・リゾルバという4つのハンドラを規定しています。 
通常アプリケーション側で実装する必要があるのは、これらのハンドラが発生させるイベントのうち、処理したいものへのインターフェースだけです。 インターフェースは1つのオブジェクトにまとめることも、複数のオブジェクトに分けることも可能です。 
ハンドラはすべてのメソッドがデフォルトで実装されるように、xml.sax で提供される基底クラスを継承しなくてはなりません。 
アプリケーションにとって最も重要なメインの SAX コールバック・インターフェースです。 
このインターフェースで発生するイベントの順序はドキュメント内の情報の順序を反映しています。 
DTD イベントのハンドラです。 未構文解析エンティティや属性など、パースに必要な DTD イベントの抽出だけをおこなうインターフェースです。 
エンティティ解決用の基本インターフェースです。 
このインターフェースを実装したオブジェクトを作成しパーサに登録することで、パーサはすべての外部エンティティを解決するメソッドを呼び出すようになります。 
エラーや警告メッセージをアプリケーションに通知するためにパーサが使用するインターフェースです。 
このオブジェクトのメソッドが、エラーをただちに例外に変換するか、あるいは別の方法で処理するかの制御をしています。 
これらのクラスに加え、xml.sax.handler は機能やプロパティ名のシンボル定数を提供しています。 
値: "http://xml.org/sax/features/namespaces" 
true: 名前空間の処理を有効にする。 
false: オプションで名前空間の処理を無効にする(暗黙に namespace-prefixes も無効にする - デフォルト )。 
アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可 feature_namespace_prefixes 
値: "http://xml.org/sax/features/namespace-prefixes" 
true: 名前空間宣言で用いられているオリジナルのプリフィックス名と属性を通知する。 
false: 名前空間宣言で用いられている属性を通知しない。 
値: "http://xml.org/sax/features/string-interning" 
true: すべての要素名、プリフィックス、属性、名前、名前空間、URI、ローカル名を組込みの intern 関数を使ってシンボルに登録する。 
false: 名前のすべてを必ずしもシンボルに登録しない(デフォルト)。 
アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可 feature_validation 
値: "http://xml.org/sax/features/validation" 
true: すべての妥当性検査エラーを通知する(external-general-entities とexternal-parameter-entities が暗黙の前提になっている)。 
値: "http://xml.org/sax/features/external-general-entities" 
true: 外部一般(テキスト)エンティティの取り込みをおこなう。 
false: 外部一般エンティティを取り込まない。 
アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可 
値: "http://xml.org/sax/features/external-parameter-entities" 
true: 外部 DTD サブセットを含むすべての外部パラメータ・エンティティの取り込みをおこなう。 
false: 外部パラーメタ・エンティティおよび外部 DTD サブセットを取り込まない。 アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可 
すべての機能の一覧。 property_lexical_handler 
値: "http://xml.org/sax/properties/lexical-handler" 
data type: xml.sax.sax2lib.LexicalHandler (Python 2 では未サポート)description: コメントなど字句解析イベント用のオプション拡張ハンドラ。 
アクセス: 読み書き可 
data type: xml.sax.sax2lib.DeclHandler (Python 2 では未サポート)description: ノーテーションや未解析エンティティをのぞく DTD 関連イベント用のオプション拡張ハンドラ。 
data type: org.w3c.dom.Node (Python 2 では未サポート) description: パース時は DOM イテレータにおけるカレント DOM ノード、非パース時はルート DOM ノードを指す。 
アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可 property_xml_string 
値: "http://xml.org/sax/properties/xml-string" 
データ型: 文字列 説明: カレント・イベントの元になったリテラル文字列 アクセス: リードオンリー 
既知のプロパティ名の全リスト。 
13.10.1 ContentHandler オブジェクト 
xml.sax パッケージはPython 用の Simple API for XML (SAX) インターフェースを実装した数多くのモジュールを提供しています。 
またパッケージには SAX 例外と SAX API 利用者が頻繁に利用するであろう有用な関数群も含まれています。 
その関数群は以下の通りです: make_parser 
SAX XMLReader オブジェクトを作成して返します。 
パーサには最初に見つかったものが使われます。 
parser_list を指定する場合は、create_parser() 関数を含んでいるモジュール名のシーケンスを与える必要があります。 
parser_list のモジュールはデフォルトのパーサのリストに優先して使用されます。 
SAX パーサを作成してドキュメントをパースします。 
filename_or_stream として指定するドキュメントはファイル名、ファイル・オブジェクトのいずれでもかまいません。 
handler パラメータには SAX ContentHandler のインスタンスを指定します。 
error_handler には SAX ErrorHandler のインスタンスを指定します。 これが指定されていないときは、すべてのエラーで SAXParseException 例外が発生します。 
関数の戻り値はなく、すべての処理は handler に渡されます。 
parse() に似ていますが、こちらはパラメータ string で指定されたバッファをパースします。 
典型的な SAX アプリケーションでは3種類のオブジェクト(リーダ、ハンドラ、入力元)が用いられます(ここで言うリーダとはパーサを指しています)。 
つまり SAX アプリケーションには、リーダ・オブジェクト、(作成またはオープンされる)入力元のオブジェクト、ハンドラ・オブジェクト、そしてこれら3つのオブジェクトを連携させることが必須なのです。 
Python はインターフェースという明確な概念を提供していないため、形としてはクラスが用いられています。 しかし提供されるクラスを継承せずに、アプリケーション側で独自に実装することも可能です。 
InputSource、Locator、Attributes、AttributesNS、XMLReader の各インターフェースは 
モジュールで定義されています。 ハンドラ・インターフェースは 
しばしばアプリケーション側で直接インスタンスが作成されるInputSource とハンドラ・クラスは利便性のため xml.sax にも含まれています。 
これらのインターフェースに関しては後に解説します。 このほかに xml.sax は次の例外クラスも提供しています。 
例外SAXException 
XML エラーと警告をカプセル化します。 
このクラスには XML パーサとアプリケーションで発生するエラーおよび警告の基本的な情報を持たせることができます。 また機能追加や地域化のためにサブクラス化することも可能です。 
オプションの exception パラメータは None もしくはパース用コードで補足、渡って来る情報でなければなりません。 このクラスはSAX 例外の基底クラスになります。 
例外SAXParseException 
パースエラー時に発生する SAXException のサブクラスです。 パースエラーに関する情報として、このクラスのインスタンスが SAXErrorHandler インターフェースのメソッドに渡されます。 
このクラスは SAXException 同様 SAX Locator インターフェースもサポートしています。 
例外SAXNotRecognizedException 
SAX XMLReader が認識できない機能やプロパティに遭遇したとき発生させる SAXException のサブクラスです。 
SAX アプリケーションや拡張モジュールにおいて同様の目的にこのクラスを利用することもできます。 
例外SAXNotSupportedException 
SAX XMLReader が要求された機能をサポートしていないとき発生させる SAXException のサブクラスです。 
SAX アプリケーションや拡張モジュールにおいて同様の目的にこのクラスを利用することもできます。 
SAX API 定義に関し中心となっているサイトです。 
Java による実装とオンライン・ドキュメントが提供されています。 
実装と SAX API の歴史に関する情報のリンクも掲載されています。 xml.sax.handler 
:モジュール 
SAX アプリケーション向けの有用な関数群. 
13.9.1 SAXException オブジェクト 
モジュール xml.sax.saxutils には SAX アプリケーションの作成に役立つ多くの関数やクラスも含まれており、直接利用したり、基底クラスとして使うことができます。 
文字列データ内の ""、""、"" をエスケープします。 
オプションの entities パラメータに辞書を渡すことで、そのほかの文字をエスケープさせることも可能です。 
辞書のキーと値はすべて文字列で、キーに指定された文字は対応する値に置換されます。 
エスケープされた文字列 "amp;"、"lt;"、"gt;" を元の文字に戻します。 オプションの entities パラメータに辞書を渡すことで、そのほかの文字をエスケープさせることも可能です。 
escape() に似ていますが、data は属性値の作成に使われます。 
戻り値はクォート済みの data で、置換する文字の追加も可能です。 
quoteattr() はクォートすべき文字を data の文脈から判断し、クォートすべき文字を残さないように文字列をエンコードします。 
data の中にシングル・クォート、ダブル・クォートがあれば、両方ともエンコードし、全体をダブルクォートで囲みます。 
戻り値の文字列はそのままで属性値として利用できます。 
この関数は参照具象構文を使って、 HTML や SGML の属性値を生成するのに便利です。 
バージョン 2.2 で 新たに追加 された仕様です。 クラスXMLGenerator 
このクラスは ContentHandler インターフェースの実装で、SAX イベントを XML ドキュメントに書き戻します。 
つまり、XMLGenerator をコンテント・ハンドラとして用いると、パースしたオリジナル・ドキュメントの複製が作れるのです。 out に指定するのはファイル風のオブジェクトで、デフォルトは sys.stdout です。 
encoding は出力ストリームのエンコーディングで、デフォルトは'iso-8859-1' です。 クラスXMLFilterBase 
このクラスは XMLReader とクライアント・アプリケーションのイベント・ハンドラとの間に位置するものとして設計されています。 
デフォルトでは何もせず、ただリクエストをリーダに、イベントをハンドラに、それぞれ加工せず渡すだけです。 しかし、サブクラスでメソッドをオーバーライドすると、イベント・ストリームやリクエストを加工してから渡すように変更可能です。 
この関数は引き数に入力ソース、オプションとして URL を取り、読み取り可能な解決済み InputSource オブジェクトを返します。 
入力ソースは文字列、ファイル風オブジェクト、InputSource のいずれでも良く、この関数を使うことで、パーサは様々な source パラメータをparse() に渡すことが可能になります。 
各 SAX パーサは Python モジュールとして XMLReader インターフェースを実装しており、関数 create_parser() を提供しています。 
この関数は新たなパーサ・オブジェクトを生成する際、xml.sax.make_parser() から引き数なしで呼び出されます。 
クラスXMLReader 
SAX パーサが継承可能な基底クラスです。 
クラスIncrementalParser 
入力ソースをパースする際、すべてを一気に処理しないで、途中でドキュメントのチャンクを取得したいことがあります。 
SAX リーダは通常、ファイル全体を一気に読み込まずチャンク単位で処理するのですが、全体の処理が終わるまで parse() は return しません。 
つまり、IncrementalParser インターフェースは parse() にこのような排他的挙動を望まないときに使われます。 パーサのインスタンスが作成されると、feed メソッドを通じてすぐに、データを受け入れられるようになります。 
SAX イベントとドキュメントの位置を関連付けるインターフェースです。 
locator オブジェクトは DocumentHandler メソッドを呼び出している間だけ正しい情報を返し、それ以外とのときに呼び出すと、予測できない結果が返ります。 
情報を取得できない場合、メソッドは None を返すこともあります。 
クラスInputSource 
クラスAttributesImpl 
Attributes interface(13.12.5 参照)の実装です。 
辞書風のオブジェクトで、startElement() 内で要素の属性表示をおこないます。 
多くの辞書風オブジェクト操作に加え、ほかにもインターフェースに記述されているメソッドを、多数サポートしています。 
このクラスのオブジェクトはリーダによってインスタンスを作成しなければなりません。 また、attrs は 属性名と属性値を含む辞書風オブジェクトでなければなりません。 
クラスAttributesNSImpl 
AttributesImpl を名前空間認識型に改良したクラスで、startElementNS() に渡されます。 
AttributesImpl の派生クラスですが、namespaceURI と localname、この2つのタプルを解釈します。 
さらに、元のドキュメントに出てくる修飾名を返す多くのメソッドを提供します。 
このクラスは 
AttributesNSinterface (section13.12.6 参照) の実装です。 
リリース 2.0 で撤廃されました。 
代わりに 
バージョン 1.5.2 で 変更 された仕様:名前空間のサポートを追加 
クラスXMLParser 
このクラスは次のインターフェース・メソッドとインスタンス変数を提供しています。 
要素名のマッピングへのマッピング・オブジェクトで、デフォルトは空の辞書です。 
このデフォルト変数はすべての XMLParser インスタンスで共有されるため、継承せずにオーバーライドする必要があります。 
なお、要素名のマッピングの方は、その要素に妥当な属性名とそのデフォルトの属性値をマッピングしており、デフォルト値がない場合は None になります。 
要素名からタプルへのマッピングです。 
タプルには要素の開始タグと終了タグをそれぞれ処理する関数、または unknown_starttag() やunknown_endtag() 呼出された場合に使用する None が含まれます。 
デフォルトは空の辞書になっています。 
このデフォルト変数はすべての XMLParser インスタンスで共有されるため、継承せずにオーバーライドする必要があります。 
エンティティ名からその値へのマッピングです。 
デフォルトで 'lt'、 'gt'、 'amp'、 'quot'、 and 'apos' の定義がされています。 
同時に未処理のデータはすべて失われます。 
このメソッドはインスタンス生成時、暗黙裡に呼び出されます。 
タグの処理を中止します。 
このメソッドの呼び出し以降、すべての入力はリテラル(CDATA)として扱われます。 
リテラルモード(CDATA mode)に入ります。 
このモードは最後に処理した開始タグに対応する終了タグが見つかった時点で自動的に終了します。 
テキストをパーサに送ります。 
完全なタグで構成された部分までを処理し、不完全なタグは次のデータが来るか close() が呼び出されるまでバッファリングされます。 
現在バッファリング中のデータの前に end-of-file ファイルが来たものと強制的にみなします。 
このメソッドは派生クラスにおいて、入力終了時におこなう追加処理のために再定義されることもありますが、再定義したメソッドの中で必ずこの close() を呼び出さなければなりません。 
data の中にある実体参照と文字参照をすべて変換し、変換後の文字列を返します。 
現在有効な名前空間の短縮名から名前空間 URI へのマッピングを返します。 
このメソッドは "?xml ...?" タグを処理します。 引数はタグ中のエンコーディングの値とスタンドアロン宣言です。 
エンコーディングとスタンドアロン属性はともにオプションです。 
デフォルトはそれぞれ None と文字列 'no' になります。 
引数にはルート要素のタグ名、公式公開識別子 
(指定されていない場合は None)、システム識別子、および内部 DTD サブセットを処理せずそのまま文字列で指定します(指定されていない場合は None)。 
このメソッドはインスタンス変数 elements にハンドラが定義されている開始タグを処理します。 
tag はタグ名で、method は開始タグの意味解析サポートに使われる関数(メソッド)です。 
attributes は タグ内に記述されている属性名がキー、属性値を値として持つ辞書になります。 
文字およびエンティティの参照は解釈されます。 
たとえば、開始タグ A HREF="http://www.cwi.nl/" に対するこのメドッドの呼出しは handle_starttag('A', self.elements['A'][0], {'HREF':'http://www.cwi.nl/'}) となります。 
基本的な実装は単純で、引数に attributes を使い、method を呼び出すだけのものです。 
このメソッドはインスタンス変数 elements にハンドラが定義されている終了タグを処理します。 
tag はタグ名で、method は終了タグの意味解析サポートに使われる関数(メソッド)です。 
たとえば、終了タグ /A に対するこのメドッドの呼出しは handle_endtag('A',self.elements['A'][1]) となります。 
基本的な実装は単純で、method を呼び出すだけのものです。 
これは任意のデータを処理するメソッドです。 
派生クラスでオーバライドして使います。 基底クラスの実装では何もおこないません。 
この値が ASCII に変換された後、その文字列を引数にしてメソッド handle_data() が呼び出されます。 
ref の値が許容範囲外のときは、エラーハンドリングのためにunknown_charref(ref) が呼び出されます。 
ASCII 範囲外の文字をサポートするには、サブクラスでこのメソッドをオーバーライドする必要があります。 
コメントを検出すると、このメソッドが呼び出されます。 
引数 comment は、デリミタ "!-" から "-" の間にある文字列であり、デリミタ自体は含まれません。 
たとえばコメント "!-text-" を処理する場合、引数は 'text' でこのメソッドが呼び出されます。 
このメソッドはデフォルトでは何もしません。 
CDATA 要素を検出すると、このメソッドが呼び出されます。 
引数 data は、デリミタ "![CDATA[" と "]]" の間にある文字列であり、デリミタ自体は含まれません。 
たとえばエンティティ "![CDATA[text]]" を処理する場合、引数は 'text' でこのメソッドが呼び出されます。 
このメソッドはデフォルトでは何もしないため、オーバーライドして使用します。 
処理命令 (PI) を検出すると、このメソッドが呼び出されます。 
引数 name は処理命令のターゲット、data は、処理命令ターゲットと終了デリミタの間にある文字列であり、デリミタ自体は含まれません。 
たとえば命令 "?XML text?" を処理する場合、引数は 'XML' と 'text' の2つでこのメソッドが呼び出されます。 
このメソッドはデフォルトでは何もしません。 
なおドキュメントの冒頭に現れる "?xml ..?" は handle_xml() で処理されます。 
宣言を検出すると、このメソッドが呼び出されます。 
引数 data は、デリミタ "!" と "" の間にある文字列であり、デリミタ自体は含まれません。 
たとえば 
エンティティ宣言 "!ENTITY text" を処理する場合、引数は 'ENTITY text' でこのメソッドが呼び出されます。 
このメソッドはデフォルトでは何もしないため、オーバーライドして使用します。 
なおドキュメントの冒頭に現れる"!DOCTYPE ..." は別途処理しなければなりません。 
シンタックスエラーが発生すると、このメソッドが呼び出されます。 
引数 message はエラー内容を知らせるテキストです。 
このメソッドはデフォルトで RuntimeError 例外を発生させます。 
メソッドをオーバライドして、return するように変えることも可能です。 
なお、このメソッドが呼び出されるのは回復可能なエラーの場合だけです。 
回復不能なエラー発生したときは、syntax_error() を呼び出すことなくRuntimeError が発生します。 
未知の開始タグを検出すると、このメドッドが呼び出されます。 
派生クラスでオーバライドして使います。 基底クラスの実装では何もおこないません。 
未知の終了タグを検出すると、このメドッドが呼び出されます。 
解決できない文字参照を検出すると、このメドッドが呼び出されます。 派生クラスでオーバライドして使います。 
基底クラスの実装では何もおこないません。 
解決できない実体参照を検出すると、このメドッドが呼び出されます。 
派生クラスでオーバライドして使います。 基底クラスの実装では syntax_error() でエラーを通知するようになっています。 
World Wide Web Consortium (W3C) が送出した XML の仕様書で、XML のシンタックスと処理に必要な内容が定義されています。 
仕様書の翻訳など、そのほかの文献は http://www.w3.org/XML/ で参照できます。 
Python XML トピックガイドは Python で XML を扱うための情報と XML 関連情報源へのリンクを数多く提供しています。 
Python XML Special Interest Group は Python で XML を扱うための開発に多大な貢献をしています。 
...ないます。 
実際には、パーサに非標準的な形式のドキュメントを許容するための、いくつかのキーワード引数を指定できるようになっており、その内容は次の通りです。 
これらのデフォルト値はすべて 0 (false) ですが、最後のキーワード引数だけは 1 (true)になっています。 
accept_unquoted_attributes (特定の属性がクォートされていなくても受け入れるようにする)、 accept_missing_endtag_name (/のようなタグ名なしの終了タグを許容する)、map_case (タグや属性名が大文字で書かれていても、小文字で解釈する)、 accept_utf8 (UTF-8文字列の入力を許容する。 これは XML 標準規格で必須とされている内容ですが、Python は今のところ UTF-8 を適切に処理できないため、デフォルトでは無効になっています。 
)、 translate_attribute_references (属性値として使われている文字列や実体参照はそれ以上解釈しない。 ) 
XML-RPCはXMLを利用した遠隔手続き呼び出し(Remote Procedure Call)の一種で、HTTPをトランスポートとして使用します。 
XML-RPCでは、クライアントはリモートサーバ(URIで指定されたサーバ)上のメソッドをパラメータを指定して呼び出し、構造化されたデータを取得します。 
このモジュールは、XML-RPCクライアントの開発をサポートしており、Pythonオブジェクトに適合する転送用XMLの変換の全てを行います。 
クラスServerProxy 
ServerProxyは、リモートのXML-RPCサーバとの通信を管理するオブジェクトです。 
最初のパラメータはURI(Uniform Resource Indicator)で、通常はサーバのURLを指定します。 
2番目のパラメータにはトランスポート・ファクトリを指定する事ができます。 トランスポート・ファクトリを省略した場合、URLがhttps: ならモジュール内部のSafeTransportインスタンスを使用し、それ以外の場合にはモジュール内部のTransportインスタンスを使用します。 
オプションの 3 番目の引数はエンコード方法で、デフォルトでは UTF-8です。 
オプションの 4 番目の引数はデバッグフラグです。 
allow_none が真の場合、Python の定数 None は XMLに翻訳されます; デフォルトの動作は None に対してTypeError を送出します。 
この仕様は XML-RPC 仕様でよく用いられている拡張ですが、全てのクライアントやサーバでサポートされているわけではありません;詳細記述については http://ontosys.com/xml-rpc/extensions.html を参照してください。 
HTTP及びHTTPS通信の両方で、http://user:pass@host:port/pathのようなHTTP基本認証のための拡張URL構文をサポートしています。 
user:passはbase64でエンコードしてHTTPの`Authorization'ヘッダとなり、XML-RPCメソッド呼び出し時に接続処理の一部としてリモートサーバに送信されます。 
リモートサーバが基本認証を要求する場合のみ、この機能を利用する必要があります。 生成されるインスタンスはリモートサーバへのプロクシオブジェクトで、RPC呼び出しを行う為のメソッドを持ちます。 
リモートサーバがイントロスペクションAPIをサポートしている場合は、リモートサーバのサポートするメソッドを検索(サービス検索)やサーバのメタデータの取得なども行えます。 
ServerProxyインスタンスのメソッドは引数としてPythonの基礎型とオブジェクトを受け取り、戻り値としてPythonの基礎型かオブジェクトを返します。 
以下の型をXMLに変換(XMLを通じてマーシャルする)する事ができます(特別な指定がない限り、逆変換でも同じ型として変換されます): 
名前 
定数TrueとFalse 
整数 
そのまま 
浮動小数点 
文字列 
配列 
変換可能な要素を含むPythonシーケンス。 
戻り値はリスト。 
構造体 
Pythonの辞書。 
キーは文字列のみ。 全ての値は変換可能でなくてはならない。 
日付 
エポックからの経過秒数。 引数として指定する時はDataTimeラッパクラスのインスタンスを使用する。 
バイナリ 
Binaryラッパクラスのインスタンス 
上記のXML-RPCでサポートする全データ型を使用することができます。 
メソッド呼び出し時、XML-RPCサーバエラーが発生するとFaultインスタンスを送出し、HTTP/HTTPSトランスポート層でエラーが発生した場合にはProtocolErrorを送出します。 
Python 2.2以降では組み込み型のサブクラスを作成する事ができますが、現在のところxmlrpclibではそのようなサブクラスのインスタンスをマーシャルすることはできません。 文字列を渡す場合、""・""・""などのXMLで特殊な意味を持つ文字は自動的にエスケープされます。 
しかし、ASCII値0〜31の制御文字などのXMLで使用することのできない文字を使用することはできず、使用するとそのXML-RPCリクエストはwell-formedなXMLとはなりません。 
そのような文字列を渡す必要がある場合は、後述のBinaryラッパクラスを使用してください。 
Serverは、上位互換性の為にServerProxyの別名として残されています。 
新しいコードではServerProxyを使用してください。 
ZIP は一般によく知られているアーカイブ(書庫化)および圧縮の標準ファイルフォーマットです。 このモジュールでは ZIP 形式のファイルの作成、読み書き、追記、書庫内のファイル一覧の作成を行うためのツールを提供します。 
より高度な使い方でこのモジュールを利用したいなら、 
不備のある ZIP ファイル操作の際に送出されるエラー 
ZIP ファイルの読み書きのためのクラスです。 
コンストラクタの詳細については、``ZipFile オブジェクト'' (7.18.1 節) を参照してください。 
Python ライブラリを含む ZIP アーカイブを生成するためのクラスです。 
クラスZipInfo 
アーカイブ中のメンバに関する情報を提供するために用いられるクラスです。 
このクラスのインスタンスは ZipFile オブジェクトのgetinfo() および infolist() メソッドによって返されます。 
zipfile モジュールを利用するほとんどのユーザはこのオブジェクトを自ら生成する必要はなく、モジュールが生成して返すオブジェクトを利用するだけでしょう。 filename はアーカイブメンバの完全な名前で、date_time は ファイルの最終更新時刻を記述する、 6 つのフィールドからなるタプルでなくてはなりません。 
各フィールドについては7.18.3, ``ZipInfo オブジェクト'' 節を参照してください。 is_zipfile 
filename が正しいマジックナンバをもつ ZIP ファイルのときにTrue を返し、そうでない場合 False を返します。 
このモジュールは現在のところ、コメントを追記した ZIP ファイルを扱うことができません。 
アーカイブメンバが圧縮されていないことを表す数値定数です。 
通常の ZIP 圧縮手法を表す数値定数。 
ZIP 圧縮は zlib モジュールを必要とします。 
現在のところ他の圧縮手法はサポートされていません。 
ZIP ファイル形式およびアルゴリズムを作成した Phil Katz によるドキュメント。 
Info-ZIP プロジェクトによる ZIP アーカイブプログラム及びプログラム開発ライブラリに関する情報。 
このモジュールでは、データ圧縮を必要とするアプリケーションが zlib ライブラリを使って圧縮および解凍を行えるようにします。 
圧縮および解凍時のエラーによって送出される例外。 
string のAdler-32 チェックサムを計算します。 
(Adler-32 チェックサムは、おおむね CRC32 と同等の信頼性を持ちながらはるかに高速に計算することができます。 
)value が与えられていれば、value はチェックサム計算の初期値として使われます。 それ以外の場合には固定のデフォルト値が使われます。 
この機能によって、複数の入力文字列を結合したデータ全体にわたり、通しのチェックサムを計算することができます。 
このアルゴリズムは暗号法論的には強力とはいえないので、認証やデジタル署名などに用いるべきではありません。 
このアルゴリズムはチェックサムアルゴリズムとして用いるために設計されたものなので、汎用的なハッシュアルゴリズムには向きません。 
デフォルトの値は 6 です。 
圧縮時に何らかのエラーが発生した場合、 error 例外を送出します。 
string の CRC (Cyclic Redundancy Check, 巡回符号方式) 
チェックサムを計算します。 
value が与えられていれば、チェックサム計算の初期値として使われます。 
与えられていなければデフォルトの初期値が使われます。 
value を与えることで、複数の入力文字列を結合したデータ全体にわたり、通しのチェックサムを計算することができます。 
このアルゴリズムは暗号法論的には強力ではなく、認証やデジタル署名に用いるべきではありません。 
アルゴリズムはチェックサムアルゴリズムとして設計されてえいるので、汎用のハッシュアルゴリズムには向きません。 
string 内のデータを解凍して、解凍されたデータを含む文字列を返します。 
wbits パラメタはウィンドウバッファの大きさを制御します。 
bufsize が与えられていれば、出力バッファの書記サイズとして使われます。 
解凍処理に何らかのエラーが生じた場合、error 例外を送出します。 wbits の絶対値は、データを圧縮する際に用いられるヒストリバッファのサイズ (ウィンドウサイズ) に対し、 2 を底とする対数をとったものです。 
最近のほとんどのバージョンの zlib ライブラリを使っているなら、wbits の絶対値は 8 から 15 とするべきです。 より大きな値はより良好な圧縮につながりますが、より多くのメモリを必要とします。 
デフォルトの値は 15 です。 
wbits の値が負の場合、標準的な gzip ヘッダを出力しません。 これは zlib ライブラリの非公開仕様であり、unzip の圧縮ファイル形式に対する互換性のためのものです。 
bufsize は解凍されたデータを保持するためのバッファサイズの初期値です。 
バッファの空きは必要に応じて必要なだけ増加するので、なれば、必ずしも正確な値を指定する必要はありません。 この値のチューニングでできることは、 malloc() が呼ばれる回数を数回減らすことぐらいです。 
デフォルトのサイズは 16384 です。 
メモリ上に一度に展開できないようなデータストリームを解凍するために用いられる解凍オブジェクトを返します。 
wbits パラメタはウィンドウバッファのサイズを制御します。 
圧縮オブジェクトは以下のメソッドをサポートします: 
string を圧縮し、圧縮されたデータを含む文字列を返します。 この文字列は少なくとも string に相当します。 
このデータは以前に呼んだcompress() が返した出力と結合することができます。 
入力の一部は以後の処理のために内部バッファに保存されることもあります。 
未処理の入力データが処理され、この未処理部分を圧縮したデータを含む文字列が返されます。 mode は定数 Z_SYNC_FLUSH 、Z_FULL_FLUSH 、または Z_FINISH のいずれかをとり、デフォルト値は Z_FINISH です。 
Z_SYNC_FLUSH およびZ_FULL_FLUSH ではこれ以後にもデータ文字列を圧縮できるモードで、解凍時の部分的なエラーリカバリを可能にします。 一方、Z_FINISH は圧縮ストリームを閉じ、これ以後のデータの圧縮を禁止します。 
mode に Z_FINISH を設定してflush() メソッドを呼び出した後は、compress() メソッドを再び呼ぶべきではありません。 唯一の現実的な操作はこのオブジェクトを削除することだけです。 
解凍オブジェクトは以下のメソッドと 2 つの属性をサポートします: 
圧縮データの末尾までのバイト列が入った文字列です。 
すなわち、この値は圧縮データの入っているバイト列の最後の文字までが読み出せるかぎり "" となります。 
解凍されたデータを収めるバッファの長さ制限を超えたために、最も最近のdecompress 呼び出しで処理しきれなかったデータを含む文字列です。 
このデータはまだ zlib 側からは見えていないので、正しい解凍出力を得るには以降の decompress メソッド呼び出しに (場合によっては後続のデータが追加された) データを差し戻さなければなりません。 
[max_length] string を解凍し、少なくとも string の一部分に対応する解凍されたデータを含む文字列を返します。 
このデータは以前にdecompress() メソッドを呼んだ時に返された出力と結合することができます。 
入力データの一部分が以後の処理のために内部バッファに保存されることもあります。 オプションパラメタ max_length が与えられると、返される解凍データの長さが max_length 以下に制限されます。 
このことは入力した圧縮データの全てが処理されるとは限らないことを意味し、処理されなかったデータは unconsumed_tail 属性に保存されます。 
解凍処理を継続したいならば、この保存されたデータを以降のdecompress() 呼び出しに渡さなくてはなりません。 
max_length が与えられなかった場合、全ての入力が解凍され、unconsumed_tail 属性は空文字列になります。 
未処理の入力データを全て処理し、最終的に圧縮されなかった残りの出力文字列を返します。 
flush() を呼んだ後、 decompress() を再度呼ぶべきではありません。 このときできる唯一現実的な操作はオブジェクトの削除だけです。 
モジュールオブジェクト固有の関数は数個しかありません。 
この PyTypeObject のインスタンスは Python のモジュールオブジェクト型を表現します。 
このオブジェクトは、Python プログラムには types.ModuleType として公開されています。 
o がモジュールオブジェクトかモジュールオブジェクトのサブタイプであるときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
o がモジュールオブジェクトで、かつモジュールオブジェクトのサブタイプでないときに真を返します。 
PyModule_Type.バージョン 2.2 で 新たに追加 された仕様です。 PyObject* 
__name__ 属性が name に設定された新たなモジュールオブジェクトを返します。 
モジュールの __doc__ および__name__ 属性だけに値が入っています; __file__属性に値を入れるのは呼び出し側の責任です。 
module の名前空間を実現する辞書オブジェクトを返します;このオブジェクトはモジュールオブジェクトの __dict__と同じです。 
この関数が失敗することはありません。 
拡張モジュールでは、この関数で得たモジュールの__dict__ を直接いじるより、他のPyModule_*() およびPyObject_*() 関数を使うよう勧めます。 
module の __name__ の値を返します。 
モジュールがこの属性を提供していない場合や文字列型でない場合、SystemError を送出して NULL を返します。 
module をロードするために使ったファイルの名前を、moduleの __file__ 属性から調べて返します。 
__file__が定義されていない場合や文字列型でない場合、SystemError を送出して NULL を返します。 
module にオブジェクトをname として追加します。 
この関数はモジュールの初期化関数から利用される便宜関数です。 
エラーのときには -1 を、成功したときには 0 を返します。 
バージョン 2.0 で 新たに追加 された仕様です。 
module に整数定数をname として追加します。 
この便宜関数はモジュールの初期化関数から利用されています。 
エラーのときには -1 を、成功したときには 0 を返します。 バージョン 2.0 で 新たに追加 された仕様です。 
module に文字列定数をname として追加します。 
文字列 value は null 終端されていなければなりません。 
エラーのときには -1 を、成功したときには 0 を返します。 バージョン 2.0 で 新たに追加 された仕様です。 
クラスMorsel 
RFC 2109の属性をキーと値で保持するabstractクラスです。 Morselは辞書風のオブジェクトで、キーは次のようなRFC 2109準拠の定数となっています。 
キーの大小文字は区別されます。 
クッキーの値。 
実際に送信する形式にエンコードされたcookieの値。 
cookieの名前。 
メンバkey、value、coded_valueに値をセットします。 
KがMorselのキーであるかどうかを判定します。 
MoselをHTTPヘッダ形式の文字列表現にして返します。 
attrs を指定しない場合、デフォルトですべての属性を含めます。 
ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と同様に動作する埋め込み可能なJavaScript snippetを返します。 attrsの意味はoutput()と同じです。 
Moselの文字列表現をHTTPやJavaScriptで囲まずに出力します。 attrsの意味はoutput()と同じです。 
読み出し待ちの打鍵イベントが存在する場合に真を返します。 
打鍵を読み取り、読み出された文字を返します。 
コンソールには何もエコーバックされません。 
この関数呼び出しは読み出し可能な打鍵がない場合にはブロックしますが、文字を読み出せるようにするために Enter の打鍵を待つ必要はありません。 打鍵されたキーが特殊機能キー (function key) である場合、この関数は '000' または 'xe0' を返します; キーコードは次に関数を呼び出した際に返されます。 
この関数でControl-C の打鍵を読み出すことはできません。 
getch() に似ていますが、打鍵した字が印字可能な文字の場合エコーバックされます。 
キャラクタ char をバッファリングを行わないでコンソールに出力します。 
キャラクタ char をコンソールバッファに ``押し戻し (push back)'' ます; これにより、押し戻された文字は getch() や getche() で次に読み出される文字になります。 
C 言語による実行時システムにおけるファイル記述子 fd に基づいて、ファイルの一部にロックをかけます。 
一つのファイルの複数の領域を同時にロックすることは可能ですが、領域が重複してはなりません。 
連接する領域をまとめて指定することはできません; それらの領域は個別にロック解除しなければなりません。 
指定されたバイト列にロックをかけます。 
指定領域がロックできなかった場合、プログラムは 1 秒後に再度ロックを試みます。 
10 回再試行した後でもロックをかけられない場合、IOErrorが送出されます。 
指定領域はあらかじめロックされていなければなりません。 
ファイル記述子 fd に対して、行末文字の変換モードを設定します。 
テキストモードに設定するには、flags を os.O_TEXTにします; バイナリモードにするには os.O_BINARY にします。 
C 言語による実行時システムにおけるファイル記述子をファイルハンドルhandle から生成します。 
返されるファイル記述子は os.fdopen() でファイルオブジェクトを生成するために使うことができます。 
ファイル記述子 fd のファイルハンドルを返します。 
fdが認識できない場合、 IOError を送出します。 
malloc() されたヒープ領域を強制的に消去させて、未使用のメモリブロックをオペレーティングシステムに返します。 
この関数はWindows NT 上でのみ動作します。 
失敗した場合、 IOErrorを送出します。 
6.29.4 ログイベントをネットワーク越しに送受信する 
コンソールとファイルに、別々のメッセージ書式で、別々の状況に応じたログ出力を行わせたいとしましょう。 
例えば DEBUG よりも高いレベルのメッセージはファイルに記録し、INFO 以上のレベルのメッセージはコンソールに出力したいという場合です。 
また、ファイルにはタイムスタンプを記録し、コンソールには出力しないとします。 
このスクリプトを実行すると、コンソールには以下のように表示されるでしょう: 
そして、ファイルは以下のようになるはずです: 
ご覧のように、 DEBUG メッセージはファイルだけに出力され、その他のメッセージは両方に出力されます。 
この例題では、コンソールとファイルのハンドラだけを使っていますが、実際には任意の数のハンドラや組み合わせを使えます。 
mutex には以下のメソッドがあります: 
mutex がロックされているかどうか調べます。 
「原子的 (Atomic)」な Test-and-Set 操作です。 
ロックがセットされていなければ獲得して True を返します。 それ以外の場合にはFalseを返します。 
mutex がロックされていなければ function(argument) を実行します。 
mutex がロックされている場合、関数とその引数をキューに置きます。 キューに置かれた 
function(argument) がいつ実行されるかについてはunlockを参照してください。 
キューが空ならば mutex をロック解除します。 そうでなければ、キューの最初の要素を実行します。 
名前 (name) 
とは、オブジェクトを参照するものを指します。 
名前への束縛 (name binding) 操作を行うと、名前を導入できます。 
プログラムテキスト中に名前が出現するたびに、その名前が使われている最も内側の関数ブロック中で作成された束縛 (binding) を使って名前の参照が行われます。 
ブロック (block) 
は、Python のプログラムテキストからなる断片で、一つの実行単位となるものです。 
モジュール、関数本体、そしてクラス定義はブロックです。 
また、対話的に入力された個々のコマンドもブロックです。 
スクリプトファイル (インタプリタに標準入力として与えたり、コマンドラインの第一引数として指定したファイル) は、コードブロックです。 
スクリプトコマンド (インタプリタのコマンドライン上で`-c' オプションを使って指定したコマンド) もコードブロックです。 
組み込み関数 eval() や exec 文に渡した文字列もコードブロックになります。 
組み込み関数 input() から読み取られ、評価される式もまた、コードブロックです。 
また、現在のコードブロックの実行が完了した際に、どのようにプログラムの実行を継続するかを決定しています。 スコープ (scope) 
は、ある名前があるブロック内で参照できるかどうかを決めます。 
ローカル変数があるブロック内で定義されている場合、変数のスコープはそのブロックを含みます。 
関数ブロック内で名前の定義を行った場合、その名前に対して別の束縛を行っているブロックを除いた、関数内の全てのブロックを含むようにスコープが拡張されます。 
クラス内で定義された名前のスコープは、クラスのブロック内に制限されます; スコープがメソッドのコードブロックを含むよう拡張されることはありません。 ある名前がコードブロック内で使われると、その名前を最も近傍から囲うようなスコープ (最内スコープ: nearest enclosing scope) を使って束縛の解決を行います。 
こうしたスコープからなる、あるコードブロック内で参照できるスコープ全ての集合は、ブロックの 環境 (environment) と呼ばれます。 
ある名前がブロック内で束縛されている場合、名前はそのブロックにおけるローカル変数 (local variable) です。 
ある名前がモジュールレベルで束縛されている場合、名前はグローバル変数 (global variable) です。 
(モジュールコードブロックの変数は、ローカル変数でもあるし、グローバル変数でもあります。 
)ある変数がコードブロック内で使われているが、そのブロックでは定義されていない場合、変数は自由変数 (free variable) 
です。 ある名前の定義がどこにもない場合、NameError 
例外が送出されます。 
名前がまだ束縛されていないローカルな変数を参照した場合、UnboundLocalError 
例外が送出されます。 
UnboundLocalError は、NameError のサブクラスです。 名前への束縛は、以下の文構成 (construct): 関数の仮引数 (formal parameter)指定、import 文、クラスや関数の定義 (定義を行ったブロック中で、クラスや関数名の束縛が行われます)、代入時に、代入対象が識別子である場合、for ループのヘッダ、または第二形式のexcept 文ヘッダ、で行われます。 
形式の import 文は、import しようとするモジュール内で定義されている名前について、アンダースコアから始まっている名前以外の全てを束縛します。 
この形式は、モジュールレベルでしか使うことができません。 del 文で指定された対象は、(del の意味付けは、実際は名前の解放 (unbind) ですが) 文の目的上、束縛済みのものとみなされます。 
このため、ある名前が束縛される前にブロック内で使われるとエラーを引き起こす可能性があります。 この規則はやや微妙です。 
Python には宣言文がなく、コードブロックのどこで名前束縛操作を行ってもかまいません。 
あるコードブロックにおけるローカル変数は、ブロック全体から名前束縛操作が行われている部分を走査して決定します。 global 文で指定された名前がブロック内にある場合、その名前は常にトップレベルの名前空間で束縛された名前を参照します。 
それらの名前はグローバル名前空間、すなわちコードブロックが収められているモジュールの名前空間とモジュール名 __builtin__で表される組み込み名前空間、を検索することによって、トップレベルの名前空間で解決されます。 グローバル名前空間は、常に最初に検索されます。 
名前がグローバル名前空間中に見つからない場合、組み込み名前空間が検索されます。 
global 文は、その名前が使われている全ての文に先立って記述されていなければなりません。 
あるコードブロックの実行時に関連付けられる組み込み名前空間は、実際にはコードブロックのグローバル名前空間内に入っている名前__builtins__ を参照する形になっています; __builtins__ は辞書かモジュール (後者の場合にはモジュールの辞書が使われます)でなければなりません。 
通常、__builtins__ 名前空間は、組み込みモジュール __builtin__ (注意: `s' なし)のモジュール辞書です。 
そうでない場合、制限実行 (restricted execution) 
モードが有効になっています。 あるモジュールの名前空間は、そのモジュールが最初に import された時に自動的に作成されます。 
スクリプトの主モジュール (main module)は常に __main__ と呼ばれます。 
グローバル文は、同じブロックの束縛操作と同じスコープを持ちます。 
ある自由変数の最内スコープに global 文がある場合、その自由変数はグローバル変数とみなされます。 クラス定義は一つの実行文で、名前の使用や定義を行います。 
クラス定義への参照は、通常の名前解決規則に従います。 クラス定義の名前空間は、そのクラスの属性辞書になります。 
クラスのスコープで定義された名前は、メソッドからは見えません。 
4.1.1 動的な機能とのやりとり 
12. インターネット上のデータの操作 この章ではインターネット上で一般的に利用されているデータ形式の操作をサポートするモジュール群について記述します. 
汎用の出力書式化機構およびデバイスインタフェース。 
電子メールのメッセージを解析、操作および生成を支援するパッケージ。 これには MIME 文書もふくまれる。 
電子メールのメッセージを表現する基底クラス 
電子メールメッセージのフラットなテキストを解析し、メッセージオブジェクト構造体を生成する。 
メッセージ構造からフラットな電子メールテキストを生成する。 
非ASCII形式のヘッダを表現する 
文字セット 
電子メールメッセージのペイロードのためのエンコーダ。 email.Errors 
email パッケージで使われる例外クラス 
電子メールパッケージの雑多なユーティリティ。 
メッセージオブジェクトツリーをたどる。 
mailcap ファイルの操作。 
様々なメールボックス形式の読み出し。 
Python から MH のメイルボックスを操作します。 
MIME-スタイルのメッセージ本体を解析するためのツール。 
ファイル名拡張子の MIME 型へのマッピング。 
汎用 MIME ファイルライター。 
電子メイルメッセージの MIME 化および非 MIME 化。 
MIME データのような、個別の部分を含んだファイル群に対する読み出しのサポート。 
RFC 2822 形式のメイルメッセージを解釈します。 
RFC 3548: Base16, Base32, Base64 テータの符号化 
バイナリと各種 ASCIIコード化バイナリ表現との間の変換を行うツール群。 
binhex4 形式ファイルのエンコードおよびデコード。 
MIME quoted-printable 形式ファイルのエンコードおよびデコード。 
uuencode形式のエンコードとデコードを行う。 
外部データ表現 (XDR, External Data Representation) データのエンコードおよびデコード。 
.netrc ファイル群の読み出し。 
robots.txt ファイルを読み出し、他の URL に対する取得可能性の質問に答えるクラス。 
デリミタで区切られた形式のファイルに対するテーブル状データ読み書き。 
netrc インスタンスは以下のメソッドを持っています: 
host の認証情報として、三要素のタプル (login, account, password) を返します。 
与えられた host に対するエントリが netrc ファイルにない場合、`default' エントリに関連付けられたタプルが返されます。 
host に対応するエントリがなく、default エントリもない場合、None を返します。 
netrc のインスタンスは以下の公開されたインスタンス変数を持っています: 
ホスト名を (login, account, password) からなるタプルに対応づけている辞書です。 
`default' エントリがある場合、その名前の擬似ホスト名として表現されます。 
マクロ名を文字列のリストに対応付けている辞書です。 
+ 注意:Passwords are limited to a subset of the ASCII character set.+ Versions of this module prior to 2.3 were extremely limited. Starting with+ 2.3, all ASCII punctuation is allowed in passwords. However, note that+ whitespace and non-printable characters are not allowed in passwords. This+ is a limitation of the way the .netrc file is parsed and may be removed in+ the future. 
注意:利用可能なパスワードの文字セットは、ASCIIのサブセットのみです。 
2.3より前のバージョンでは厳しく制限されていましたが、2.3以降ではASCIIの記号を使用することができます。 しかし、空白文字と印刷不可文字を使用することはできません。 
この制限は.netrcファイルの解析方法によるものであり、将来解除されます。 
以下のメソッドは新しい形式のクラス (new-style class) のみに適用されます。 
クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。 
10.1 オブジェクトをヒープ上にメモリ確保する 
10. オブジェクト実装サポート (object implementation support) 
この章では、新しいオブジェクト型 (new object type) を定義する際に使われる関数、型、およびマクロについて説明します。 
10.9 循環参照ガベージコレクションをサポートする 
NNTP インスタンスは以下のメソッドを持っています。 
全てのメソッドにおける戻り値のタプルで最初の要素となる response は、サーバの応答です: この文字列は 3 桁の数字からなるコードで始まります。 サーバの応答がエラーを示す場合、上記のいずれかの例外が送出されます。 
サーバに最初に接続した際に送信される応答中のウェルカムメッセージを返します。 
(このメッセージには時に、ユーザにとって重要な免責事項やヘルプ情報が入っています。 
このメソッドは印字されるデバッグ出力の量を制御します。 
標準では 0 に設定されていて、これはデバッグ出力を全く印字しません。 
1 はそこそこの量、一般に NNTP 要求や応答あたり 1 行のデバッグ出力を生成します。 
値が 2 やそれ以上の場合、(メッセージテキストを含めて) NNTP接続上で送受信された全ての内容を一行ごとにログ出力する、最大限のデバッグ出力を生成します。 
"NEWSGROUPS" 命令を送信します。 
date 引数は'yy 
dd' の形式を取り、日付を表します。 time 引数は 'hh 
ss' の形式をとり、時刻を表します。 
与えられた日付および時刻以後新たに出現したニュースグループ名のリストを groups として、(response, groups) を返します。 file引数が指定されている場合、"NEWGROUPS"コマンドの出力結果はファイルに格納されます。 
fileが文字列の場合、この文字列をファイル名としてファイルをオープンし、書き込み後にクローズします。 fileがファイルオブジェクトの場合、オブジェクトのwrite()メソッドを呼び出して出力結果を格納します。 
fileが指定されている場合は戻り値として空のリストを返します。 
"NEWNEWS" 命令を送信します。 
ここで、group はグループ名または '*' で、 date および time はnewsgrups() における引数と同じ意味を持ちます。 
(response, articles) からなるペアを返し、articles は記事 ID のリストです。 file引数が指定されている場合、"NEWNEWS"コマンドの出力結果はファイルに格納されます。 
"LIST" 命令を送信します。 
(response, list) からなるペアを返します。 
list はタプルからなるリストです。 各タプルは (group, last, first, flag)の形式をとり、group がグループ名、last および first はそれぞれ最新および最初の記事の記事番号 (を表す文字列)、そしてflag は投稿が可能な場合には 'y'、そうでない場合には'n'、グループがモデレート (moderated) されている場合には'm' となります。 
(順番に注意してください: last、first の順です。 )file引数が指定されている場合、"LIST"コマンドの出力結果はファイルに格納されます。 
"LIST NEWSGROUPS" 命令を送信します。 grouppattern はRFC2980 の定義に従う wildmat 文字列です (実際には、 DOS や UNIX のシェルワイルドカード文字列と同じです)。 
(response,list)からなるペアを返し、list はタプル(name, title)リストになります。 
単一のグループgroup から説明文字列を取り出します。 
('group' が実際には wildmat 文字列で) 複数のグループがマッチした場合、最初にマッチしたものを返します。 
何もマッチしなければ空文字列を返します。 このメソッドはサーバからの応答コードを省略します。 
応答コードが必要なら、descriptions() を使ってください。 
記事番号は文字列で返されます。 
"HELP" 命令を送信します。 
"NEXT" 命令を送信します。 
stat() のような応答を返します。 
"LAST" 命令を送信します。 
"HEAD" 命令を送信します。 id は stat() におけるのと同じ意味を持ちます。 
(response, number, id, list)からなるタプルを返します。 最初の 3 要素は stat() と同じもので、list は記事のヘッダからなるリスト(まだ解析されておらず、末尾の改行が取り去られたヘッダ行のリスト)です。 
"BODY" 命令を送信します。 id は stat() におけるのと同じ意味を持ちます。 
file 引数が与えられている場合、記事本体 (body) はファイルに保存されます。 
file が与えられていた場合、 返される list は空のリストになります。 
"ARTICLE" 命令を送信します。 id は stat() におけるのと同じ意味を持ちます。 
head() のような戻り値を返します。 
"SLAVE" 命令を送信します。 
サーバの response を返します。 
"XHDR" 命令を送信します、この命令は RFC には定義されていませんが、一般に広まっている拡張です。 
header 引数は、例えば 'subject'といったヘッダキーワードです。 
string 引数は 'first-last' の形式でなければならず、ここでfirst および last は検索の対象とする記事範囲の最初と最後の記事番号です。 
"POST" 命令を使って記事をポストします。 
file引数は開かれているファイルオブジェクトで、その内容はreadline() メソッドを使って EOF まで読み出されます。 
内容は必要なヘッダを含め、正しい形式のニュース記事でなければなりません。 
post() メソッドは "."で始まる行を自動的にエスケープします。 
"IHAVE" 命令を送信します。 
応答がエラーでない場合、file を post() と全く同じように扱います。 
descriptions() または description() を使うようにしてください。 
(resp, list) からなるペアを返します。 list はタプルからなるリストで、各タプルは記事番号 start および end の間に区切られた記事です。 
各タプルは(article number, subject, poster, date,id, references, size, lines) の形式をとります。 file引数が指定されている場合、"XHDR"コマンドの出力結果はファイルに格納されます。 
fileが指定されている場合は戻り値として空のリストを返します。 これはオプションの NNTP 拡張なので、全てのサーバでサポートされているとは限りません。 
(resp, path) からなるペアを返します。 path は メッセージ ID が id である記事のディレクトリパスです。 
これはオプションの NNTP 拡張なので、全てのサーバでサポートされているとは限りません。 
"QUIT" 命令を送信し、接続を閉じます。 
このメソッドを呼び出した後は、NTTP オブジェクトの他のいかなるメソッドも呼び出してはいけません。 
いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。 
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を維持するだけの目的で残されています。 Python のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしてもかまわず、その際に何か重要なことを忘れていると思う必要もありません。 
引数 function は呼び出しができるオブジェクト (ユーザ定義および組み込みの関数またはメソッド、またはクラスオブジェクト)でなければなりません。 args はシーケンス型でなくてはなりません。 
function は引数リスト args を使って呼び出されます;引数の数はタプルの長さになります。 オプションの引数 keywords を与える場合、 keywords は文字列のキーを持つ辞書でなければなりません。 
これは引数リストの最後に追加されるキーワード引数です。 apply() の呼び出しは、単なる 
function(args) の呼び出しとは異なります。 というのは、apply() の場合、引数は常に一つだからです。 
apply() は 
function(*args, **keywords) を使うのと等価です。 上のような ``拡張された関数呼び出し構文'' は apply() と全く等価なので、必ずしも apply() を使う必要はありません。 
リリース 2.3 で撤廃されました。 上で述べられたような拡張呼び出し構文を使ってください。 
引数 object を参照する新たなバッファオブジェクトが生成されます。 
引数 object は (文字列、アレイ、バッファといった) バッファ呼び出しインタフェースをサポートするオブジェクトでなければなりません。 
返されるバッファオブジェクトは object の先頭 (または offset)からのスライスになります。 
スライスの末端は object の末端まで(または引数 size で与えられた長さになるまで) です。 
二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを返します。 変換に使われる規則は算術演算における規則と同じです。 
型変換が不可能である場合、TypeError を送出します。 
string を ``隔離'' された文字列のテーブルに入力し、隔離された文字列を返します - この文字列は string 自体かコピーです。 隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに有効です - 辞書中のキーが隔離されており、検索するキーが隔離されている場合、(ハッシュ化後の) キーの比較は文字列の比較ではなくポインタの比較で行うことができるからです。 
通常、Python プログラム内で利用されている名前は自動的に隔離され、モジュール、クラス、またはインスタンス属性を保持するための辞書は隔離されたキーを持っています。 
バージョン 2.3 で 変更 された仕様:隔離された文字列の有効期限は (Python 2.2 またはそれ以前は永続的でしたが) 永続的ではなくなりました;intern() の恩恵を受けるためには、intern()の返す値に対する参照を保持しなければなりません 
リリース 2.4 ，平成18年6月27日 更新 
None に対する PyTypeObject は、 Python/C API では直接公開されていないので注意してください。 
None は単量子(singleton) なので、オブジェクトのアイデンティティテスト(C では "==") を使うだけで十分だからです。 同じ理由から、PyNone_Check() 関数はありません。 
Python における None オブジェクトで、値がないことを表します。 
このオブジェクトにはメソッドがありません。 
リファレンスカウントについては、このオブジェクトも他のオブジェクトと同様に扱う必要があります。 
C 関数から Py_None を戻す操作を適切に行うためのマクロです。 
字句解析と構文に関する記述では、BNF 文法記法に手を加えたものを使っています。 
この記法では、以下のような記述形式をとります: 
最初の行は、name が lc_letter の後ろに ゼロ個またはそれ以上の lc_letter とアンダースコアが続いたものであることを示しています。 
そして、lc_letter は "a" から "z" までの何らかの文字一字であることを示します (この規則は、このドキュメントに記述されている字句規則と構文規則において定義されている名前 (name) で一貫して使われています)。 
各規則は name (規則によって定義されているものの名前) とコロン一つから始まります。 
垂直線 (|) は、複数の選択項目を分かち書きするときに使います; この記号は、この記法において最も結合優先度の低い演算子です。 
アスタリスク (*) は、直前にくる要素のゼロ個以上の繰り返しを表します; 同様に、プラス (+) は一個以上の繰り返しで、角括弧([ ]) に囲われた字句は、字句がゼロ個か一個出現する(別の言い方をすれば、囲いの中の字句はオプションである) ことを示します。 
* および + 演算子の結合範囲は可能な限り狭くなっています; 字句のグループ化には丸括弧を使います。 
リテラル文字列はクオートで囲われます。 
各カッコ中の字句 (...) は、定義済みのシンボルを記述する非形式的なやりかたです; 例えば、`制御文字' を書き表す必要があるときなどに使われることがあります。 字句と構文規則の定義の間で使われている表記はほとんど同じですが、その意味には大きな違いがあります: 字句定義は入力ソース中の個々の文字を取り扱いますが、構文定義は字句解析で生成された一連のトークンを取り扱います。 
次節 (``字句解析'') における BNF はすべて字句定義のためのものです; それ以降の章では、構文定義のために使っています。 
1.11 C++での拡張モジュール作成 
一般論として、オブジェクトへの参照を引数にとる関数はユーザがNULL ポインタを渡すとは予想しておらず、渡そうとするとコアダンプになる (か、あとでコアダンプを引き起こす) ことでしょう。 
一方、オブジェクトへの参照を返すような関数は一般に、例外の発生を示す場合にのみ NULL を返します。 
型を調べるマクロには、NULL チェックを行う変化形はありません。 Python から C 関数を呼び出す機構は、 C 関数に渡される引数リスト(例でいうところの args) が決して NULL にならないよう保証しています -- 実際には、常にタプル型になるよう保証しています。 
NULL ポインタを Python ユーザレベルに ``逃がし'' てしまうと、深刻なエラーを引き起こします。 
... 実際には、常にタプル型になるよう保証しています。 
``旧式の'' 呼び出し規約を使っている場合には、この保証は適用されません -- 既存のコードにはいまだに旧式の呼び出し規約が多々あります 
10.4 マップ型オブジェクト構造体 (mapping object 
拡張型で数値型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。 
オブジェクト o が数値型プロトコルを提供している場合に1 を返し、そうでないときには偽を返します。 
成功するとo1 と o2 を加算した結果を返し、失敗すると NULL を返します。 
成功するとo1 から o2 を減算した結果を返し、失敗すると NULL を返します。 
成功するとo1 と o2 を乗算した結果を返し、失敗すると NULL を返します。 
成功すると o1 を o2 で除算した結果を返し,失敗すると NULL を返します。 
成功するとo1 を o2 で除算した切捨て値を返し、失敗すると NULL を返します。 
``旧仕様の'' 整数間での除算と同じです。 バージョン 2.2 で 新たに追加 された仕様です。 
成功すると、数学的な o1 の o2 による除算値に対する妥当な近似 (reasonable approximation) を返し、失敗すると NULL を返します。 
全ての実数を 2 を基数として表現するのは不可能なため、二進の浮動小数点数は``近似値'' しか表現できません。 このため、戻り値も近似になります。 
この関数に二つの整数を渡した際、浮動小数点の値を返すことがあります。 
成功すると o1 を o2 で除算した剰余を返し、失敗すると NULL を返します。 
組み込み関数 divmod() を参照してください。 
失敗すると NULL を返します。 
Python の式 "divmod(o1, o2)" と同じです。 
組み込み関数pow() を参照してください。 
Python の式 "pow(o1, o2, o3)"と同じです。 o3 はオプションです。 
o3 を無視させたいなら、 Py_None を入れてください(o3 にNULL を渡すと、不正なメモリアクセスを引き起こすことがあります)。 
成功するとo の符号反転を返し、失敗すると NULL を返します。 Python の式 "-o 
成功すると o を返し、失敗すると NULL を返します。 
Python の式 "+o 
成功すると o の絶対値を返し、失敗すると NULL を返します。 
Python の式 "abs(o)" と同じです。 
成功すると o のビット単位反転 (bitwise negation) を返し、失敗すると NULL を返します。 
Python の式 "~o " と同じです。 
" と同じです。 
成功すると o1 を o2 だけ右シフトした結果を返し、失敗すると NULL を返します。 
成功すると o1 と o2 の ``ビット単位論理積 (bitwise and)'' を返し、失敗すると NULL を返します。 
成功すると o1 と o2 の ``ビット単位排他的論理和 (bitwise exclusive or)'' を返し、失敗すると NULL を返します。 
Python の式 " 
成功すると o1 と o2 の ``ビット単位論理和 (bitwise or)'' を返し失敗すると NULL を返します。 
o1 が in-place 演算をサポートする場合、in-place 演算を行います。 
Python の文 " 
成功するとo1 を o2 で除算した切捨て値を返し、失敗すると NULL を返します。 
" と同じです。 
バージョン 2.2 で 新たに追加 された仕様です。 
この関数に二つの整数を渡した際、浮動小数点の値を返すことがあります。 
o1 が in-place 演算をサポートする場合、in-place 演算を行います。 バージョン 2.2 で 新たに追加 された仕様です。 
成功すると o1 を o2 で除算した剰余を返し、, 失敗すると NULL を返します。 
組み込み関数pow() を参照してください。 
失敗すると NULL を返します。 
o1 が in-place 演算をサポートする場合、in-place 演算を行います。 
この関数は o3 が Py_None の場合は Python 文" 
" と同じで、それ以外の場合は"pow(o1, o2, o3)" の in-place 版です。 
o3 を無視させたいなら、 Py_None を入れてください(o3 にNULL を渡すと、不正なメモリアクセスを引き起こすことがあります)。 
成功すると o1 を o2 だけ左シフトした結果を返し、失敗すると NULL を返します。 
o1 が in-place 演算をサポートする場合、in-place 演算を行います。 
Python の文 " 
この関数はPyObject* 型の二つの変数のアドレスを引数にとります。 
と*p2 
が指すオブジェクトが同じ型の場合、それぞれの参照カウントをインクリメントして 0 (成功) を返します。 
オブジェクトを変換して共通の数値型にできる場合、*p1 と *p2 を変換後の値に置き換えて (参照カウントを'新しく' して) 、0 を返します。 
変換が不可能な場合や、その他何らかのエラーが生じた場合、-1(失敗) を返し、参照カウントをインクリメントしません。 
PyNumber_Coerce(o1, o2) の呼び出しは Python 文" 
o1, o2 = coerce(o1, o2)" と同じです。 PyObject* 
成功するとo を整数に変換したものを返し、失敗すると NULL を返します。 
引数の値が整数の範囲外の場合、長整数を代わりに返します。 
Python の式 "int(o)" 
と同じです。 PyObject* 
成功するとo を長整数に変換したものを返し、失敗すると NULL を返します。 
Python の式 "long(o)" と同じです。 
成功するとo を浮動小数点数に変換したものを返し、失敗すると NULL を返します。 
Python の式 "float(o)" と同じです。 
数値リテラルは 4 種類あります: 整数 (plain integer)、長整数 (longinteger)、浮動小数点数 (floating point number)、そして虚数 (imaginarynumber) です。 
複素数のためのリテラルはありません (複素数は実数と虚数の和で作ることができます)。 数値リテラルには符号が含まれていないことに注意してください; -1のような句は、実際には単項演算子 (unary operator) `-' とリテラル1 を組み合わせたものです。 
3.3.6 シーケンス型エミュレーションで使われるその他のメソッド 
3.3.8 型強制規則 (coercion rule) 3.3.7 数値型をエミュレーションする 
以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。 
特定の種類の数値型ではサポートされていないような演算に対応するメソッド (非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。 
これらのメソッドは、二項算術演算 (+, -, *, //, %,divmod() 
, , ^, |)を実現するために呼び出されます。 
例えば、式 x 
yの場合、x が __add__() メソッドをもつクラスのインスタンスであれば、 
x.__add__(y) が呼び出されます。 
__divmod__() メソッドは、__floordiv__() と__mod__() を使った場合と等価にならなければなりません; __truediv__() (下記参照) と関連づける必要はありません。 
組み込みの三項演算子バージョンの関数pow() 
をサポートする場合には、__pow__() は、オプションとなる第三の引数を受け取れなくてはなりません。 
除算演算 (/) は、これらのメソッドで実現されています。 
__truediv__() は、 __future__.division が有効であるときに使われます。 それ以外の場合には __div__() が使われますs。 
二つのメソッドのうち一方しか定義されていなければ、オブジェクトは他方の演算コンテキストをサポートしなくなります; このとき、TypeError が送出されます。 
これらのメソッドは二項算術演算(+,-, *, /, %,divmod() 
, , ^, |) を実現しますが、メソッド呼び出しが行われる被演算子が逆転して (reflected, swapped: 入れ替えられて) います。 
これらの関数は、左側の被演算子が対応する演算をサポートしていない場合にのみ呼び出されます。 
例えば、x 
y において、y が __rsub__() メソッドを持つクラスのインスタンスである場合、 
y.__rsub__(x) が呼び出されます。 
これらのメソッドは、累算算術演算 (augmented arithmetic operations,+=, -=, *=, /=, %=,**=, 
=, =,^=, |=) を実現するために呼び出されます。 
これらのメソッドは、演算をその場で(self を変更する形で)行うよう試み、その結果(変更された self またはその代わりのもの)を返さなければなりません。 
特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドで代用されます。 
例えば、x 
y を評価する際、x が __iadd__() メソッドを持つクラスのインスタンスであれば、 
x.__iadd__(y) が呼び出されます。 
反対に、x が __iadd() メソッドを持たないクラスのインスタンスであれば、x 
y.__radd__(x) を考慮します。 
単項算術演算 (-,+, abs() 
および ~)を実現するために呼び出されます。 
組み込み関数complex() 
,および float() 
を実現するために呼び出されます。 
適切な型の値を返さなければなりません。 
``型混合モード (mixed-mode)'' での数値間の算術演算を実現するために呼び出されます。 
self と other を共通の数値型に変換して、2 要素のタプルにして返すか、不可能な場合には None を返さなければなりません。 
共通の型が other の型になる場合、 None を返すだけで十分です。 この場合、インタプリタはもう一方のオブジェクトを調べて型強制を行おうとするからです (とはいえ、もう一方の値の型が実装上変更できない場合には、ここで self を other の型に変換しておいた方が便利です)。 
戻り値に NotImplemented を使うのは、 None を返すのと同じです。 
7.2.1 (通常)整数型オブジェクト (plain integer object) 
オブジェクト o をファイル fp に出力します。 
失敗すると-1 を返します。 
flags 引数は何らかの出力オプションを有効にする際に使います。 
現在サポートされている唯一のオプションはPy_PRINT_RAW です;このオプションを指定すると、repr() の代わりにstr() を使ってオブジェクトを書き込みます。 
o が属性 attr_name を持つときに 1 を、それ以外のときに 0 を返します。 
この関数は Python の式"hasattr(o, attr_name)" と同じです。 
この関数は常に成功します。 
"と同じです。 
オブジェクト o から、名前 attr_name の属性を取得します。 成功すると属性値を返し失敗すると NULL を返します。 
この関数は Python の式 " 
オブジェクト o のattr_name という名の属性に、値v を設定します。 
失敗すると -1 を返します。 
この関数は Python の式 " 
オブジェクト o のattr_name という名の属性を削除します。 
失敗すると -1 を返します。 
この関数は Python の文 "del o.attr_name "と同じです。 
o1 と o2 を opid に指定した演算によって比較します。 opid はPy_LT,Py_LE,Py_EQ,Py_NE,Py_GT, またはPy_GE, のいずれかでなければならず、それぞれ,=,==,!=,, および= に対応します。 
この関数は Python の式 " 
" と同じで、op が opid に対応する演算子です。 
成功すると比較結果の値を返し失敗すると NULL を返します。 
比較結果が真ならば 1 を、偽ならば 0 を、エラーが発生すると -1 を返します。 
この関数は Python の式 " 
" と同じで、op が opid に対応する演算子です。 
o1 と o2 の値を比較します。 このときo1 が比較ルーチンを持っていればそれを使い、なければ o2 のルーチンを使います。 
比較結果は result に返されます。 
Python 文 
result = cmp(o1, o2)"と同じです。 
成功すると比較結果を返します。 
エラーが生じた場合の戻り値は未定義です; PyErr_Occurred() を使ってエラー検出を行って下さい。 
Python 式 
"cmp(o1, o2)"と同じです。 
o の文字列表現を計算します。 
成功すると文字列表現を返し、失敗すると NULL を返します。 
Python 式"repr(o)"と同じです。 
Python 式"str(o)"と同じです。 
この関数は組み込み関数str() 
やprint 文の処理で呼び出されます。 
o の Unicode 文字列表現を計算します。 
成功するとUnicode 文字列表現を返し失敗すると NULL を返します。 Python 式"unicode(o)" と同じです。 
inst が cls のインスタンスか、 cls のサブクラスのインスタンスの場合に -1 を返し、そうでなければ 0 を返します。 
エラーの時には -1 を返し、例外をセットします。 
cls がクラスオブジェクトではなく型オブジェクトの場合、PyObject_IsInstance() は inst がcls であるときに 1 を返します。 
cls をタプルで指定した場合、cls に指定した全てのエントリについてチェックを行います。 少なくとも一つのエントリに対するチェックが 1 を返せば結果は1 になり、そうでなければ 0 になります。 
inst がクラスインスタンスでなく、かつ cls が型オブジェクトでもクラスオブジェクトでもタプルでもない場合、inst には __class__ 属性がなくてはなりません --この場合、__class__ 属性の値と、cls の値の間のクラス関係を、関数の戻り値を決定するのに使います。 バージョン 2.1 で 新たに追加 された仕様です。 
バージョン 2.2 で 変更 された仕様:二つ目の引数にタプルのサポートを追加しました。 
サブクラスの決定はかなり正攻法で行いますが、クラスシステムの拡張を実装する人たちに知っておいて欲しいちょっとした問題点があります。 
A と B がクラスオブジェクトの場合、 B がA のサブクラスとなるのは、B が A を直接的あるいは間接的に継承 (inherit) している場合です。 
両方がクラスオブジェクトでない場合、二つのオブジェクト間のクラス関係を決めるには、より汎用の機構を使います。 
B が A のサブクラスであるか調べたとき、A がB と等しければ、PyObject_IsSubclass() は真を返します。 
A および B が異なるオブジェクトなら、B の__bases__ 属性から深さ優先探索 (depth-first search)でA を探索します -- オブジェクトに__bases__ があるだけで、この決定法を適用する条件を満たしているとみなされます。 
クラス derived が cls と同じクラスか、cls の導出クラスの場合に 1 を返し、それ以外の場合には 0 を返します。 
エラーが生じると -1 を返します。 
derived または cls のいずれかが実際のクラスオブジェクト(あるいはタプル) でない場合、上で述べた汎用アルゴリズムを使います。 バージョン 2.1 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:以前の Python のバージョンは、二つ目の引数にタプルをサポートしていませんでした 
オブジェクト o が呼び出し可能オブジェクトかどうか調べます。 
オブジェクトが呼び出し可能であるときに 1 を返し、そうでないときには 0 を返します。 
呼び出し可能な Python オブジェクト callable_object をタプルで指定された引数 args および辞書で指定された名前つき引数 (named argument) kw とともに呼び出します。 
成功すると呼び出し結果として得られたオブジェクトを返し、失敗すると NULL を返します。 
Python の式 "apply(callable_object, args, kw)"あるいは " 
callable_object(*args, **kw)" と同じです。 
呼び出し可能な Python オブジェクト callable_object をタプルで指定された引数 args とともに呼び出します。 
引数を必要としない場合、 args を NULL にしてもかまいません。 
成功すると呼び出し結果として得られたオブジェクトを返し、失敗すると NULL を返します。 
Python の式 "apply(callable_object, args)" あるいは " 
callable_object(*args)" と同じです。 
呼び出し可能な Python オブジェクト callable_object を可変数個の C 引数とともに呼び出します。 
C 引数はPy_BuildValue() 形式のフォーマット文字列を使って記述します。 
format はNULLにしてもよく、与える引数がないことを表します。 
成功すると呼び出し結果として得られたオブジェクトを返し、失敗すると NULL を返します。 
Python の式 "apply(callable, args)" あるいは " 
callable(*args)" と同じです。 
オブジェクト o の method という名前のメソッドを、可変数個の C 引数とともに呼び出します。 
C 引数はタプルを生成するようなPy_BuildValue() 形式のフォーマット文字列を使って記述します。 
format はNULLにしてもよく、与える引数がないことを表します。 
成功すると呼び出し結果として得られたオブジェクトを返し、失敗すると NULL を返します。 
Python の式 " 
o.method(args)" と同じです。 
呼び出し可能な Python オブジェクト callable_object を可変数個の PyObject* 引数とともに呼び出します。 
引数列は末尾に NULLがついた可変数個のパラメタとして与えます。 成功すると呼び出し結果として得られたオブジェクトを返し失敗すると NULL を返します。 
オブジェクト o のメソッドを呼び出します、メソッド名はPython 文字列オブジェクトname で与えます。 
可変数個のPyObject* 引数と共に呼び出されます.引数列は末尾に NULLがついた可変数個のパラメタとして与えます。 
成功すると呼び出し結果として得られたオブジェクトを返し失敗すると NULL を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
オブジェクト o のハッシュ値を計算して返します。 
失敗すると -1 を返します。 
Python の式 "hash(o)" と同じです。 
o が真を表すとみなせる場合には 1 を、そうでないときには 0 を返します。 
失敗すると -1 を返します。 
o が真を表すとみなせる場合には 0 を、そうでないときには 1 を返します。 
o が NULLでない場合、オブジェクトo のオブジェクト型に相当する型オブジェクトを返します。 
失敗すると SystemError を送出して NULLを返します。 
Python の式 type(o)と同じです。 
この関数は戻り値の参照カウントをインクリメントします。 
参照カウントのインクリメントが必要でない限り、広く使われていてPyTypeObject* 型のポインタを返す表記法 o-ob_type の代わりに使う理由は全くありません。 
オブジェクト o が、 type か type のサブタイプであるときに真を返します。 
どちらのパラメタも NULLであってはなりません。 バージョン 2.2 で 新たに追加 された仕様です。 
o の長さを返します。 
オブジェクトo がシーケンス型プロトコルとマップ型プロトコルの両方を提供している場合、シーケンスとしての長さを返します。 
エラーが生じると -1 を返します。 
Python の式 "len(o)"と同じです。 
成功するとオブジェクト key に対応する o の要素を返し、失敗すると NULL を返します。 
オブジェクト key を値 v に対応付けます。 
失敗すると -1 を返します。 
オブジェクト o から key に対する対応付けを削除します。 
Python の文 "del o[key]" と同じです。 
Python オブジェクトからファイル記述子を取り出します。 
オブジェクトが整数か長整数なら、その値を返します。 
(長)整数でない場合、オブジェクトに fileno() メソッドがあれば呼び出します; この場合、 fileno() メソッドは整数または長整数をファイル記述子の値として返さなければなりません。 
この関数は Python の式 "dir(o)" と同じで、オブジェクトの変数名に割り当てている文字列からなるリスト(空の場合もあります) を返します。 エラーの場合には NULLを返します。 
引数を NULLにすると、Python における"dir()" と同様に、現在のローカルな名前を返します; この場合、アクティブな実行フレームがなければ NULL を返しますが、PyErr_Occurred() は偽を返します。 
Python の式 "iter(o)" と同じです。 引数にとったオブジェクトに対する新たなイテレータか、オブジェクトがすでにイテレータの場合にはオブジェクト自身を返します。 
オブジェクトが反復処理不可能であった場合にはTypeError を送出して NULL を返します。 
Python/C API 関数は、 PyObject* 型の一つ以上の引数と戻り値を持ちます。 
この型は、任意の Python オブジェクトを表現する不透明 (opaque) なデータ型へのポインタです。 
Python 言語は、全ての Python オブジェクト型をほとんどの状況 (例えば代入、スコープ規則 (scope rule)、引数渡し) で同様に扱います。 
ほとんど全ての Python オブジェクトはヒープ (heap) 上に置かれます: このため、PyObject 型のオブジェクトは、自動記憶 (automatic) としても静的記憶 (static) としても宣言できません。 PyObject* 型のポインタ変数のみ宣言できます。 
唯一の例外は、型オブジェクト 
です;型オブジェクトはメモリ解放 (deallocate) してはならないので、通常は静的記憶の PyTypeObject オブジェクトにします。 全ての Python オブジェクトには (Python 整数型ですら) 型 (type) と参照カウント (reference count) があります。 
あるオブジェクトの型は、そのオブジェクトがどの種類のオブジェクトか (例えば整数、リスト、ユーザ定義関数、など; その他多数については、 
Python リファレンスマニュアル 
で説明しています) を決定します。 
よく知られている型については、各々マクロが存在して、あるオブジェクトがその型かどうか調べられます; 例えば、"PyList_Check(a)" は、a で示されたオブジェクトがPython リスト型のとき (かつそのときに限り) 真値を返します。 
これらのモジュールは通常 import して利用できません; 利用できるようにするには作業を行わなければなりません。 Python で書かれたものは、標準ライブラリの一部としてインストールされている lib-old/ ディレクトリの中にインストールされます。 
利用するには、PYTHONPATH を使うなどして、lib-old/ ディレクトリを sys.path に追加しなければなりません。 
撤廃された拡張モジュールのうち C で書かれたものは、標準の設定ではビルドされません。 Unixでこれらのモジュールを有効にするには、ビルドツリー内の Modules/Setup の適切な行のコメントアウトを外して、モジュールを静的リンクするなら Python をビルドしなおし、動的にロードされる拡張を使うなら共有オブジェクトをビルドしてインストールする必要があります。 
-- パッケージへの別のアプローチです。 
組み込みのパッケージサポートを使ってください。 
-- ファイル比較関数です。 
新しい 
を使ってください。 
-- 古い cmp モジュールのキャッシュ化版です。 
-- 関数コードオブジェクトからか数名や行番号を抽出します(現在ではこれらは属性: co.co_name, func.func_name,co.co_firstlineno としてアクセスできます)。 
-- ディレクトリ間の差分 (diff) ツールを構築するためのクラスです(デモかツールになるかもしれません)。 
リリース 2.0 で撤廃されました。 
モジュールが dircmpに置き換わります。 
-- 変数を再構築する Python コードを出力します。 
-- テキスト書式化処理の抽象化モジュールです (低速すぎます)。 
-- FCNTL ファイルロック機構へのラッパです (fcntl.lockf()/flock() を使ってください。 ; 
-- 新たな dir() 関数です。 (現在では標準の dir() が同じくらい改良されました)。 
-- fmt の補助モジュールです。 
-- 多項式です。 
-- Emacs 形式の正規表現サポートです; 古いコード内で未だに使われているかもしれません (拡張モジュールです) 。 
ドキュメントは 
Python1.6 Documentation を参照してください。 
-- regex で利用するための、正規表現に基づいた文字列置換ユーティリティです (拡張モジュールです)。 
-- 局所変数のダンプを伴うトレースバック印字のためのモジュールです(pdb.pm() または 
を使ってください)。 
-- 高い精度で経過時間を計測します (time.clock() を使ってください)。 
(拡張モジュールです。 ) 
-- タイムゾーン指定を解釈します (完成していません; 将来は消滅するモジュールで、TZ 環境変数が設定されていないと動作しません)。 
-- 他のどこにも分類しようがない有用な関数群です。 
-- 音声ファイルを識別します; 
-- 数学的な ``体'' の性質を計算します。 
以下のモジュールは撤廃されましたが、ツールやスクリプトとして復活しているようです: 
-- ディレクトリツリー内からパターンに合致するファイルを探します。 
-- Python による grep 実装です。 
-- 自己展開形式の Unix シェルアーカイブを生成します。 
以下のモジュールはこのマニュアルの以前のバージョンでドキュメントされていましたが、現在では撤廃されたものと考えられています。 
これらのドキュメントのソースは、まだドキュメントソースアーカイブから取得可能です。 
-- ``パッケージ内の'' モジュールを import します。 今では基本的なパッケージのサポートは組み込みになっています。 
組み込みのサポートはこのモジュールで提供されていた内容に非常に近いものとなっています。 
-- 乱数生成器への古いインタフェースです。 
-- 共有キーと同じような名前縮約アルゴリズムです。 
特定のアルゴリズムは公開されているどのアルゴリズムとも一致しないようです。 
OpenerDirector インスタンスは以下のメソッドを持っています: 
handler は BaseHandler のインスタンスでなければなりません。 
以下のメソッドを使った検索が行われ、URL を取り扱うことが可能なハンドラの連鎖が追加されます (HTTP エラーは特別扱いされているので注意してください)。 
protocol_open() --ハンドラが protocol の URL を開く方法を知っているかどうかを調べます。 
protocol_error() --ハンドラが (http でない) protocol のエラーを処理する方法を知っていることを示すシグナルです。 
protocol_response() --ハンドラが protocol リクエストのポストプロセス方法を知っていることを示すシグナルです。 
与えられたプロトコルにおけるエラーを処理します。 
このメソッドは与えられたプロトコルにおける登録済みのエラーハンドラを(プロトコル固有の) 引数で呼び出します。 
HTTP プロトコルは特殊なケースで、特定のエラーハンドラを選び出すのに HTTP レスポンスコードを使います; ハンドラクラスの http_error_*() メソッドを参照してください。 返り値および送出される例外は urlopen() と同じものです。 
OpenerDirector オブジェクトは、以下の 3 つのステージに分けてURL を開きます:各ステージで OpenerDirector オブジェクトのメソッドがどのような順で呼び出されるかは、ハンドラインスタンスの並び方で決まります。 
protocol_request() 形式のメソッドを持つ全てのハンドラに対してそのメソッドを呼び出し、リクエストのプリプロセスを行います。 
protocol_open() 形式のメソッドを持つハンドラを呼び出し、リクエストを処理します。 
このステージは、ハンドラがNone でない値 (すなわちレスポンス) を返すか、例外 (通常は URLError) を送出した時点で終了します。 
例外は伝播 (propagate) できます。 実際には、上のアルゴリズムではまず default_open という名前のメソッドを呼び出します。 
このメソッドが全て None を返す場合、同じアルゴリズムを繰り返して、今度は 
protocol_open()形式のメソッドを試します。 
メソッドが全て None を返すと、さらに同じアルゴリズムを繰り返して unknown_open() を呼び出します。 これらのメソッドの実装には、親となる OpenerDirector インスタンスの .open() や.error() といったメソッド呼び出しが入る場合があるので注意してください。 
protocol_response() 形式のメソッドを持つ全てのハンドラに対してそのメソッドを呼び出し、リクエストのポストプロセスを行います。 
下のテーブルでは、個々の抽象的な操作が、どのように Python 構文上の各演算子や 
モジュールの関数に対応しているかを示しています。 
操作 
構文 
関数 
加算 
結合 
包含テスト 
除算 
__future__.division が無効な場合の div(a, b) # 
__future__.division が有効な場合の truediv(a, b) # 
論理積 
ビット反転 
論理和 
べき乗 
インデクス指定の削除 
インデクス指定 
左シフト 
剰余 
乗算 
(算術)否 
(論理)否 
右シフト 
シーケンスの反復 
スライス指定の代入 
スライス指定の削除 
スライス指定 
文字列書式化 
減算 
真値テスト 
順序付け 
等価性 
不等性 
以下のトークンは演算子です: 
比較演算子 と != は、同じ演算子について別の書き方をしたものです。 
書き方としては != を推奨します; は時代遅れの書き方です。 
optparse は、素直で慣習に則ったコマンドラインインタフェースを備えたプログラムの作成を援助する目的で設計されました。 
その結果、Unix で慣習的に使われているコマンドラインの構文や機能だけをサポートするに留まっています。 
こうした慣習に詳しくなければ、よく知っておくためにもこの節を読んでおきましょう。 
6.21.4.3 コールバック中で例外を送出する 
6.21.4.5 コールバックの例 2: オプションの順番をチェックする 
引数をとらず、発見したオプションを単に記録するだけのコールバックオプションの例を以下に示します: 
もちろん、store_true アクションを使っても実現できます。 
6.21.4.4 コールバックの例 1: ありふれたコールバック 
6.21.4.6 コールバックの例 3: オプションの順番をチェックする 
もう少し面白みのある例を示します: この例では、"-a" を発見して、その後で"-b" がコマンドライン中に現れた場合にはエラーになります。 
6.21.4.7 コールバックの例 4: 任意の条件をチェックする 
このコールバック (フラグを立てるが、"-b" が既に指定されていればエラーになる) を同様の複数のオプションに対して再利用したければ、もう少し作業する必要があります:エラーメッセージとセットされるフラグを一般化しなければなりません。 
6.21.4.8 コールバックの例5: 固定引数 
もちろん、単に定義済みのオプションの値を調べるだけにとどまらず、コールバックには任意の条件を入れられます。 
例えば、満月でなければ呼び出してはならないオプションがあるとしましょう。 
やらなければならないことはこれだけです: def check_moon(option, opt_str, value, parser):if is_moon_full():raise OptionValueError("%s option invalid when moon is full"% opt_str)setattr(parser.values, option.dest, 1)[...]parser.add_option("--foo",action="callback", callback=check_moon, dest="foo") 
(is_moon_full() の定義は読者への課題としましょう。 
決まった数の引数をとるようなコールパックオプションを定義するなら、問題はやや興味深くなってきます。 
引数をとるようコールバックに指定するのは、store やappend オプションの定義に似ています: type を定義していれば、そのオプションは引数を受け取ったときに該当する型に変換できねばなりません;さらに nargs を指定すれば、オプションは nargs 個の引数を受け取ります。 
標準の store アクションをエミュレートする例を以下に示します: 
optparse は 3 個の引数を受け取り、それらを整数に変換するところまで面倒をみてくれます; ユーザは単にそれを保存するだけです。 
(他の処理もできます;いうまでもなく、この例にはコールバックは必要ありません) 
あるオプションに可変個の引数を持たせたいと考えているなら、問題はいささか手強くなってきます。 
この場合、optparse では該当する組み込みのオプション解析機能を提供していないので、自分でコールバックを書かねばなりません。 
さらに、optparse が普段処理している、伝統的な Unix コマンドライン解析における難題を自分で解決せねばなりません。 
とりわけ、コールバック関数では引数が裸の"-" や "-" の場合における慣習的な処理規則: 
裸の "-" (何らかのオプションの引数でない場合): コマンドライン処理を停止し、"-"を無視します。 
裸の"-" (何らかのオプションの引数でない場合): コマンドライン処理を停止しますが、"-" は残します (parser.largs に追加します)。 を実装せねばなりません。 
オプションが可変個の引数をとるようにさせたいなら、いくつかの巧妙で厄介な問題に配慮しなければなりません。 
どういう実装をとるかは、アプリケーションでどのようなトレードオフを考慮するかによります (このため、optparse では可変個の引数に関する問題を直接的に取り扱わないのです)。 とはいえ、可変個の引数をもつオプションに対するスタブ (stub、仲介インタフェース) を以下に示しておきます: 
def vararg_callback(option, opt_str, value, parser):assert value is Nonedone = 0value = []rargs = parser.rargswhile rargs:arg = rargs[0]# "--foo", "-a", "-fx", "--file=f" といった引数で停止。 
# "-3" や "-3.0" でも止まるので、オプションに数値が入る場合には# それを処理せねばならない。 
この実装固有の弱点は、-c 以後に続いて負の数を表す引数があった場合、その引数は-c の引数ではなく次のオプションとして解釈される(そしておそらくエラーを引き起こす)ということです。 
この問題の修正は読者の練習課題としておきます。 
6.21.3.5 オプション解析器への問い合わせと操作 
注意が足りないと、衝突するオプションを定義しやすくなります: 
(とりわけ、OptionParser から標準的なオプションを備えた自前のサブクラスを定義してしまった場合にはよく起きます。 )ユーザがオプションを追加するたびに、optparse は既存のオプションとの衝突がないかチェックします。 
何らかの衝突が見付かると、現在設定されている衝突処理メカニズムを呼び出します。 
衝突処理メカニズムはコンストラクタ中で呼び出せます: 
個別にも呼び出せます: 
衝突時の処理として、以下のメカニズムを利用できます: 
error (デフォルトの設定) 
オプション間の衝突をプログラム上のエラーとみなし、OptionConflictError を送出します。 
オプション間の衝突をインテリジェントに解決します (下記参照)。 
一例として、衝突をインテリジェントに解決するOptionParserを定義し、衝突を起こすようなオプションを追加してみましょう: 
この時点で、optparse はすでに追加済のオプションがオプション文字列 "-n" を使っていることを検出します。 
conflict_handler が "resolve" なので、optparseは既に追加済のオプションリストの方から"-n" を除去して問題を解決します。 
従って、"-n" の除去されたオプションは"-dry-run" だけでしか有効にできなくなります。 
ユーザがヘルプ文字列を要求した場合、問題解決の結果を反映したメッセージが出力されます: 
これまでに追加したオプション文字列を跡形もなく削り去り、ユーザがそのオプションをコマンドラインから起動する手段をなくせます。 
この場合、optparse はオプションを完全に除去してしまうので、こうしたオプションはヘルプテキストやその他のどこにも表示されなくなります。 例えば、現在の OptionParser の場合、以下の操作: 
parser.add_option("--dry-run", ..., help="new dry-run option") を行った時点で、最初の -n/-dry-runオプションはもはやアクセスできなくなります。 
このため、optparse はオプションを消去してしまい、ヘルプテキスト: 
options:[...]-n, --noisy be noisy--dry-run new dry-run option だけが残ります。 
上記の例は全て、何らかのコマンドラインオプションが見つかった時に何らかの変数 (保存先: destination) に値を設定していました。 
では、該当するオプションが見つからなかった場合には何が起きるのでしょうか？ 
デフォルトは全く与えていないため、これらの値は全て None になります。 
optparse に対して、-q がない限り verbose を True に設定させたいなら、以下のようにします: 
デフォルトの値は特定のオプションではなく 保存先 に対して適用されます。 また、これら二つのオプションはたまたま同じ保存先を持っているにすぎないため、上のコードは下のコードと全く等価になります: 
下のような場合を考えてみましょう: 
前の例と同様、あるオプションの値の保存先に対するデフォルトの値は最後に指定した値になります。 
コードを読みやすくするため、デフォルト値を設定するときには両方のやり方を混ぜるのではなく、片方だけを使うようにしましょう。 
6.21.4.2 コールバック関数はどのように呼び出されるか 
callbackオプションを最も簡単に定義するには、parser.add_option() メソッドを使います。 
action の他に指定しなければならない属性は callback、すなわちコールバックする関数自体です: 
callback は関数 (または呼び出し可能オブジェクト)なので、callbackオプションを定義する時にはあらかじめ my_callback() を定義しておかねばなりません。 この単純なケースでは、optparse は -c が何らかの引数をとるかどうか判別できず、通常は-c が引数を伴わないことを意味します -- 知りたいことはただ単に -c がコマンドライン上に現れたどうかだけです。 
とはいえ、場合によっては、自分のコールバック関数に任意の個数のコマンドライン引数を消費させたいこともあるでしょう。 
これがコールバック関数をトリッキーなものにしています; これについてはこの節の後の方で説明します。 
optparse は常に四つの引数をコールバックに渡し、その他にはcallback_args および callback_kwargs で指定した追加引数しか渡しません。 
従って、最小のコールバック関数シグネチャは: 
他で使われているのと同じ意味です: store や append アクションの時と同じく、この属性はoptparseに引数を一つ消費して、type に指定した型に変換させます。 
optparse は変換後の値をどこかに保存する代わりにコールバック関数に渡します。 
これも他で使われているのと同じ意味です: このオプションが指定されていて、かつ nargs 1 である場合、 optparseはnargs 個の引数を消費します。 このとき各引数は type 型に変換できねばなりません。 
変換後の値はタプルとしてコールバックに渡されます。 
各々のOption インスタンス、は-f や--fileといった同義のコマンドラインオプションからなる集合を表現しています。 
一つのOption には任意の数のオプションを短い形式でも長い形式でも指定できます。 ただし、少なくとも一つは指定せねばなりません。 
正しい方法でOption インスタンスを生成するには、以降の例でも示すようにmake_option() を使います。 
とはいえ、make_optionやparser.add_option() も同じ呼び出しシグネチャを備えています: 
短い形式のオプション文字列を一つだけ持つようなオプションを生成するには: 
make_option("-f", attr=value, ...) のようにします。 
また、長い形式のオプション文字列を一つだけ持つようなオプションの定義は: 
make_option("--foo", attr=value, ...) のようになります。 
attr=value キーワード引数では、オプションの属性、すなわち Option オブジェクトの属性を定義しています。 
オプションの属性のうちでもっとも重要なのはaction です。 action は他のどの属性と関連があるか、そしてどの属性が必要かに大きく作用します。 
関係のないオプション属性を指定したり、必要な属性を指定し忘れたりすると、optparse は誤りを解説したOptionError例外を送出します。 コマンドライン上にあるオプションが見つかったときのoptparse の振舞いを決定しているのは アクション(action) です。 
optparse でハードコードされているアクションには以下のようなものがあります: 
オプションの引数を保存します [デフォルトの動作です] 
定数を保存します 
真 (True) を保存します store_false 
偽 (False) を保存します 
オプションの引数をリストに追加します 
カウンタを一つ増やします 
指定された関数を呼び出します 
全てのオプションとそのドキュメントの入った使用法メッセージを出力します。 
(アクションを指定しない場合、デフォルトは store になります。 
を呼び出した場合、optparse はまず options オブジェクトを生成します: 
パーザ中で以下のようなオプション 
が定義されていて、パーズしたコマンドラインに以下のいずれかが入っていた場合: 
optparse は -f か --file オプションを見つけて、 
と同等の処理を行います。 type および dest オプション属性は action と同じくらい重要ですが、全ての オプションで意味をなすのはaction だけなのです。 
6.21.2.7 バージョン番号の出力 
optparse にはヘルプと使い方の説明 (usage text) を生成する機能があり、ユーザに優しいコマンドラインインタフェースを作成する上で役立ちます。 
やらなければならないのは、各オプションに対するhelp の値と、必要ならプログラム全体の使用法を説明する短いメッセージを与えることだけです。 
ユーザフレンドリな (ドキュメント付きの) オプションを追加したOptionParser を以下に示します: 
optparse がコマンドライン上で"-h" や"-help" を見つけた場合やユーザがparser.print_help() を呼び出した場合、このOptionParser は以下のようなメッセージを標準出力に出力します: 
スクリプト自体の利用法を表すメッセージを定義します: 
optparse は "%prog" を現在のプログラム名、すなわちos.path.basename(sys.argv[0]) と置き換えます。 
全てのオプションにヘルプ文字列を定義します。 行の折り返しは気にしなくてかまいません -- optparse は行の折り返しに気を配り、見栄えのよいヘルプ出力を生成します。 
オプションが値をとるということは自動的に生成されるヘルプメッセージの中で分かります。 例えば、``mode'' option の場合には: 
のようになります。 ここで ``MODE'' はメタ変数 (meta-variable) と呼ばれます: メタ変数は、ユーザが -m/--mode に対して指定するはずの引数を表します。 
デフォルトでは、optparse は保存先の変数名を大文字だけにしたものをメタ変数に使います。 
これは時として期待通りの結果になりません -- 例えば、上の例の--filename オプションでは明示的に metavar="FILE" を設定しており、その結果自動生成されたオプション説明テキストは: 
デフォルト値を持つオプションのヘルプ文字列には%default を入れられます -- optparse は%default をデフォルト値のstr() で置き換えます。 
該当するオプションにデフォルト値がない場合(あるいはデフォルト値が None である場合) %default の展開結果は none になります。 
フラグオプション--特定のオプションに対して真または偽の値の値を設定するオプション--はよく使われます。 optparse では、二つのアクション、store_trueおよび store_false をサポートしています。 
例えば、verbose というフラグを"-v" で有効にして、"-q" で無効にしたいとします: 
ここでは二つのオプションに同じ保存先を指定していますが、全く問題ありません(下記のように、デフォルト値の設定を少し注意深く行わねばならないだけです) 
"-v" をコマンドライン上に見つけると、optparse はoptions.verbose を True に設定します。 
"-q"を見つければ、options.verbose は False にセットされます。 
6.21.4.1 callbackオプションの定義 
コールバックは全て以下の形式で呼び出されます: 
ここで、 
コールバックを呼び出している Option のインスタンスです。 
は、コールバック呼び出しのきっかけとなったコマンドライン上のオプション文字列です。 
(長い形式のオプションに対する省略形が使われている場合、opt は完全な、正式な形のオプション文字列となります -- 例えば、ユーザが --foobar の短縮形として"-foo" をコマンドラインに入力した時には、opt_str は "-foobar" となります。 ) 
オプションの引数で、コマンドライン上に見つかったものです。 optparse は、type が設定されている場合、単一の引数しかとりません;value の型はオプションの型として指定された型になります。 
このオプションに対する type がNone である(引数なしの) 場合、value は None になります。 
"nargs" 1 であれば、value はは適切な型をもつ値のタプルになります。 
現在のオプション解析の全てを駆動している OptionParser インスタンスです。 この変数が有用なのは、この値を介してインスタンス属性としていくつかの興味深いデータにアクセスできるからです: 
現在放置されている引数、すなわち、すでに消費されたものの、オプションでもオプション引数でもない引数からなるリストです。 
parser.largs は自由に変更でき、たとえば引数を追加したりできます (このリストは args 、すなわちparse_args() の二つ目の戻り値になります) 
現在残っている引数、すなわち、 opt_str およびvalue) があれば除き、それ以外の引数が残っているリストです。 
parser.rargs は自由に変更でき、例えばさらに引数を消費したりできます。 
[parser.values]オプションの値がデフォルトで保存されるオブジェクト (optparse.OptionValuesのインスタンス です。 
この値を使うと、コールバック関数がオプションの値を記憶するために、他のoptparse と同じ機構を使えるようにするため、グローバル変数や閉包(closure) を台無しにしないので便利です。 
コマンドライン上にすでに現れているオプションの値にもアクセスできます。 
callback_args オプション属性で与えられた任意の固定引数からなるタプルです。 
callback_args オプション属性で与えられた任意のキーワード引数からなるタプルです。 
6.21.2.9 全てをつなぎ合わせる 
optparse を使う場合に気を付けねばならないエラーには、大きく分けてプログラマ側のエラーとユーザ側のエラーという二つの種類があります。 
プログラマ側のエラーの多くは、例えば不正なオプション文字列や定義されていないオプション属性の指定、あるいはオプション属性を指定し忘れるといった、誤ったparse.add_option() 呼び出しによるものです。 
というのも、ユーザの操作エラーというものはコードの安定性に関係なく起こるからです。 
optparse は、誤ったオプション引数の指定 (整数を引数にとるオプション-n に対して "-n4x" と指定してしまうなど) や、引数を指定し忘れた場合 (-n が何らかの引数をとるオプションであるのに、"-n" が引数の末尾に来ている場合) といった、ユーザによるエラーを自動的に検出します。 
また、アプリケーション側で定義されたエラー条件が起きた場合、parser.error() を呼び出してエラーを通知できます: 
値を全く指定しない場合には、以下のようになります: 
optparse は、常にエラーを引き起こしたオプションについて説明の入ったエラーメッセージを生成するよう気を配ります; 従って、parser.error() をアプリケーションコードから呼び出す場合にも、同じようなメッセージになるようにしてください。 optparse のデフォルトのエラー処理動作が気に入らないのなら、OptionParser をサブクラス化して、exit() かつ/またはerror() をオーバライドする必要があります。 
callback オプションの定義は二つのステップからなります: 
callback アクションを使ってオプション自体を定義する。 
6.21.2.3 ブール値 (フラグ) オプションの処理 
この他にも、optparse は以下のようなアクションをサポートしています: 
定数値を保存します。 
オプションの引数を指定のリストに追加します。 
指定のカウンタを 1 増やします。 
指定の関数を呼び出します。 
これらのアクションについては、6.21.3 節の「リファレンスガイド」および6.21.4 節の「オプション・コールバック」で触れます。 
パーザにオプションを加えていくにはいくつか方法があります。 
推奨するのは6.21.2 節のチュートリアルで示したようなOptionParser.add_option() を使う方法です。 
add_option() は以下の二つのうちいずれかの方法で呼び出せます: 
make_option()に (すなわちOption のコンストラクタに)固定引数とキーワード引数の組み合わせを渡して、Option インスタンスを生成させます。 
(make_option() などが返す)Optionインスタンスを渡します。 もう一つの方法は、あらかじめ作成しておいたOption インスタンスからなるリストを、以下のようにして OptionParser のコンストラクタに渡すというものです: 
(make_option() は Option インスタンスを生成するファクトリ関数です; 現在のところ、個の関数はOption のコンストラクタの別名にすぎません。 
optparseの将来のバージョンでは、Option を複数のクラスに分割し、make_option() は適切なクラスを選んでインスタンスを生成するようになる予定です。 
従って、Option を直接インスタンス化しないでください。 ) 
6.21.2.8 optparse のエラー処理法 
optparse では、使用法メッセージと同様にプログラムのバージョン文字列を出力できます。 
OptionParser のversion 引数に文字列を渡します: 
"%prog" はusage と同じような展開を受けるので注意してください。 
その他にもversion には何でも好きな内容を入れられます。 
$ /usr/bin/foo --versionfoo 1.0 のようになります。 
optparse を使ったスクリプトは、通常以下のようになります: 
自前のオプションパーザをつつきまわして、何が起こるかを調べると便利なことがあります。 
OptionParser では便利な二つのメソッドを提供しています: 
OptionParser に("-q" や "-verbose" のような)オプション opt_str がある場合、真を返します。 
オプション文字列opt_strに対するOption インスタンスを返します。 
該当するオプションがなければ None を返します。 remove_option(opt_str) 
OptionParser にopt_str に対応するオプションがある場合、そのオプションを削除します。 
該当するオプションに他のオプション文字列が指定されていた場合、それらのオプション文字列は全て無効になります。 opt_str がこの OptionParser オブジェクトのどのオプションにも属さない場合、ValueError を送出します。 
オプション自体か、あるいはその引数に問題があるばあい、コールバック関数はOptionValueError を送出せねばなりません。 optparse はこの例外をとらえてプログラムを終了させ、ユーザが指定しておいたエラーメッセージを標準エラー出力に出力します。 
エラーメッセージは明確、簡潔かつ正確で、どのオプションに誤りがあるかを示さねばなりません。 
さもなければ、ユーザは自分の操作のどこに問題があるかを解決するのに苦労することになります。 
6.21.3.1 パーザへのオプション追加 
様々なオプション・アクションにはどれも互いに少しづつ異なった条件と作用があります。 
ほとんどのアクションに関連するオプション属性がいくつかあり、値を指定してoptparseの挙動を操作できます; いくつかのアクションには必須の属性があり、必ず値を指定せねばなりません。 
store [relevant: type, dest, nargs, choices]オプションの後には必ず引数が続きます。 引数はtype に従った値に変換されてdest に保存されます。 
nargs 1 の場合、複数の引数をコマンドラインから取り出します; 引数は全て type に従って変換され、dest にタプルとして保存されます。 
とすると、以下のようなコマンドライン: 
を解析した場合、optparse は 
のように設定を行います。 
store_const [required: const; relevant: dest]値cost をdest に保存します。 
"-noisy" が見つかると、 optparse は 
append [relevant: type, dest, nargs, choices]このオプションの後ろには必ず引数が続きます。 引数はdest のリストに追加されます。 
dest のデフォルト値を指定しなかった場合、optparse がこのオプションを最初にみつけた時点で空のリストを自動的に生成します。 
nargs 1 の場合、複数の引数をコマンドラインから取り出し、長さ nargs のタプルを生成して destに追加します。 type および dest のデフォルト値は store アクションと同じです。 
例: parser.add_option("-t", "--tracks", action="append", type="int") 
"-t3" がコマンドライン上で見つかると、optparse は: 
と同等の処理を行います。 
その後、"-tracks=4" が見つかると: 
options.tracks.append(int("4")) を実行します。 
count [relevant: dest] dest に保存されている整数値をインクリメントします。 
dest は (デフォルトの値を指定しない限り) 最初にインクリメントを行う前にゼロに設定されます。 
例: parser.add_option("-v", action="count", dest="verbosity") 
コマンドライン上で最初に "-v" が見つかると、optparse は: 
と同等の処理を行います。 以後、"-v" が見つかるたびに、 
この関数のシグネチャは 
func(option : Option,opt : string,value : any,parser : OptionParser,*args, **kwargs) のようになっています。 
詳細は、 節の「オプション・コールバック」を参照してください。 
現在のオプションパーザ内の全てのオプションに対する完全なヘルプメッセージを出力します。 
ヘルプメッセージは OptionParser のコンストラクタに渡したusage 文字列と、各オプションに渡した help 文字列から生成します。 オプションに help 文字列が指定されていなくても、オプションはヘルプメッセージ中に列挙されます。 
オプションを完全に表示させないようにするには、特殊な値 optparse.SUPPRESS_HELP を使ってください。 
optparse は全てのOptionParser に自動的にhelp オプションを追加するので、通常自分で生成する必要はありません。 
例: from optparse import OptionParser, SUPPRESS_HELPparser = OptionParser()parser.add_option("-h", "--help", action="help"),parser.add_option("-v", action="store_true", dest="verbose",help="Be moderately verbose")parser.add_option("--file", dest="filename",help="Input file to read data from"),parser.add_option("--secret", help=SUPPRESS_HELP) 
optparse がコマンドライン上に "-h" または "-help" を見つけると、以下のようなヘルプメッセージを標準出力に出力します (sys.argv[0] は"foo.py"だとします): 
ヘルプメッセージの出力後、optparse は sys.exit(0)でプロセスを終了します。 
OptionParser に指定されているバージョン番号を標準出力に出力して終了します。 
バージョン番号は、実際には OptionParserのprint_version() メソッドで書式化されてから出力されます。 
通常、 OptionParser のコンストラクタに versionが指定されたときのみ関係のあるアクションです。 
help オプションと同様、optparse はこのオプションを必要に応じて自動的に追加するので、version オプションを作成することはほとんどないでしょう。 
optparse には、string (文字列)、int (整数)、 long (長整数)、 choice (選択肢)、 float (浮動小数点数) および complex (複素数) の 6 種類のオプション型があります。 
新たなオプションの型を追加したければ、 節、「optparse の拡張」を参照してください。 
文字列オプションの引数はチェックや変換を一切受けません: コマンドライン上のテキストは保存先にそのまま保存されます (またはコールバックに渡されます)。 整数引数は int() に渡され、Python の整数型に変換されます。 
int() が失敗した場合 optparse の処理も失敗に終わりますが、より役に立つエラーメッセージを出力します。 
(内部的には、optparse はOptionValueError を送出します; OptionParser はこの例外をより上のレベルで捕捉し、メッセージとともにプログラムを停止させます。 )同様に、浮動小数点数引数は float() 、長整数引数は long() 、複素数引数は complex()に渡され変換されます。 
それ以外の点では整数引数の場合と同様の扱いです。 
choice オプションは string オプションのサブタイプです。 
choice オプションの属性 (文字列からなるシーケンス) には、利用できるオプション引数のセットを指定します。 
optparse.option.check_choice()はユーザの指定したオプション引数とマスタリストを比較して、無効な文字列が指定された場合にはOptionValueError を送出します。 
6.21.2.3 ブール値 (フラグ) オプションの処理 6.21.2.2 store アクション 
もっとも良く使われるアクションは store です。 
このアクションは次の引数 (あるいは現在の引数の残りの部分) を取り出し、正しい型の値か確かめ、指定した保存先に保存するようoptparse に指示します。 
例えば: parser.add_option("-f", "--file",action="store", type="string", dest="filename") 
のように指定しておき、偽のコマンドラインを作成して optparse に解析させてみましょう: 
オプション文字列 "-f" を見つけると、optparse は次の引数である "foo.txt" を消費し、その値を options.filename に保存します。 
従って、このparse_args()呼び出し後にはoptions.filename は"foo.txt"になっています。 
オプションの型として、optparse は他にもint やfloatをサポートしています。 整数の引数を想定したオプションの例を示します: 
このオプションには長い形式のオプション文字列がないため、設定に問題がないということに注意してください。 
また、デフォルトのアクションは store なので、ここでは action を明示的に指定していません。 架空のコマンドラインをもう一つ解析してみましょう。 
今度は、オプション引数をオプションの右側にぴったりくっつけて一緒くたにします: -n42 (一つの引数のみ) は -n 42 (二つの引数からなる) と等価になるので、 
は "42" を出力します。 型を指定しない場合、 optparse は引数をstring であると仮定します。 
デフォルトのアクションが store であることも併せて考えると、最初の例はもっと短くなります: 
保存先 (destination) を指定しない場合、 optparse はデフォルト値としてオプション文字列から気のきいた名前を設定します: 最初に指定した長い形式のオプション文字列が"-foo-bar" であれば、デフォルトの保存先は foo_barになります。 
長い形式のオプション文字列がなければ、optparse は最初に指定した短い形式のオプション文字列を探します: 例えば、"-f" に対する保存先はf になります。 
optparse では、long やcomplex といった組み込み型も取り入れています。 
型の追加は 
節の「optparse の拡張」で触れています。 
6.21.1.2 オプションとは何か 
引数 (argument) 
コマンドラインでユーザが入力するテキストの塊で、シェルがexecl() や execv() に引き渡すものです。 
Pythonでは、引数は sys.argv[1:] の要素となります。 (sys.argv[0]は実行しようとしているプログラムの名前です。 
引数解析に関しては、この要素はあまり重要ではありません。 ) Unix シェルでは、 「語 (word)」 という用語も使います。 
場合によっては sys.argv[1:] 以外の引数リストを代入する方が望ましいことがあるので、「引数」 は 「sys.argv[1:] またはsys.argv[1:] の代替として提供される別のリストの要素」と読むべきでしょう。 
オプション (option) 
追加的な情報を与えるための引数で、プログラムの実行に対する教示やカスタマイズを行います。 
また、伝統的な Unix における書法では、複数のオプションを一つの引数にまとめられます。 
例えば"-x -F" は"-xF" と等価です。 
GNU プロジェクトでは "-" の後ろにハイフンで区切りの語を指定する方法、例えば "-file" や "-dry-run" も提供しています。 
optparse は、これら二種類のオプション書法だけをサポートしています。 
他に見られる他のオプション書法には以下のようなものがあります: 
ハイフンの後ろに数個の文字が続くもので、例えば "-pf" (このオプションは複数のオプションを一つにまとめたものとは違います) 
ハイフンの後ろに語が続くもので、例えば "-file" (これは技術的には上の書式と同じですが、通常同じプログラム上で一緒に使うことはありません) 
プラス記号の後ろに一文字、数個の文字、または語を続けたもので、例えば "+f" 、 "+rgb" 
スラッシュ記号の後ろに一文字、数個の文字、または語を続けたもので、例えば "/f" 、 "/file" 
上記のオプション書法は optparse ではサポートしておらず、今後もサポートする予定はありません。 
これは故意によるものです:最初の三つはどの環境の標準でもなく、最後の一つは VMS や MS-DOS,そして Windows を対象にしているときにしか意味をなさないからです。 
オプション引数 (option argument) 
あるオプションの後ろに続く引数で、そのオプションに密接な関連をもち、オプションと同時に引数リストから取り出されます。 optparse では、オプション引数は以下のように別々の引数にできます: 
また、一つの引数中にも入れられます: 
多くの人々が 「オプションのオプション引数」機能を欲しています。 
これは、あるオプションが引数が指定されている場合には引数をとり、そうでない場合には引数をもたないようにするという機能です。 この機能は引数解析をあいまいにするため、議論の的となっています:例えば、もし -a がオプション引数をとり、-b がまったく別のオプションだとしたら、-ab をどうやって解析すればいいのでしょうか？ 
こうした曖昧さが存在するため、optparse は今のところこの機能をサポートしていません。 
固定引数 (positional argument) 
他のオプションが解析される、すなわち他のオプションとその引数が解析されて引数リストから除去された後に引数リストに置かれているものです。 
必須のオプション (required option) 
コマンドラインで与えなければならないオプションです; 「必須なオプション(required option)」という語は、英語では矛盾した言葉です。 optparseでは必須オプションの実装を妨げてはいませんが、とりたてて実装上役立つこともしていません。 
optparse で必須オプションを実装する方法は、optparseソースコード配布物中のexamples/required_1.py やexamples/required_2.py を参照してください。 
例えば、下記のような架空のコマンドラインを考えてみましょう: 
"-v" と"-report" はどちらもオプションです。 
--report オプションが引数をとるとすれば、"/tmp/report.txt" はオプションの引数です。 
"foo"と"bar" は固定引数になります。 
6.21.1.3 固定引数とは何か 
optparse はとても柔軟で強力でありながら、ほとんどの場合には簡単に利用できます。 
これでオプションを定義できるようになりました。 
基本的な構文は以下の通りです: 
オプションを全て定義したら、optparse にコマンドラインを解析するように指示します: 
) parse_args() は二つの値を返します: 
全てのオプションに対する値の入ったオブジェクトoptions -- 例えば、"-file" が単一の文字列引数をとる場合、options.file はユーザが指定したファイル名になります。 
オプションを指定しなかった場合にはNone になります。 
オプションの解析後に残った固定引数からなるリストargs。 
このチュートリアルの節では、最も重要な四つのオプション属性:action, type, dest (destination), およびhelp についてしか触れません。 
このうち最も重要なのはactionです。 
アクション(action)はoptparse が コマンドライン上にあるオプションを見つけたときに何をすべきかを指示します。 
optparse には押し着せのアクションのセットがハードコードされています。 新たなアクションの追加は上級者向けの話題であり、 
オプションはプログラムの実行を調整したり、カスタマイズしたりするための補助的な情報を与えるために使います。 
もっとはっきりいうと、オプションはあくまでもオプション(省略可能)であるということです。 
本来、プログラムはともかくもオプションなしでうまく実行できてしかるべきです。 
(Unix やGNU ツールセットのプログラムをランダムにピックアップしてみてください。 
オプションを全く指定しなくてもちゃんと動くでしょう？ 
例外はfind, tar, dd くらいです--これらの例外は、オプション文法が標準的でなく、インタフェースが混乱を招くと酷評されてきた変種のはみ出しものなのです)多くの人が自分のプログラムに「必須のオプション」を持たせたいと考えます。 
しかしよく考えてください。 
必須なら、それはオプション(省略可能) ではないのです！プログラムを正しく動作させるのに絶対的に必要な情報があるとすれば、そこには固定引数を割り当てるべきなのです。 
良くできたコマンドラインインタフェース設計として、ファイルのコピーに使われるcp ユーティリティのことを考えてみましょう。 
ファイルのコピーでは、コピー先を指定せずにファイルをコピーするのは無意味な操作ですし、少なくとも一つのコピー元が必要です。 従って、cp は引数無しで実行すると失敗します。 
とはいえ、cp はオプションを全く必要としない柔軟で便利なコマンドライン文法を備えています: 
まだあります。 
ほとんどの cp の実装では、ファイルモードや変更時刻を変えずにコピーする、シンボリックリンクの追跡を行わない、すでにあるファイルを上書きする前にユーザに尋ねる、など、ファイルをコピーする方法をいじるための一連のオプションを実装しています。 
しかし、こうしたオプションは、一つのファイルを別の場所にコピーする、または複数のファイルを別のディレクトリにコピーするという、cp の中心的な処理を乱すことはないのです。 
固定引数とは、プログラムを動作させる上で絶対的に必要な情報となる引数です。 よいユーザインタフェースとは、可能な限り少ない固定引数をもつものです。 
プログラムを正しく動作させるために 17 個もの別個の情報が必要だとしたら、その方法 はさして問題にはなりません --ユーザはプログラムを正しく動作させられないうちに諦め、立ち去ってしまうからです。 
ユーザインタフェースがコマンドラインでも、設定ファイルでも、GUI やその他の何であっても同じです: 多くの要求をユーザに押し付ければ、ほとんどのユーザはただ音をあげてしまうだけなのです。 要するに、ユーザが絶対に提供しなければならない情報だけに制限する-- そして可能な限りよく練られたデフォルト設定を使うよう試みてください。 
もちろん、プログラムには適度な柔軟性を持たせたいとも望むはずですが、それこそがオプションの果たす役割です。 
繰り返しますが、設定ファイルのエントリであろうが、 GUI でできた「環境設定」ダイアログ上のウィジェットであろうが、コマンドラインオプションであろうが関係ありません -- より多くのオプションを実装すればプログラムはより柔軟性を持ちますが、実装はより難解になるのです。 
高すぎる柔軟性はユーザを閉口させ、コードの維持をより難しくするのです。 
5.3.3 既存テストコードの再利用 
単体テストの基礎となる構築要素は、テストケース -- セットアップと正しさのチェックを行う、独立したシナリオ -- です。 
PyUnitでは、テストケースは 
モジュールのTestCaseクラスのインスタンスで示します。 
何らかのテストを行う場合、ベースクラスTestCaseのassert*() か fail*()メソッドを使用してください。 
テストケース実行時、テストが失敗すると例外が送出され、テストフレームワークはテスト結果をfailureとします。 
assert*() とfail*()以外からの例外が発生した場合、テスト結果はerrorsとなります。 テストの実行方法については後述とし、まずはテストケースインスタンスの作成方法を示します。 
テストケースインスタンスは、以下のように引数なしでコンストラクタを呼び出して作成します。 
似たようなテストを数多く行う場合、同じ環境設定処理を何度も必要となります。 
例えば上記のようなWidgetのテストが100種類も必要な場合、それぞれのサブクラスで``Widget''オブジェクトを生成する処理を記述するのは好ましくありません。 
テスト中にsetUp()メソッドで例外が発生した場合、テストフレームワークはテストを実行することができないとみなし、runTest()を実行しません。 同様に、終了処理をtearDown()メソッドに記述すると、runTest()メソッド終了後に実行されます: 
setUp()が正常終了した場合、runTest()の結果に関わり無くtearDown()が実行されます。 このような、テストを実行する環境をfixtureと呼びます。 
この例ではrunTest()がありませんが、二つのテストメソッドを定義しています。 
このクラスのインスタンスはtest*()メソッドのどちらか一方の実行と、self.widgetの生成・解放を行います。 
PyUnitではテストスイートによってテストケースインスタンスをテスト対象の機能によってグループ化することができます。 
テストスイートは、 
のTestSuiteクラスで作成します。 
各テストモジュールで、テストケースを組み込んだテストスイートオブジェクトを作成する呼び出し可能オブジェクトを用意しておくと、テストの実行や参照が容易になります: 
または: 
(小心者は前者を使うべし)一般的には、TestCaseのサブクラスには良く似た名前のテスト関数が複数定義されますので、テストケースクラスの全テストケースを使ってテストスイートを作成するmakeSuite()関数を用意しています: 
makeSuite()でテストスイートを作成した場合、テストケースの実行順序はテストケース関数名をcmp()組み込み関数でソートした順番となります。 
システム全体のテストを行う場合など、テストスイートをさらにグループ化したい場合がありますが、このような場合、TestSuiteインスタンスにはTestSuiteと同じようにTestSuiteを追加する事ができます。 
テストケースやテストスイートは (widget.py のような) テスト対象のモジュール内にも記述できますが、テストは(widgettests.py のような) 独立したモジュールに置いた方が以下のような点で有利です: 
テストモジュールだけをコマンドラインから実行することができる。 
テストコードと出荷するコードを分離する事ができる。 
テストコードを、テスト対象のコードに合わせて修正する誘惑に駆られにくい。 
テストコードは、テスト対象コードほど頻繁に更新されない。 
テストコードをより簡単にリファクタリングすることができる。 
Cで書いたモジュールのテストは、どっちにしろ独立したモジュールとなる。 
テスト戦略を変更した場合でも、ソースコードを変更する必要がない。 
これらの関数は、ファイル記述子を使って参照されているI/Oストリームを操作します。 
ファイルディスクリプタ fd を閉じます。 利用できる環境: Macintosh、 Unix、 Windows 
注意:注:この関数は低レベルの I/O のためのもので、open() や pipe() が返すファイル記述子に対して適用しなければなりません。 
組み込み関数 open() や popen() 、fdopen() の返す ``ファイルオブジェクト'' を閉じるには、オブジェクトの close() メソッドを使ってください。 
ファイル記述子 fd の複製を返します。 利用できる環境: Macintosh、 Unix、 Windows. 
ファイル記述子を fd から fd2 に複製し、必要なら後者の記述子を前もって閉じておきます。 利用できる環境: Unix、Windows 
開いているファイルに関連したシステム設定情報 (system configurationinformation) を返します。 name には取得したい設定名を指定します; これは定義済みのシステム固有値名の文字列で、多くの標準(POSIX.1、 Unix 95、 Unix 98 その他) で定義されています。 
プラットフォームによっては別の名前も定義しています。 
ホストオペレーティングシステムの関知する名前は pathconf_names辞書で与えられています。 
name の指定値がホストシステムでサポートされておらず、pathconf_names にも入っていない場合、errno.EINVAL をエラー番号として OSError を送出します。 
stat() のようにファイル記述子 fd の状態を返します。 利用できる環境: Unix、Windows 
statvfs() のように、ファイル記述子 fd に関連づけられたファイルが入っているファイルシステムに関する情報を返します。 利用できる環境: Unix 
ファイル記述子 fd を持つファイルのディスクへの書き込みを強制します。 
Unixでは、ネイティブの fsync() 関数を、Windows では MS _commit() 関数を呼び出します。 Python のファイルオブジェクト f を使う場合、f の内部バッファを確実にディスクに書き込むために、まず 
f.flush() を実行し、それから os.fsync(f.fileno()) してください。 
利用できる環境: Unix、2.2.3 以降では Windows も。 
ファイル記述子 fd に対応するファイルを、サイズが最大で length バイトになるように切り詰めます。 利用できる環境: Unix。 
ファイル file を開き、flag に従って様々なフラグを設定し、可能なら mode に従ってファイルモードを設定します。 mode の標準の設定値は 0777 (8進表現) で、先に現在の umask を使ってマスクを掛けます。 
注意:この関数は低レベルの I/O のためのものです。 通常の利用では、read() や write() (やその他多くの) メソッドを持つ「ファイルオブジェクト」 を返す、組み込み関数 open() を使ってください。 
新しい擬似端末のペアを開きます。 
ファイル記述子のペア(master, slave) を返し、それぞれ pty および ttyを表します。 
(少しだけ) より可搬性のあるアプローチとしては、 
モジュールを使ってください。 利用できる環境: いくつかの Unix風システム。 
パイプを作成します。 
ファイル記述子のペア (r, w) を返し、それぞれ読み出し、書き込み用に使うことができます。 利用できる環境: Unix、Windows。 
ファイル記述子 fd から最大で n バイト読み出します。 読み出されたバイト列の入った文字列を返します。 
fd が参照しているファイルの終端に達した場合、空の文字列が返されます。 利用できる環境:Macintosh、Unix、Windows。 
注意:この関数は低レベルの I/O のためのもので、open() や pipe() が返すファイル記述子に対して適用しなければなりません。 
組み込み関数 open() や popen() 、fdopen() の返す ``ファイルオブジェクト'' 、あるいはsys.stdin から読み出すには、オブジェクトの read() メソッドを使ってください。 
fd (open() が返す開かれたファイル記述子) で与えられる端末に関連付けられたプロセスグループを返します。 利用できる環境: Unix。 
fd (open() が返す開かれたファイル記述子) で与えられる端末に関連付けられたプロセスグループを pgに設定します。 利用できる環境: Unix。 
ファイル記述子 fd に関連付けられている端末デバイスを特定する文字列を返します。 
fd が端末に関連付けられていない場合、例外が送出されます。 利用できる環境: Unix。 
組み込み関数 open() や popen() 、fdopen() の返す ``ファイルオブジェクト'' 、あるいはsys.stdout、sys.stderr に書き込むには、オブジェクトのwrite() メソッドを使ってください。 
以下のデータ要素は open() 関数の flags 引数を構築するために利用することができます。 
上のフラグと同様、open() 関数の flag 引数のためのオプションフラグです。 
open() 関数の flag 引数のためのオプションフラグです。 
利用できる環境:Macintosh、Windows。 
実 uid/gid を使って path に対するアクセスが可能か調べます。 
アクセスが許可されている場合 True を、そうでない場合 False を返します。 
access() の mode に渡すための値で、path が存在するかどうかを調べます。 
access() の mode に渡すための値で、path が読み出し可能かどうかを調べます。 
access() の mode に渡すための値で、path が書き込み可能かどうかを調べます。 
access() の mode に渡すための値で、path が実行可能かどうかを調べます。 
現在の作業ディレクトリ (current working directory) を path に設定します。 
現在の作業ディレクトリを表現する文字列を返します。 
path のモードを数値 mode に変更します。 mode は、(stat モジュールで定義されている)以下の値のいずれかを取り得ます: 
利用できる環境: Unix、Windows。 
path の所有者 (owner) id とグループ id を、数値 uidおよび gid に変更します。 
利用できる環境: Unix。 
src を指しているハードリンク dst を作成します。 利用できる環境: Unix。 
ディレクトリ内のエントリ名が入ったリストを返します。 リスト内の順番は不定です。 
特殊エントリ '.' および '..'は、それらがディレクトリに入っていてもリストには含められません。 
バージョン 2.3 で 変更 された仕様:Windows NT/2k/XP と Unix では、path が Unicode オブジェクトの場合、Unicode オブジェクトのリストが返されます。 利用できる環境: Macintosh、 Unix、Windows。 
stat() に似ていますが、シンボリックリンクをたどりません。 利用できる環境: Unix。 
数値で指定されたモード mode を持つ FIFO (名前付きパイプ) をpath に作成します。 
mode の標準の値は 0666 (8進)です。 
FIFOは (例えば os.unlink() を使って) 削除されるまで存在しつづけます。 
一般的に、FIFO は ``クライアント'' と ``サーバ''形式のプロセス間でランデブーを行うために使われます: このとき、サーバは FIFO を読み出し用に開き、クライアントは書き込み用に開きます。 
mkfifo() は FIFO を開かない -- 単にランデブーポイントを作成するだけ -- なので注意してください。 
filename という名前で、ファイルシステム・ノード (ファイル、デバイス特殊ファイル、または、名前つきパイプ) を作ります 。 mode は、作ろうとするノードの使用権限とタイプを、S_IFREG、S_IFCHR、S_IFBLK、S_IFIFO (これらの定数は stat で使用可能) のいずれかと（ビット OR で）組み合わせて指定します。 
S_IFCHR と S_IFBLK を指定すると、device は新しく作られたデバイス特殊ファイルを (おそらく os.makedev() を使って) 定義し、指定しなかった場合には無視します。 
バージョン 2.3 で 新たに追加 された仕様です。 
生のデバイス番号から、デバイスのメジャー番号を取り出します。 バージョン 2.3 で 新たに追加 された仕様です。 
生のデバイス番号から、デバイスのマイナー番号を取り出します。 バージョン 2.3 で 新たに追加 された仕様です。 
major と minor から、新しく生のデバイス番号を作ります。 バージョン 2.3 で 新たに追加 された仕様です。 
数値で指定されたモード mode をもつディレクトリ path を作成します。 mode の標準の値は 0777 (8進)です。 
システムによっては、 mode は無視されます。 
利用の際には、現在の umask 値が前もってマスクされます。 利用できる環境:Macintosh、 Unix、Windows。 
再帰的なディレクトリ作成関数です。 
mkdir() に似ていますが、末端 (leaf) となるディレクトリを作成するために必要な中間の全てのディレクトリを作成します。 
末端ディレクトリがすでに存在する場合や、作成ができなかった場合には error例外を送出します。 
mode の標準の値は 0777 (8進)です。 
(Windows システムにのみ関係することですが、Universal Naming Convention パスは、`hostpath' という書式のパスです）バージョン 1.5.2 で 新たに追加 された仕様です。 
指定されたファイルに関係するシステム設定情報を返します。 varname には取得したい設定名を指定します; これは定義済みのシステム固有値名の文字列で、多くの標準(POSIX.1、 Unix 95、 Unix 98 その他) で定義されています。 
pathconf() および fpathconf() が受理するシステム設定名を、ホストオペレーティングシステムで定義されている整数値に対応付けている辞書です。 
この辞書はシステムでどの設定名が定義されているかを決定するために利用できます。 利用できる環境: Unix。 
シンボリックリンクが指しているパスを表す文字列を返します。 
返される値は絶対パスにも、相対パスにもなり得ます; 相対パスの場合、os.path.join(os.path.dirname(path), result)を使って絶対パスに変換することができます。 
利用できる環境: Unix。 
ファイル path を削除します。 
path がディレクトリの場合、OSError が送出されます; ディレクトリの削除についてはrmdir() を参照してください。 
この関数は下で述べられているunlink() 関数と同一です。 
Windows では、使用中のファイルを削除しようと試みると例外を送出します; Unixでは、ディレクトリエントリは削除されますが、記憶装置上にアロケーションされたファイル領域は元のファイルが使われなくなるまで残されます。 利用できる環境: Macintosh、 Unix、Windows。 
再帰的なディレクトリ削除関数です。 
rmdir() と同じように動作しますが、末端ディレクトリがうまく削除できるかぎり、パスを構成する要素の右端となるディレクトリを刈り込んでゆき、指定したパス全体が削除されるかエラーが送出されるまで続けます (このエラーは通常、指定したディレクトリの親ディレクトリが空でないことを意味するだけなので無視されます)。 
末端のディレクトリがうまく削除できない場合には error を送出します。 バージョン 1.5.2 で 新たに追加 された仕様です。 
ファイルまたはディレクトリ src を dst に名前変更します。 
dst がディレクトリの場合、OSError が送出されます。 
Unixでは、 dst が存在し、かつファイルの場合、ユーザの権限があるかぎり暗黙のうちに元のファイルが削除されます。 
この操作はいくつかの Unix 系において、src と dstが異なるファイルシステム上にあると失敗することがあります。 
ファイル名の変更が成功する場合、この操作は原子的 (atomic) 操作となります (これは POSIX 要求仕様です) Windows では、dst が既に存在する場合には、たとえファイルの場合でもOSError が送出されます; これは dst が既に存在するファイル名の場合、名前変更の原子的操作を実装する手段がないからです。 
利用できる環境:Macintosh、 Unix、Windows。 
注意:この関数はコピー元の末端のディレクトリまたはファイルを削除する権限がない場合には失敗します。 
ディレクトリ path を削除します。 利用できる環境:Macintosh、 Unix、Windows。 
与えられた path に対して stat() システムコールを実行します。 
戻り値はオブジェクトで、その属性が stat 構造体の以下に挙げる各メンバ:st_mode (保護モードビット)、st_ino (i ノード番号)、st_dev (デバイス)、st_nlink (ハードリンク数)、st_uid (所有者のユーザ ID)、st_gid (所有者のグループID)、st_size (ファイルのバイトサイズ)、st_atime (最終アクセス時刻)、st_mtime (最終更新時刻)、st_ctime (プラットフォーム依存：Unixでは最終メタデータ変更時刻、Windowsでは作成時刻)となっています。 
バージョン 2.3 で 変更 された仕様:もし stat_float_times が真を返す場合、時間値は浮動小数点で秒を計ります。 
ファイルシステムがサポートしていれば、秒の小数点以下の桁も含めて返されます。 
Mac OS では、時間は常に浮動小数点です。 
詳細な説明は stat_float_times を参照してください 
では、stat 構造体から情報を引き出す上で便利な関数や定数を定義しています。 (Windows では、いくつかのデータ要素はダミーの値が埋められています。 
例えば、FAT や FAT32 ファイルシステムを使っているWindows システムでは、st_atime の精度は 1 日に過ぎません。 
詳しくはお使いのオペレーティングシステムのドキュメントを参照してください。 
利用できる環境: Macintosh、 Unix、Windows。 
バージョン 2.2 で 変更 された仕様:返されたオブジェクトの属性としてのアクセス機能を追加しました 
stat_result がタイムスタンプに浮動小数点オブジェクトを使うかどうかを決定します。 
newvalue が真の場合、以後の stat() 呼び出しは浮動小数点を返し、偽の場合には整数を返します。 
newvalue が省略された場合、現在の設定どおりの戻り値になります。 古いバージョンの Python と互換性を保つため、stat_result にタプルとしてアクセスすると、常に整数が返されます。 
また、Python 2.2 との互換性のため、タイムスタンプにフィールド名を指定してアクセスすると、整数で返されす。 
タイムスタンプの秒を小数点以下の精度で求めたいアプリケーションは、タイムスタンプを浮動小数点型にするために、この関数を使うことができます。 
浮動小数点型のタイムスタンプを処理すると、不正確な動作をするようなライブラリを使う場合、ライブラリが修正されるまで、浮動小数点型を返す機能を停止させておくべきです。 
与えられた path に対して statvfs() システムコールを実行します。 
では、シーケンスとしてアクセスする場合に、statvfs 構造体から情報を引き出す上便利な関数や定数を定義しています; これは属性として各フィールドにアクセスできないバージョンの Python で動作する必要のあるコードを書く際に便利です。 
src を指しているシンボリックリンクを dst に作成します。 利用できる環境: Unix。 
一時ファイル (temporary file) を生成する上でファイル名として相応しい一意なパス名を返します。 
この値は一時的なディレクトリエントリを表す絶対パスで、dir ディレクトリの下か、dir が省略されたり None の場合には一時ファイルを置くための共通のディレクトリの下になります。 
prefix が与えられており、かつNone でない場合、ファイル名の先頭につけられる短い接頭辞になります。 
アプリケーションは tempnam()が返したパス名を使って正しくファイルを生成し、生成したファイルを管理する責任があります; 一時ファイルの自動消去機能は提供されていません。 
この値は一時ファイルを置くための共通のディレクトリ下の一時的なディレクトリエントリを表す絶対パスです。 
アプリケーションは tmpnam()が返したパス名を使って正しくファイルを生成し、生成したファイルを管理する責任があります; 一時ファイルの自動消去機能は提供されていません。 
この関数はおそらく Windows では使うべきではないでしょう;Micorosoft の tmpnam() 実装では、常に現在のドライブのルートディレクトリ下のファイル名を生成しますが、これは一般的にはテンポラリファイルを置く場所としてはひどい場所です (アクセス権限によっては、この名前をつかってファイルを開くことすらできないかもしれません)。 
tmpnam() がテンポラリ名を再利用し始めるまでに生成できる一意な名前の最大数です。 
remove() と同じです; unlink() の名前は伝統的な Unix の関数名です。 利用できる環境: Macintosh、 Unix、Windows。 
path で指定されたファイルに最終アクセス時刻および最終修正時刻を設定します。 times が None の場合、ファイルの最終アクセス時刻および最終更新時刻は現在の時刻になります。 
walk() は、ディレクトリツリー以下のファイル名を、ツリーをトップダウンとボトムアップの両方向に歩行することで生成します。 
ディレクトリ top を根に持つディレクトリツリーに含まれる、各ディレクトリ(top 自身を含む) から、タプル (dirpath, dirnames, filenames) を生成します。 
このリスト内の名前には、ファイル名までのパスが含まれないことに、注意してください。 
dirpath 内のファイルやディレクトリへの (top からたどった) フルパスを得るには、os.path.join(dirpath, name) してください。 
オプション引数 topdown が真であるか、指定されなかった場合、各ディレクトリからタプルを生成した後で、サブディレクトリからタプルを生成します。 
topdown が偽のときに dirnames を変更しても効果はありません。 ボトムアップモードでは dirnames 自身が生成される前にdirnames内のディレクトリの情報が生成されるからです。 
デフォルトでは、os.listdir() 呼び出しから送出されたエラーは無視されます。 
オプションの引数 onerror を指定するなら、この値は関数でなければなりません; この関数は単一の引数として、os.error インスタンスを伴って呼び出されます。 
この関数ではエラーを報告して歩行を続けたり、例外を送出して歩行を中断したりできます。 
ファイル名は例外オブジェクトの filename 属性として取得できることに注意してください。 
注意:相対パスを渡した場合、walk() の回復の間でカレント作業ディレクトリを変更しないでください。 walk() はカレントディレクトリを変更しませんし、呼び出し側もカレントディレクトリを変更しないと仮定しています。 
注意:シンボリックリンクをサポートするシステムでは、サブディレクトリへのリンクが dirnames リストに含まれますが、walk() はそのリンクをたどりません (シンボリックリンクをたどると、無限ループに陥りやすくなります)。 
リンクされたディレクトリをたどるには、os.path.islink(path) でリンク先ディレクトリを確認し、各ディレクトリに対して walk(path) を実行するとよいでしょう。 
以下の例では、最初のディレクトリ以下にある各ディレクトリに含まれる、非ディレクトリファイルのバイト数を表示します。 
ただし、CVS サブディレクトリより下を見に行きません。 
次の例では、ツリーをボトムアップで歩行することが不可欠になります;rmdir() はディレクトリが空になる前に削除させないからです: 
暗号に関する用途に適したn バイトからなるランダムな文字列を返します。 
この関数は OS 固有の乱数発生源からランダムなバイト列を生成して返します。 
この関数の返すデータは暗号を用いたアプリケーションで十分利用できる程度に予測不能ですが、実際のクオリティは OS の実装によって異なります。 
Unix系のシステムでは /dev/urandom への問い合わせを行い、Windows では CryptGenRandom を使います。 
乱数発生源が見つからない場合、NotImplementedError を送出します。 バージョン 2.4 で 新たに追加 された仕様です。 
以下の関数は新しいファイルオブジェクトを作成します。 
ファイル記述子 fd に接続している、開かれたファイルオブジェクトを返します。 
引数 mode および bufsize は、組み込み関数 open() における対応する引数と同じ意味を持ちます。 
利用できる環境: Macintosh、 Unix、Windows 
command への、または command からのパイプ入出力を開きます。 
戻り値はパイプに接続されている開かれたファイルオブジェクトで、mode が 'r' (標準の設定です) または 'w' かによって読み出しまたは書き込みを行うことができます。 引数 bufsize は、組み込み関数 open() における対応する引数と同じ意味を持ちます。 
バージョン 2.0 で 変更 された仕様:この関数は、Pythonの初期のバージョンでは、Windows環境下で信頼できない動作をしていました。 
これはWindowsに付属して提供されるライブラリの _popen() 関数を利用したことによるものです。 
新しいバージョンの Python では、Windows 付属のライブラリにある壊れた実装を利用しません 
更新モード("w+b")で開かれた新しいファイルオブジェクトを返します。 
このファイルはディレクトリエントリ登録に関連付けられておらず、このファイルに対するファイル記述子がなくなると自動的に削除されます。 利用できる環境: Unix、Windows 
以下の popen() の変種はどれも、bufsizeが指定されている場合には I/O パイプのバッファサイズを表します。 mode を指定する場合には、文字列 'b' または 't'でなければなりません; これは、Windows でファイルをバイナリモードで開くかテキストモードで開くかを決めるために必要です。 
mode の標準の設定値は't' です。 またUnixではこれらの変種はいずれも cmd をシーケンスにできます。 
その場合、引数はシェルの介在なしに直接 (os.spawnv() のように) 渡されます。 
cmd が文字列の場合、引数は( os.system() のように)シェルに渡されます。 
以下のメソッドは子プロセスからリターンコードを取得できるようにはしていません。 
cmd を子プロセスとして実行します。 
ファイル・オブジェクト(child_stdin, child_stdout) を返します。 利用できる環境: Unix、Windowsバージョン 2.0 で 新たに追加 された仕様です。 
ファイルオブジェクト (child_stdin, child_stdout, child_stderr) を返します。 利用できる環境: Unix、Windowsバージョン 2.0 で 新たに追加 された仕様です。 
は子プロセスの視点で名付けられているので注意してください。 
モジュール内の同じ名前の関数を使っても実現できますが、これらの関数の戻り値は異なる順序を持っています。 
文字列形式によるシステム設定値 (system configuration value)を返します。 
name には取得したい設定名を指定します; この値は定義済みのシステム値名を表す文字列にすることができます; 名前は多くの標準 (POSIX.1、 Unix 95、 Unix 98 その他) で定義されています。 
ホストオペレーティングシステムの関知する名前は confstr_names辞書で与えられています。 
name の指定値がホストシステムでサポートされておらず、confstr_names にも入っていない場合、errno.EINVAL をエラー番号として OSError を送出します。 
過去 1 分、5 分、15分間で、システムで走っているキューの平均プロセス数を返します。 平均負荷が得られない場合には OSError を送出します。 
整数値のシステム設定値を返します。 name で指定された設定値が定義されていない場合、-1 が返されます。 
name に関するコメントとしては、confstr()で述べた内容が同様に当てはまります; 既知の設定名についての情報を与える辞書は sysconf_names で与えられています。 利用できる環境: Unix。 
以下のデータ値はパス名編集操作をサポートするために利用されます。 
これらの値は全てのプラットフォームで定義されています。 パス名に対する高レベルの操作は 
モジュールで定義されています。 
現在のディレクトリ参照するためにオペレーティングシステムで使われる文字列定数です。 例: POSIX では '.' 、Machintosh では':' 。 
os.path からも利用できます。 
親ディレクトリを参照するためにオペレーティングシステムで使われる文字列定数です。 例: POSIX では '..' 、Machintosh では'::' 。 
パス名を要素に分割するためにオペレーティングシステムで利用されている文字で、例えば POSIX では "/" で、Machintosh では ":" です。 
os.path からも利用できます。 
文字パス名を要素に分割する際にオペレーティングシステムで利用されるもう一つの文字で、分割文字が一つしかない場合には None になります。 
この値は sep がバックスラッシュとなっている DOS や Windows システムでは "/" に設定されています。 
ベースのファイル名と拡張子を分ける文字。 たとえば、os.py では "." です。 
os.path からも利用できます。 
バージョン 2.2 で 新たに追加 された仕様です。 
(PATH のような) サーチパス内の要素を分割するためにオペレーティングシステムが慣習的に用いる文字で、POSIX における":" や DOS および Windows における ";" に相当します。 
exec*p*() や spawn*p*() において、環境変数辞書内に'PATH' キーがない場合に使われる標準設定のサーチパスです。 
現在のプラットフォーム上で行を分割 (あるいは終端) するために用いられている文字列です。 
この値は例えば POSIX での'n' や MacOS での'r' のように、単一の文字にもなりますし、例えば DOS や Windows での'rn' のように複数の文字列にもなります。 
バージョン 2.4 で 新たに追加 された仕様です。 
プロセスを生成したり管理するために、以下の関数を利用することができます。 様々な exec*() 関数が、プロセス内にロードされた新たなプログラムに与えるための引数からなるリストをとります。 
どの場合でも、新たなプログラムに渡されるリストの最初の引数は、ユーザがコマンドラインで入力する引数ではなく、プログラム自身の名前になります。 
C プログラマにとっては、これはプログラムの main() に渡される argv[0] になります。 
例えば、"os.execv('/bin/echo', ['foo', 'bar'])" は、標準出力に"bar" を出力します; "foo" は無視されたかのように見えることでしょう。 
SIGABRT シグナルを現在のプロセスに対して生成します。 
Unixでは、標準設定の動作はコアダンプの生成です; Windows では、プロセスは即座に終了コード 3 を返します。 
signal.signal() を使って SIGABRT に対するシグナルハンドラを設定しているプログラムは異なる挙動を示すので注意してください。 利用できる環境: Unix、Windows。 
これらの関数はすべて、現在のプロセスを置き換える形で新たなプログラムを実行します; 現在のプロセスは戻り値を返しません。 
Unixでは、新たに実行される実行コードは現在のプロセス内にロードされ、呼び出し側と同じプロセス ID を持つことになります。 
エラーは OSError 例外として報告されます。 "l" および "v" のついた exec*() 関数は、コマンドライン引数をどのように渡すかが異なります。 
"l" 型は、コードを書くときにパラメタ数が決まっている場合に、おそらくもっとも簡単に利用できます。 個々のパラメタは単にexecl*() 関数の追加パラメタとなります。 
"v" 型は、パラメタの数が可変の時に便利で、リストかタプルの引数が args パラメタとして渡されます。 
どちらの場合も、子プロセスに渡す引数は動作させようとしているコマンドの名前から始めるべきですが、これは強制ではありません。 末尾近くに "p" をもつ型(execlp()、 execlpe()、 execvp()、および execvpe()) は、プログラム file を探すために環境変数 PATH を利用します。 
_exit() は通常、 fork() された後の子プロセスでのみ使われます。 
以下の終了コードは必須ではありませんが _exit() と共に使うことができます。 
一般に、 メールサーバの外部コマンド配送プログラムのような、Python で書かれたシステムプログラムに使います。 
誤った個数の引数が渡されたときなど、コマンドが間違って使われたことを表す終了コード。 
利用できる環境: Unix。 
利用できる環境: Unix。 
指定されたユーザが存在しなかったことを表す終了コード。 
指定されたホストが存在しなかったことを表す終了コード。 
要求されたサービスが利用できないことを表す終了コード。 
利用できる環境: Unix。 
fork できない、pipe の作成ができないなど、オペレーティング・システム・エラーが検出されたことを表す終了コード。 
利用できる環境: Unix。 
ユーザには作成できない出力ファイルを指定したことを表す終了コード。 
利用できる環境: Unix。 
一時的な失敗が発生したことを表す終了コード。 
操作を行うために十分な許可がなかった（ファイルシステムの問題を除く）ことを表す終了コード。 
利用できる環境: Unix。 
子プロセスを fork します。 
子プロセスでは 0 が返り、親プロセスでは子プロセスの id が返ります。 利用できる環境: Unix。 
子プロセスを fork します。 
このとき新しい擬似端末 (psheudo-terminal) を子プロセスの制御端末として使います。 親プロセスでは (pid, fd) からなるペアが返り、fd は擬似端末のマスタ側 (master end) のファイル記述子となります。 
可搬性のあるアプローチを取るためには、 
モジュールを利用してください。 利用できる環境: いくつかの Unix系。 
プロセス pid をシグナル sig で kill します。 
ホストプラットフォームで利用可能なシグナルを特定する定数は 
モジュールで定義されています。 利用できる環境: Unix。 
プロセスの ``nice 値'' に increment を加えます。 
新たなnice 値を返します。 利用できる環境: Unix。 
プログラムのセグメント (program segment) をメモリ内でロックします。 
op (sys/lock.h で定義されています) にはどのセグメントをロックするかを指定します。 利用できる環境: Unix。 
子プロセスを起動し、子プロセスとの通信のために開かれたパイプを返します。 
これらの関数は 6.1.2 節で記述されています。 
新たなプロセス内でプログラム path を実行します。 
mode が P_NOWAIT の場合、この関数は新たなプロセスのプロセス ID となります。 ; mode が P_WAITの場合、子プロセスが正常に終了するとその終了コードが返ります。 
そうでない場合にはプロセスを kill したシグナル signal に対して-signal 
"l" 型は、コードを書くときにパラメタ数が決まっている場合に、おそらくもっとも簡単に利用できます。 個々のパラメタは単にspawnl*() 関数の追加パラメタとなります。 
どちらの場合も、子プロセスに渡す引数は動作させようとしているコマンドの名前から始まらなくてはなりません。 末尾近くに "p" をもつ型(spawnlp()、 spawnlpe()、 spawnvp()、および spawnvpe()) は、プログラム file を探すために環境変数 PATH を利用します。 
環境変数が (次の段で述べるspawn*e() 型関数で) 置き換えられる場合、環境変数はPATH を決定する上の情報源として使われます。 
利用できる環境: Unix、Windows。 spawnlp()、spawnlpe()、 spawnvp() および spawnvpe() は Windows では利用できません。 
バージョン 1.6 で 新たに追加 された仕様です。 P_NOWAIT 
spawn*() 関数ファミリに対する mode パラメタとして取れる値です。 
この値のいずれかを mode として与えた場合、spawn*() 関数は新たなプロセスが生成されるとすぐに、プロセスの ID を戻り値として返ります。 
spawn*() 関数ファミリに対する mode パラメタとして取れる値です。 
この値を mode として与えた場合、spawn*() 関数は新たなプロセスを起動して完了するまで返らず、プロセスがうまく終了した場合には終了コードを、シグナルによってプロセスが kill された場合には -signal を返します。 
利用できる環境:Unix、Windows。 バージョン 1.6 で 新たに追加 された仕様です。 
spawn*() 関数ファミリに対する mode パラメタとして取れる値です。 
ファイルを関連付けられたアプリケーションを使って「スタート」します。 
この動作は、 Windows の Explorer 上でのファイルをダブルクリックや、コマンドプロンプト (interactive command shell) 上でのファイル名を start 命令の引数としての実行と同様です:ファイルは拡張子が関連付けされているアプリケーション (が存在する場合)を使って開かれます。 
startfile() は関連付けされたアプリケーションが起動すると同時に返ります。 
アプリケーションが閉じるまで待機させるためのオプションはなく、アプリケーションの終了状態を取得する方法もありません。 
path 引数は現在のディレクトリからの相対で表します。 
絶対パスを利用したいなら、最初の文字はスラッシュ ("/") ではないので注意してください; もし最初の文字がスラッシュなら、システムの背後にある Win32 ShellExecute() 関数は動作しません。 os.path.normpath() 関数を使って、Win32 用に正しくコード化されたパスになるようにしてください。 
利用できる環境:Windows。 
バージョン 2.0 で 新たに追加 された仕様です。 
サブシェル内でコマンド (文字列) を実行します。 
この関数は標準 C 関数 system() を使って実装されており、system() と同じ制限があります。 
posix.environ、 sys.stdin 等に対する変更を行っても、実行されるコマンドの環境には反映されません。 Unixでは、戻り値はプロセスの終了ステータスで、wait() で定義されている書式にコード化されています。 
(プロセスまたはその他の) 積算時間を秒で表す浮動小数点数からなる、5 要素のタプルを返します。 
タプルの要素は、ユーザ時間 (user time)、システム時間 (system time)、子プロセスのユーザ時間、子プロセスのシステム時間、そして過去のある固定時点からの経過時間で、この順に並んでいます。 
Unix マニュアルページ 
times(2) または対応する Windows プラットフォーム API ドキュメントを参照してください。 利用できる環境: Unix、Windows。 
子プロセスの実行完了を待機し、子プロセスの pid と終了コードインジケータ-- 16 ビットの数で、下位バイトがプロセスを kill したシグナル番号、上位バイトが終了ステータス (シグナル番号がゼロの場合) -- の入ったタプルを返します; コアダンプファイルが生成された場合、下位バイトの最上桁ビットが立てられます。 利用できる環境: Unix。 
プロセス id pid で与えられた子プロセスの完了を待機し、子プロセスのプロセス id と(wait() と同様にコード化された)終了ステータスインジケータからなるタプルを返します。 
pid が0 の場合、現在のプロセスグループ内の任意の子プロセスの状態に対する要求です。 
pid が -1 の場合、現在のプロセスの任意の子プロセスに対する要求です。 
pid が -1 よりも小さい場合、プロセスグループ -pid 
(すなわち pid の絶対値) 内の任意のプロセスに対する要求です。 
子プロセス状態がすぐに取得できなかった場合にハングアップしてしまわないようにするための waitpid() のオプションです。 
プロセスが停止された (stop) 場合に真を返します。 利用できる環境: Unix。 
プロセスがシグナルによって終了した (exit) 場合に真を返します。 利用できる環境: Unix。 
プロセスが 
exit(2) システムコールで終了した場合に真を返します。 利用できる環境: Unix。 
WIFEXITED(status) が真の場合、 
exit(2) システムコールに渡された整数パラメタを返します。 
そうでない場合、返される値には意味がありません。 利用できる環境: Unix。 
プロセスを停止させたシグナル番号を返します。 利用できる環境: Unix。 
プロセスを終了させたシグナル番号を返します。 利用できる環境: Unix 
これらの関数とデータ要素は、現在のプロセスおよびユーザに対する情報提供および操作のための機能を提供しています。 
環境変数の値を表すマップ型オブジェクトです。 
それ以後に変更された環境変数は os.environ を直接変更しない限り反映されません。 
プラットフォーム上で putenv() がサポートされている場合、このマップ型オブジェクトは環境変数に対するクエリと同様に変更するために使うこともできます。 
putenv() はマップ型オブジェクトが修正される時に、自動的に呼ばれることになります。 
注意: 
putenv() を直接呼び出してもos.environ の内容は変わらないので、os.environを直接変更する方がベターです。 
注意:FreeBSD と Mac OS X を含むいつくかのプラットフォームでは、environ の値を変更するとメモリリークの原因になる場合があります。 
システムの putenv に関するドキュメントを参照してください。 
putenv() が提供されていない場合、このマッピングオブジェクトを適切なプロセス生成機能に渡して、子プロセスが修正された環境変数を利用するようにできます。 
これらの関数は、``ファイルとディレクトリ'' (6.1.4 節) で説明されています。 
プロセスの制御端末に対応するファイル名を返します。 利用できる環境: Unix。 
現在のプロセスの実行グループ id を返します。 
この id は現在のプロセスで実行されているファイルの `set id' ビットに対応します。 利用できる環境: Unix。 
現在のプロセスの実行ユーザ id を返します。 利用できる環境: Unix。 
現在のプロセスの実際のグループ id を返します。 利用できる環境: Unix。 
現在のプロセスに関連づけられた従属グループ id のリストを返します。 利用できる環境: Unix。 
現在のプロセスの制御端末にログインしているユーザ名を返します。 
利用できる環境: Unix。 
現在のプロセス・グループの id を返します。 利用できる環境: Unix。 
現在のプロセス id を返します。 利用できる環境: Unix, Windows.。 
親プロセスの id を返します。 利用できる環境: Unix。 
現在のプロセスのユーザ id を返します。 利用できる環境: Unix。 
varname と名づけられた環境変数の値を文字列 value に設定します。 
このような環境変数への変更は、os.system() 、popen() 、 fork() および execv() により起動された子プロセスに影響します。 
利用できる環境: 主な Unix互換環境、Windows。 
注意:FreeBSD と Mac OS X を含むいつくかのプラットフォームでは、environ の値を変更するとメモリリークの原因になる場合があります。 
システムの putenv に関するドキュメントを参照してください。 
現在のプロセスに有効なグループIDをセットします。 利用できる環境: Unix。 
現在のプロセスに有効なユーザIDをセットします。 利用できる環境: Unix。 
現在のプロセスにグループ id をセットします。 利用できる環境: Unix。 
現在のグループに関連付けられた従属グループ id のリストを groupsに設定します。 groups はシーケンス型でなくてはならず、各要素はグループを特定する整数でなくてはなりません。 
この操作は通常、スーパユーザしか利用できません。 Availability: Unix.バージョン 2.2 で 新たに追加 された仕様です。 
システムコール setpgrp() またはsetpgrp(0, 0) のどちらかのバージョンのうち、(実装されていれば) 実装されている方を呼び出します。 
機能については Unix マニュアルを参照してください。 利用できる環境: Unix 
システムコール setpgid() を呼び出して、pid の id をもつプロセスのプロセスグループ id を pgrpに設定します。 
利用できる環境: Unix 
現在のプロセスに対して実際のユーザ id および実行ユーザ id を設定します。 利用できる環境: Unix 
現在のプロセスに対して実際のグループ id および実行ユーザ id を設定します。 利用できる環境: Unix 
システムコール getsid() を呼び出します。 
機能についてはUnix マニュアルを参照してください。 利用できる環境: Unix 
システムコール setsid() を呼び出します。 
現在のプロセスのユーザ id を設定します。 利用できる環境: Unix 
エラーコード code に対応するエラーメッセージを返します。 利用できる環境: Unix、Windows 
現在の数値 umask を設定し、以前の umask 値を返します。 利用できる環境: Unix、Windows 
現在のオペレーティングシステムを特定する情報の入った 5 要素のタプルを返します。 
このタプルには 5 つの文字列:(sysname, nodename, release, version,machine) が入っています。 
システムによっては、ノード名を 8 文字、または先頭の要素だけに切り詰めます; ホスト名を取得する方法としては、socket.gethostname() 
を使う方がよいでしょう、あるいは socket.gethostbyaddr(socket.gethostname())でもかまいません。 
利用できる環境: Unix互換環境 
filename という名前の標準 I/O ファイル fp が対話的(interactive) であると考えられる場合に真 (非ゼロ) を返します。 
これは"isatty(fileno(fp))" が真になるファイルの場合です。 
グローバルなフラグ Py_InteractiveFlag が真の場合には、filename ポインタが NULL か、名前が 'stdin'または '???' のいずれかに等しい場合にも真を返します。 
ファイル filename の最終更新時刻を返します。 結果は標準 C ライブラリ関数 time() が返すタイムスタンプと同じ様式で符号化されています。 
プロセスが fork した後の内部状態を更新するための関数です;fork 後 Python インタプリタを使い続ける場合、新たなプロセス内でこの関数を呼び出さねばなりません。 
新たなプロセスに新たな実行可能物をロードする場合、この関数を呼び出す必要はありません。 
インタプリタがスタック空間を使い尽くしたときに真を返します。 
このチェック関数には信頼性がありますが、USE_STACKCHECKが定義されている場合 (現状では Microsoft Visual C++ コンパイラでビルドした Windows 版と Macintosh 版) にしか利用できません . USE_CHECKSTACK は自動的に定義されます; 自前のコードでこの定義を変更してはなりません。 
シグナル i に対する現在のシグナルハンドラを返します。 
この関数は sigaction() または signal()のいずれかに対する薄いラッパです。 
sigaction() や signal() を直接呼び出してはなりません! PyOS_sighandler_t は void (*)(int) の typedef による別名です。 
シグナル i に対する現在のシグナルハンドラを h に設定します; 以前のシグナルハンドラを返します。 
この関数は sigaction() または signal()のいずれかに対する薄いラッパです。 
sigaction() や signal() を直接呼び出してはなりません! PyOS_sighandler_t は void (*)(int) の typedef による別名です。 
オーディオデバイスに読み書きできるようになるには、まず3 つのメソッドを正しい順序で呼び出さねばなりません: 
setfmt() で出力形式を設定し、 
channels() でチャンネル数を設定し、 
speed() でサンプリングレートを設定します。 
この代わりにsetparameters() メソッドを呼び出せば、三つのオーディオパラメタを一度で設定できます。 
setparameters() は便利ですが、多くの状況で柔軟性に欠けるでしょう。 open() の返すオーディオデバイスオブジェクトには以下のメソッドがあります: 
オーディオデバイスを明示的に閉じます。 
オーディオデバイスは、読み出しや書き込みが終了したら必ず閉じねばなりません。 
閉じたオブジェクトを再度開くことはできません。 
デバイスに関連付けられているファイル記述子を返します。 
オーディオ入力から size バイトを読みだし、 Python 文字列型にして返します。 
多くの Unix デバイスドライバと違い、 ブロックデバイスモード (デフォルト) の OSS オーディオデバイスでは、要求した量のデータ全体を取り込むまでread() がブロックします。 
Python 文字列 data の内容をオーディオデバイスに書き込み、書き込まれたバイト数を返します。 
オーディオデバイスがブロックモード(デフォルト) の場合、常に文字列データ全体を書き込みます (前述のように、これは通常のUnix デバイスの振舞いとは異なります)。 
デバイスが非ブロックモードの場合、データの一部が書き込まれないことがあります -- writeall() を参照してください。 
実際に書き込まれたデータの量と渡したデータの量は必ず同じになるので、戻り値はありません。 
以下のメソッドの各々は ioctl() システムコール一つ一つに対応しています。 
対応関係ははっきりしています:例えば、setfmt() は SNDCTL_DSP_SETFMT ioctlに対応していますし、sync() はSNDCTL_DSP_SYNCに対応しています (このシンボル名は OSS のドキュメントを参照する時に助けになるでしょう)。 
根底にある ioctl() が失敗した場合、これらの関数は全て IOError を送出します。 
デバイスを非ブロックモードにします。 
いったん非ブロックモードにしたら、ブロックモードは戻せません。 
サウンドカードがサポートしているオーディオ出力形式をビットマスクで返します。 
典型的なLinuxシステムでは以下のフォーマットがあります: 
対数符号化 (Sun の .au 形式や/dev/audio で使われている形式) 
対数符号化 
Interactive Multimedia Association で定義されている 4:1 圧縮形式 
符号なし 8 ビットオーディオ 
符号つき 16 ビットオーディオ、リトルエンディアンバイトオーダ (Intelプロセッサで使われている形式) 
符号つき16ビットオーディオ、ビッグエンディアンバイトオーダ (68k、PowerPC、Sparcで使われている形式) 
符号つき 8 ビットオーディオ 
符号なし 16 ビットリトルエンディアンオーディオ 
符号なし 16 ビットビッグエンディアンオーディオ 
ほとんどのシステムは、上記の形式のサブセットしかサポートしていません。 
また、多くのデバイスが AFMT_U8 だけしかサポートしていません。 現在使われている最も一般的な形式はAFMT_S16_LEです。 
現在のオーディオ形式をformatに設定しようと試みます --formatについてはgetfmts()のリストを参照してください。 
実際にデバイスに設定されたオーディオ形式を返します。 
要求通りの形式でないこともあります。 AFMT_QUERY を渡すと現在デバイスに設定されているオーディオ形式を返します。 
出力チャネル数をnum_channelsに設定します。 
1 はモノラル、2 はステレオです。 
いくつかのデバイスでは2つより多いチャンネルを持つものもありますし、ハイエンドなデバイスではモノラルをサポートしないものもあります。 デバイスに設定されたチャンネル数を返します。 
サンプリングレートを1秒あたりsamplerate に設定しようと試み、実際に設定されたレートを返します。 
たいていのサウンドデバイスでは任意のサンプリングレートをサポートしていません。 
一般的なレートは以下の通りです: 
レート 
/dev/audio のデフォルト 
会話音声の録音に使われるレート 
(サンプルあたり 16 ビットで 2 チャネルの場合) CD 品質のオーディオ 
(サンプル当たり 24 ビットの場合) DVD 品質のオーディオ 
サウンドデバイスがバッファ内の全てのデータを再生し終えるまで待機します。 
(デバイスを閉じると暗黙のうちに sync() が起こります) OSS のドキュメント上では、sync() を使うよりデバイスを一度閉じて開き直すよう勧めています。 
再生あるいは録音を即座に中止して、デバイスをコマンドを受け取れる状態に戻します。 
OSSのドキュメントでは、reset() を呼び出した後に一度デバイスを閉じ、開き直すよう勧めています。 
ドライバに出力の一時停止 (pause) が起きそうであることを伝え、ドライバが一時停止をより賢く扱えるようにします。 
短いサウンドエフェクトを再生した直後やユーザ入力待ちの前、またディスク I/O 前などに使うことになるでしょう。 
以下のメソッドは、複数の ioctl を組み合わせたり、ioctl と単純な計算を組み合わせたりした便宜用メソッドです。 
主要なオーディオパラメタ、サンプル形式、チャネル数、サンプルレートを一つのメソッド呼び出しで設定します。 format、nchannels および samplerate には、それぞれsetfmt()、channels() および speed()と同じやり方で値を設定します。 
strict の値が真の場合、setparameters() は値が実際に要求通りにデバイスに設定されたかどうか調べ、違っていれば OSSAudioError を送出します。 
実際にデバイスドライバが設定したパラメタ値を表す (format, nchannels, samplerate) からなるタプルを返します (setfmt()、channels() および speed()の返す値と同じです)。 
以下に例を示します: (fmt, channels, rate) = dsp.setparameters(fmt, channels, rate) 
ハードウェアのバッファサイズをサンプル数で返します。 
ハードウェアバッファ上に残っていてまだ再生されていないサンプル数を返します。 
ブロックを起こさずにハードウェアの再生キューに書き込めるサンプル数を返します。 
1.1 MacPython-OSXの取得とインストール 
1.1.3 設定 
1.1.2 GUI つきのスクリプトの実行 Mac OS X には、一つだけ知っておかねばならないクセがあります: Aqua ウィンドウマネージャとやり取りするような (すなわち、何らかの GUIを持つような) プログラムは、特殊な方法で起動せねばならないのです。 
GUIを持ったスクリプトを実行するには python の代わりにpythonw を使ってください。 
16.6 他のグラフィカルユーザインタフェースパッケージ 
へ付け加えられるたくさんの拡張ウィジェットがあります。 
Python メガウィジェット 
モジュールを使い Python で高レベルの複合ウィジェットを構築するためのツールキットです。 
基本クラスとこの基礎の上に構築された柔軟で拡張可能なメガウィジェットから構成されています。 
これらのメガウィジェットはノートブック、コンボボックス、選択ウィジェット、ペインウィジェット、スクロールするウィジェット、ダイアログウィンドウなどを含みます。 
BLTに対するPmw.Bltインタフェースを持ち、busy、graph、stripchart、tabsetおよびvectorコマンドが利用できます。 Pmwの最初のアイディアは、Michael McLennanによるTk itcl拡張[incr Tk]とMark Ulfertsによる[incr Widgets]から得ました。 
メガウィジェットのいくつかはitclから Python へ直接変換したものです。 
は、新しい Tkinter ウィジェットを、 Python で書けるようにするライブラリです。 
WCK フレームワークは、ウィジェットの生成、設定、スクリーンの外観、イベント操作における、完全な制御を提供します。 
Tk/Tcl レイヤーを通してデータ転送する必要がなく、直接 Python のデータ構造を操作することができるので、WCK ウィジェットは非常に高速で軽量になり得ます。 
Tk は Python にとって唯一の GUI というわけではありませんが、もっともよく使われています。 
Qt、Tk、MotifおよびGTK+のもっとも魅力のある性質を一つのパッケージに結合したGUIツールキットです。 
Tkinterに依存しない Python クラスブラウザがあります。 wxWindowsは 
よりさらにウィジェットが豊富で、そのへヘルプシステム、洗練されたHTMLと画像ビューアおよび他の専門分野別のウィジェット、多数のドキュメントと印刷機能を持っています。 
PyQtはsipでラップされたQtツールキットへのバインディングです。 
PyKDEはsipでラップされたKDEデスクトップライブラリに対するインタフェースです。 
KDEはUnixコンピュータ用のデスクトップ環境です。 グラフィカル・コンポーネントはQtに基づいています。 
FOXは、グラフィカルユーザインタフェースを簡単かつ効率良く開発するためのC++ベースのツールキットです。 
それは幅広く、成長しているコントロール・コレクションで、3Dグラフィックスの操作のためのOpenGLウィジェットと同様に、ドラッグアンドドロップ、選択のような最新の機能を提供します。 
FOXはアイコン、画像およびステータスライン・ヘルプやツールチップのようなユーザにとって便利な機能も実装しています。 
FOXはすでに大規模なコントロール・コレクションを提供していますが、単に既存のコントロールを使って望みの振る舞いを追加または再定義する派生クラスを作成することによってプログラマが簡単に追加コントロールとGUI要素を構築できるようにするために、FOXはC++を利用しています。 
GTKウィジェットセットのための一連のバインディングです。 Cのものより少しだけ高レベルなオブジェクト指向インタフェースを提供します。 
普通はC APIを使ってやらなければならない型キャストとリファレンス・カウントをすべて自動的に行います。 
GNOMEに対しても、バインディングがあります。 チュートリアルが手に入ります。 
トークンの解析にあいまいさが生じた場合、トークンは左から右に読んで不正でないトークンを構築できる最長の文字列を含むように構築されます。 
7.5.1 ファイルオブジェクト (file object) 
オブジェクトへの参照を関数の内外に渡す場合には、オブジェクトの所有権が参照と共に渡されるか否かが常に関数インタフェース仕様の一部となります。 オブジェクトへの参照を返すほとんどの関数は、参照とともに所有権も渡します。 
特に、PyInt_FromLong() やPy_BuildValue() のように、新しいオブジェクトを生成する関数は全て所有権を相手に渡します。 
オブジェクトが実際には新たなオブジェクトでなくても、そのオブジェクトに対する新たな参照の所有権を得ます。 
例えば、PyInt_FromLong()はよく使う値をキャッシュしており、キャッシュされた値への参照を返すことがあります。 PyObject_GetAttrString() のように、あるオブジェクトから別のオブジェクトを抽出するような関数もまた、参照とともに所有権を委譲します。 
とはいえ、この規則には二つの重要な例外:PyTuple_SetItem() とPyList_SetItem()があります。 
これらの関数は、渡された引数要素に対して所有権を乗っ取り (take over) ます -- たとえ失敗してもです!(PyDict_SetItem() とその仲間は所有権を乗っ取りません --これらはいわば ``普通の'' 関数です。 
)Python から C 関数が呼び出される際には、C 関数は呼び出し側から引数への参照を借用します。 
C 関数の呼び出し側はオブジェクトへの参照を所有しているので、借用参照の生存期間が保証されるのは関数が処理を返すまでです。 
このようにして借用参照を保存したり他に渡したりしたい場合にのみ、Py_INCREF() を使って所有参照にする必要があります。 Python から呼び出された C 関数が返す参照は所有参照でなければなりません -- 所有権は関数から呼び出し側へと委譲されます。 
Python パッケージインデクス (Python Package Index, PyPI) は、distutils でパッケージ化された配布物に関するメタデータを保持しています。 
配布物のメタデータをインデクスに提出するには、 Distutils のコマンド register を使います。 
register は以下のように起動します: 
Distutils は以下のようなプロンプトを出します: 
注意: ユーザ名とパスワードをローカルの計算機に保存しておくと、このメニューは表示されません。 まだ PyPI に登録したことがなければ、まず登録する必要があります。 
この場合選択肢 2 番を選び、リクエストされた詳細情報を入力してゆきます。 
詳細情報を提出し終えると、登録情報の承認を行うためのメールを受け取るはずです。 すでに登録を行ったことがあれば、選択肢 1 を選べます。 
PyPI は提出された配布物の (名前、バージョン) の各組み合わせについて記録を保持しています。 
ある配布物名について最初に情報を提出したユーザが、その配布物名のオーナ (owner) になります。 
オーナは registerコマンドか、web インタフェースを介して変更を提出できます。 
オーナは他のユーザをオーナやメンテナとして指名できます。 
メンテナはパッケージ情報を編集できますが、他の人をオーナやメンテナに指名することはできません。 デフォルトでは、 PyPI はあるパッケージについて全てのバージョンを表示します。 
特定のバージョンを非表示にしたければ、パッケージのHidden プロパティを yes に設定します。 
この値は web インタフェースで編集しなければなりません。 
丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです: 
丸括弧で囲われた式のリストは、個々の式が表現するものになります:リスト内に少なくとも一つのカンマが入っていた場合、タプルになります;そうでない場合、式のリストを構成している単一の式自体の値になります。 中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。 
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。 
タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。 
例外は空のタプルで、この場合には丸括弧が必要です -- 丸括弧のつかない、``何も記述しない式 (nothing)'' を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。 
PyArg_ParseTuple() は、以下のように宣言されています: 
引数arg は C 関数から Python に渡される引数リストが入ったタプルオブジェクトでなければなりません。 
format 引数は書式化文字列で、 
の ``引数の解釈と値の構築'' で解説されている書法に従わねばなりません。 残りの引数は、それぞれの変数のアドレスで、書式化文字列から決まる型になっていなければなりません。 
PyArg_ParseTuple() は Python 側から与えられた引数が必要な型になっているか調べるのに対し、PyArg_ParseTuple() は呼び出しの際に渡された C 変数のアドレスが有効な値を持つか調べられないことに注意してください: ここで間違いを犯すと、コードがクラッシュするかもしれませんし、少なくともでたらめなビットをメモリに上書きしてしまいます。 
慎重に! 呼び出し側に提供されるオブジェクトへの参照はすべて 借用参照 (borrowed reference) になります; これらのオブジェクトの参照カウントをデクリメントしてはなりません!以下にいくつかの呼び出し例を示します: 
int ok;int i, j;long k, l;const char *s;int size;ok = PyArg_ParseTuple(args, ""); /* 引数なし *//* Python での呼び出し: f() */ 
ok = PyArg_ParseTuple(args, "s", s); /* 文字列 *//* Python での呼び出し例: f('whoops!') */ 
ok = PyArg_ParseTuple(args, "lls", k, l, s); /* 二つの long と文字列 *//* Python での呼び出し例: f(1, 2, 'three') */ 
ok = PyArg_ParseTuple(args, "(ii)s#", i, j, s, size);/* 二つの int と文字列、文字列のサイズも返す *//* Python での呼び出し例: f((1, 2), 'three') */ 
{int left, top, right, bottom, h, v;ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",left, top, right, bottom, h, v);/* 矩形と点を表現するデータ *//* Python での呼び出し例:f(((0, 0), (400, 300)), (10, 10)) */} 
{Py_complex c;ok = PyArg_ParseTuple(args, "D:myfunction", c);/* 複素数。 
エラー発生時用に関数名も指定 *//* Python での呼び出し例: myfunction(1+2j) */} 
PyArg_ParseTupleAndKeywords() は、以下のように宣言されています: 
arg と format パラメタはPyArg_ParseTuple() のものと同じです。 
kwdict パラメタはキーワード引数の入った辞書で、 Python ランタイムシステムから第三パラメタとして受け取ります。 
kwlist パラメタは各パラメタを識別するための文字列からなる、NULL終端されたリストです; 各パラメタ名は format 中の型情報に対して左から右の順に照合されます。 
成功するとPyArg_ParseTupleAndKeywords() は真を返し、それ以外の場合には適切な例外を送出して偽を返します。 
注意:キーワード引数を使っている場合、タプルは入れ子にして使えません!kwlist 内に存在しないキーワードパラメタが渡された場合、TypeError の送出を引き起こします。 
以下にキーワードを使ったモジュール例を示します。 
voidinitkeywdarg(void){/* モジュールを作成して関数を追加する */Py_InitModule("keywdarg", keywdarg_methods);} 
pass はヌル操作 (null operation) です -- passが実行されても、何も起きません。 
pass は、例えば: 
def f(arg): pass # a function that does nothing (yet)class C: pass # a class with no methods (yet) のように、構文法的には文が必要だが、コードとしては何も実行したくない場合のプレースホルダとして有用です。 
PenとRawPenオブジェクトは、demo()がメソッドとしは除かれますが、与えられたペンを操作する上記のすべてのグローバル関数を持っています。 メソッドになって強力になっているメソッドはdegrees()だけです。 
fullcircleはデフォルトで360です。 
物理行とは、利用しているプラットフォームで行終端として取り決めている文字列で終端されたものです。 
Unixでは、行終端は ASCII LF (行送り: linefeed)文字です。 
Windows では、 ASCII 配列の CR LF (復帰: return に続いて行送り) です。 
Macintosh では、 ASCII CR (復帰) 文字です。 
以下にあるクラスについてどうやって picklle 化の振る舞いを変更するかのれいを示します。 
TextReader クラスはファイルを開き、readline() メソッドが呼ばれるたびに行番号と行の内容を返します。 
TextReader インスタンスが pickle 化された場合、ファイルオブジェクト 以外の 全ての属性が保存されます。 
インスタンスが unpickle 化された際、ファイルは再度開かれ、以前のファイル位置から読み出しを再開します。 
使用例は以下のようになるでしょう: 
が Python プロセス間でうまく働くことを見たいなら、先に進む前に他の Python セッションを開始してください。 
以下の振る舞いは同じプロセスでも新たなプロセスでも起こります。 
参考: copy_reg 
オブジェクトのインデクス付きデータベース; pickle を使います。 
オブジェクトの浅いコピーおよび深いコピー。 
高いパフォーマンスを持つ組み込み型整列化機構。 . 
3.14.5.1 通常のクラスインスタンスの pickle 化および unpickle 化 
3.14.5.2 拡張型の pickle 化および 
pickle 化されたクラスインスタンスが unpickle 化されたとき、__init__() メソッドは通常呼び出されません 。 
unpickle 化の際に __init__() が呼び出される方が望ましい場合、旧スタイルクラスではメソッド __getinitargs__() を定義することができます。 
このメソッドはクラスコンストラクタ (すなわち __init__()) に渡されるべき タプルを 返さなければなりません。 
__getinitargs__() メソッドは pickle 時に呼び出されます;この関数が返すタプルはインスタンスの pickle 化データに組み込まれます。 
新スタイルクラスでは、プロトコル 2 で呼び出される__getnewargs__() を定義する事ができます。 
インスタンス生成時に内部的な不変条件が成立する必要があったり、（タプルや文字列のように）型の__new__()メソッドに指定する引数によってメモリの割り当てを変更する必要がある場合には__getnewargs__()を定義してください。 
新スタイルクラスCのインスタンスは、次のように生成されます。 
ここでargsは元のオブジェクトの__getnewargs__()メソッドを呼び出した時の戻り値となります。 __getnewargs__()を定義していない場合、argsは空のタプルとなります。 
クラスは、インスタンスの pickle 化方法にさらに影響を与えることができます; クラスが __getstate__() メソッドを定義している場合、このメソッドが呼び出され、返された状態値はインスタンスの内容として、インスタンスの辞書の代わりに pickle 化されます。 
__getstate__() メソッドが定義されていない場合、インスタンスの __dict__ の内容が pickle 化されます。 unpickle 化では、クラスが __setstate__() も定義していた場合、unpickle 化された状態値とともに呼び出されます 
3.6 。 
__setstate__() メソッドが定義されていない場合、pickle 化された状態は辞書型でなければならず、その要素は新たなインスタンスの辞書に代入されます。 
クラスが__getstate__() と __setstate__() の両方を定義している場合、状態値オブジェクトは辞書である必要はなく、これらのメソッドは期待通りの動作を行います。 
警告:新しいスタイルのクラスにおいて __getstate__() が負値を返す場合、__setstate__() メソッドは呼ばれません。 
... 化された状態値とともに呼び出されます 
これらのメソッドはクラスインスタンスのコピーを実装する際にもｔ用いられます 
...は期待通りの動作を行います。 
このプロトコルはまた、 
で定義されている浅いコピーや深いコピー操作でも用いられます。 
3.14.4 何を pickle 化したり 
3.14.5.1 通常のクラスインスタンスの pickle 化および 
この節では pickler/unpickler と直列化対象のオブジェクトとの間のインタフェースを定義する ``pickle 化プロトコル'' について記述します。 
このプロトコルは自分のオブジェクトがどのように直列化されたり非直列化されたりするかを定義し、カスタマイズし、制御するための標準的な方法を提供します。 
この節での記述は、unpickle 化環境を不信な pickle 化データに対して安全にするために使う特殊なカスタマイズ化についてはカバーしていません; 詳細は3.14.6 を参照してください。 
3.14.5.3 外部オブジェクトの pickle 化および 
デフォルトでは、逆 pickle 化は pickle 化されたデータ中に見つかったクラスを import することになります。 
自前の unpickler をカスタマイズすることで、何が unpickle 化されて、どのメソッドが呼び出されるかを厳密に制御することはできます。 
しかし不運なことに、厳密になにを行うべきかはpickle と cPickle のどちらを使うかで異なります 
3.10 。 
pickle モジュールでは、Unpickler からサブクラスを導出し、load_global() メソッドを上書きする必要があります。 load_global() は pickle データ列から最初の 2 行を読まなければならず、ここで最初の行はそのクラスを含むモジュールの名前、2 行目はそのインスタンスのクラス名になるはずです。 
次にこのメソッドは、例えばモジュールをインポートして属性を掘り起こすなどしてクラスを探し、発見されたものを unpickler のスタックに置きます。 
あるいは全てのインスタンスに対して unpickling を許可したくないならエラーを送出してください。 
このからくりがハックのように思えるなら、あなたは間違っていません。 
属性が None の場合、インスタンスを unpickle しようとする試みは全て UnpicklingError を送出します。 
属性が関数の場合、この関数はモジュール名またはクラス名を受理し、対応するクラスオブジェクトを返さなくてはなりません。 
... のどちらを使うかで異なります 
注意してください: ここで記述されている機構は内部の属性とメソッドを使っており、これらはPython の将来のバージョンで変更される対象になっています。 
われわれは将来、この挙動を制御するための、pickle および cPickle の両方で動作する、共通のインタフェースを提供するつもりです。 
プレーヤーオブジェクト（open()で返されます）には以下のメソッドがあります： 
CD-ROMドライブのイジェクトボタンのロックを解除して、ユーザがCDキャディを排出するのを許可します。 
メソッドreadda()のパラメータnum_framesとして最適の値を返します。 
最適値はCD-ROMドライブからの連続したデータフローが許可される値が定義されます。 
プレーヤーオブジェクトと関連付けられたリソースを解放します。 
close()を呼び出したあとでは、そのオブジェクトに対するメソッドは使用できません。 
CD-ROMドライブからキャディを排出します。 
CD-ROMドライブの現在の状態に関する情報を返します。 
返される情報は以下の値からなるタプルです：state、track、rtime、atime、ttime、first、last、scsi_audio、cur_block。 rtimeは現在のトラックの初めからの相対的な時間；atimeはディスクの初めからの相対的な時間；ttimeはディスクの全時間です。 
それぞれの値の詳細については、マニュアルページ CDgetstatus(3dm)を参照してください。 
stateの値は以下のうちのどれか一つです：ERROR、NODISC、READY、PLAYING、PAUSED、STILL、CDROM。 
特定のトラックについての情報を返します。 
返される情報は、トラックの開始時刻とトラックの時間の長さの二つの要素からなるタプルです。 
分、秒、フレームの3つからなる絶対的なタイムコードを、与えられたCD-ROMドライブの相当する論理ブロック番号に変換します。 
時刻を比較するにはmsftoblock()よりもmsftoframe()を使うべきです。 
論理ブロック番号は、CD-ROMドライブによって必要とされるオフセット値が違うため、フレームナンバーと異なります。 
CD-ROMドライブのオーディオCDの特定のトラックから再生を開始します。 
CD-ROMドライブのヘッドフォン端子と（備えているなら）オーディオ端子から出力されます。 
ディスクの最後で再生は停止します。 startは再生を開始するCDのトラックナンバーです；playが0なら、CDは最初の一時停止状態になります。 
その状態からメソッドtogglepause()で再生を開始できます。 
play()と似ていますが、開始位置をトラックナンバーの代わりに分、秒、フレームで与えます。 
play()と似ていますが、トラックの終わりで再生を停止します。 
play()と似ていますが、指定した絶対的な時刻から再生を開始して、指定したトラックで終了します。 
CD-ROMドライブのイジェクトボタンをロックして、ユーザがCDキャディを排出できないようにします。 
CD-ROMドライブにマウントされたオーディオCDから、指定したフレーム数を読み込みます。 
オーディオフレームのデータを示す文字列を返します。 
この文字列はそのままパーザオブジェクトのメソッドparseframe()へ渡すことができます。 
CD-ROMから次にデジタルオーディオデータを読み込む開始位置のポインタを設定します。 
ポインタはminutes、seconds、framesで指定した絶対的なタイムコードの位置に設定されます。 
返される値はポインタが設定された論理ブロック番号です。 
ポインタは指定した論理ブロック番号に設定されます。 
返される値はポインタが設定された論理ブロック番号です。 
ポインタは指定したトラックに設定されます。 
返される値はポインタが設定された論理ブロック番号です。 
現在実行中の再生を停止します。 
再生中ならCDを一時停止し、一時停止中なら再生します。 
poll() システムコールはほとんどの Unix システムでサポートされており、非常に多数のクライアントに同時にサービスを提供するようなネットワークサーバが高い拡張性を持てるようにしています。 
poll() に高い拡張性があるのは、select() がビット対応表を構築し、対象ファイルの記述子に対応するビットを立て、その後全ての対応表の全てのビットを線形探索するのに対し、poll() は対象のファイル記述子を列挙するだけでよいからです。 select() は O(最大のファイル記述子番号) なのに対し、poll() は O(対象とするファイル記述子の数) で済みます。 
ファイル記述子をポーリングオブジェクトに登録します。 
これ以降のpoll() メソッド呼び出しでは、そのファイル記述子に処理待ち中のI/O イベントがあるかどうかを監視します。 fd は整数か、整数値を返す fileno() メソッドを持つオブジェクトを取ります。 
ファイルオブジェクトも通常 fileno() を実装しているので、引数として使うことができます。 
eventmask はオプションのビットマスクで、どのタイプの I/O イベントを監視したいかを記述します。 この値は以下の表で述べる定数 POLLIN、POLLPRI、および POLLOUT の組み合わせにすることができます。 
ビットマスクを指定しない場合、標準の値が使われ、3 種のイベント全てに対して監視が行われます。 
読み出せるデータの存在 
緊急の読み出しデータの存在 
書き出せるかどうか: 書き出し処理がブロックしないかどうか 
何らかのエラー状態 
ハングアップ 
無効な要求: 記述子が開かれていない 
すでに登録済みのファイル記述子を登録してもエラーにはならず、一度だけ登録した場合と同じ効果になります。 
ポーリングオブジェクトによって追跡中のファイル記述子を登録解除します。 
register() メソッドと同様に、fd は整数か、整数値を返す fileno() メソッドを持つオブジェクトを取ります。 登録されていないファイル記述子を登録解除しようとするとKeyError 例外が送出されます。 
fd はファイル記述子で、event は該当するファイル記述子について報告されたイベントを表すビットマスクです -- 例えばPOLLIN は入力待ちを示し、POLLOUT はファイル記述子に対する書き込みが可能を示す、などです。 
空のリストは呼び出しがタイムアウトしたか、報告すべきイベントがどのファイル記述子でも発生しなかったことを示します。 
timeout が与えられた場合、処理を戻すまで待機する時間の長さをミリ秒単位で指定します。 timeout が省略されたり、負の値であったり、あるいは None の場合、そのポーリングオブジェクトが監視している何らかのイベントが発生するまでブロックします。 
これは（エラーチェックもない）最も小さなサンプルで、メールボックスを開いて、すべてのメッセージを取り出し、プリントします。 
モジュールの末尾に、より広い範囲の使用例となるtestセクションがあります。 
インスタンスのデバッグレベルを指定します。 
これはデバッギングアウトプットの表示量をコントロールします。 
デフォルト値の 0 は、デバッギングアウトプットを表示しません。 
値を 1 とすると、デバッギングアウトプットの表示量を適当な量にします。 これは大体、リクエストごと1行になります。 
値を 2 以上にすると、デバッギングアウトプットの表示量を最大にします。 コントロール中の接続で送受信される各行をログに出力します。 
POP3サーバーから送られるグリーティングメッセージを返します。 
userコマンドを送出します。 応答はパスワード要求を表示します。 
POP3サーバーにログオンするのに、よりセキュアなAPOP認証を使用します。 
POP3サーバーにログオンするのに、（UNIXのr-コマンドと同様の）RPOP認証を使用します。 
メールボックスの状態を得ます。 
結果は2つのintegerからなるタプルとなります。 (message count, mailbox size). 
which が与えられると、それによりメッセージを指定します。 
which 番のメッセージ全体を取り出し、そのメッセージに既読フラグを立てます。 結果は (response, ['line', ...], octets)という形式で表されます。 
which 番のメッセージに削除のためのフラグを立てます。 
ほとんどのサーバで、QUITコマンドが実行されるまでは実際の削除は行われません（もっとも良く知られた例外は Eudora QPOPで、その配送メカニズムはRFCに違反しており、どんな切断状況でも削除操作を未解決にしています）。 
メールボックスの削除マークすべてを取り消します。 
何もしません。 
接続保持のために使われます。 
Signoff: commit changes, unlock mailbox, drop connection.サインオフ：変更をコミットし、メールボックスをアンロックして、接続を破棄します。 
メッセージヘッダと howmuch で指定した行数のメッセージを、whichで指定したメッセージ分取り出します。 
という形式のメッセージ、または(response, ['mesgnum uid', ...],octets)という形式のリストとなります。 
POP3_SSL クラスのインスタンスは追加のメソッドを持ちません。 
このサブクラスのインターフェイスは親クラスと同じです。 
何らかの形式でプロセス間通信を利用している際には常に、制御フローについて注意深く考える必要があります。 
これはこのモジュール (あるいは 
モジュールにおける等価な機能) で生成されるファイルオブジェクトの場合にもあてはまります。 親プロセスが子プロセスの標準出力を読み出している一方で、子プロセスが大量のデータを標準エラー出力に書き込んでいる場合、この子プロセスから出力を読み出そうとするとデッドロックが発生します。 
同様の状況は読み書きの他の組み合わせでも生じます。 
に従うようにし、子プロセスで以下: 
import osimport sys# note that each of these print statements# writes a single long stringprint sys.stderr, 400 * 'this is a test\n'os.close(sys.stderr.fileno())print sys.stdout, 400 * 'this is another test\n' のようなコードにすることでしょう。 
とりわけ、sys.stderr は全てのデータを書き込んた後に閉じられなければならないということに注意してください。 さもなければ、readlines() は返ってきません。 
また、sys.stderr.close() が stderr を閉じないようにos.close() を使わなければならないことにも注意してください。 
(そうでなく、sys.stderr に関連付けると、暗黙のうちに閉じられてしまうので、それ以降のエラーが出力されません)。 より一般的なアプローチををサポートする必要があるアプリケーションでは、パイプ経由の I/O を select() ループでまとめるか、個々の popen*() 関数や Popen*クラスが提供する各々のファイルに対して、個別のスレッドを使って読み出しを行います。 
Popen3 および Popen4 クラスのインスタンスは以下のメソッドを持ちます: 
子プロセスがまだ終了していない際には -1 を、そうでない場合にはリターンコードを返します。 
子プロセスの状態コード出力を待機して返します。 
状態コードでは子プロセスのリターンコードと、プロセスが exit() によって終了したか、あるいはシグナルによって死んだかについての情報を符号化しています。 
状態コードの解釈を助けるための関数は 
モジュールで定義されています; 6.1.5 節の W*() 関数ファミリを参照してください。 
以下の属性も利用可能です: 
子プロセスからの出力を提供するファイルオブジェクトです。 
Poepn4 インスタンスの場合、この値は標準出力と標準エラー出力の両方を提供するオブジェクトになります。 
子プロセスへの入力を提供するファイルオブジェクトです。 
コンストラクタに capturestderr を渡した際には子プロセスからの標準エラー出力を提供するファイルオブジェクトで、そうでない場合None になります。 
Popen4 インスタンスでは、この値は常に None になります。 
子プロセスのプロセス番号です。 
posix では以下のデータ項目を定義しています: 
インタプリタが起動した時点の環境変数文字列を表現する辞書です。 
例えば、environ['HOME'] はホームディレクトリのパス名で、C 言語の getenv("HOME") と等価です。 この辞書を変更しても、execv()、popen() またはsystem() などに渡される環境変数文字列には影響しません;そうした環境を変更するする必要がある場合、environ を execve() に渡すか、system() またはpopen() の命令文字列に変数の代入や export 文を追加してください。 
注意: 
モジュールでは、もう一つの environ 実装を提供しており、環境変数が変更された場合、その内容を更新するようになっています。 
os.environ を更新した場合、この辞書は古い内容を表していることになってしまうので、このことにも注意してください。 
posix モジュール版を直接アクセスするよりも、 
モジュール版を使う方が推奨されています。 
モジュールのドキュメントを参照してください。 
いくつかのオペレーティングシステム (AIX, HPIX, Irix および Solarisが含まれます) は、int および long を 32 ビット値とする C プログラムモデルで 2Gb を超えるサイズのファイルのサポートを提供しています。 
このサポートは典型的には 64 ビット値のオフセット値と、そこからの相対サイズを定義することで実現しています。 
このようなファイルは時にラージファイル (large files) と呼ばれます。 Python では、off_t のサイズが long より大きく、かつ long long 型を利用することができて、少なくとも off_t 型と同じくらい大きなサイズである場合、ラージファイルのサポートが有効になります。 
この場合、ファイルのサイズ、オフセットおよびPython の通常整数型の範囲を超えるような値の表現には Python の長整数型が使われます。 
例えば、ラージファイルのサポートは Irix の最近のバージョンでは標準で有効ですが、Solaris 2.6 および 2.7 では、以下のようにする必要があります: 
3.1 インストール後実行スクリプト (postinstallation script) 
実行可能なインストーラは、Windows 環境ではごく自然なバイナリ配布形式です。 
インストーラは結構なグラフィカルユーザインタフェースを表示して、モジュール配布物に関するいくつかの情報を setup スクリプト内のメタデータから取り出して示し、ユーザがいくつかのオプションを選んだり、インストールを決行するか取りやめるか選んだりできるようにします。 メタデータは setup スクリプトから取り出されるので、Windows インストーラの作成は至って簡単で、以下を実行するだけです: 
あるいは、bdist コマンドを --formats オプション付きで実行します: 
(pure Python モジュールとパッケージだけの入った) pure モジュール配布物の場合、作成されるインストーラは実行バージョンに依存しない形式になり、 foo-1.0.win32.exe のような名前になります。 
従って、サポートしたい全てのバージョンの Python に対して、別々のインストーラを作成しなければなりません。 インストーラは、ターゲットとなるシステムにインストールを実行した後、 pure モジュールを通常 (normal) モードと最適化 (optimizing)モードでコンパイルしようと試みます。 
--title オプションを使えば、タイトルを別のテキストに変更できます。 インストーラファイルは ``配布物ディレクトリ (distribution directory)''-- 通常は dist/ に作成されますが、--dist-dir オプションで指定することもできます。 
Python 2.3 からは、インストール実行後スクリプトを--install-script オプションで指定できるようになりました。 
これらの関数は、インストール後実行スクリプトがディレクトリやファイルを作成した際に呼び出さなければなりません。 
この関数はアンインストーラに作成されたpathを登録し、配布物をアンインストールする際にファイルが消されるようにします。 
安全を期すために、ディレクトリは空の時にのみ削除されます。 
この関数は、「スタートメニュー」や「デスクトップ」といった、Windows における特殊なフォルダ位置を取得する際に使えます。 
この関数はフォルダのフルパスを返します。 
csidl_string は以下の文字列のいずれかでなければなりません: "CSIDL_APPDATA""CSIDL_COMMON_STARTMENU""CSIDL_STARTMENU""CSIDL_COMMON_DESKTOPDIRECTORY""CSIDL_DESKTOPDIRECTORY""CSIDL_COMMON_STARTUP""CSIDL_STARTUP""CSIDL_COMMON_PROGRAMS""CSIDL_PROGRAMS""CSIDL_FONTS" 
詳細については、 SHGetSpecialFolderPath() 関数に関するMicrosoft の ドキュメントを参照してください。 
この関数はショートカットを作成します。 
target はショートカットによって起動されるプログラムへのパスです。 
これについても、詳しくはIShellLink インタフェースに関する Microsoft の ドキュメントを参照してください。 
従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この演算規則は、被演算子の評価順序を縛る規則ではありません)。 べき乗演算子は、二つの引数で呼び出される組み込み関数 pow() と同じ意味付けを持っています。 
引数はまず共通の型に変換されます。 
結果の型は、型強制後の引数の型になります。 引数型を混合すると、二項算術演算における型強制規則が適用されます。 
整数や長整数の被演算子の場合、第二引数が負でない限り、結果は (型強制後の) 被演算子と同じになります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。 
例えば、10**2 は 100 を返しますが、10**-2 は 0.01 を返します。 (上述の仕様のうち、最後のものはPython 2.2 で追加されました。 
負の数を小数でべき乗すると ValueErrorになります。 
このマークアップは、ドキュメント中で述べているソフトウェアのバージョン番号を設定します。 
このマークアップは、ドキュメントが扱っているソフトウェアの ``短い形式の''バージョン番号をsver にします。 
6.2 メタ情報マークアップ ご意見やご指摘をお寄せになりたい方は、 
一次語は、言語において最も結合の強い操作を表します。 文法は以下のようになります: 
5.3.1 属性参照 
print は、式を逐次的に評価し、得られたオブジェクトを標準出力に書き出します。 
オブジェクトが文字列でなければ、まず文字列変換規則を使って文字列に変換され、次いで (得られた文字列か、オリジナルの文字列が) 書き出されます。 
出力系の現在の書き出し位置が行頭にあると考えられる場合を除き、各オブジェクトの出力前にスペースが一つ出力されます。 
行頭にある場合とは、(1) 標準出力にまだ何も書き出されていない場合、(2) 標準出力に最後に書き出された文字が "n"である、または (3) 標準出力に対する最後の書き出し操作が print 文によるものではない場合、です。 
(こうした理由から、場合によっては空文字を標準出力に書き出すと便利なことがあります。 
) 注意:組み込みのファイルオブジェクトでない、ファイルオブジェクトに似た動作をするオブジェクトでは、組み込みのファイルオブジェクトが持つ上記の性質を適切にエミュレートしていないことがあるため、当てにしないほうがよいでしょう。 
print 文がカンマで終了していない限り、末尾には文字"n" が書き出されます。 
この仕様は、文に予約語print がある場合のみの動作です。 
標準出力は、組み込みモジュール sys 内で stdout という名前のファイルオブジェクトとして定義されています。 
該当するオブジェクトが存在しないか、オブジェクトに write()メソッドがない場合、RuntimeError例外が送出されます。 . 
print には、上で説明した構文の第二形式で定義されている拡張形式 
の直後にくる最初の式の値評価結果は ``ファイル類似 (file-like)'' なオブジェクト、とりわけ上で述べたように write() メソッドを持つオブジェクトでなければなりません。 
この拡張形式では、ファイルオブジェクトを指定する式よりも後ろの式が、指定されたファイルオブジェクトに出力されます。 
最初の式の値評価結果が None になった場合、 sys.stdout が出力ファイルとして使われます。 
致命的エラーメッセージ (fatal error message) を出力してプロセスを強制終了 (kill) します。 
後始末処理は行われません。 
この関数は、Python インタプリタを使い続けるのが危険であるような状況が検出されたとき; 例えば、オブジェクト管理が崩壊していると思われるときにのみ、呼び出されるようにしなければなりません。 
Unixでは、標準 C ライブラリ関数abort() 
を呼び出して coreを生成しようと試みます。 
現在のプロセスを終了 (exit) します。 
この関数はPy_Finalize() 
を呼び出し、次いで標準 C ライブラリ関数exit(status) 
を呼び出します。 
から呼び出される後始末処理を行う関数 (cleanup function) を登録します。 
後始末関数は引数無しで呼び出され、値を返しません。 
最大で 32 の 
後始末処理関数を登録できます。 
登録に成功すると、Py_AtExit() は 0 を返します; 失敗すると -1 を返します。 
最後に登録した後始末処理関数から先に呼び出されます。 各関数は高々一度しか呼び出されません。 
Python の内部的な終了処理は後始末処理関数より以前に完了しているので、func からはいかなる Python API も呼び出してはなりません。 
プロファイラは イベントをハンドリングの際の time 関数呼出しおよびその値を保存するためのオーバーヘッドを補正するための、定数を持っています。 
デフォルトの値は 0 です。 以下の手順で、プラットフォームに合った、より適切な定数が得られます(前節「制限事項」の説明を参照)。 
import profile# 1. 算出した補正値 (your_computed_bias) をこれ以降生成する# Profile インスタンスに適用する。 
profile.Profile.bias = your_computed_bias# 2. 特定の Profile インスタンスに補正値を適用する。 
pr = profile.Profile()pr.bias = your_computed_bias# 3. インスタンスのコンストラクタに補正値を指定する。 
方法を選択したら、補正値は小さめに設定した方が良いでしょう。 プロファイルの結果に負の値が表われる``確率が少なく''なるはずです。 
...一定の結果が得られたら、それを使う方法には3通りあります。 
Python 2.2 より前のバージョンではプロファイラのソースコードに補正値として埋め込まれた定数を直接編集する必要がありました。 
今でも同じことは可能ですが、その方法は説明しません。 なぜなら、もうソースを編集する必要がないからです。 
10.2 旧バージョンのプロファイラとの違い 
この節は ``マニュアルなんか読みたくない人''のために書かれています。 
ここではきわめて簡単な概要説明とアプリケーションのプロファイリングを手っとり早くおこなう方法だけを解説します。 main エントリにある関数 foo() をプロファイルしたいとき、モジュールに次の内容を追加します。 
このように書くことで foo() を実行すると同時に一連の情報(プロファイル)が表示されます。 
この方法はインタプリタ上で作業をしている場合、最も便利なやり方です。 
プロファイルの結果をファイルに残し、後で検証したいときは、run() の2番目の引数にファイル名を指定します。 
スクリプトファイル profile.py を使って、別のスクリプトをプロファイルすることも可能です。 
次のように実行します。 
profile.py はオプションとしてコマンドライン引数を2つ受け取ります。 
-s は標準出力(つまり、 -o が与えられなかった場合)にのみ有効です。 
利用可能なソートの値は、 Stats のドキュメントをご覧ください。 プロファイル内容を確認するときは、pstats モジュールのメソッドを使用します。 
統計データの読み込みは次のようにします。 
Stats クラス(上記コードはこのクラスのインスタンスを生成するだけの内容です)は p に読み込まれたデータを操作したり、表示するための各種メソッドを備えています。 
先に profile.run() を実行したとき表示された内容と同じものは、3つのメソッド・コールにより実現できます。 
最初のメソッドはモジュール名からファイル名の前に付いているパス部分を取り除きます。 
2番目のメソッドはエントリをモジュール名/行番号/名前にもとづいてソートします(旧プロファイラとの構文上の互換性機能)。 
3番目のメソッドで全ての統計情報を出力します。 
次のようなソート・メソッドも使えます。 
最初の行ではリストを関数名でソートしています。 2号目で情報を出力しています。 
さらに次の内容も試してください。 
このようにすると、関数が消費した累計時間でソートされ、さらにその上位10 件だけを表示します。 
どのアルゴリズムが時間を多く消費しているのか知りたいときは、この方法が役に立つはずです。 ループで多くの時間を消費している関数はどれか調べたいときは、次のようにします。 
上記は関数の実行で消費した時間でソートされ、上位10個の関数の情報が表示されます。 次の内容も試してください。 
このようにするとファイル名でソートされ、そのうちクラスの初期化メソッド(メソッド名 __init__)に関する統計情報だけが表示されます。 
".5" は上位 50% だけの選択を意味し、さらにその中から文字列 init を含むものだけが表示されます。 どの関数がどの関数を呼び出しているのかを知りたければ、次のようにします(p は最後に実行したときの状態でソートされています)。 
このようにすると、各関数ごとの呼出し側関数の一覧が得られます。 さらに詳しい機能を知りたければマニュアルを読むか、次の関数の実行結果から内容を推察してください。 
スクリプトとして起動した場合、pstats モジュールはプロファイルのダンプを読み込み、分析するための統計ブラウザとして動きます。 
シンプルな行指向のインターフェース( 
を使って実装)とヘルプ機能を備えています。 
このプロファイラには2つの基本的な制限事項があります。 
ひとつは、Python インタプリタによる 呼び出し、リターン、例外発生 というイベントの連携を前提にしていることです。 
コンパイル済みの C コードはインタプリタの管理外で、プロファイラからは``見えません''。 
(組込み関数を含む) C のコードに費やされた時間は、その C コードを呼出した Python 関数のものとして計上されることになります。 
最も明白な制限は、(一般に)``クロック''は .001 秒の精度しかないということです。 
これ以上の精度で計測することはできません。 
仮に充分な精度が得られたとしても、``エラー''が計測の平均値に影響を及ぼすことがあります。 
最初のエラーを取り除いたとしても、それがまた別のエラーを引き起こす原因となります。 もうひとつの問題として、イベントを検知してからプロファイラがその時刻を実際に取得するまでに ``いくらかの時間がかかる'' ことです。 
プロファイラが時刻を取得する(そしてその値を保存する)までの間に、ユーザコードがもう一度処理を実行したときにも、同様の遅延が発生します。 
結果的に多く呼び出される関数または多数の関数から呼び出される関数の情報にはこの種のエラーが蓄積する傾向にあります。 
この種のエラーによる遅延の蓄積は一般にクロックの精度を越える(1クロック以下のタイミング)ところで起きていますが、一方でこの時間を累計可能ということが大きな意味を持っています。 
このプロファイラはプラットフォームごとに(平均値から)予想されるエラーによる遅延を補正する機能を備えています。 プロファイラに補正を施すと(少くとも形式的には)正確さが増しますが、ときには数値が負の値になってしまうこともあります(呼出し回数が少く、確率の神があなたに意地悪をしたとき :-) )。 
プロファイルの結果に負の値が出力されても驚かないでください。 
これは補正をおこなった場合にのみ現れることで、実際の計測結果は補正をおこなわない場合より、より正確なはずだからです。 
Stats には次のメソッドがあります。 
このメソッドは Stats にファイル名の前に付いているすべてのパス情報を取り除かせるためのものです。 
出力の幅を80文字以内に収めたいときに重宝します。 
このメソッドはオブジェクトを変更するため、取り除いたパス情報は失われます。 
パス情報除去の操作後、オブジェクトが保持するデータエントリは、オブジェクトの初期化、ロード直後と同じように``ランダムに''並んでいます。 
strip_dirs() を実行した結果、2つの関数名が区別できない(両者が同じファイルの同じ行番号で同じ関数名となった)場合、一つのエントリに合算されされます。 
Stats クラスのこのメソッドは、既存のプロファイリング・オブジェクトに情報を追加します。 
引数は対応するバージョンの profile.run() によって生成されたファイルの名前でなくてはなりません。 
関数の名前が区別できない(ファイル名、行番号、関数名が同じ)場合、一つの関数の統計情報として合算されます。 
Stats オブジェクトに読み込まれたデータを、ファイル名filename のファイルに保存します。 
ファイルが存在しない場合新たに作成され、すでに存在する場合には上書きされます。 
このメソッドは profile.Profile クラスの同名のメソッドと等価です。 バージョン 2.3 で 新たに追加 された仕様です。 
このメソッドは Stats オブジェクトを指定した基準に従ってソートします。 
引数には通常ソートのキーにしたい項目を示す文字列を指定します(例: 'time' や'name' など)。 2つ以上のキーが指定された場合、2つ目以降のキーは、それ以前のキーで同等となったデータエントリの再ソートに使われます。 
たとえば sort_stats('name', 'file') とした場合、まずすべてのエントリが関数名でソートされた後、同じ関数名で複数のエントリがあればファイル名でソートされるのです。 キー名には他のキーと判別可能である限り綴りを省略して名前を指定できます。 
現バージョンで定義されているキー名は以下の通りです。 
正式名 
内容 
呼び出し回数 
合計時間 
ファイル名 
モジュール名 
プリミティブな呼び出しの回数 
行番号 
関数名 
関数名/ファイル名/行番号 
標準名 
内部時間 
すべての統計情報のソート結果は降順(最も多く時間を消費したものが一番上に来る)となることに注意してください。 ただし、関数名、ファイル名、行数に関しては昇順(アルファベット順)になります。 
'nfl' と 'stdname' はやや異なる点があります。 標準名(standard name)とは表示欄の名前なのですが、埋め込まれた行番号の文字コード順でソートされます。 
たとえば、(ファイル名が同じで)3、20、40という行番号のエントリがあった場合、20、30、40 の順に表示されます。 
一方 'nfl' は行番号を数値として比較します。 
結果的に、sort_stats('nfl') は sort_stats('name', 'file', 'line') と指定した場合と同じになります。 旧バージョンのプロファイラとの互換性のため、数値を引数に使った -1、 0、 1、 2 の形式もサポートしています。 
それぞれ 'stdname'、'calls'、'time'、'cumulative' として処理されます。 
引数をこの旧形式で指定した場合、最初のキー(数値キー)だけが使われ、複数のキーを指定しても2番目以降は無視されます。 
Stats クラスのこのメソッドは、オブジェクト内の情報のリストを逆順にソートします。 
これは旧プロファイラとの互換性のために用意されています。 
現在は選択したキーに応じて昇順、降順が適切に選ばれるため、このメソッドの必要性はほとんどないはずです。 
Stats クラスのこのメソッドは、profile.run() の項で述べた プロファイルのレポートを出力します。 
出力するデータの順序はオブジェクトに対し最後におこなった sort_stats() による操作にもとづいたものになります(add() と strip_dirs() による制限にも支配されます)。 引数は一覧に大きな制限を加えることになります。 
初期段階でリストはプロファイルした関数の完全な情報を持っています。 
制限の指定は(行数を指定する)整数、(行のパーセンテージを指定する) 0.0 から 1.0 までの割合を指定する小数、(出力する standard name にマッチする)正規表現のいずれかを使っておこないます。 正規表現は Python 1.5b1 で導入された 
モジュールで使える Perl スタイルのものです。 
複数の制限は指定された場合、それは指定の順に適用されます。 たとえば次のようになります。 
上記の場合まず出力するリストは全体の10%に制限され、さらにファイル名の一部に文字列 .*foo: を持つ関数だけが出力されます。 
こちらの例の場合、リストはまずファイル名に .*foo: を持つ関数だけに制限され、その中の最初の 10% だけが出力されます。 print_callers 
Stats クラスのこのメソッドは、プロファイルのデータベースの中から何らかの関数呼び出しをおこなった関数すべてを出力します。 
出力の順序は print_stats() によって与えられるものと同じです。 出力を制限する引数も同じです。 
呼出し側関数の後にパーレンで囲まれて表示される数値は呼出しが何回おこなわれたかを示すものです。 
続いてパーレンなしで表示される数値は、関数が消費した時間の合計です。 
Stats クラスのこのメソッドは指定した関数から呼出された関数のリストを出力します。 
呼出し側、呼出される側の方向は逆ですが、引数と出力の順序に関しては print_callers() と同じです。 
現バージョンの Python のPython では不要です。 
Python が None 以外の使われなかった結果を表示するときに使われたもので、旧バージョンとの互換性のためだけに定義されています。 
10.1 プロファイラとは 
10. Python プロファイラ 
Permission to use, copy, modify, and distribute this Python softwareand its associated documentation for any purpose (subject to therestriction in the following sentence) without fee is hereby granted,provided that the above copyright notice appears in all copies, andthat both that copyright notice and this permission notice appear insupporting documentation, and that the name of InfoSeek not be used inadvertising or publicity pertaining to distribution of the softwarewithout specific, written prior permission. This permission isexplicitly restricted to the copying and modification of the softwareto remain in Python, compiled Python, or other languages (such as C)wherein the modified or derived code is exclusively imported into aPython module.INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THISSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY ANDFITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANYSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVERRESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OFCONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR INCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.このプロファイラは私が Python プログラミングを始めてからわずか3週間後に書いたものです。 
その結果、稚拙なコードが出来上がってしまったのかもしれませんが、なにせ私はまだ初心者なのでそれもよくわかりません :-) コードはプロファイリングにふさわしいスピードを実現することに心血を注ぎました。 
しかし部分的な繰り返しを避けたため、かなり不格好になってしまったところがあります。 
改善のための意見があれば、ぜひ jar@netscape.com までメールをください。 
アップデートと LaTeX への変換は Guido van Rossum によるもの。 
テキスト中に古いプロファイラのリファレンスも残してありますが、そのコードはもう含まれていません。 
10.1 プロファイラとは 
10.1 プロファイラとは 
Python インタプリタは、プロファイル: 分析 (profile) や実行のトレース: 追跡 (trace) といった機能を組み込むために低水準のサポートを提供しています。 
このサポートは、プロファイルやデバッグ、適用範囲分析 (coverage analysis) ツールなどに使われます。 Python 2.2 になってから、この機能の実装は実質的に作り直され、C から呼び出すためのインタフェースが追加されました。 
この C インタフェースは、プロファイルやトレース作業時に、Python レベルの呼び出し可能オブジェクトが呼び出されることによるオーバヘッドを避け、直接 C 関数呼び出しが行えるようにしています。 
プロファイルやトレース機能の本質的な特性は変わっていません;インタフェースではとレース関数をスレッドごとにインストールでき、トレース関数に報告される基本イベント (basic event) は以前のバージョンにおいて Python レベルのトレース関数で報告されていたものと同じです。 
what の値 
arg の意味 
常に NULLです。 
sys.exc_info() の返す例外情報です。 
呼び出し側に返される予定の値です。 
呼び出している関数の名前です。 
関数やメソッドが新たに呼び出されたり、ジェネレータが新たなエントリの処理に入ったことを報告する際の、Py_tracefunc のwhat の値です。 
イテレータやジェネレータ関数の生成は、対応するフレーム内のPython バイトコードに制御の委譲 (control transfer) が起こらないため報告されないので注意してください。 
例外が送出された際のPy_tracefunc のwhat の値です。 
現在実行されているフレームで例外がセットされ、何らかのバイトコードが処理された後に、what にこの値がセットされた状態でコールバック関数が呼び出されます。 
この結果、例外の伝播によって Python が呼び出しスタックを逆戻りする際に、各フレームから処理が戻るごとにコールバック関数が呼び出されます。 
トレース関数だけがこれらのイベントを受け取ります; プロファイラはこの種のイベントを必要としません。 
行番号イベントを報告するときに (プロファイル関数ではなく)トレース関数のwhat パラメタとして渡す値です。 
関数呼び出しが例外の伝播なしに返るときにPy_tracefunc 関数のwhat パラメタとして渡す値です。 
C関数を呼び出す直前にPy_tracefunc 関数のwhat パラメタとして渡す値です。 
C関数が例外を送出したときにPy_tracefunc 関数のwhat パラメタとして渡す値です。 
C関数から戻るときにPy_tracefunc 関数のwhat パラメタとして渡す値です。 
プロファイル関数を func に設定します。 
obj パラメタは関数の第一パラメタとして渡され、何らかの Python オブジェクトかまたはNULLになります。 
プロファイル関数がスレッド状態を維持する必要があるなら、各々のスレッドに異なる obj を使うことで、状態を記憶しておく便利でスレッドセーフな場所を提供できます。 
プロファイル関数は、モニタされているイベントのうち、行番号イベントを除く全てのイベントに対して呼び出されます。 
トレース関数を func にセットします。 
PyEval_SetProfile() に似ていますが、トレース関数は行番号イベントを受け取る点が違います。 
言語仕様の中では、その言語を処理するインタプリタがどのように起動されるかまで規定する必要はないのですが、完全な Python プログラムについての概念を持っておくと役に立ちます。 
完全な Python プログラムは、最小限に初期化された環境: 全ての組み込み変数と標準モジュールが利用可能で、かつsys (様々なシステムサービス)、__builtin__ (組み込み関数、例外、および None)、__main__ の 3 つを除く全てのモジュールが初期化されていない状態で動作します。 
__main__ は、完全なプログラムを実行する際に、ローカルおよびグローバルな名前空間を提供するために用いられます。 
完全な Python プログラムの構文は、下の節で述べるファイル入力のためのものです。 インタプリタは、対話的モード (interactive mode) で起動されることもあります; この場合、インタプリタは完全なプログラムを読んで実行するのではなく、一度に単一の実行文 (複合文のときもあります) を読み込んで実行します。 
初期状態の環境は、完全なプログラムを実行するときの環境と同じです; 各実行文は、__main__ の名前空間内で実行されます。 
Unix の環境下では、完全なプログラムをインタプリタに渡すには三通りの方法があります: 第一は、 -c string コマンドラインオプションを使う方法、第二はファイルを第一コマンドライン引数として指定する方法、そして最後は標準入力から入力する方法です。 ファイルや標準入力がtty (端末) デバイスの場合、インタプリタは対話モードに入ります; そうでない場合、ファイルを完全なプログラムとして実行します。 
ProgressBarオブジェクトでは、モードレスなプログレスバーダイアログのサポートを提供しています。 
定量プログレスバー (温度計スタイル) と不定量プログレスバー(床屋の螺旋看板スタイル) がサポートされています。 
プログレスバーの最大値がゼロ以上の場合には定量インジケータに、そうでない場合は不定量インジケータになります。 バージョン 2.2 で 変更 された仕様:不定量プログレスバーのサポートを追加しました。 
ダイアログは作られるとすぐに表示されます。 
ダイアログの``Cancel''ボタンを押すか、Cmd-. (コマンドキーを押しながらピリオド(".")を押す) か、あるいはESC をタイプすると、ダイアログウィンドウを非表示にしてKeyboardInterruptを送出します (ただし、この応答は次にプログレスバーを更新するときまで、すなわち次にinc() またはset() を呼び出してダイアログを更新するまで発生しません) 。 
それ以外の場合、プログレスバーはProgressBar オブジェクトを廃棄するまで表示されたままになります。 
ProgressBarオブジェクトには以下の属性とメソッドがあります。 
プログレスバーの現在の値 (整数型あるいは長整数型) です。 
プログレスバーの通常のアクセスのメソッドによってcurvalを0とmaxvalの間にします。 
この属性を直接変更してはなりません。 
プログレスバーの最大値　(整数型あるいは長整数型) です;プログレスバー (温度計, thermometer) では、curval がmaxval に等しい時に全量に到達します。 
maxvalが0 の場合、不定量プログレスバー (床屋の螺旋看板, barbar pole)になります。 
プログレスダイアログのタイトルバーのテキストをnewstrに設定します。 
プログレスダイアログ中のプログレスボックスのテキストをnewstrに設定します。 
max も指定した場合、maxvalをmaxにします。 
value は前もって 0 とmaxval の間になるよう強制的に設定されます。 
温度計バーの場合、変更内容を反映するよう表示を更新します。 変更によって定量プログレスバーから不定量プログレスバーへ、あるいはその逆への推移が起こります。 
プログレスバーのcurvalをnだけ増やします。 n を指定しなければ1だけ増やします。 
(n は負にもでき、その場合はcurval を減少させます。 
)変更内容を反映するようプログレスバーの表示を更新します。 
プログレスバーが不定量プログレスバーの場合、床屋の螺旋看板 (barbar pole)模様を 1 度「回転」させます。 
増減によって curval が 0 からmaxval までの範囲を越えた場合、 0 とmaxval の範囲に収まるよう強制的に値を設定します。 
ProtocolErrorオブジェクトはトランスポート層で発生したエラー(URIで指定したサーバが見つからなかった場合に発生する404 `not found'など)の内容を示し、以下のメンバを持ちます: 
エラーの原因となったURIまたはURL。 
エラーコード。 
エラーメッセージまたは診断文字列。 
エラーの原因となったHTTP/HTTPSリクエストを含む文字列。 
ProxyHandler は、コンストラクタで与えた辞書 proxies にプロキシが設定されているような protocol 全てについて、メソッド 
最初に例示するプログラムは、Python スクリプト内の関数を実行するためのものです。 
超高水準インタフェースに関する節で挙げた例と同様に、Python インタプリタはアプリケーションと直接やりとりはしません (が、次の節でやりとりするよう変更します)。 Python スクリプト内で定義されている関数を実行するためのコードは以下のようになります: 
このコードはargv[1] を使って Python スクリプトをロードし、argv[2] 内に指定された名前の関数を呼び出します。 
関数の整数引数は argv 配列中の他の値になります。 
このプログラムをコンパイルしてリンクし (できた実行可能形式をcall と呼びましょう)、以下のような Pythonスクリプトを実行することにします: 
実行結果は以下のようになるはずです: 
この程度の機能を実現するにはプログラムがいささか大きすぎますが、ほとんどは Python から C へのデータ変換やエラー報告のためのコードです。 
Python の埋め込みという観点から最も興味深い部分は以下のコード、 
Py_Initialize();pName = PyString_FromString(argv[1]);/* pName のエラーチェックは省略している */pModule = PyImport_Import(pName); から始まる部分です。 
インタプリタの初期化後、スクリプトはPyImport_Import() を使って読み込まれます。 
このルーチンは Python 文字列を引数に取る必要があり、データ変換ルーチンPyString_FromString() で構築します。 
pFunc = PyObject_GetAttrString(pModule, argv[2]);/* pFunc は新たな参照 */if (pFunc PyCallable_Check(pFunc)) {...}Py_XDECREF(pFunc); 
ひとたびスクリプトが読み込まれると、PyObject_GetAttrString() を使って必要な名前を取得できます。 
名前がスクリプト中に存在し、取得したオブジェクトが呼び出し可能オブジェクトであれば、このオブジェクトが関数であると考えて差し支えないでしょう。 
そこでプログラムは定石どおりに引数のタプル構築に進みます。 
その後、Python 関数を以下のコードで呼び出します: 
関数が処理を戻す際、pValue は NULL になるか、関数の戻り値への参照が入っています。 
値を調べた後には忘れずに参照を解放してください。 
2 pure Python 配布物 
単に二つのモジュール、特定のパッケージに属しないモジュールを配布するだけなら、setup スクリプト中で py_modules オプションを使って個別に指定できます。 もっとも単純なケースでは、二つのファイル: setup スクリプト自体と、配布したい単一のモジュール、この例では foo.py について考えなければなりません: 
(この節の全ての図において、 root は配布物ルートディレクトリを参照します。 
) この状況を扱うための最小の setup スクリプトは以下のようになります: 
配布物の名前は name オプションで個々に指定し、配布されるモジュールの一つと配布物を同じ名前にする必要はないことに注意してください (とはいえ、この命名方法はよいならわしでしょう)。 
また、セットアップスクリプトは以下のようになります． 
モジュールのソースファイルは他のディレクトリに置けますが、そうしなければならないようなモジュールを沢山持っているのなら、モジュールを個別に列挙するよりもパッケージを指定した方が簡単でしょう。 
二つ以上のモジュールを配布する場合、とりわけ二つのパッケージに分かれている場合、おそらく個々のモジュールよりもパッケージ全体を指定する方が簡単です。 
たとえモジュールがパッケージ内に入っていなくても状況は同じで、その場合はルートパッケージにモジュールが入っているとDistutils に教えることができ、他のパッケージと同様にうまく処理されます(ただし、__init__.py があってはなりません)。 最後の例で挙げた setup スクリプトは、 
のようにも書けます (空文字はルートパッケージを意味します)これら二つのファイルをサブディレクトリ下に移動しておいて、インストール先はルートパッケージのままにしておきたい、例えば: 
のような場合には、パッケージ名にはルートパッケージをそのまま指定しておきますが、ルートパッケージに置くソースファイルがどこにあるかを Distutils に教えなければなりません: 
もっと典型的なケースでは、複数のモジュールを同じパッケージ (またはサブパッケージ) に入れて配布しようと思うでしょう。 
例えば、foo と bar モジュールがパッケージfoobar に属する場合、ソースツリーをレイアウトする一案として、以下が考えられます。 
実際、 Distutils ではこれをデフォルトのレイアウトとして想定していて、setup スクリプトを書く際にも最小限の作業しか必要ありません: 
モジュールを入れるディレクトリをパッケージの名前にしたくない場合、ここでも package_dir オプションを使う必要があります。 
例えば、パッケージ foobar のモジュールが src に入っているとします: 
適切な setup スクリプトは、 
from distutils.core import setupsetup(name='foobar',version='1.0',package_dir={'foobar': 'src'},packages=['foobar'],) のようになるでしょう。 
また、メインパッケージ内のモジュールを配布物ルート下に置くことがあるかもしれません: 
この場合、 setup スクリプトは 
from distutils.core import setupsetup(name='foobar',version='1.0',package_dir={'foobar': ''},packages=['foobar'],) のようになるでしょう。 
(空文字列も現在のディレクトリを表します。 )サブパッケージがある場合、packages で明示的に列挙しなければなりませんが、package_dirはサブパッケージへのパスを自動的に展開します。 
(別の言い方をすれば、 Distutils はソースツリーを走査せず、どのディレクトリが Python パッケージに相当するのかを__init__.py files. を探して調べようとします。 
) このようにして、デフォルトのレイアウトはサブパッケージ形式に展開されます: 
対応する setup スクリプトは以下のようになります。 
(ここでも、package_dir を空文字列にすると現在のディレクトリを表します。 
クラス記述オブジェクトは、readmodule() やreadmodule()_ex が返す辞書の値として使われており、以下のデータメンバを提供しています。 
クラス記述オブジェクトが記述している対象のクラスを定義しているモジュールの名前です。 
クラスの名前です。 
クラス記述オブジェクトが記述しようとしている対象クラスの、直接の基底クラス群について記述しているクラス記述オブジェクトのリストです。 
スーパクラスとして挙げられているが readmodule() が見つけられなかったクラスは、クラス記述オブジェクトではなくクラス名としてリストに挙げられます。 
メソッド名を行番号に対応付ける辞書です。 
クラスを定義している class 文が入っているファイルの名前です。 
file で指定されたファイル内にある class 文の数です。 
readmodule_ex() の返す辞書内でキーに対応する値として使われている関数記述オブジェクトは、以下のデータメンバを提供しています: 
関数記述オブジェクトが記述している対象の関数を定義しているモジュールの名前です。 
関数の名前です。 
関数を定義してる def 文が入っているファイルの名前です。 
file で指定されたファイル内にある def 文の数です。 
このドキュメントを読んでいるのなら、モジュール (module)、拡張モジュール (extension) などが何を表すのかをよく知っているかもしれません。 
とはいえ、読者がみな共通のスタートポイントに立って Distutils の操作を始められるように、ここで一般的な Python 用語について以下のような用語集を示しておきます: 
モジュール (module) 
Python においてコードを再利用する際の基本単位: すなわち、他のコードから import されるひとかたまりのコードです。 
ここでは、三種類のモジュール: pure Python モジュール、拡張モジュール、パッケージが関わってきます。 
pure Python モジュール 
Python で書かれ、単一の .py ファイル内に収められたモジュールです (.pyc かつ/または .pyo ファイルと関連があります) 。 
``pure モジュール (pure module)'' と呼ばれることもあります。 
拡張モジュール (extension module) 
(現状では、 Distutils は Python 向けの C/C++ 拡張モジュールしか扱わないので注意してください。 ) 
パッケージ (package) 
他のモジュールが入っているモジュールです;通常、ファイルシステム内のあるディレクトリに収められ、__init__.py が入っていることで通常のディレクトリと区別できます。 
ルートパッケージ (root package) 
階層的なパッケージの根 (root)の部分にあたるパッケージです。 
(この部分には __init__.pyファイルがないので、本当のパッケージではありませんが、便宜上そう呼びます。 
) 標準ライブラリの大部分はルートパッケージに入っています、また、多くの小規模な単体のサードパーティモジュールで、他の大規模なモジュールコレクションに属していないものもここに入ります。 
正規のパッケージと違い、ルートパッケージ上のモジュールの実体は様々なディレクトリにあります: 実際は、sys.path に列挙されているディレクトリ全てが、ルートパッケージに配置されるモジュールの内容に影響します。 
3. Python ランタイム サービス 
この章では、PythonインタープリタやPython環境に深く関連する各種の機能を解説します。 
以下に一覧を示します: 
システムパラメータと関数へのアクセス 
循環検出ガベージコレクタのインターフェース。 
弱参照と弱辞書のサポート。 
浮動小数点例外処理の制御。 
後始末関数の登録と実行。 
組み込み型の名前 
辞書オブジェクトのためのクラスラッパー。 
リストオブジェクトのためのクラスラッパー。 
文字列オブジェクトのためのクラスラッパー。 
組み込み関数形式になっている全ての Python の標準演算子。 
使用中のオブジェクトから、情報とソースコードを取得する。 
スタックトレースの表示や取り出し。 
このモジュールによりテキストファイルの各行にランダムアクセスできます。 
Python オブジェクトからバイトストリームへの変換、およびその逆。 
pickleサポート関数を登録する。 
Python オブジェクトの永続化。 
浅いコピーおよび深いコピー操作。 
Python オブジェクトをバイト列に変換したり、その逆を (異なる拘束条件下で) 行います。 
警告メッセージを送出したり、その処理方法を制御したりします。 
import文の実装へアクセスする。 
パッケージの拡張をサポートするユーティリティです。 
対話的Pythonインタプリタのための基底クラス。 
(完全ではないかもしれない)Pythonコードをコンパイルする。 
大きさに制限のある別のrepr()の実装。 
ランタイム実装オブジェクトの作成のインターフェイス。 
サイト固有のモジュールを参照する標準の方法。 
ユーザー設定を参照するための標準的な方法を提供するモジュール 
組み込み関数一式 
トップレベルスクリプトが実行される環境。 
Future ステートメントの定義 
PyZipFile コンストラクタは ZipFile コンストラクタと同じパラメタを必要とします。 
インスタンスは ZipFile のメソッドの他に、追加のメソッドを一つ持ちます。 
*.py ファイルを探し、*.py ファイルに対応するファイルをアーカイブに追加します。 
対応するファイルとは、もしあれば *.pyo であり、そうでなければ*.pyc で、必要に応じて *.py からコンパイルします。 
もし pathname がファイルなら、ファイル名は .py で終わっていなければなりません。 また、(*.py に対応する *.py[co])ファイルはアーカイブのトップレベルに (パス情報なしで) 追加されます。 
もし pathname がディレクトリで、ディレクトリがパッケージディレクトリでないなら、全ての *.py[co] ファイルはトップレベルに追加されます。 
もしディレクトリがパッケージディレクトリなら、全ての*.py[co] ファイルはパッケージ名の名前をもつファイルパスの下に追加されます。 サブディレクトリがパッケージディレクトリなら、それらは再帰的に追加されます basename はクラス内部での呼び出しに使用するためのものです。 
writepy() メソッドは以下のようなファイル名を持ったアーカイブを生成します。 
式を伴わない場合、raise は現在のスコープで最終的に有効になっている式を再送出します。 
そのような式が現在のスコープに全くない場合、エラーを示す例外が送出されます。 
このようにしてコンストラクタを呼び出して生成したインスタンスが例外の値になります。 第三のオブジェクトが存在し、かつ None でなければ、オブジェクトはトレースバック 
オブジェクトでなければなりません (3.2 節参照)。 また、例外が発生した場所は現在の処理位置に置き換えられます。 
第三のオブジェクトが存在し、オブジェクトがトレースバックオブジェクトでも None でもなければ、TypeError 例外が送出されます。 
コンパイルされた正規表現オブジェクトは、以下のメソッドと属性をサポートします： 
もし stringの先頭の 0 個以上の文字がこの正規表現とマッチすれば、対応する MatchObject インスタンスを返します。 
もし文字列がパタンーとマッチしなければ、None を返します；これは長さゼロのマッチとは異なることに注意して下さい。 
注意:もしマッチを string のどこかに位置付けたければ、代わりに search() を使って下さい。 
省略可能な第2のパラメータ posは、文字列内の検索を始めるインデッスクを与えます；デフォールトでは 0 です。 
これは、文字列のスライシングと完全に同じ意味だというわけではありません；'^'パターン文字は、文字列の実際の先頭と改行の直後とマッチしますが、それが必ずしも検索が開始するインデックスであるわけではないからです。 省略可能なパラメータ endposは、どこまで文字列が検索されるかを制限します；あたかもその文字列が endpos 文字長であるかのようにしますので、 pos から 
endpos - 1 までの文字が、マッチのために検索されます。 
もし endpos が posより小さければ、マッチは見つかりませんが、そうでなくて、もしrx がコンパイルされた正規表現オブジェクトであれば、 
rx.match(string, 0, 50) は 
rx.match(string[:50], 0)と同じ意味になります。 
string全体を走査して、この正規表現がマッチする位置を探して、対応する MatchObject インスタンスを返します。 
もし文字列内にパターンとマッチする位置がないならば、None を返します；これは文字列内のある点で長さゼロのマッチを探すこととは異なることに注意して下さい。 省略可能な pos と endpos パラメータは、match() メソッドのものと同じ意味を持ちます。 
split() 関数と同様で、コンパイルしたパターンを使います。 
findall() 関数と同様で、コンパイルしたパターンを使います。 
finditer() 関数と同様で、コンパイルしたパターンを使います。 
sub() 関数と同様で、コンパイルしたパターンを使います。 
subn() 関数と同様で、コンパイルしたパターンを使います。 
flags 引数は、RE オブジェクトがコンパイルされたとき使われ、もし flags が何も提供されなければ 0 です。 
(?Pid)で定義された任意の記号グループ名の、グループ番号への辞書マッピングです。 
もし記号グループがパターン内で何も使われていなければ、辞書は空です。 
RE オブジェクトがそれからコンパイルされたパターン文字列です。 
一般的に、文字列p が A とマッチし、別の文字列 q が B とマッチすれば、文字列 pqは AB にマッチします。 
ただし、この状況が成り立つのは、A と B との間に境界条件がある場合や、番号付けされたグループ参照のような、優先度の低い演算をA や B が含まない場合だけです。 
かくして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規表現を容易に構築できます。 
正規表現に関する理論と実装の詳細については上記の Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。 以下で正規表現の形式に関する簡単な説明をしておきます。 
通常の文字は連結できるので、last は文字列'last'とマッチします。 
(この節の以降の説明では、正規表現を引用符を使わずにこの表示スタイル: special style で書き、マッチ対象の文字列は、'引用符で括って' 書きます。 
)"|" や "(" といったいくつかの文字は特殊文字です。 特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常の文字に対する解釈方法に影響します。 
特殊文字を以下に示します: 
"." (ドット) デフォルトのモードでは改行以外の任意の文字にマッチします。 
DOTALL フラグが指定されていれば改行も含むすべての文字にマッチします。 
(キャレット) 文字列の先頭とマッチします。 
MULTILINE モードでは各改行の直後にマッチします。 
興味深いことに、'foo1nfoo2n' を foo.$ で検索した場合、通常のモードでは 'foo2' だけにマッチし、MULTILINEモードでは 'foo1' にもマッチします。 
直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したものにマッチさせるようにします。 
例えば ab* は 'a'、'ab'、あるいは'a' に任意個数の'b' を続けたものにマッチします。 "+" 
直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせるようにします。 
例えば ab+ は 'a' に一つ以上の 'b' が続いたものにマッチし、 'a' 単体にはマッチしません。 "?" 
直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせるようにします。 
例えば ab? は 'a' あるいは 'ab' にマッチします。 *?, +?, ?? 
"*"、"+"、 "?" といった修飾子は、すべて貪欲 (greedy) マッチ、すなわちできるだけ多くのテキストにマッチするようになっています。 
時にはこの動作が望ましくない場合もあります。 例えば正規表現 .* を 'H1title/H1' にマッチさせると、'H1' だけにマッチするのではなく全文字列にマッチしてしまいます。 
"?"を修飾子の後に追加すると、非貪欲 (non-greedy) あるいは 最小一致 (minimal) のマッチになり、できるだけ 少ない文字数のマッチになります。 
例えば上の式で .*?を使うと'H1' だけにマッチします。 
前にある RE の m 回の正確なコピーとマッチすべきであることを指定します；マッチ回数が少なければ、RE 全体ではマッチしません。 
例えば、a{6} は、正確に 6個の "a" 文字とマッチしますが、5個ではマッチしません。 
結果の RE は、前にある RE を、m回からn 回まで繰り返したもので、できるだけ多く繰り返したものとマッチするように、マッチします。 
例えば、a{3,5}は、3個から 5個の "a" 文字とマッチします。 
mを省略するとマッチ回数の下限として0を指定した事になり、n を省略することは、上限が無限であることを指定します；a{4,}b は aaaabや、千個の "a" 文字に bが続いたものとマッチしますが、aaabとはマッチしません。 
コンマは省略できません、そうでないと修飾子が上で述べた形式と混同されてしまうからです。 
結果の RE は、前にある RE のm回からn 回まで繰り返したもので、できるだけ少なく繰り返したものとマッチするように、マッチします。 
これは、前の修飾子の控え目バージョンです。 
例えば、6文字 文字列 'aaaaaa'では、a{3,5} は、5個の"a" 文字とマッチしますが、a{3,5}? は3個の文字とマッチするだけです。 
特殊文字をエスケープする("*"や "?"等のような文字とのマッチをできるようにする)か、あるいは、特殊シーケンスの合図です;特殊シーケンスは後で議論します。 もしパターンを表現するのに raw string を使用していないのであれば、Python も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして使っていることを覚えていて下さい；もしエスケープシーケンスをPython の構文解析器が認識して処理しなければ、そのバックスラッシュとそれに続く文字は、結果の文字列にそのまま含まれます。 
しかし、もし Python が結果のシーケンスを認識するのであれば、バックスラッシュを 2回 繰り返さなければいけません。 
このことは複雑で理解しにくいので、最も簡単な表現以外は、すべて raw string を使うことをぜひ勧めます。 
文字の集合を指定するのに使用します。 
文字は個々にリストするか、文字の範囲を、2つの文字と"-"でそれらを分離して指定することができます。 
特殊文字は集合内では有効ではありません。 
例えば、[akm$]は、文字 "a"、"k"、"m"、あるいは "$"のどれかとマッチします；[a-z] は、任意の小文字と、[a-zA-Z0-9] は、任意の文字や数字とマッチします。 
(以下で定義する) w やSのような文字クラスも、範囲に含めることができます。 
もし文字集合に"]" や "-" を含めたいのなら、その前にバックスラッシュを付けるか、それを最初の文字として指定します。 たとえば、パターン[]] は ']' とマッチします。 
範囲内にない文字とは、その集合の補集合をとることでマッチすることができます。 
これは、集合の最初の文字として"^" を含めることで表すことができます；他の場所にある "^"は、単純に"^"文字とマッチするだけです。 
例えば、[^5] は、"5"以外の任意の文字とマッチし、[^^] は、"^" 以外の任意の文字とマッチします。 
A|B は、ここで A と B は任意の RE ですが、A か B のどちらかとマッチする正規表現を作成します。 任意個数の RE を、こういう風に "|" で分離することができます。 
これはグループ(以下参照) 内部でも同様に使えます。 
検査対象文字列をスキャンする中で、"|" で分離された RE は左から右への順に検査されます。 
一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。 このことは、もし A がマッチすれば、たとえB によるマッチが全体としてより長いマッチになったとしても、B を決して検査しないことを意味します。 
言いかえると、"|" 演算子は決して貪欲 (greedy) ではありません。 
文字通りの "|"とマッチするには、| を使うか、あるいはそれを [|] のように文字クラス内に入れます。 
丸括弧の中にどのような正規表現があってもマッチし、またグループの先頭と末尾を表します；グループの中身は、マッチが実行された後に検索され、後述する number 
特殊シーケンス付きの文字列内で、後でマッチされます。 
文字通りの "(" や ")"とマッチするには、( あるいは ) を使うか、それらを文字クラス内に入れます： [(] [)]。 
これは拡張記法です( "("に続く"?"は他には意味がありません)。 
( 集合 "i"、"L"、"m"、 "s"、"u"、"x"から1文字以上)。 
グループは空文字列ともマッチします；文字は、正規表現全体の対応するフラグ (re.I、 re.L、re.M、 re.S、re.U、 re.X ) を設定します。 
もしこのフラグの前に非空白文字があると、その結果は未定義です。 
(?:...) 正規表現の丸括弧の非グループ化バージョンです。 
どのような正規表現が丸括弧内にあってもマッチしますが、グループによってマッチされたサブ文字列は、マッチを実行したあと検索されることも、あるいは後でパターンで参照されることも できません。 
正規表現の丸括弧と同様ですが、グループによってマッチされたサブ文字列は、記号グループ名nameを介してアクセスできます。 
グループ名は、正しい Python識別子でなければならず、各グループ名は、正規表現内で一度だけ定義されなければなりません。 
記号グループは、グループに名前が付けられていない場合のように、番号付けされたグループでもあります。 
そこで上の例で 'id'という名前がついたグループは、番号グループ 1 として参照することもできます。 たとえば、もしパターンが(?Pid[a-zA-Z_]w*)であれば、このグループは、マッチオブジェクトのメソッドへの引数に、m.group('id') あるいは m.end('id')のような名前で、またパターンテキスト内(例えば、 (?P=id)) や置換テキスト内( gidのように) で名前で参照することができます。 
前に name と名前付けされたグループにマッチした、いかなるテキストにもマッチします。 
コメントです；括弧の内容は単純に無視されます。 
もし ...が次に続くものとマッチすればマッチしますが、文字列をまったく消費しません。 
これは先読みアサーション(lookahead assertion)と呼ばれます。 
例えば、Isaac (?=Asimov) は、'Isaac'に'Asimov'が続く場合だけ、'Isaac'とマッチします。 
もし ... が次に続くものとマッチしなければマッチします。 
これは否定先読みアサーション(negative lookahead assertion)です。 
例えば、Isaac (?!Asimov)は、'Isaac' に'Asimov'が続かない場合のみマッチします。 
もし文字列内の現在位置の前に、現在位置で終わる ... とのマッチがあれば、マッチします。 
これは 肯定後読みアサーション(positive lookbehind assertion)と呼ばれます。 (?=abc)def は、"abcdef" にマッチを見つけます、というのは後読みが3文字をバックアップして、含まれているパターンとマッチするかどうか検査するからです。 
含まれるパターンは、固定長の文字列にのみマッチしなければなりません、ということは、abc や a|b は許されますが、a* や a{3,4} は許されないことを意味します。 
肯定後読みアサーションで始まるパターンは、検索される文字列の先頭とは決してマッチしないことに注意して下さい；多分、match() 関数よりは search()関数を使いたいでしょう： 
この例ではハイフンに続く単語を探します： 
もし文字列内の現在位置の前に ...とのマッチがないならば、マッチします。 
これは否定後読みアサーション(negative lookbehind assertion)と呼ばれます。 
肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけにマッチしなければいけません。 
否定後読みアサーションで始まるパターンは、検索される文字列の先頭とマッチすることができます。 
特殊シーケンスは "" と以下のリストにある文字から構成されます。 
もしリストにあるのが通常文字でないならば、結果の RE は2番目の文字とマッチします。 
例えば、$ は文字 "$"とマッチします。 
同じ番号のグループの中身とマッチします。 
グループは1から始まる番号をつけられます。 
例えば、(.+) 1 は、'the the' あるいは '55 55'とマッチしますが、'the end'とはマッチしません(グループの後のスペースに注意して下さい)。 
この特殊シーケンスは最初の 99 グループのうちの一つとマッチするのに使うことができるだけです。 
もし numberの最初の桁が 0 である、すなわちnumberが 3 桁の8進数であれば、それはグループのマッチとは解釈されず、8進数値 number を持つ文字として解釈されます。 
文字クラスの "["と "]"の中の数値エスケープは、文字として扱われます。 A 
文字列の先頭だけにマッチします。 
空文字列とマッチしますが、単語の先頭か末尾の時だけです。 
単語は英数字あるいは下線文字の並んだものとして定義されていますので、単語の末尾は空白あるいは非英数字、非下線文字によって表されます。 
b は、w と Wの間の境界として定義されているので、英数字であると見なされる文字の正確な集合は、UNICODEとLOCALEフラグの値に依存することに注意して下さい。 
文字の範囲の中では、b は、Python の文字列リテラルと互換性を持たせるために、後退(backspace)文字を表します。 
空文字列とマッチしますが、それが単語の先頭あるいは末尾にない時だけです。 
これは bのちょうど反対ですので、LOCALE とUNICODEの設定にも影響されます。 
任意の十進数とマッチします；これは集合 [0-9] と同じ意味です。 
任意の非数字文字とマッチします；これは集合 [^0-9]と同じ意味です。 
任意の空白文字とマッチします；これは集合 [ tnrfv]と同じ意味です。 
任意の非空白文字とマッチします；これは集合 [^ tnrfv] と同じ意味です。 
LOCALE とUNICODE フラグが指定されていない時は、任意の英数文字および下線とマッチします；これは、集合[a-zA-Z0-9_]と同じ意味です。 
LOCALEが設定されていると、集合 [0-9_] プラス 現在のロケール用に英数字として定義されている任意の文字とマッチします。 
もし UNICODE が設定されていれば、文字 [0-9_] プラス Unicode 文字特性データベースで英数字として分類されているものとマッチします。 
LOCALEと UNICODE フラグが指定されていない時、任意の非英数文字とマッチします；これは集合 [^a-zA-Z0-9_]と同じ意味です。 
LOCALEが指定されていると、 集合 [0-9_]になく、現在のロケールで英数字として定義されていない任意の文字とマッチします。 もし UNICODEがセットされていれば、これは[0-9_] および Unicode 文字特性データベースで英数字として表されている文字以外のものとマッチします。 
文字列の末尾とのみマッチします。 
+ Python 文字列リテラルによってサポートされている標準エスケープのほとんども、正規表現パーザに認識されます： 
8進エスケープは制限された形式で含まれています：もし第1桁が0 であるか、もし8進3桁であれば、それは8進エスケープとみなされます。 
そうでなければ、それはグループ参照です。 
文字列リテラルについて、8進エスケープはほとんどの場合3桁長になります。 
以下の例では、ユーザのホームディレクトリにある .pyhist という名前のヒストリファイルを自動的に読み書きするために、readlineモジュールによるヒストリの読み書き関数をどのように使うかを例示しています。 
以下のソースコードは通常、対話セッションの中で PYTHONSTARTUPファイルから読み込まれ自動的に実行されることになります。 
次の例では code.InteractiveConsole クラスを拡張し、ヒストリの保存・復旧をサポートします。 
Python ライブラリリファレンス 
Python/C API の各関数における参照カウントの振る舞いは、説明するには、参照の所有権 (ownership of references) という言葉でうまく説明できます。 
所有権は参照に対するもので、オブジェクトに対するものではありません (オブジェクトは誰にも所有されず、常に共有されています)。 
ある参照の "所有" は、その参照が必要なくなった時点でPy_DECREF() を呼び出す役割を担うことを意味します。 
逆に、ある関数呼び出しで、あるオブジェクトへの参照を呼び出される関数に渡す際には、二つの可能性: 関数がオブジェクトへの参照を盗み取る (steal) 場合と、そうでない場合があります。 
参照を盗み取る関数はほとんどありません; 例外としてよく知られているのは、PyList_SetItem() 
とPyTuple_SetItem() 
で、これらはシーケンスに入れる要素に対する参照を盗み取ります (しかし、要素の入る先のタプルやリストの参照は盗み取りません!)。 
これらの関数は、リストやタプルの中に新たに作成されたオブジェクトを入れていく際の常套的な書き方をしやすくするために、参照を盗み取るように設計されています; 例えば、(1, 2, "three") というタプルを生成するコードは以下のようになります (とりあえず例外処理のことは忘れておきます;もっとよい書き方を後で示します): 
ちなみに、PyTuple_SetItem() はタプルに値をセットするための 唯一の 方法です; タプルは変更不能なデータ型なので、PySequence_SetItem() や PyObject_SetItem()を使うと上の操作は拒否されてしまいます。 
自分でタプルの値を入れていくつもりなら、PyTuple_SetItem() だけしか使えません。 
同じく、リストに値を入れていくコードは PyList_New() と PyList_SetItem() で書けます。 
このコードは以下のように PySequence_SetItem() を使っても書けます; これを見れば、二つの違い (Py_DECREF() を別に呼び出している) が分かります: 
``推奨されている'' アプローチのほうが、コード量が多いので奇妙に思うかもしれませんね。 
しかし実際には、タプルやリストを生成して値を入れる際には、上記のような方法はほとんど使いません。 
より汎用性のある関数、Py_BuildValue() があり、ほとんどの主要なオブジェクトをフォーマット文字列 format stringの指定に基づいて C の値から生成できます。 
例えば、上の二種類のコードブロックは、以下のように置き換えられます(エラーチェックにも配慮しています): 
自作の関数に渡す引数のように、単に参照を借りるだけの要素に対しては、PyObject_SetItem() とその仲間を使うのがはるかに一般的です。 
その場合、参照カウントをインクリメントする必要がなく、参照を引き渡せる (``参照を盗み取らせられる'') ので、参照カウントに関する動作はより健全になります。 
例えば、以下の関数は与えられた要素をリスト中の全ての要素の値にセットします: 
関数の戻り値の場合には、状況は少し異なります。 
ほとんどの関数については、参照を渡してもその参照に対する所有権が変わることがない一方で、あるオブジェクトに対する参照を返すような多くの関数は、参照に対する所有権を呼び出し側に与えます。 理由は簡単です: 多くの場合、関数が返すオブジェクトはその場で(on the fly) 生成されるため、呼び出し側が得る参照は生成されたオブジェクトに対する唯一の参照になるからです。 
従って、PyObject_GetItem() やPySequence_GetItem() のように、オブジェクトに対する参照を返す汎用の関数は、常に新たな参照を返します (呼び出し側が参照の所有者になります)。 
重要なのは、関数が返す参照の所有権を持てるかどうかは、どの関数を呼び出すかだけによる、と理解することです -- 関数呼び出し時のお飾り (関数に引数として渡したオブジェクトの型) はこの問題には関係ありません!従って、PyList_GetItem() を使ってリスト内の要素を得た場合には、参照の所有者にはなりません -- が、同じ要素を同じリストから PySequence_GetItem() (図らずもこの関数は全く同じ引数をとります) を使って取り出すと、返されたオブジェクトに対する参照を得ます。 以下は、整数からなるリストに対して各要素の合計を計算する関数をどのようにして書けるかを示した例です; 一つはPyList_GetItem() 
を使っていて、もう一つはPySequence_GetItem() 
を使っています。 
longsum_list(PyObject *list){int i, n;long total = 0;PyObject *item;n = PyList_Size(list);if (n 0)return -1; /* リストではない */for (i = 0; i n; i++) {item = PyList_GetItem(list, i); /* 失敗しないはず */if (!PyInt_Check(item)) continue; /* 整数でなければ読み飛ばす */total += PyInt_AsLong(item);}return total;} 
longsum_sequence(PyObject *sequence){int i, n;long total = 0;PyObject *item;n = PySequence_Length(sequence);if (n 0)return -1; /* 長さの概念がない */for (i = 0; i n; i++) {item = PySequence_GetItem(sequence, i);if (item == NULL)return -1; /* シーケンスでないか、その他の失敗 */if (PyInt_Check(item))total += PyInt_AsLong(item);Py_DECREF(item); /* GetItem で得た所有権を放棄する */}return total;} 
今日の計算機は有限の (しばしば非常に限られた) メモリサイズしか持たないので、参照カウントは重要な概念です; 参照カウントは、あるオブジェクトに対して参照を行っている場所が何箇所あるかを数える値です。 
参照を行っている場所とは、別のオブジェクトであったり、グローバルな (あるいは静的な) C 変数であったり、何らかの C 関数内にあるローカルな変数だったりします。 
あるオブジェクトの参照カウントがゼロになると、そのオブジェクトは解放されます。 
そのオブジェクトに他のオブジェクトへの参照が入っていれば、他のオブジェクトの参照カウントはデクリメントされます。 
デクリメントの結果、他のオブジェクトの参照カウントがゼロになると、今度はそのオブジェクトが解放される、といった具合に以後続きます。 
(言うまでもなく、互いを参照しあうオブジェクトについて問題があります; 現状では、解決策は ``何もしない'' です。 
)参照カウントは、常に明示的なやり方で操作されます。 通常の方法では、Py_INCREF() 
でオブジェクトの参照を 1 インクリメントし、Py_DECREF() 
で 1 デクリメントします。 
型固有のデアロケータは、その型が複合オブジェクト (compound object)型である場合には、オブジェクト内の他のオブジェクトに対する参照カウントをデクリメントするよう気を配るとともに、その他の必要なファイナライズ (finalize) 処理を実行します。 
参照カウントがオーバフローすることはありません; というのも、仮想メモリ空間には、(sizeof(long) = sizeof(char*) と仮定した場合) 少なくとも参照カウントの記憶に使われるビット数と同じだけのメモリ上の位置があるからです。 
従って、参照カウントのインクリメントは単純な操作になります。 オブジェクトへのポインタが入っているローカルな変数全てについて、オブジェクトの参照カウントを必ずインクリメントしなければならないわけではありません。 
理論上は、オブジェクトの参照カウントは、オブジェクトを指し示す変数が生成されたときに 1 増やされ、その変数がスコープから出て行った際に 1 減らされます。 
しかしこの場合、二つの操作は互いに相殺するので、結果的に参照カウントは変化しません。 
参照カウントを使う真の意義とは、手持ちの何らかの変数がオブジェクトを指している間はオブジェクトがデアロケートされないようにすることにあります。 
オブジェクトに対して、一つでも別の参照が行われていて、その参照が手持ちの変数と同じ間維持されるのなら、参照カウントを一時的に増やす必要はありません。 
これらの操作は常に戻り値となるオブジェクトの参照カウントをインクリメントします。 
ユーザには戻り値が不要になったら Py_DECREF() を呼ぶ責任が残されています; とはいえ、すぐにその習慣は身に付くでしょう。 
このために (他の目的もありますが)、全てのオブジェクトには自身の型オブジェクトに対するポインタが入っています。 
さて、まだ重大な疑問が残っています: いつ Py_INCREF(x) やPy_DECREF(x) を使えばよいのでしょうか? まず、いくつかの用語説明から始めさせてください。 
まず、オブジェクトは ``占有 (own)'' されることはありません;しかし、あるオブジェクトに対する参照の所有 own a reference はできます。 
オブジェクトの参照カウントは、そのオブジェクトが参照を所有を受けている回数と定義されています。 
参照の所有者は、参照が必要なくなった際にPy_DECREF() を呼び出す役割を担います。 
参照の所有権は委譲 (transfer) できます。 
所有参照 (owned reference) の放棄には、渡す、保存する、Py_DECREF() を呼び出す、という三つの方法があります。 
所有参照を処理し忘れると、メモリリークを引き起こします。 
オブジェクトに対する参照は、借用 (borrow) も可能です。 
1.2 参照の借用者は、Py_DECREF() を呼んではなりません。 
借用者は、参照の所有者から借用した期間を超えて参照を保持し続けてはなりません。 
所有者が参照を放棄した後で借用参照を使うと、解放済みメモリを使用してしまう危険があるので、絶対に避けねばなりません。 
参照の借用が参照の所有よりも優れている点は、コードがとりうるあらゆる処理経路で参照を廃棄しておくよう注意しなくて済むことです-- 別の言い方をすれば、借用参照の場合には、処理の途中で関数を終了してもメモリリークの危険を冒すことがない、ということです。 
逆に、メモリリークの危険を冒すよりも不利な点は、ごくまともに見えるコードが、実際には参照の借用元で放棄されてしまった後にその参照を使うかもしれないような微妙な状況があるということです。 Py_INCREF() を呼び出すと、借用参照を所有参照 に変更できます。 
この操作は参照の借用元の状態には影響しません -- Py_INCREF() は新たな所有参照を生成し、参照の所有者が担うべき全ての責任を課します (つまり、新たな参照の所有者は、以前の所有者と同様、参照の放棄を適切に行わねばなりません)。 
... も可能です。 1.2 
...解放済みメモリを使用してしまう危険があるので、絶対に避けねばなりません。 
参照カウントが 1 以上かどうか調べる方法はうまくいきません -- 参照カウント自体も解放されたメモリ上にあるため、その領域が他のオブジェクトに使われている可能性があります! 
1 モジュールをインストールする: install コマンド群 
1 モジュールをインストールする: install コマンド群 
6.10 参考文献リストのマークアップ ドキュメントの各節の多くには、モジュールドキュメントや外部ドキュメントを指す参考文献のリストが入っています。 
こうしたリストは、seealsoやseealso* 環境を使って作成します。 
これらの環境では、参考文献エントリを合理的なやり方で作成するための追加のマクロを定義しています。 seealso 環境は通常、節中で何らかの小節に入る直前の場所に配置します。 
これは、ある節に関係した参考文献リンクが、ドキュメントのハイパーテキスト解析を行う際に小節内に入り込んでしまわないようにするためです。 
HTML 出力の場合、このマクロの内容は本文の外側の ``サイドバー'' に表示されます。 
seealso* 環境は、参考文献リストを主コンテンツの一部として表示したい場合に使う点が異なります; seealso* を使うと、リストを特別扱いしてテキスト内から押し出したりしません。 
この環境はヘッダ ``See also:'' を作成し、個々の参考文献を記述するためのマークアップを定義します。 
この環境は主コンテンツの一部として参考文献リストを生成する際に使います。 
リストに特別にヘッダをつけることはなく、ドキュメントの本文から押し出されることもありません。 
個々の参考文献を記述するために、上と同じマークアップを提供しています。 
特定のオンラインリソースへの参照を示す場合、ちゃんとした題名をそのリソースにつけられないが、短い説明をリンクの後につけたい場合には seelink マクロを使います。 
タイトルで特定できるようなオンライン上のドキュメントにはseetitle マクロを使い、オプションに URL を指定するようにしてください。 
別のモジュールへの参照です。 why は、なぜその参考文献が興味の対象となるのかを示す短い説明にせねばなりません。 
モジュール名は name で指定し、必要があれば key でリンクキーを指定します。 
HTML および PDF 版では、モジュール名部分は参照先のモジュールを指すハイパーリンクになります。 
注意:該当のモジュールは同じドキュメント内で記述されていなければなりません (対応するdeclaremodule が必要です)。 
Python Enhancement Proposal (PEP) への参照です。 number はPEP 編集者が割り当てた公式 PEP 番号でなければならず、tiutle は PEP ドキュメントの公式版に書かれている人間可読なタイトルでなければなりません。 
このマクロは、ドキュメント中の注釈がつけられている節の内容が関係しているインタフェースや言語機能 PEP への参照を読者に示すために使います。 
IETF による Request for Comment (RFC) を参照します。 
それ以外の点では、 seepep とほとんど同じです。 
このマクロは、ドキュメント中の注釈がつけられている節の内容が関係しているプロトコルやデータ形式を仕様記述している RFC への参照を読者に示すために使います。 
任意のテキストtext を ``See also:'' リストに追加します。 
このマクロはオフラインやオンラインの資料を url マクロで参照するために使えます。 
テキストは一つかそれ以上の完全な文で構成しなければなりません。 
title という名前の外部ドキュメントに対する参照を追加します。 
url を指定した場合、HTML 版では外部ドキュメントのタイトル部分がハイパーリンクになり、組版版のドキュメントでは表題の下に URL が表示されます。 
} 特定のオンラインリソースで、意味のあるタイトルがない場合にはseeurl マクロを使って参照を行います。 
はっきりしたタイトルのあるオンラインドキュメントの場合には、seetitle マクロを使い、そのオプションパラメタに URL を指定して参照を行ってください。 
6.11 索引生成のためのマークアップ ご意見やご指摘をお寄せになりたい方は、 
単一の回帰テストを指定 (python regrtest.py test_spam.py) すると、出力を最小限にします。 
すべてのリソースを使うには、python regrtest.py -uall を実行します。 -u のオプションに all を指定すると、すべてのリソースを有効にします。 
(よくある場合ですが) 何か一つを除く全てが必要な場合、カンマで区切った不要なリソースのリストをall の後に並べます。 コマンドpython regrtest.py -uall,-audio,-largefileとすると、audio と largefile リソースを除く全てのリソースを使ってtest.regrtest を実行します。 
すべてのリソースのリストと追加のコマンドラインオプションを出力するには、python regrtest.py -h を実行してください。 
10.9 循環参照ガベージコレクションをサポートする 
以下のメソッドは Request の全ての公開インタフェースを記述します。 
従ってサブクラスではこれら全てのメソッドをオーバライドしなければなりません。 add_data 
Request のデータを data に設定します。 
HTTP リクエストメソッドを示す文字列を返します。 
このメソッドはHTTP リクエストだけに対して意味があり、現状では常に ("GET", "POST")のうちのいずれかの値をとります。 
インスタンスが None でないデータを持つかどうかを返します。 
インスタンスのデータを返します。 
リクエストに新たなヘッダを追加します。 
ヘッダは HTTP ハンドラ以外のハンドラでは無視されます。 HTTP ハンドラでは、引数はサーバに送信されるヘッダのリストに追加されます。 
同じ名前を持つヘッダを 2 つ以上持つことはできず、key の衝突が生じた場合、後で追加したヘッダが前に追加したヘッダを上書きします。 
現時点では、この機能は HTTP の機能を損ねることはありません。 というのは、複数回呼び出したときに意味を持つようなヘッダには、どれもただ一つのヘッダを使って同じ機能を果たすための (ヘッダ特有の) 方法があるからです。 
リダイレクトされたリクエストには追加されないヘッダを追加します。 バージョン 2.4 で 新たに追加 された仕様です。 
インスタンスが名前つきヘッダであるかどうかを (通常のヘッダと非リダイレクトヘッダの両方を調べて) 返します。 
バージョン 2.4 で 新たに追加 された仕様です。 get_full_url 
コンストラクタで与えられた URL を返します。 
URL のタイプ -- いわゆるスキーム (scheme) -- を返します。 
接続を行う先のホスト名を返します。 
セレクタ -- サーバに送られる URL の一部分 -- を返します。 
リクエストがプロキシサーバを経由するように準備します。 
host および type はインスタンスのもとの設定と置き換えられます。 インスタンスのセレクタはコンストラクタに与えたもともとの URL になります。 
RFC 2965 の定義よる、始原トランザクションのリクエストホストを返します。 
Request コンストラクタのドキュメントを参照してください。 
リクエストが RFC 2965 の定義における証明不能リクエストであるかどうかを返します。 Request コンストラクタのドキュメントを参照してください。 
16.6 他のグラフィカルユーザインタフェースパッケージ 
17. 制限実行 (restricted execution) 
警告:Python 2.3 では、既知の容易に修正できないセキュリティーホールのために、これらのモジュールは無効にされています。 
rexec や Bastion モジュールを使った古いコードを読むときに助けになるよう、モジュールのドキュメントだけは残されています。 
制限実行 (restricted execution) とは、信頼できるコードと信頼できないコードを区別できるようにするための Python における基本的なフレームワークです。 
このフレームワークは、信頼できる Python コード (スーパバイザ (supervisor)) が、パーミッションに制限のかけられた ``拘束セル (padded cell)''を生成し、このセル中で信頼のおけないコードを実行するという概念に基づいています。 
信頼のおけないコードはこの拘束セルを破ることができず、信頼されたコードで提供され、管理されたインタフェースを介してのみ、傷つきやすいシステムリソースとやりとりすることができます。 ``制限実行'' という用語は、``安全な Python (safe-Python)'' を裏から支えるものです。 
というのは、真の安全を定義することは難しく、制限された環境を生成する方法によって決められるからです。 
制限された環境は入れ子にすることができ、このとき内側のセルはより縮小されることはあるが決して拡大されることのない特権を持ったサブセルを生成します。 Python の制限実行モデルの興味深い側面は、信頼されないコードに提供されるインタフェースが、信頼されるコードに提供されるそれらと同じ名前を持つということです。 
このため、制限された環境で動作するよう設計されたコードを書く上で特殊なインタフェースを学ぶ必要がありません。 
また、拘束セルの厳密な性質はスーパバイザによって決められるため、アプリケーションによって異なる制限を課すことができます。 
例えば、信頼されないコードが指定したディレクトリ内の何らかのファイルを読み出すが決して書き込まないということが ``安全''と考えられるかもしれません。 
この場合、スーパバイザは組み込みのopen() 関数について、mode パラメタが 'w'の時に例外を送出するように再定義できます。 
また例えば、``安全'' とは、filename パラメタに対して chroot() に似た操作を施して、ルートパスがファイルシステム上の何らかの安全な ``砂場 (sandbox)'' 領域に対する相対パスになるようにすることかもしれません。 
この場合でも、信頼されないコードは依然として、もとの呼び出しインタフェースを持ったままの組み込みのopen() 関数を制限環境中に見出します。 
ここでは、関数に対する意味付け(semantics) は同じですが、許可されないパラメタが使われようとしているとスーパバイザが判断した場合には IOError が送出されます。 Python のランタイムシステムは、特定のコードブロックが制限実行モードかどうかを、グローバル変数の中の __builtins__ オブジェクトの一意性をもとに判断します: オブジェクトが標準の 
__builtin__ モジュール (の辞書) の場合、コードは非制限下にあるとみなされます。 
基本的な制限実行フレームワーク。 
オブジェクトに対するアクセスの制限を提供する。 
Python で書かれたインターネットブラウザ Grail です。 Python で書かれたアプレットをサポートするために、上記のモジュールを使っています。 
Grail における Python 制限実行モードの利用に関する詳しい情報は、Web サイトで入手することができます。 
return は、関数定義内で構文法的にネストして現れますが、ネストしたクラス定義内には現れません。 
式リストがある場合、リストが値評価されます。 それ以外の場合はNone で置き換えられます。 
return を使うと、式リスト (または None) を戻り値として、現在の関数呼び出しから抜け出します。 return によって、finally 節をともなう try 文の外に処理が引き渡されると、実際に関数から抜ける前に finally 節が実行されます。 
ジェネレータ関数の場合には、return 文の中にexpression_list を入れることはできません。 
ジェネレータ関数の処理コンテキストでは、単体の return はジェネレータ処理を終了し StopIteration を送出させることを示します。 
RExec クラスには以下のクラス属性があります。 
これらの属性のすべては、文字列のタプルです。 
制限された環境で実行するプログラムでは利用できないであろう、組み込み関数の名前を格納しています。 
この変数をオーバライドしたいサブクラスは、基本クラスからの値から始めて、追加した許されない関数を連結していかなければなりません - 危険な関数が新しく Python に追加された時は、それらも、このモジュールに追加します。 
安全にインポートできる組み込みモジュールの名前を格納しています。 RExecに対する値は、 ('audioop', 'array', 'binascii','cmath', 'errno', 'imageop', 'marshal', 'math', 'md5', 'operator','parser', 'regex', 'select', 'sha', '_sre', 'strop','struct', 'time') です。 
この変数をオーバーライドする場合も、同様な注意が適用されます - 基本クラスからの値を使って始めます。 
importが制限された環境で実行される時に検索されるディレクトリーを格納しています。 
RExecに対する値は、(モジュールがロードされた時は)制限されないコードの sys.path と同一です。 
モジュール内の関数の名前を格納しています。 
RExecに対する値は、 ('error', 'fstat', 'listdir','lstat', 'readlink', 'stat', 'times', 'uname', 'getpid', 'getppid','getcwd', 'getuid', 'getgid', 'geteuid', 'getegid') です。 
ok_sys_names 制限された環境で実行するプログラムで利用できる、 
モジュール内の関数名と変数名を格納しています。 
RExecに対する値は、 ('ps1', 'ps2','copyright', 'version', 'platform', 'exit', 'maxint')です。 
モジュールがロードすることを許されているファイルタイプを格納しています。 各ファイルタイプは、 
モジュールで定義された整数定数です。 意味のある値は、PY_SOURCE、PY_COMPILED およびC_EXTENSION です。 
RExecに対する値は、(C_EXTENSION,PY_SOURCE)です。 
サブクラスで PY_COMPILEDを追加することは推奨されません；攻撃者が、バイトコンパイルしたでっちあげのファイル(.pyc)を、例えば、あなたの公開 FTP サーバの /tmp に書いたり、/incoming にアップロードしたりして、とにかくあなたのファイルシステム内に置くことで、制限された実行モードから抜け出ることができるかもしれないからです。 
RExec インスタンスは以下のメソッドをサポートします： 
code は、Python の式を含む文字列か、あるいはコンパイルされたコードオブジェクトのどちらかでなければなりません。 そしてこれらは制限された環境の __main__ モジュールで評価されます。 
式あるいはコードオブジェクトの値が返されます。 
code は、1行以上の Python コードを含む文字列か、コンパイルされたコードオブジェクトのどちらかでなければなりません。 そしてこれらは、制限された環境の __main__ モジュールで実行されます。 
ファイル filename 内の Python コードを、制限された環境の__main__ モジュールで実行します。 
名前が "s_" で始まるメソッドは、"r_"で始まる関数と同様ですが、そのコードは、標準 I/O ストリーム sys.stdin、sys.stderr および sys.stdout の制限されたバージョンへのアクセスが許されています。 
code は、Python 式を含む文字列でなければなりません。 そして制限された環境で評価されます。 
code は、1行以上のPython コードを含む文字列でなければなりません。 そして制限された環境で実行されます。 
ファイル filename に含まれた Python コードを制限された環境で実行します。 
RExec オブジェクトは、制限された環境で実行されるコードによって暗黙のうちに呼ばれる、さまざまなメソッドもサポートしなければなりません。 
これらのメソッドをサブクラス内でオーバライドすることによって、制限された環境が強制するポリシを変更します。 r_import 
モジュール modulename をインポートし、もしそのモジュールが安全でないとみなされるなら、ImportError 例外を発生します。 
open() が制限された環境で呼ばれるとき、呼ばれるメソッドです。 
引数は open()のものと同じであり、ファイルオブジェクト(あるいはファイルオブジェクトと互換性のあるクラスインスタンス)が返されます。 
RExecのデフォルトの動作は、任意のファイルを読み取り用にオープンすることを許可しますが、ファイルに書き込もうとすることは許しません。 
より制限の少ない r_open()の実装については、以下の例を見て下さい。 
モジュールオブジェクト module を再ロードして、それを再解析し再初期化します。 
モジュールオブジェクト moduleをアンロードします(それを制限された環境の sys.modules 辞書から取りのぞきます)。 
および制限された標準 I/O ストリームへのアクセスが可能な同等のもの： 
モジュールオブジェクト moduleをアンロードします。 
再入可能ロック (reentrant lock) とは、同じスレッドが複数回獲得できるような同期プリミティブです。 
再入可能ロックの内部では、プリミティブロックの使うロック／アンロック状態に加え、 ``所有スレッド (owning thread)''と ``再帰レベル (recursion level)'' という概念を用いています。 ロック状態では何らかのスレッドがロックを所有しており、アンロック状態ではいかなるスレッドもロックを所有していません。 
スレッドがこのロックの状態をロックにするには、ロックのacquire()メソッドを呼び出します。 このメソッドは、スレッドがロックを所有すると処理を戻します。 
ロックの状態をアンロックにするにはrelease() メソッドを呼び出します。 acquire()/release() からなるペアの呼び出しはネストできます; 最後に呼び出した release() (最も外側の呼び出しペア)だけが、ロックの状態をアンロックにリセットし、acquire() でブロック中の別のスレッドの処理を進行させられます。 
ブロックあり、またはブロックなしでロックを獲得します。 引数なしで呼び出した場合: スレッドが既にロックを所有している場合、再帰レベルをインクリメントして即座に処理を戻します。 
それ以外の場合、他のスレッドがロックを所有していれば、そのロックの状態がアンロックになるまでブロックします。 
その後、ロックの状態がアンロックになる (いかなるスレッドもロックを所有しない状態になる) と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を戻します。 
ロックの状態がアンロックになるのを待っているスレッドが複数ある場合、その中の一つだけがロックの所有権を獲得できます。 
引数なしで呼び出した場合にブロックするような状況であった場合には直ちに偽を返します。 それ以外の場合には、引数なしで呼び出したときと同じ処理を行い真を返します。 
再帰レベルをデクリメントしてロックを解放します。 
デクリメント後に再帰レベルがゼロになった場合、ロックの状態をアンロック (いかなるスレッドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックしているスレッドがある場合にはその中のただ一つだけが処理を進行できるようにします。 
このインターフェースのオブジェクトは XMLReader からのエラーや警告の情報を受け取るために使われます。 
このインターフェースを実装したオブジェクトを作成し XMLReader に登録すると、パーサは警告やエラーの通知のためにそのオブジェクトのメソッドを呼び出すようになります。 
エラーには警告、回復可能エラー、回復不能エラーの3段階があります。 
すべてのメソッドは SAXParseException だけをパラメータとして受け取ります。 
受け取った例外オブジェクトを raise することで、エラーや警告は例外に変換されることもあります。 
パーサが回復可能なエラーを検知すると呼び出されます。 
このメソッドが例外を raise しないとパースは継続されますが、アプリケーション側ではエラー以降のドキュメント情報を期待していないこともあります。 
パーサが処理を継続した場合、入力ドキュメント内のほかのエラーを見つけることができます。 
パーサが回復不能なエラーを検知すると呼び出されます。 このメソッドがreturn した後、すぐにパースを停止することが求められています。 
パーサが軽微な警告情報をアプリケーションに通知するために呼び出されます。 
このメソッドが return した後もパースを継続し、ドキュメント情報をアプリケーションに送り続けるよう求められています。 このメソッドで例外を発生させた場合、パースは中断されてしまいます。 
SAXException 例外クラスは以下のメソッドをサポートしています。 
エラー状態を示す可読メッセージを返します。 
カプセル化した例外オブジェクトまたは None を返します。 
schedulerインスタンスは以下のメソッドを持っています: 
新しいイベントをスケジュールします。 
引数timeは、コンストラクタへ渡されたtimefuncの戻り値と互換な数値型でなければいけません。 
同じtimeによってスケジュールされたイベントは、それらのpriorityによって実行されるでしょう。 
時間単位以上のdelayでイベントをスケジュールします。 
そのとき、その他の関連時間、その他の引数、効果、戻り値は、enterabs()に対するものと同じです。 
キューからイベントを消去します。 
もしeventがキューにある現在のイベントでないならば、このメソッドはRuntimeErrorを送出します。 
もしイベントキューが空ならば、Trueを返します。 
すべてのスケジュールされたイベントを実行します。 
この関数は次のイベントを(コンストラクタへ渡された関数delayfuncを使うことで)待ち、そしてそれを実行し、イベントがスケジュールされなくなるまで同じことを繰り返します。 actionあるいはdelayfuncは例外を投げることができます。 
いずれの場合も、スケジューラは一貫した状態を維持し、例外を伝播するでしょう。 
例外がactionによって投げられる場合、イベントはrun()への呼出しを未来に行なわないでしょう。 イベントのシーケンスが、次イベントの前に、利用可能時間より実行時間が長いと、スケジューラは単に遅れることになるでしょう。 
イベントが落ちることはありません;呼出しコードはもはや適切でないキャンセルイベントに対して責任があります。 
1.2.4.2 Pythonモード付きのエディタ 
BBEdit でスクリプトを作成しているなら、保存したファイルをダブルクリックして起動できるように、クリエータコードを Python に指定したいと考えるでしょう。 
BBEdit を立ち上げます。 
「Edit」メニューから「Preferences」を選択します。 
スクロールリストから「File Types」を選択します。 
「Add...」ボタンをクリックし、 MacPython 配布物ディレクトリの下に移動して、PythonInterpreter を選び、「open」をクリックします。 
設定パネルの``Save''ボタンをクリックします。 
Python は オープンスクリプティングアーキテクチャ(Open ScriptingArchitecure、OSA、一般的には AppleScript と呼ばれる)のかなり完全な実装を行っていて、Python プログラムからスクリプト可能なアプリケーションを操作したり、Python へのインターフェースを備えたものにすることができます。 
AppleScript と OSA の様々なコンポーネントの記述のために、また、アーキテクチャおよび用語についての理解を得るために、アップルの文書を読む必要があります。 
"Applescript Language Guide" は概念のモデルおよび用語、Standard Suiteについて説明した文書です。 
"Open Scripting Architecture" 文書は、アプリケーションプログラマの視点から OSA を使用する方法について説明しています。 
これらの文書はAppleヘルプビューワのDeveloper Documentation中のCore Technologiesセクションにあります。 アプリケーションをスクリプトで操作する例として、次の AppleScript は、一番前の Finder ウィンドウの名前を取得し、それを印字します。 
Pythonでは以下のコードで同じ事ができます。 
配布されている Python ライブラリは、Standard Suite を実装したパッケージに加えて、いくつかの一般的なアプリケーションへのインターフェースを実装したパッケージが含まれています。 アプリケーションに AppleEvent を送るためには、アプリケーションの用語(Script Editorが「辞書」と呼ぶもの)に接続する Python パッケージを最初に作成しなければなりません。 
これは、PythonIDE の内部から、あるいは、コマンドラインからのスタンドアロンのプログラムとして gensuitemodule.py モジュールを実行することにより行うことができます。 gensuitemodule.py モジュールで生成される出力は多くのモジュールを備えたパッケージのため、全ての Suite をプログラムの中で 1 つにまとめて利用できるようにするために __init__ モジュールが追加されています。 
Python 継承グラフは AppleScript 継承グラフを理解するので、Standard Suite をサポートしていて、余分な引数を備えた1つあるいは2つの変数を拡張する事ができるようにプログラム辞書が書かれていた場合、出力された Suite は、StdSuites.Standard_Suite からすべてをインポートして再エクスポートし、さらに拡張機能をもったメソッドをオーバーライドするモジュール Standard_Suite を含みます。 
また AppleScript クラスは Python クラス、そして類事物その他のもろもろの物として実装されています。 変数を実装する主要な Python クラスは、さらに AppleScriptクラス "application" で宣言されたプロパティおよび要素へのアクセスを許可します。 
現在のリリースでオブジェクト指向的にやろうとするならば、例えば、より Python 的な f.window(1).name.get() の代りに f.get(f.window(1).name) を利用する必要があります。 AppleScript 識別子が Python 識別子と同じでない場合、名前は少数の規則によって判別します。 
スペースは下線に置換されます。 
_xx_ が16進法の文字値である場合、他の英数字でない文字は xx と置換されます。 
あらゆるPython 予約語には下線を追加します。 
Python は、さらに Python でスクリプト対応アプリケーションを作成する事をサポートしています。 次のモジュールはMacPythonのAppleScriptサポートに適切です。 
OSA辞書からスタブパッケージを作成します。 
Apple Eventを送るための基本的なサポート 
Python変数とAppleEventデータコンテナ間の変換 
Apple Event オブジェクトモデルの Python 表現 
オープンスクリプティングアーキテクチャ(OSA)サーバ(``Apple Events'')のサポート。 
さらに、Finder, Terminal, Explorer,Netscape, CodeWarrior, SystemEvents そしてStdSuites のサポートモジュールは、あらかじめ生成されています。 
スクロールウィンドウオブジェクトは、次のメソッドを追加したコントロールウィンドウオブジェクトです。 
水平スクロールバーと垂直スクロールバーを作成します(あるいは破棄します)。 
引数はどちらが欲しいか指定します(デフォルトは両方)。 
スクロールバーは常に最小値 0 、最大値 32767 です。 
このメソッドは必ず作っておかなくてはいけません。 
現在のスクロールバーの位置を与えるタプル (x, y) を(0 の 32767 間で)返してください。 
バーの方向について全文書が可視状態であること知らせるため None を返す事もできます。 
文書に変更があった場合はこのメソッドを呼びます。 
このメソッドはgetscrollbarvalues() を呼んでスクロールバーを更新します。 
あらかじめ与えておくメソッドで、ユーザーとの対話により呼ばれます。 which は 'x' か 'y' 、whatは '-','-', 'set','++', '+'のどれかです。 
'set' の場合は、valueに新しいスクロールバー位置を入れておきます。 
getscrollbarvalues() の結果から値を計算するのを助ける補助的なメソッドです。 
文書の最小値と最大値、可視部分に関する最先頭値(最左値)と最底値(最右値)を渡すと、正しい数か None を返します。 
ウィンドウが最前面になった時、スクロールバーのディム(dimming)/ハイライトの面倒をみます。 
このメソッドをオーバーライドするなら、オーバーライドしたメソッドの最後でオリジナルのメソッドを呼んでください。 
スクロールバーを正しい位置に移動させます。 
オーバーライドする時は、オーバーライドしたメソッドの一番最初でオリジナルのメソッドを呼んでください。 
スクロールバーのインタラクションを処理します。 
これをオーバーライドする時は、オリジナルのメソッドを最初に呼び出してください。 非ゼロの返り値はスクロールバー内がヒットされたことを意味し、実際に処理が進むことになります。 
2 ソースコード配布物を作成する: sdist command 
4.1 Python サーチパスの変更 
たまに、 3 節で述べたような別の場所へのインストールスキームが、自分のやりたいインストール方法と違うことがあります。 
もしかすると、同じベースディレクトリ下にあるディレクトリのうち、一つか二つだけをいじりたかったり、インストールスキームを完全に再定義したいと思うかもしれません。 どちらの場合にせよ、こうした操作ではカスタムのインストールスキーム を作成することになります。 
別の場所へのインストールスキームに関するこれまでの説明で、``オーバライドするためのオプション'' というコラムにお気づきかもしれません。 
このオプションは、カスタムのインストールスキームを定義するための手段です。 
各オーバライドオプションには、相対パスを指定しても、絶対パスを指定しても、インストールベースディレクトリのいずれかを明示的に指定してもかまいません。 
Unix 環境での例をもう一つ紹介します: インストール済みの Python が、/usr/local/python を prefix にしてビルドされ、インストールされていて、標準のインストールスクリプトは /usr/local/python/binに入るようになっているとします。 
/usr/local/bin に入るようにしたければ、絶対パスを --install-scripts オプションに与えて上書きすることになるでしょう: 
(この操作を行うと、 ``prefix スキーム'' を使ったインストールになり、 prefix は Python インタプリタがインストールされている場所-- この場合には /usr/local/python になります。 )Windows 用の Python を管理しているのなら、サードパーティ製モジュールを prefix そのものの下ではなく、 prefix の下にあるサブディレクトリに置きたいと考えるかもしれません。 
この作業は、インストールディレクトリのカスタマイズとほぼ同じくらい簡単です -- 覚えておかねばならないのは、モジュールには二つのタイプ、pure モジュールと非 pure モジュール (非 pure モジュール配布物内のモジュール) があるということです。 
指定したインストール先ディレクトリは、prefix からの相対です。 
もちろん、prefix を .pth ファイルに入れるなどして、これらのディレクトリが Python のモジュール検索パス内に入るようにしなければなりません。 
Python のモジュール検索パスを修正する方法は、4.1 節を参照してください。 インストールスキーム全体を定義したいのなら、全てのインストールディレクトリオプションを指定しなければなりません。 
この作業には、相対パスを使った指定を勧めます; 例えば、全ての Python モジュール関連ファイルをホームディレクトリ下の python ディレクトリの下に置き、そのホームディレクトリをマウントしている各プラットフォームごとに別のディレクトリを置きたければ、以下のようにインストールスキームを定義します: 
また、以下のようにも指定できます: 
そこで、オプションは Distutils 設定ファイル (5 参照) にも指定できます: 
あるいは、以下のようにも指定できます: 
これら二つは、 setup スクリプトを異なるインストールベースディレクトリから実行した場合には同じには ならない ので注意してください。 
とすると、最初の書き方では pure モジュールが/tmp/python/lib に入り、二番目の書き方では /tmp/lib に入ります。 
(二番目のケースでは、インストールベースを /tmp/python に指定しようと考えるでしょう。 )読者は、設定ファイル例で、入力値に $HOME や $PLAT を使っていることに気づいているかもしれませんね。 
Python インタプリタが import 文を実行するとき、インタプリタは Python コードや拡張モジュールをモジュール検索パス中から探します。 
検索パスのデフォルト値は、インタプリタをビルドする際に Python のバイナリ内に設定されます。 
検索パスは、sys を import して、 sys.path を出力すればわかります。 
sys.path 内の空文字列は、現在の作業ディレクトリを表します。 
ローカルでインストールされるパッケージは、.../site-packages/ディレクトリに入るのが決まりですが、ユーザはどこか任意のディレクトリにPython モジュールをインストールしたいと思うかもしれません。 
例えば、自分のサイトでは、 web サーバに関連する全てのソフトウェアを /www に置くという決まりがあるかもしれません。 
そこで、アドオンの Python モジュールが /www/python 置かれることになると、モジュールを import するためにはディレクトリを sys.pathに追加せねばなりません。 
ディレクトリを検索パスに追加するには、いくつかの異なる方法が存在します。 
最も手軽な方法は、パス設定ファイルをすでに Python の検索パスに含まれるディレクトリ、通常は .../site-packages/ ディレクトリに置くというものです。 
パス設定ファイルは拡張子が .pth で、ファイルには sys.path に追加するパスを一行に一つづつ記述しなければなりません。 
(新たなパスは今の sys.path の後ろに追加されるので、追加されたディレクトリ内にあるモジュールが標準のモジュールセットを上書きすることはありません。 
つまり、このメカニズムを使って、標準モジュールに対する修正版のインストールはできないということです。 )パスは絶対パスでも相対パスでもよく、相対パスの場合には .pthファイルのあるパスからの相対になります。 
site モジュールのドキュメント 
を読んでください。 やや便利さには欠けますが、Python の標準ライブラリ中にある site.py ファイルを編集することでも、sys.path を変更できます。 
site.py は、 -S スイッチを与えて抑制しないかぎり、Python インタプリタが実行される際に自動的に import されます。 
ただし、設定するには、単にsite.py を編集して、例えば以下のような二行を加えます: 
しかしながら、(例えば 2.2 から 2.2.2 にアップグレードするときのように)同じメジャーバージョンの Python を再インストールすると、site.py は手持ちのバージョンで上書きされてしまいます。 
ファイルが変更されていることを覚えておき、インストールを行う前にコピーを忘れずとっておかねばなりません。 また、sys.path を修正できる二つの環境変数があります。 
PYTHONHOME を使うと、インストールされている Python のプレフィクスを別の値に設定できます。 
例えば、 PYTHONHOME を "/www/python" に設定すると、検索パスは ['', '/www/python/lib/python2.2/', '/www/python/lib/python2.3/plat-linux2', ...] といった具合になります。 
PYTHONPATH を使うと、sys.path の先頭に一連のパスを追加できます。 
例えば、PYTHONPATH を"/www/python:/opt/py" に設定すると、検索パスは['/www/python', '/opt/py'] から始まります。 
(sys.path にディレクトリを追加するには、そのディレクトリが実在しなければなりません; site は実在しないディレクトリを除去します。 
)最後に、 sys.path はただの普通の Python のリストなので、どんな Python アプリケーションもエントリを追加したり除去したりといった修正を行えます。 
セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなどを保護するために使われます。 
リソースのサイズが固定の状況では、常に有限セマフォを使わねばなりません。 
主スレッドは、作業スレッドを立ち上げる前にセマフォを初期化します: 
作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が生じたときにセマフォのacquire およびreleaseメソッドを呼び出します: 
有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうというプログラム上の間違いを見逃しにくくします。 
セマフォ (semaphore) は、計算機科学史上最も古い同期プリミティブの一つで、草創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました(彼はacquire()とrelease()の代わりにP()とV()を使いました)。 セマフォはacquire() でデクリメントされrelease()でインクリメントされるような内部カウンタを管理します。 
カウンタは決してゼロより小さくはなりません; acquire() は、カウンタがゼロになっている場合、他のスレッドがrelease()を呼び出すまでブロックします。 
クラスSemaphore 
オプションの引数には、内部カウンタの初期値を指定します。 
デフォルトは1です。 
セマフォを獲得します。 引数なしで呼び出した場合: acqure() 処理に入ったときに内部カウンタがゼロより大きければ、カウンタを 1 デクリメントして即座に処理を戻します。 
acqure() 処理に入ったときに内部カウンタがゼロの場合、他のスレッドが release()を呼び出してカウンタをゼロより大きくするまでブロックします。 
この処理は、適切なインターロック (interlock) を介して行い、複数の acquire() 呼び出しがブロックされた場合、release() が正確に一つだけを起こせるようにします。 
この実装はランダムに一つ選択するだけでもよいので、ブロックされたスレッドがどの起こされる順番に依存してはなりません。 
引数なしで呼び出した場合にブロックするような状況であった場合には直ちに偽を返します。 それ以外の場合には、引数なしで呼び出したときと同じ処理を行い真を返します。 
内部カウンタを 1 インクリメントして、セマフォを解放します。 
release() 処理に入ったときにカウンタがゼロであり、カウンタの値がゼロより大きくなるのを待っている別のスレッドがあった場合、そのスレッドを起こします。 
クラスSequenceMatcher 
オプションの引数 isjunk は、None (デフォルトの値です)にするか、単一の引数をとる関数にせねばなりません。 後者の場合、関数はシーケンスの要素を受け取り、要素が ``junk'' であり、無視すべきである場合に限り真をかえすようにせねばなりません。 
isjunk に None を渡すと、lambda x: 0 を渡したのと同じになります; すなわち、いかなる要素も無視しなくなります。 例えば以下のような引数を渡すと、空白とタブ文字を無視して文字のシーケンスを比較します。 
オプションの引数 a と b は、比較される文字列です。 
デフォルトで、それらは空の文字列で、文字列の要素はハッシュ化できます。 
SequenceMatcher オブジェクトは以下のメソッドを持ちます。 
比較される2つの文字列を設定します。 
SequenceMatcher オブジェクトは2つ目の文字列についての詳細な情報を算定し、保管します。 そのため、ひとつの文字列をいくつもの文字列と比較する場合、まず set_seq2() を使って文字列を設定しておき、別の文字列をひとつづつ比較するために、繰り返し set_seq() を呼び出します。 
比較を行うひとつ目の文字列を設定します。 
比較される2つ目の文字列は変更されません。 
比較を行う2つめ目のシーケンスを設定します。 
比較されるひとつ目のシーケンスは変更されません。 
isjunkが省略されたかNoneの時、get_longest_match()は 
a[i:i+k] が b[j:j+k]と等しいような(i, j, k)を返します。 
その値は 
かつ 
(i', j', k')でも、同じようになります。 
さらに 
が 
でも同様です。 言い換えると、いくつものマッチ列すべてのうち、a内で最初に始まるものを返します。 
そしてそのa内で最初のマッチ列すべてのうちb内で最初に始まるものを返します。 s = SequenceMatcher(None, " abcd", "abcd abcd") s.find_longest_match(0, 5, 0, 9)(0, 4, 5) 
引数isjunkが与えられている場合、上記の通り、はじめに再長のマッチ列を判定します。 ブロック内にjunk要素が見当たらないような追加条件の際はこれに該当しません。 
代わりに'abcd'にはマッチします。 
どんな列にもマッチしない時は、(alo, blo, 0)を返します。 
マッチしたシーケンス中で個別にマッチしたシーケンスをあらわす、3つの値のリストを返します。 
最後のタプルはダミーで、(len(a), len(b), 0)という値を持ちます。 これは 
n==0である唯一のタプルです。 
aをbにするための方法を記述する5つのタプルを返します。 それぞれのタプルは(tag, i1, i2, j1, j2)という形式であらわされます。 
最初のタプルは 
a[i1:i2]は 
b[j1:j2]に置き換えられる 
a[i1:i2] は削除される。 
この時、 
である 
b[j1:j2] が a[i1:i1]に挿入される。 
この時 
である。 
例: a = "qabxcd" b = "abycdf" s = SequenceMatcher(None, a, b) for tag, i1, i2, j1, j2 in s.get_opcodes():... print ("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %... (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))delete a[0:1] (q) b[0:0] ()equal a[1:3] (ab) b[0:2] (ab)replace a[3:4] (x) b[2:3] (y)equal a[4:6] (cd) b[3:5] (cd)insert a[6:6] () b[5:6] (f) 
[0, 1]の範囲の浮動小数点で、シーケンスの同一性を測る値を返します。 Tが2つのシーケンスそれぞれがもつ要素の総数だと仮定し、Mをマッチした数とすると、この値は2.0*M/Tであらわされます。 
ratio()で測定する同一性をより素早く、限定された形で測ります。 
このメソッドはratio()より限定されており、これを超えるとは見なされませんが、高速に実行します。 
ratio()で測定する同一性を非常に素早く測ります。 
このメソッドはratio()より限定されており、これを超えるとは見なされませんが、ratio()やquick_ratio()より高速に実行します。 
この文字列全体のマッチ率を返す3つのメソッドは、異なる近似値に基づく異なる結果を返します。 
とはいえ、quick_ratio()とreal_quick_ratio()は、常にratio()より大きな値を示します。 s = SequenceMatcher(None, "abcd", "bcde") s.ratio()0.75 s.quick_ratio()0.75 s.real_quick_ratio()1.0 
以下のオプションとなるメソッドを定義して、シーケンスオブジェクトをより高度にエミュレーションできます。 
変更不能なシーケンスのメソッドでは、__getslice__() が定義できるだけです; 変更可能なシーケンスでは三つのメソッド全てを定義できます。 
リリース 2.0 で撤廃されました。 スライスオブジェクトは __getitem__() メソッドのパラメタとしてサポートするようになりました。 
self[i:j] の値評価を実現するために呼び出されます。 
返されるオブジェクトは self と同じ型でなければなりません。 
スライス表記で i や j がない場合には、それぞれゼロやsys.maxint に置き換えられるので注意してください。 
スライスに負のインデクスが用いられた場合、シーケンスの長さがインデクス値に加算されます。 
self[i:j] への代入を実現するために呼び出されます。 
i および j に関しては、__getslice__() と同じ注釈があてはまります。 このメソッドは撤廃されています。 
self[i:j] の削除を実現するために呼び出されます。 
これらのメソッドは、単一のコロンを使った単一のスライスで、かつスライスメソッドが利用できるときにだけ呼び出されることに注意してください。 
拡張スライス表記を含んでいるスライス表記や、スライスメソッドがない場合、__getitem__()、__setitem__() 、あるいは __delitem__() がスライスオブジェクトを引数として呼び出されます。 以下の例は、プログラムやモジュールを以前のバージョンの Pythonに対して互換性を持たせる方法を示したものです(__getitem__()、 __setitem__() 、および__delitem__() は引数としてスライスオブジェクトをサポートするものと仮定します): 
max() を呼び出していることに注意してください; この呼び出し__*slice__() メソッド呼び出される前に、負のインデクス値を処理しておくために必要です。 
負のインデクス値が使われた場合、 __*item__() メソッドは与えられた値をそのまま使いますが、__*slice__() メソッドは``調理済みの (cooked)'' 形式になったインデクス値を受け取ります。 
負のインデクス値が使われると、メソッドを呼び出す前に、常にシーケンスの長さをインデクス値に加算します (加算してもまだ負の値となっていてもかまいません); これは、組み込みシーケンス型における慣習的な負のインデクス処理方法で、__*item__() メソッドでも同様の処理を行うよう期待しています。 
しかし、ここではすでに負のインデクス値の処理を行っているので、負のインデクスを渡すべきではありません; インデクス値は、__*item__()メソッドに渡される前に、シーケンスのインデクス集合の境界に制限されていなければなりません。 max(0, i) を呼び出せば、適切な値を返すので便利です。 
10.7 バッファオブジェクト構造体 (buffer object 
拡張型でシーケンス型プロトコルを実装するために使われる関数群へのポインタを保持するために使われる構造体です。 
以下のメソッドを定義して、コンテナオブジェクトを実装することができます。 
コンテナは通常、(リストやタプルのような) シーケンスや、(辞書のような)マップ型を指しますが、他のコンテナも同じように表現することができます。 
最初の一連のメソッドは、シーケンスをエミュレートしたり、マップ型をエミュレートするために使われます; その違いとして、シーケンスの場合には、キーとして許されているのが、シーケンスの長さが N であるときの0 = k N 
なる整数 k か、あるいは要素の範囲を表すスライスオブジェクトでなければならないということです。 
(後方互換性のため、__getslice__() (以下参照) を定義して、拡張されていない単純なスライスを扱うようにもできます。 
)変更可能なシーケンスでは、Python の標準リストオブジェクトのように、メソッド append()、 count()、index()、extend()、insert()、 pop()、remove()、reverse()、およびsort() を提供しなければなりません。 マップ型でも、Python の標準辞書オブジェクトのように、keys()、 values()、items()、 has_key()、 get()、 clear()、setdefault()、iterkeys()、 itervalues()、iteritems()、 pop()、 popitem()、copy()、 および update() といったメソッドをマップ型で提供するよう推奨しています。 
UserDict モジュールでは、これらのメソッドを__getitem__()、 __setitem__()、__delitem__()、および keys() といった基本セットから作成する上で役に立つ DictMixin クラスを提供しています。 
最後に、シーケンス型では以下に述べるメソッド群 __add__()、__radd__()、 __iadd__()、__mul__()、__rmul__()、および __imul__() を定義して、(シーケンス間の結合を意味する) 加算操作と (要素の繰り返しを意味する) 乗算操作を実装しなければなりません; __coerce__() や、その他の数値演算子を定義してはなりません。 
マップでもシーケンスでも、in 演算子が有効利用できるように__contains__() メソッドの定義を推奨します; マップ型では、in はhas_key() と等価でなければなりません; シーケンスでは、シーケンス内の値にわたって検索を行わなければなりません。 
さらに、マップでもシーケンスでも、コンテナ内にわたる反復操作ができるようにするため、__iter__() を実装するよう勧めます; マップ型の場合、__iter__() は iterkeys() と等価でなければなりません;シーケンスの場合、シーケンス内の値にわたって反復操作を行わなければなりません。 
オブジェクトの長さを = 0 である整数で返さなければなりません。 
また、オブジェクトが __nonzero__() メソッドを定義しておらず、__len__() メソッドがゼロを返す場合には、ブール演算コンテキストでは偽であるとみなされます。 
self[key] の値評価 (evaluation) を実現するために呼び出されます。 
シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 
(シーケンス型をエミュレートする場合) 負のインデクスの解釈は __getitem__() メソッド次第となります。 key が不適切な型であった場合、TypeErrorを送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) key がシーケンスのインデクス集合外の値である場合、IndexError を送出しなければなりません。 
for ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して IndexError が送出されるものと期待しています。 
self[key] に対する代入を実現するために呼び出されます。 
__getitem__() と同じ注意事項があてはまります。 
このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。 
不正な key に対しては、__getitem__()メソッドと同様の例外の送出を行わなければなりません。 
self[key] の削除を実現するために呼び出されます。 
このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。 
不正な key に対しては、__getitem__()メソッドと同様の例外の送出を行わなければなりません。 
このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。 このメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができるような、新たなイテレータオブジェクトを返さなければなりません。 
マップの場合、コンテナ内のキーに渡る反復処理でなければならず、かつiterkeys() によって利用できなければなりません。 イテレータオブジェクトでもこのメソッドを実装する必要があります;イテレータの場合、自分自身を返さなければなりません。 
イテレータオブジェクトに関するより詳細な情報は、 
の ``イテレータ型'' を参照してください。 
メンバシップテスト演算子 (in および not in) は通常、シーケンスに渡る反復処理を使って実装されます。 
しかし、コンテナオブジェクトで以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがシーケンスでなくてもよいようにできます。 
メンバシップテスト演算を実現するために呼び出されます。 
item が self 内に存在する場合には真を、そうでない場合には偽を返さなければなりません。 
マップオブジェクトの場合、値やキーと値の組ではなく、キーに対するメンバシップテストを考えなければなりません。 
オブジェクトがシーケンス型プロトコルを提供している場合に 1 を返し、そうでないときには 0 を返します。 
成功するとシーケンス o 中のオブジェクトの数を返し、失敗すると -1 を返します。 
シーケンス型プロトコルをサポートしないオブジェクトに対しては、Python の式 "len(o)" と同じになります。 
PySequence_Size() の別名です。 
成功するとオブジェクトo の count 回繰り返しを返し、失敗すると NULL を返します。 
Python の式 " 
成功するとo1 と o2 の連結 (concatenation) を返し、失敗すると NULL を返します。 
o1 が in-place 演算をサポートする場合、in-place 演算を行います。 
成功すると o の i 番目の要素を返し、失敗すると NULL を返します。 Python の式 " 
o[i]" と同じです。 
成功するとo の i1 から i2 までの間のスライスを返し、失敗すると NULL を返します。 
o[i1:i2]" と同じです。 
o の i 番目の要素に v を代入します。 
o の i 番目の要素を削除します。 
失敗すると -1 を返します。 
Python の文 "del o[i]" と同じです。 
o の i1 から i2 までの間のスライスに vを代入します。 
Python の文 " 
シーケンスオブジェクト o の i1 から i2 までの間のスライスを削除します。 
Python の文 "del o[i1:i2]" と同じです。 
o における value の出現回数、すなわち o[key] == value 
となる key の個数を返します。 
Python の式 " 
o.count(value)" と同じです。 
o にvalue が入っているか判定します。 
o のある要素が value と等価 (equal) ならば1 を返し、それ以外の場合には 0 を返します。 エラーが発生すると -1 を返します。 
Python の式 " 
エラーが発生すると -1 を返します。 
o.index(value)" と同じです。 
任意のシーケンス o と同じ内容を持つリストオブジェクトを返します。 
返されるリストは必ず新しいリストオブジェクトになります。 
任意のシーケンス o と同じ内容を持つタプルオブジェクトを返します。 
o がタプルの場合、新たな参照を返します。 
それ以外の場合、適切な内容が入ったタプルを構築して返します。 PyObject* 
シーケンス o がすでにタプルやリストであれば o を返し、そうでなければ o をタプルで返します。 
返されるタプルのメンバにアクセスするにはPySequence_Fast_GET_ITEM() を使ってください。 
オブジェクトがシーケンスでなければ、m がメッセージテキストになっているTypeError を送出します。 
PyObject ポインタの背後にあるアレイを返します．この関数では，o はPySequence_Fast() の返したオブジェクトであり，NULLでないものと仮定しています．バージョン 2.4 で 新たに追加 された仕様です。 
o がNULLでなく、PySequence_Fast() が返したオブジェクトであると仮定して、o の長さを返します。 
o のサイズはPySequence_Size() を呼び出しても得られますが、PySequence_Fast_GET_SIZE() の方がo をリストかタプルであると仮定して処理するため、より高速です。 
7.2.5.2 Python オブジェクトとしての複素数型 
シーケンスオブジェクトに対する一般的な操作については前の章ですでに述べました; この節では、Python 言語にもともと備わっている特定のシーケンスオブジェクトについて扱います。 
この例は2つの文字列を比較します。 
空白を``junk''とします。 
ratio() は、[0, 1] の範囲の値を返し、シーケンスの同一性を測ります。 
経験によると、ratio() の値が0.6を超えると、シーケンスがよく似ていることを示します。 
シーケンスのどこがマッチしているかにだけ興味のある時には get_matching_blocks() が手軽でしょう。 
注意:最後のタプルは、get_matching_blocks()が常にダミーであることで返されるものです。 (len(a), len(b), 0) であり、これは最後のタプルの要素（マッチするようその数）がゼロとなる唯一のケースです。 
はじめのシーケンスがどのようにして2番目のものになるのかを知るには、get_opcodes() を使います。 for opcode in s.get_opcodes():... print "%6s a[%d:%d] b[%d:%d]" % opcodeequal a[0:8] b[0:8]insert a[8:8] b[8:17]equal a[8:14] b[17:23]equal a[14:29] b[23:38] 
See also the function get_close_matches() in this module,which shows how simple code building on SequenceMatcher can beused to do useful work.SequenceMatcher を使った、シンプルで使えるコードを知るには、このモジュールの関数 get_close_matches() を参照してください。 
ServerProxyインスタンスの各メソッドはそれぞれXML-RPCサーバの遠隔手続き呼び出しに対応しており、メソッドが呼び出されると名前と引数をシグネチャとしてRPCを実行します(同じ名前のメソッドでも、異なる引数シグネチャによってオーバロードされます)。 
RPC実行後、変換された値を返すか、またはFaultオブジェクトもしくはProtocolErrorオブジェクトでエラーを通知します。 予約メンバsystemから、XMLイントロスペクションAPIの一般的なメソッドを利用する事ができます。 
XML-RPCサーバがサポートするメソッド名(system以外)を格納する文字列のリストを返します。 
XML-RPCサーバで実装されているメソッドの名前を指定し、利用可能なシグネチャの配列を取得します。 
シグネチャは型のリストで、先頭の型は戻り値の型を示し、以降はパラメータの型を示します。 
XML-RPCでは複数のシグネチャ(オーバロード)を使用することができるので、単独のシグネチャではなく、シグネチャのリストを返します。 シグネチャは、メソッドが使用する最上位のパラメータにのみ適用されます。 
例えばあるメソッドのパラメータが構造体の配列で戻り値が文字列の場合、シグネチャは単に"文字列, 配列" となります。 
パラメータが三つの整数で戻り値が文字列の場合は"文字列, 整数, 整数, 整数"となります。 メソッドにシグネチャが定義されていない場合、配列以外の値が返ります。 
Pythonでは、この値はlist以外の値となります。 
XML-RPCサーバで実装されているメソッドの名前を指定し、そのメソッドを解説する文書文字列を取得します。 
文書文字列を取得できない場合は空文字列を返します。 
文書文字列にはHTMLマークアップが含まれます 
イントロスペクション用のメソッドは、PHP・C・Microsoft .NETのサーバなどでサポートされています。 
UserLand Frontierの最近のバージョンでもイントロスペクションを部分的にサポートしています。 
Perl, Python, JavaでのイントロスペクションサポートについてはXML-RPC Hacksを参照してください。 
SetとImmutableSetのインスタンスはともに、以下の操作を備えています: 
等価な演算 
集合sの濃度 (cardinality) 
xがsに帰属していれば真を返す 
xがsに帰属していなければ真を返す 
sのすべての要素がtに帰属していれば真を返す 
tのすべての要素がsに帰属していれば真を返す 
sとtの両方の要素からなる新しい集合 
sとtで共通する要素からなる新しい集合 
sにあるがtにない要素からなる新しい集合 
sとtのどちらか一方に属する要素からなる集合 
sの浅いコピーからなる集合 
演算子を使わない書き方である union()、 intersection()、difference()、およびsymmetric_difference() は任意のイテレート可能オブジェクトを引数として受け取るのに対し、演算子を使った書き方の方では引数は集合型でなければならないので注意してください。 これはエラーの元となるSet('abc') 'cbs' のような書き方を排除し、より可読性のあるSet('abc').intersection('cbs')を選ばせるための仕様です。 
バージョン 2.3.1 で 変更 された仕様:以前は全ての引数が集合型でなければなりませんでした。 
加えて、SetとImmutableSet は集合間の比較をサポートしています。 
たとえば、互いに素な 2 つの集合は等しくありませんし、互いの部分集合でもないので、 
s のハッシュ値を返す 
以下はSetで利用可能であるがImmutableSetにはない操作です: 
tを加えた要素からなる集合sを返します 
tでも見つかった要素だけを持つ集合sを返します 
tにあった要素を取り除いた後の集合sを返します 
sとtのどちらか一方に属する要素からなる集合sを返します 
要素xを集合sに加えます 
要素xを集合sから取り除きます; x がなければ KeyError を送出します 
要素xが存在すれば、集合sから取り除きます 
sから要素を取り除き、それを返します;集合が空なら KeyError を送出します 
集合sからすべての要素を取り除きます 
演算子を使わない書き方である union_update()、 intersection_update()、difference_update()、およびsymmetric_difference_update() は任意のイテレート可能オブジェクトを引数として受け取るので注意してください。 バージョン 2.3.1 で 変更 された仕様:以前は全ての引数が集合型でなければなりませんでした。 
時に、配布物をビルドする際に必要な全ての設定をあらかじめ 書ききれない状況が起きます: 例えば、ビルドを進めるために、ユーザに関する情報や、ユーザのシステムに関する情報を必要とするかもしれません。 
こうした情報が単純 -- C ヘッダファイルやライブラリを検索するディレクトリのリストのように -- であるかぎり、ユーザに設定ファイル (configuration file) setup.cfg を提供して編集してもらうのが、安上がりで簡単な特定方法になります。 
設定ファイルはまた、あらゆるコマンドにおけるオプションにデフォルト値を与えておき、インストール作業者がコマンドライン上や設定ファイルの編集でデフォルト設定を上書きできるようにします。 
setup 設定ファイルは setup スクリプト --理想的にはインストール作業者から見えないもの 1 
--と、作者の手を離れて、全てインストール作業者次第となる setup スクリプトのコマンドライン引数との間を橋渡しする中間層として有効です。 
実際、setup.cfg (と、ターゲットシステム上にある、その他のDistutils 設定ファイル) は、 setup スクリプトの内容より後で、かつコマンドラインで上書きする前に処理されます。 
この仕様の結果、いくつかの利点が生まれます: 
インストール作業者は、作者が setup.py に設定した項目のいくつかを setup.cfg を変更して上書きできます。 
setu.py では簡単に設定できないような、標準でないオプションのデフォルト値を設定できます。 
インストール作業者は、setup.cfg に書かれたどんな設定もsetup.py のコマンドラインオプションで上書きできます。 
設定ファイルの基本的な構文は簡単なものです: 
ここで、 command は Distutils コマンドのうちの一つ(例えば build_py, install) で、option はそのコマンドでサポートされているオプションのうちの一つです。 
各コマンドには任意の数のオプションを設定でき、一つの設定ファイル中には任意の数のコマンドセクションを収められます。 
空白行は無視されます、 "#" 文字で開始して行末まで続くコメントも同様に無視されます。 
長いオプション設定値は、継続行をインデントするだけで複数行にわたって記述できます。 あるコマンドがサポートしているオプションのリストは、--help オプションで調べられます。 
例えば以下のように。 python setup.py --help build_ext[...]Options for 'build_ext' command:--build-lib (-b) directory for compiled extension modules--build-temp (-t) directory for temporary files (build by-products)--inplace (-i) ignore build-lib and put compiled extensions into thesource directory alongside your pure Python modules--include-dirs (-I) list of directories to search for header files--define (-D) C preprocessor macros to define--undef (-U) C preprocessor macros to undefine[...] 
コマンドライン上で --foo-bar と綴るオプションは、設定ファイル上では foo_bar と綴るので注意してください。 例えば、拡張モジュールを ``インプレース (in-place)'' でビルドしたいとします -- すなわち、pkg.ext という拡張モジュールを持っていて、コンパイル済みの拡張モジュールファイル (例えば Unixでは ext.so) を pure Python モジュール pkg.mod1および pkg.mod2 と同じソースディレクトリに置きたいとします。 
こんなときには、--inplace を使えば、確実にビルドを行えます。 
しかし、この操作では、常に build_ext を明示的に指定しなければならず、 --inplace オプションを忘れずに与えなければなりません。 こうした設定を ``設定しっ放しにする'' 簡単な方法は、setup.cfg に書いておくやり方で、設定ファイルは以下のようになります: 
この設定は、明示的に build_ext を指定するかどうかに関わらず、モジュール配布物の全てのビルドに影響します。 
ソース配布物に setup.cfg を含めると、エンドユーザの手で行われるビルドにも影響します -- このオプションの例に関してはsetup.cfg を含めるのはおそらくよくないアイデアでしょう。 というのは、拡張モジュールをインプレースでビルドすると常にインストールしたモジュール配布物を壊してしまうからです。 
とはいえ、ある特定の状況では、モジュールをインストールディレクトリの下に正しく構築できるので、機能としては有用だと考えられます。 
(ただ、インストールディレクトリ上でのビルドを想定するような拡張モジュールの配布は、ほとんどの場合よくない考え方です。 )もう一つ、例があります: コマンドによっては、実行時にほとんど変更されないたくさんのオプションがあります; 例えば、bdist_rpm には、RPM 配布物を作成する際に、``spec'' ファイルを作成するために必要な情報を全て与えなければなりません。 
この情報には setup スクリプトから与えるものもあり、(インストールされるファイルのリストのように) Distutils が自動的に生成するものもあります。 
しかし、こうした情報の中にはbdist_rpm のオプションとして与えるものがあり、毎回実行するごとにコマンドライン上で指定するのが面倒です。 
そこで、以下のような内容が Distutils 自体の setup.cfgには入っています: 
doc_files オプションは、単に空白で区切られた文字列で、ここでは可読性のために複数行をまたぐようにしています。 
設定ファイルに関する詳細情報は、システム管理者向けのこのマニュアルにあります。 
...から見えないもの 
Distutils が自動設定機能(auto-configuration) をサポートするまで、おそらくこの理想状態を達成することはないでしょう 
setup スクリプトは、Distutils を使ってモジュールをビルドし、配布し、インストールする際の全ての動作の中心になります。 
setup スクリプトの主な目的は、モジュール配布物について Distutils に伝え、モジュール配布を操作するための様々なコマンドを正しく動作させることにあります。 
(Distutils が入っているのは Python 1.6 以降であり、 Python 1.5.2 ユーザが他のモジュール配布物をインストールできるようにするための独立したパッケージがあることを思い出してください。 
ここで示した、Distutils 自身の setup スクリプトは、Python 1.5.2 にDistutils パッケージをインストールする際に使います。 
上の例と、2 で示したファイル一つからなる小さな配布物とは、違うところは二つしかありません: メタデータの追加と、モジュールではなくパッケージとして pure Python モジュール群を指定しているという点です。 
setup スクリプトに与えるパス名 (ファイルまたはディレクトリ)は、 Unix におけるファイル名規約、つまりスラッシュ ('/') 区切りで書かねばなりません。 
Distutils はこのプラットフォーム中立の表記を、実際にパス名として使う前に、現在のプラットフォームに適した表記に注意深く変換します。 
この機能のおかげで、setup スクリプトを異なるオペレーティングシステム間にわたって可搬性があるものにできます。 言うまでもなく、これは Distutils の大きな目標の一つです。 
この精神に従って、このドキュメントでは全てのパス名をスラッシュ区切りにしています。 
(Mac OS プログラマは、先頭にスラッシュが ない場合は、 相対パス を表すということを心に留めておかねばなりません。 
この規約は、コロンを使った Mac OS での規約と逆だからです。 
)もちろん、この取り決めは Distutils に渡すパス名だけに適用されます。 もし、例えば glob.glob() や os.listdir() のような、標準の Python 関数を使ってファイル群を指定するのなら、パス区切り文字 (path separator) をハードコーディングせず、以下のように可搬性のあるコードを書くよう注意すべきです: 
20. SGI IRIX 特有のサービス 
この章で記述されているモジュールは、SGI の IRIX オペレーティングシステム (バージョン4と5) 特有の機能へのインターフェイスを提供します。 
SGIのオーディオ機能。 
alモジュールで使われる定数。 
Silicon GraphicsシステムのCD-ROMへのインターフェース 
グラフィカルユーザーインターフェースのためのFORMSライブラリ。 
flモジュールで使用される定数。 
保存されたFORMSデザインをロードする関数。 
SGIワークステーションの Font Manager インターフェース。 
Silicon Graphics のGraphics Library の関数。 
glモジュールで使われる定数。 
SGI imglib ファイルのサポート。 
JPEGファイルの読み書きを行います。 
5.6 二項算術演算 (binary arithmetic 
シフト演算は、算術演算よりも低い優先順位を持っています: 
シフトの演算子は整数または長整数を引数にとります。 
引数は共通の型に変換されます。 
シフト演算では、最初の引数を二つ目の引数に応じたビット数だけ、左または右にビットシフトします。 n ビットの右シフトは、pow(2,n) による除算として定義されています。 
n ビットの左シフトは、pow(2,n) による乗算として定義されています; 整数の場合、桁あふれ (overflow) のチェックはされないので、演算によって末端のビットは捨てられます。 また、結果の絶対値がpow(2, 31) よりも小さくない場合には、符号の反転が起こります。 
負のビット数でシフトを行うと、 ValueError 例外を送出します。 
5.20.1 モジュールの内容 
shlex インスタンスは以下のメソッドを持っています: 
トークンを一つ返します。 
トークンが push_token() で使ってスタックに積まれていた場合、トークンをスタックからポップします。 
そうでない場合、トークンを一つ入力ストリームから読み出します。 
読み出し即時にファイル終了子に遭遇した場合、self.eof (非 POSIX モードでは空文字列 ('')、POSIX モードでは None) が返されます。 
完全性のためにここで記述されています)。 
shlex がソースリクエスト (下の source を参照してください) を検出した際、このメソッドはその後に続くトークンを引数として渡され、ファイル名と開かれたファイル類似オブジェクトからなるタプルを返すとされています。 
通常、このメソッドはまず引数から何らかのクオートを剥ぎ取ります。 処理後の引数が絶対パス名であった場合か、以前に有効になったソースリクエストが存在しない場合か、以前のソースが (sys.stdin のような)ストリームであった場合、この結果はそのままにされます。 
そうでない場合で、処理後の引数が相対パス名の場合、ソースインクルードスタックにある直前のファイル名からディレクトリ部分が取り出され、相対パスの前の部分に追加されます (この動作は C 言語プリプロセッサにおける#include "file.h" の扱いと同様です) 。 これらの操作の結果はファイル名として扱われ、タプルの最初の要素として返されます。 
同時にこのファイル名で open() を呼び出した結果が二つ目の要素になります (注意: インスタンス初期化のときとは引数の並びが逆になっています！)このフックはディレクトリサーチパスや、ファイル拡張子の追加、その他の名前空間に関するハックを実装できるようにするために公開されています。 `close' フックに対応するものはありませんが、shlex インスタンスはソースリクエストされている入力ストリームが EOF を返した時にはclose() を呼び出します。 
ソーススタックをより明示的に操作するには、push_source() および pop_source() メソッドを使ってください。 push_source 
入力ソースストリームを入力スタックにプッシュします。 
ファイル名引数が指定された場合、以後のエラーメッセージ中で利用することができます。 
sourcehook メソッドが内部で使用しているのと同じメソッドです。 
バージョン 2.1 で 新たに追加 された仕様です。 pop_source 
このメソッドはエラーメッセージの論述部分を Unix C コンパイラエラーラベルの形式で生成します; この書式は'"%s", line %d: ' で、"%s" は現在のソースファイル名で置き換えられ、"%d" は現在の入力行番号で置き換えられます(オプションの引数を使ってこれらを上書きすることもできます)。 このやり方は、shlex のユーザに対して、Emacs やその他のUnix ツール群が解釈できる一般的な書式でのメッセージを生成することを推奨するために提供されています。 
shlex サブクラスのインスタンスは、字句解析を制御したり、デバッグに使えるような public なインスタンス変数を持っています: 
複数文字からなるトークンを構成するためにバッファに蓄積していくような文字からなる文字列です。 
標準では、全ての ASCII 英数字およびアンダースコアが入っています。 
空白と見なされ、読み飛ばされる文字群です。 
空白はトークンの境界を作ります。 
標準では、スペース、タブ、改行 (linefeed) および復帰 (carriage-return) が入っています。 
エスケープ文字と見なされる文字群です。 
これは POSIX モードでのみ使われ、デフォルトでは "" だけが入っています。 バージョン 2.3 で 新たに追加 された仕様です。 
文字列引用符と見なされる文字群です。 
トークンを構成する際、同じクオートが再び出現するまで文字をバッファに蓄積します(すなわち、異なるクオート形式はシェル中で互いに保護し合う関係にあります)。 
標準では、ASCII 単引用符および二重引用符が入っています。 
quotes のうち、escape で定義されたエスケープ文字を解釈する文字群です。 
これは POSIX モードでのみ使われ、デフォルトでは """ だけが入っています。 
バージョン 2.3 で 新たに追加 された仕様です。 
whitespace_split この値が True であれば、トークンは空白文字でのみで分割されます。 
たとえば shlex がシェル引数と同じ方法で、コマンドラインを解析するのに便利です。 バージョン 2.3 で 新たに追加 された仕様です。 
現在の入力ファイル名です。 クラスのインスタンス化時に初期設定されるか、その後のソースリクエストでスタックされます。 
エラーメッセージを構成する際にこの値を調べると便利なことがあります。 
shlex インスタンスが文字を読み出している入力ストリームです。 
このメンバ変数は標準で None を取ります。 
この値に文字列を代入すると、その文字列は多くのシェルにおける "source" キーワードに似た、字句解析レベルでのインクルード要求として認識されます。 
すなわち、その直後に現れるトークンをファイル名として新たなストリームを開き、そのストリームを入力として、EOF に到達するまで読み込まれます。 新たなストリームの EOF に到達した時点で close() が呼び出され、入力は元の入力ストリームに戻されます。 
ソースリクエストは任意のレベルの深さまでスタックしてかまいません。 
このメンバ変数が数値で、かつ1 またはそれ以上の値の場合、shlex インスタンスは動作に関する冗長な進捗報告を出力します。 
この出力を使いたいなら、モジュールのソースコードを読めば詳細を学ぶことができます。 
ソース行番号 (遭遇した改行の数に 1 を加えたもの) です。 
トークンバッファです。 
例外を捕捉した際にこの値を調べると便利なことがあります。 
ファイルの終端を決定するのに使われるトークンです。 
非 POSIX モードでは空文字列 ('') 、POSIX モードでは None が入ります。 
非 POSIX モードで動作中の shlex は以下の規則に従おうとします。 
ワード内の引用符を認識しない (Do"Not"Separate は単一ワード Do"Not"Separate として解析されます) 
エスケープ文字を認識しない 
引用符で囲まれた文字列は、引用符内の全ての文字リテラルを保持する 
閉じ引用符でワードを区切る ("Do"Separate は、"Do" とSeparate であると解析されます) 
whitespace_split が False の場合、wordchar、whitespace または quote として宣言されていない全ての文字を、単一の文字トークンとして返す。 
True の場合、shlex は空白文字でのみ単語を区切る。 
空文字列 ('') で EOF を送出する 
引用符に囲んであっても、空文字列を解析しない 
POSIX モードで動作中の shlex は以下の解析規則に従おうとします。 
引用符を取り除き、引用符で単語を分解しない ("Do"Not"Separate" は単一ワード DoNotSeparate として解析されます) 
escapedquotes でない引用符文字 ("'" など) で囲まれている全ての文字のリテラル値を保持する 
引用符に囲まれた escapedquotes に含まれる文字 (""" など) は、escape に含まれる文字を除き、全ての文字のリテラル値を保持する。 
エスケープ文字群は使用中の引用符、または、そのエスケープ文字自身が直後にある場合のみ、特殊な機能を保持する。 
他の場合にはエスケープ文字は普通の文字とみなされる。 
None で EOF を送出する 
引用符に囲まれた空文字列 ('') を許す 
6.5 インラインマークアップ 
6.4 コードの例示 Python ソースコードや対話セッションの例には verbatim 環境を使います。 
この環境は LaTeX の標準の環境です。 
TeX はタブをスペースに変換せずに捨てるので、コード例中でのインデントにはスペースだけを使ってください。 対話セッションの表現には、プロンプトや Python コードからの出力を含める必要があります。 
対話セッションには特殊なマークアップを行う必要はありません。 
最後の入力行または出力行を示した後に、``未使用の'' 一次プロンプトを置いてはなりません; 以下にやってはいけない 例を示します: 
verbatim 環境の中では、LaTeX の特殊文字を何らかの特殊な方法でマークする必要はありません。 
例題は全体が等幅フォントで表示されます; この環境は Python コードの表示でなくても、コードの表示でさえなくても使えなければならないため、``整形印刷'' は一切行おうとしません。 
verbatim で表示する際には、先頭や末尾に空行を入れてはなりません。 長いverbatim テキストを表示する場合には、平文テキストだけの入った例題のテキストを外部ファイルに入れて取り込めます。 
ファイルは標準マクロ verbatiminput で取り込めます;このマクロは単一の引数名として、例題テキストの入ったファイル名をとります。 
例えば、 example.py の入った Python ソースファイルを取り込むには、以下のようにします: 
verbatiminput を使うと、取り込むファイルに対して特殊な編集モードを使いやすくできます。 
ファイルはドキュメントの LaTeX ファイルと同じディレクトリに置かねばなりません。 Python Documentation Special Interest Group では、コード表示や対話セッションに対して整形印刷を行うための数々のアプローチについて議論してきました; この話題に関する詳細は、Python Web サイトの Doc-SIG エリアを参照してください。 
以下は前述のcopytree()関数のドキュメント文字列を省略した実装例です。 
本モジュールで提供される他の関数の使い方を示しています。 
2 簡単な例setup スクリプトは通常単純なものですが、Python で書かれているため、スクリプト中で何かを処理しようと考えたとき特に制限はありません。 
とはいえ、 setup スクリプト中に何かコストの大きな処理を行うときは十分注意してください。 
autoconf 形式の設定スクリプトとは違い、 setup スクリプトはモジュール配布物をビルドしてインストールする中で複数回実行されることがあります。 
foo.py という名前のファイルに収められている foo という名前のモジュールを配布したいだけなら、setup スクリプトは以下のような単純なものになります: 
以下のことに注意してください: 
Distutils に与えなければならない情報のほとんどは、 setup() 関数のキーワード引数として与えます。 
キーワード引数は二つのカテゴリ: パッケージのメタデータ (パッケージ名、バージョン番号) 、パッケージに何が収められているかの情報 (上の場合は pure Python モジュールのリスト)、に行き着きます。 
モジュールはファイル名ではなく、モジュール名で指定します(パッケージと拡張モジュールについても同じです) 
作者名、電子メールアドレス、プロジェクトの URL といった追加のメタデータを入れておくよう奨めます (4 の例を参照してください) 
このモジュールのソースコード配布物を作成するには、 上記のコードが入ったsetup スクリプト setup.py を作成して、以下のコマンド: 
アーカイブファイルの名前はfoo-1.0.targ.gz (または .zip) になり、展開するとディレクトリ foo-1.0 を作成します。 エンドユーザが foo モジュールをインストールしたければ、foo-1.0.tar.gz (または .zip) をダウンロードし、パッケージを展開して、以下のスクリプトを -- foo-1.0 ディレクトリ中で -- 実行します: 
この操作を行うと、インストールされている Python での適切なサードパーティ製モジュール置き場にfoo.py を完璧にコピーします．ここで述べた簡単な例では、 Distutils の基本的な概念のいくつかを示しています。 
まず、開発者とインストール作業者は同じ基本インタフェース、すなわち setup スクリプトを使っています。 
二人の作業の違いは、使っている Distutils コマンド (command)にあります: sdist コマンドは、ほぼ完全に開発者だけが対象となる一方、install はどちらかというとインストール作業者向けです (とはいえ、ほとんどの開発者は自分のコードをインストールしたくなることがあるでしょう)。 ユーザにとって本当に簡単なものにしたいのなら、一つまたはそれ以上のビルド済み配布物を作ってあげられます。 
例えば、Windows マシン上で作業をしていて、他の Windows ユーザにとって簡単な配布物を提供したいのなら、実行可能な形式の (このプラットフォーム向けのビルド済み配布物としてはもっとも適切な) インストーラを作成できます。 これにはbdist_wininst を使います。 
とすると、実行可能なインストーラ形式、foo-1.0.win32.exe が現在のディレクトリに作成されます。 その他の有用な配布形態としては、bdist_rpm に実装されている RPM 形式、 Solaris pkgtool(bdist_pkgtool) 、 HP-UX swinstall(bdist_sdux) があります。 
例えば、以下のコマンドを実行すると、foo-1.0.noarch.rpm という名前の RPM ファイルを作成します: 
(bdist_rpm コマンドは rpm コマンドを使うため、Red Hat Linux や SuSE Linux、 Mandrake Linux といった RPM ベースのシステムで実行しなければなりません)どの配布形式が利用できるかは、 
python setup.py bdist --help-formats を実行すれば分かります。 
SimpleXMLRPCServer クラスは SocketServer.TCPServer のサブクラスで、基本的なスタンドアロンの XML-RPC サーバーを作成する手段を提供します。 
XML-RPCリクエストに応じる関数を登録します。 
引数nameが与えられている場合はその値が、関数functionに関連付けられます。 
オブジェクトを登録し、そのオブジェクトのregister_function()で登録されていないメソッドを公開します。 
もし、instanceがメソッド_dispatch()を定義していれば、_dispatch()が、リクエストされたメソッド名とパラメータの組を引数として呼び出されます。 そして、_dispatch()の返り値が結果としてクライアントに返されます。 
そのAPIは def _dispatch(self, method, params)(注意: paramsは可変引数リストではありません)です。 
仕事をするために下位の関数を呼ぶ時には、その関数はfunc(*params)のように呼ばれます。 _dispatch()の返り値はクライアントへ結果として返されます。 
もし、instanceがメソッド_dispatch()を定義していなければ、リクエストされたメソッド名がそのインスタンスに定義されているメソッド名から探されます。 リクエストされたメソッド名がピリオドを含む場合は、（訳注：通常のPythonでのピリオドの解釈と同様に）階層的にオブジェクトを探索します。 
XML-RPC のイントロスペクション関数、system.listMethods、system.methodHelp、system.methodSignature を登録します。 
XML-RPC における複数の要求を処理する関数 system.multicall を登録します。 
以下に例を示します。 
6. 単純文 (simple statement) 
単純文とは、単一の論理行内に収められる文です。 
単一の行内には、複数の単純文をセミコロンで区切って入れることができます。 
単純文の構文は以下の通りです: 
6.1 式文 (expression statement) 
"spam" (Monty Python ファンの好物ですね) という名の拡張モジュールを作成することにして、C ライブラリ関数 system() に対するPython インタフェースを作成したいとします。 
この関数は null で終端されたキャラクタ文字列を引数にとり、整数を返します。 
この関数を以下のようにして Python から呼び出せるようにしたいとします: 
これで、Python API を取り込みます (必要なら、モジュールの用途に関する説明や、著作権表示を追加します)。 
Python は、システムによっては標準ヘッダの定義に影響するようなプリプロセッサ定義を行っているので、 Python.h はいずれの標準ヘッダよりも前にインクルードせねばなりません。 
Python.h で定義されているユーザから可視のシンボルは、全て接頭辞"Py" または "PY" が付いています。 ただし、標準ヘッダファイル内の定義は除きます。 
ここでは、Python の引数リスト (例えば、単一の式 "ls -l") から C 関数に渡す引数にそのまま変換しています。 
C 関数は常に二つの引数を持ち、便宜的に self および argsと呼ばれます。 self 引数は C 関数が Python の関数ではなく組み込みメソッドを実装している場合にのみ使われます。 
この例ではメソッドではなく関数を定義しているので、 self は常に NULL ポインタになります。 
タプル内の各要素は、呼び出しの際の引数リストにおける各引数に対応します。 
引数は Python オブジェクトです -- C 関数で引数を使って何かを行うには、オブジェクトから C の値に変換せねばなりません。 
Python API の関数 PyArg_ParseTuple()は引数の型をチェックし、C の値に変換します。 
PyArg_ParseTuple() はテンプレート文字列を使って、引数オブジェクトの型と、変換された値を入れる C 変数の型を判別します。 
これについては後で詳しく説明します。 
PyArg_ParseTuple() は、全ての引数が正しい型を持っていて、アドレス渡しされた各変数に各引数要素を保存したときに真 (非ゼロ) を返します。 
この関数は不正な引数リストを渡すと偽 (ゼロ) を返します。 
後者の場合、関数は適切な例外を送出するので、呼び出し側は(例にもあるように) すぐにNULL を返すようにしてください。 
... インタフェースを作成したいとします。 
この関数へのインタフェースはすでに標準モジュール osにあります -- この関数を選んだのは、単純で直接的な例を示したいからです。 
拡張モジュールは、ext_modules オプションを使って指定します。 package_dir は、拡張モジュールのソースファイルをどこで探すかには影響しません; pure Python モジュールのソースのみに影響します。 
もっとも単純なケースでは、単一の C ソースファイルで書かれた単一の拡張モジュールは: 
root/setup.pyfoo.c になります。 
foo 拡張をルートパッケージ下に所属させたい場合、 setup スクリプトは 
from distutils.core import setupsetup(name='foobar',version='1.0',ext_modules=[Extension('foo', ['foo.c'])],) になります。 
同じソースツリーレイアウトで、この拡張モジュールを foopkgの下に置き、拡張モジュールの名前を変えるには: 
from distutils.core import setupsetup(name='foobar',version = '1.0',ext_modules=[Extension('foopkg.foo', ['foo.c'])],) のようにします。 
スライスオブジェクトの型オブジェクトです。 
types.SliceType と同じです。 
ob がスライスオブジェクトの場合に真を返します;ob は NULL であってはなりません。 
指定した値から新たなスライスオブジェクトを返します。 
パラメタstart, stop, および step はスライスオブジェクトにおける同名の属性として用いられます。 
これらの値はいずれもNULL にでき、対応する値には None が使われます。 
新たなオブジェクトをアロケーションできない場合には NULL を返します。 
スライスオブジェクト slice における start, stop, および step のインデクス値を取得します。 このときシーケンスの長さを length と仮定します。 
バージョン 2.3 以前のPython でスライスオブジェクトを使いたいのなら、PySlice_GetIndicesEx のソースを適切に名前変更して自分の拡張モジュールのソースコード内に組み込むとよいでしょう。 
PySlice_GetIndices の置き換えとして使える関数です。 
境界をはみだしたインデクスは、通常のスライスを扱うのと同じ一貫したやり方でクリップされます。 成功のときには 0 を、エラーのときには例外をセットして-1 を返します。 
スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。 
スライス表記は式として用いたり、代入や del 文の対象として用いたりできます。 
スライス表記の構文は以下のようになります: 
上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。 
この場合には、(スライスリストの評価結果が、適切なスライスや省略表記(ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記としての解釈の方が高い優先順位を持つように定義することで、構文法をより難解にすることなくあいまいさを取り除いています。 
同様に、スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが続いていない場合、拡張スライスとしての解釈より、単純なスライスとしての解釈が優先されます。 
単純なスライスに対する意味付けは以下のようになります。 
一次語の値評価結果は、シーケンス型のオブジェクトでなければなりません。 
下境界および上境界を表す式がある場合、それらの値評価結果は整数でなくてはなりません; デフォルトの値は、それぞれゼロとsys.maxint です。 
どちらかの境界値が負である場合、シーケンスの長さが加算されます。 
こうして、スライスはi および j をそれぞれ指定した下境界、上境界として、インデクス k が 
となる全ての要素を選択します。 
選択の結果、空のシーケンスになることもあります。 
また、辞書は以下に述べるようにしてスライスリストから生成されたキーによってインデクス指定できなければなりません。 
スライスリストに少なくとも一つのカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります;それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。 
一個の式でできたスライス要素の変換は、その式になります。 
省略表記スライス要素の変換は、組み込みの Ellipsis オブジェクトになります。 
適切なスライスの変換は、スライスオブジェクト(3.2 参照) で、start, stop およびstep 属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。 式がない場合には、None に置き換えられます。 
デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための辞書を持っています。 
この仕様は、ほとんどインスタンス変数を持たないようなオブジェクトの場合には記憶領域の無駄遣いになります。 
記憶領域の消費量は、大量のインスタンスを生成する際には深刻です。 このデフォルトの設定は、新たな形式のクラス定義において __slots__ を定義することでオーバライドできます。 
__slots_ 宣言はインスタンス変数のシーケンスを受け取ります。 各々のインスタンス上には、各変数の値を記憶するのにちょうど必要な量だけの記憶領域を確保します。 
各々のインスタンスに対して __dict__ が生成されることがないので、記憶領域が節約されます。 
このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが用いる変数名を表す文字列からなるシーケンスを代入することができます。 
この変数が新しい形式のクラスで定義されている場合、__slots__は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、__dict__ と__weakref__ が自動的に生成されないようにします。 バージョン 2.2 で 新たに追加 された仕様です。 
__slots__ を利用する際の注意 
__dict__ 変数がない場合、__slots__ に列挙されていない新たな変数をインスタンスに代入することはできません。 
列挙されていない変数名を使って代入しようとした場合、AttributeError が送出されます。 
新たな変数を動的に代入したいのなら、__slots__ を宣言する際に'__dict__' を変数名のシーケンスに追加してください。 
バージョン 2.3 で 変更 された仕様:これまでは、'__dict__' を __slots__宣言に追加しても、インスタンス変数名として他にリストされていない新たな属性の代入はできませんでした。 
__slots__ を定義しているクラスの各インスタンスに__weakref__ 変数がない場合、インスタンスに対する弱参照(weak reference) はサポートされません。 弱参照のサポートが必要なら、 __slots__ を宣言する際に'__weakref__' を変数名のシーケンスに追加してください。 
バージョン 2.3 で 変更 された仕様:これまでは、'__weakref__' を __slots__宣言に追加しても、弱参照のサポートを有効にできませんでした。 
__slots__ は、クラスのレベルで各変数に対するデスクリプタ (3.3.2 を参照) を使って実装されます。 
その結果、__slots__ に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。 
あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は(デスクリプタを基底クラスから直接取得しない限り) アクセスできなくなります。 
これにより、プログラムの趣意が不定になってしまいます。 
将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。 
__slots__ 宣言が動作するのは、定義が行われたクラスだけに限られています。 
その結果、サブクラスでは、__slots__ を定義しない限り __dict__ を持つことになります。 
__slots__ は、long、 str、およびtuple といった、``可変長 (variable-length)'' の組み込み型から導出されたクラスでは動作しません。 __slots__ には、文字列でない反復可能オブジェクトを代入することができます。 
辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。 
7.2.3 例 以下はTCP/IPプロトコルの簡単なサンプルとして、受信したデータをクライアントにそのまま返送するサーバ(接続可能なクライアントは一件のみ)と、サーバに接続するクライアントの例を示します。 
サーバでは、socket()・bind()・listen()・accept()を実行し(複数のクライアントからの接続を受け付ける場合、accept()を複数回呼び出します)、クライアントではsocket()とconnect()だけを呼び出しています。 
サーバではsend()/recv()メソッドはlisten中のソケットで実行するのではなく、accept()で取得したソケットに対して実行している点にも注意してください。 次のクライアントとサーバは、IPv4のみをサポートしています。 
The next two examples are identical to the above two, but support bothIPv4 and IPv6.The server side will listen to the first address family available(it should listen to both instead).On most of IPv6-ready systems, IPv6 will take precedenceand the server may not accept IPv4 traffic.The client side will try to connect to the all addresses returned as a resultof the name resolution, and sends traffic to the first one connectedsuccessfully.次のサンプルは上記のサンプルとほとんど同じですが、IPv4とIPv6の両方をサポートしています。 
ソケットオブジェクトは以下のメソッドを持ちます。 
makefile()以外のメソッドは、Unixのソケット用システムコールに対応しています。 
接続を受け付けます。 
ソケットはアドレスにbind済みで、listen中である必要があります。 戻り値は(conn, address)のペアで、connは接続を通じてデータの送受信を行うための新しいソケットオブジェクト、addressは接続先でソケットにbindしているアドレスを示します。 
ソケットをaddressにbindします。 
bind済みのソケットを再バインドする事はできません。 addressのフォーマットはアドレスファミリによって異なります(前述)。 
注意:本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前はAF_INETアドレスを示す二つの値を指定する事ができました。 
これは本来の仕様ではなく、Python 2.0以降では使用することはできません。 
addressで示されるリモートソケットに接続します。 
addressのフォーマットはアドレスファミリによって異なります(前述)。 注意:本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前はAF_INETアドレスを示す二つの値を指定する事ができました。 
connect(address)と同様ですが、C言語のconnect()関数の呼び出しでエラーが発生した場合には例外を送出せずにエラーを戻り値として返します。 (これ以外の、``host not found,''等のエラーの場合には例外が発生します。 
)処理が正常に終了した場合には0を返し、エラー時にはerrnoの値を返します。 
この関数は、非同期接続をサポートする場合などに使用することができます。 
注意:本来、このメソッドは単一のタプルのみを引数として受け付けますが、以前はAF_INETアドレスを示す二つの値を指定する事ができました。 これは本来の仕様ではなく、Python 2.0以降では使用することはできません。 
ソケットのファイルディスクリプタを整数型で返します。 
Unix にはこの制限はありません。 
ソケットが接続しているリモートアドレスを返します。 
この関数は、リモートIPv4/v6ソケットのポート番号を調べる場合などに使用します。 addressのフォーマットはアドレスファミリによって異なります(前述)。 
この関数をサポートしていないシステムも存在します。 
ソケット自身のアドレスを返します。 
この関数は、IPv4/v6ソケットのポート番号を調べる場合などに使用します。 addressのフォーマットはアドレスファミリによって異なります(前述)。 
ソケットに指定されたオプションを返します(Unixのマニュアルページ 
getsockopt(2)を参照)。 
SO_*等のシンボルは、このモジュールで定義しています。 
buflenを省略した場合、取得するオブションは整数とみなし、整数型の値を戻り値とします。 
buflenを指定した場合、長さbuflenのバッファでオプションを受け取り、このバッファを文字列として返します。 
このバッファは、呼び出し元プログラムで 
モジュール等を利用して内容を読み取ることができます。 
ソケットをListenし、接続を待ちます。 
引数backlogには接続キューの最大の長さ(1以上)を指定します。 backlogの最大数はシステムに依存します(通常は5)。 
ソケットに関連付けられたファイルオブジェクトを返します(ファイルオブジェクトについては2.3.9の``ファイルオブジェクト''を参照)。 
ファイルオブジェクトはソケットをdup()したファイルディスクリプタを使用しており、ソケットオブジェクトとファイルオブジェクトは別々にクローズしたりガベージコレクションで破棄したりする事ができます。 ソケットはブロッキングモードでなければなりません。 
オプション引数のmodeとbufsizeには、file()組み込み関数と同じ値を指定します。 2.1の``組み込み関数''を参照してください。 
ソケットからデータを受信し、文字列として返します。 
値の意味についてはUnixマニュアルページの 
recv(2)を参照してください。 
ソケットからデータを受信し、結果をタプル(string,address)として返します。 
stringは受信データの文字列で、addressは送信元のアドレスを示します。 
オプション引数flagsの意味は、上記recv()と同じです。 addressのフォーマットはアドレスファミリによって異なります(前述)。 
ソケットにデータを送信します。 
ソケットはリモートソケットに接続済みでなければなりません。 
オプション引数flagsの意味は、上記recv()と同じです。 
send()と異なり、このメソッドはstringの全データを送信するか、エラーが発生するまで処理を継続します。 
正常終了の場合はNoneを返し、エラー発生時には例外が発生します。 
エラー発生時、送信されたバイト数を調べる事はできません。 
このメソッドでは接続先をaddressで指定するので、接続済みではいけません。 
オプション引数flagsの意味は、上記recv()と同じです。 
戻り値として、送信したバイト数を返します。 addressのフォーマットはアドレスファミリによって異なります(前述)。 
ソケットのブロッキング・非ブロッキングモードを指定します。 flagが0の場合は非ブロッキングモード、0以外の場合はブロッキングモードとなります。 
全てのソケットは、初期状態ではブロッキングモードです。 
非ブロッキングモードでは、recv()メソッド呼び出し時に読み込みデータが無かったりsend()メソッド呼び出し時にデータを処理する事ができないような場合にerror例外が発生します。 しかし、ブロッキングモードでは呼び出しは処理が行われるまでブロックされます。 
s.setblocking(0)はs.settimeout(0)と、s.setblocking(1)はs.settimeout(None)とそれぞれ同じ意味を持ちます。 
ソケットのブロッキング処理のタイムアウト値を指定します。 
valueには、正の浮動小数点で秒数を指定するか、もしくはNoneを指定します。 浮動小数点値を指定した場合、操作が完了する前にvalueで指定した秒数が経過するとtimeoutが発生します。 
タイムアウト値にNoneを指定すると、ソケットのタイムアウトを無効にします。 
s.settimeout(0.0)はs.setblocking(0)と、s.settimeout(None)はs.setblocking(1)とそれぞれ同じ意味を持ちます。 バージョン 2.3 で 新たに追加 された仕様です。 
ソケットに指定されたタイムアウト値を取得します。 
タイムアウト値が設定されている場合には浮動小数点型で秒数が、設定されていなければNoneが返ります。 
この値は、最後に呼び出されたsetblocking()またはsettimeout()によって設定されます。 バージョン 2.3 で 新たに追加 された仕様です。 
ソケットのブロッキングとタイムアウトについて:ソケットオブジェクトのモードは、ブロッキング・非ブロッキング・タイムアウトの何れかとなります。 
初期状態では常にブロッキングモードです。 
ブロッキングモードでは、処理が完了するまでブロックされます。 
非ブロッキングモードでは、処理を行う事ができなければ(不幸にもシステムによって異なる値の)エラーとなります。 
タイムアウトモードでは、ソケットに指定したタイムアウトまでに完了しなければ処理は失敗となります。 
setblocking()メソッドは、settimeout()の省略形式です。 内部的には、タイムアウトモードではソケットを非ブロッキングモードに設定します。 
ブロッキングとタイムアウトの設定は、ソケットと同じネットワーク端点へ接続するファイルディスクリプタにも反映されます。 
ソケットのオプションを設定します(Unixのマニュアルページ 
setsockopt(2)を参照)。 
SO_*等のシンボルは、このモジュールで定義しています。 
valueには、整数または文字列をバッファとして指定する事ができます。 
文字列を指定する場合、文字列には適切なビットを設定するようにします。 ( 
モジュールを利用すれば、Cの構造体を文字列にエンコードする事ができます。 ) 
接続の片方向、または両方向を切断します。 
howがSHUT_RDの場合、以降は受信を行えません。 
howがSHUT_WRの場合、以降は送信を行えません。 
howがSHUT_RDWRの場合、以降は送受信を行えません。 
read()メソッドとwrite()メソッドは存在しませんので注意してください。 代わりにflagsを省略したrecv()とsend()を使うことができます。 
7. オプションのオペレーティングシステムサービス 
この章で説明するモジュールでは、特定のオペレーティングシステムでだけ利用できるオペレーティングシステム機能へのインターフェースを提供します。 
このインターフェースは、おおむね Unix や C のインターフェースにならってモデル化してありますが、他のシステム上（WindowsやNTなど）でも利用できることがあります。 
次に概要を示します。 
非同期イベントにハンドラを設定します。 
低レベルネットワークインターフェース。 
複数のストリームに対してI/O 処理の完了を待機します。 
1つのインタープリタの中でのマルチスレッド制御 
高水準のスレッドインタフェース 
の代替モジュール。 
同期キュークラス 
Unix とWindowsのメモリマップファイルへのインターフェース 
DBM 形式のデータベースモジュールに対する汎用インタフェース。 
BSD データベースライブラリへの DBM 形式のインタフェース。 
どのDBM形式のモジュールが与えられたデータベースを作ったかを推測する 
Berkeley DB ライブラリへのインタフェース 
単純な DBM インタフェースに対する可搬性のある実装。 
gzip 互換の圧縮／解凍ルーチンへの低レベルインタフェース 
ファイルオブジェクトを用いた gzip 圧縮および解凍のためのインタフェース 
bzip2 互換の圧縮／解凍ルーチンへのインタフェース 
ZIP-フォーマットのアーカイブファイルを読み書きする 
tar-形式のアーカイブファイルを読み書きします。 
Python のための GNU readline サポート。 
GNU readline ライブラリ向けのPython識別子補完 
3 setup 設定ファイル (setup 
6.1 プリアンブル用のマークアップ 
6 特殊マークアップ構文 Python ドキュメントのクラスでは、環境やマクロを新たに数多く定義しています。 
この節にはこれらの機能についてのリファレンスマニュアルがあります。 
Python ドキュメントでは ``標準の'' LaTeX 構文も使っていますが、ここには含めていません。 
6.1 プリアンブル用のマークアップ 
6.1 プリアンブル用のマークアップ ご意見やご指摘をお寄せになりたい方は、 
実装では、いくつかのオブジェクト型に対して、数個の読み出し専用の特殊な属性を追加しています。 
それぞれ: 
オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書または他のマップ型オブジェクトです。 
リリース 2.2 で撤廃されました。 オブジェクトの属性からなるリストを取得するには、組み込み関数 dir() を使ってください。 
この属性はもう利用できません。 
クラスインスタンスが属しているクラスです。 
クラスオブジェクトの基底クラスからなるタプルです。 
特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や添え字表記、スライス表記のような) 特定の演算をクラスで実装することができます。 
これは、個々のクラスが Python 言語で提供されている演算子に対応した独自の振る舞いをできるようにするための、演算子のオーバロード (operator overloading) に対する Python のアプローチです。 
例えば、あるクラスが __getitem__() という名前のメソッドを定義しており、x がこのクラスのインスタンスであるとすると、x[i] は x.__getitem__(i) と等価になります。 
特に注釈のない限り、適切なメソッドが定義されていない場合にこのような演算を行おうとすると例外が送出されます。 
組み込み型をエミュレーションするようなクラスを実装する際には、エミューレーションの実装をモデル化しようとしているオブジェクトで意味のある範囲だけにとどめることが重要です。 
例えば、シーケンスによっては個々の要素の取り出し操作が意味のある操作である一方、スライスの抽出が意味をなさないことがあります。 
(W3C ドキュメントオブジェクトモデルにおける NodeList インタフェースがその一例です。 
SSLオブジェクトには、以下のメソッドがあります。 
文字列sをSSL接続で出力します。 戻り値として、送信したバイト数を返します。 
SSL接続からデータを受信します。 nを指定した場合は指定したバイト数のデータを受信し、省略時はEOFまで読み込みます。 
戻り値として、受信したバイト列の文字列を返します。 
Python には数多くの codec が組み込みで付属します。 これらは C 言語の関数、対応付けを行うテーブルの両方で提供されています。 
以下のテーブルでは codec と、いくつかの良く知られている別名と、エンコーディングが使われる言語を列挙します。 
別名のリスト、言語のリストともしらみつぶしに網羅されているわけではありません。 
大文字と小文字、またはアンダースコアの代りにハイフンにしただけの綴りも有効な別名です。 多くの文字セットは同じ言語をサポートしています。 
これらの文字セットは個々の文字 (例えば、EURO SIGN がサポートされているかどうか) や、文字のコード部分への割り付けが異なります。 
特に欧州言語では、典型的に以下の変種が存在します: 
ISO 8859 コードセット 
Microsoft Windows コードページで、8859 コード形式から導出されているが、制御文字を追加のグラフィック文字と置き換えたもの 
IBM EBCDIC コードページ 
ASCII 互換の IBM PC コードページ 
別名 
言語 
英語 
繁体字中国語 
ヘブライ語 
西ヨーロッパ言語 
ギリシャ語 
バルト沿岸国 
850, IBM850 西ヨーロッパ 
中央および東ヨーロッパ 
ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア 
トルコ語 
ポルトガル語 
861, CP-IS, IBM861 アイスランド語 
カナダ 
アラビア語 
デンマーク、ノルウェー 
ロシア語 
タイ語 
日本語 
韓国語 
西ヨーロッパ 
ギリシャ 
トルコ 
ヘブライ 
アラビア 
バルト沿岸国 
ベトナム 
簡体字中国語 
簡体字中国語 
日本語, 韓国語, 簡体字中国語, 西欧, ギリシャ語 
西ヨーロッパ 
エスペラント、マルタ 
バルト沿岸国 
北欧 
ケルト 
ウクライナ 
アイスランド 
カザフ 
全ての言語 
全ての言語 (BMP only) 
codec のいくつかは Python 特有のものなので、それらの codec 名は Pythonの外では無意味なものとなります。 
これらの codec の中にはUnicode 文字列からバイト文字列への変換を行わず、むしろ単一の引数をもつ全写像関数はエンコーディングとみなせるというPython codec の性質を利用したものもあります。 以下に列挙した codec では、``エンコード'' 方向の結果は常にバイト文字列方向です。 
``デコード'' 方向の結果はテーブル内の被演算子型として列挙されています。 
被演算子の型 
目的 
被演算子を MIME base64 に変換します。 
被演算子をbz2を使って圧縮します。 
被演算子をバイトあたり 2 桁の 16 進数の表現に変換します。 
RFC 3490 の実装です。 バージョン 2.3 で 新たに追加 された仕様です。 
Windows のみ: 被演算子を ANSI コードページ (CP_ACP) に従ってエンコードします。 
PalmOS 3.5 のエンコーディングです。 
RFC 3492 を実装しています。 バージョン 2.3 で 新たに追加 された仕様です。 
被演算子を MIME quoted printable 形式に変換します。 
Python ソースコードにおける raw Unicode リテラルとして適切な文字列を生成します。 
被演算子のシーザー暗号 (Caesar-cypher) を返します。 
Python ソースコードにおける文字列リテラルとして適切な文字列を生成します。 
全ての変換に対して例外を送出します。 
バイト列と Unicode 文字列との間で自動的な型強制をおこないたくない時にシステムエンコーディングとして使うことができます。 
Python ソースコードにおける Unicode リテラルとして適切な文字列を生成します。 
被演算子の内部表現を返します。 
被演算子を uuencode を用いて変換します。 
被演算子を gzip を用いて圧縮します。 
2.1 プラットフォームによる違い 
1.2 節で述べたよいうに、 Distutils を使ったモジュール配布物のビルドとインストールは、通常は単純なコマンド: 
で行います。 Unixでは、このコマンドをシェルプロンプトで行います; Windows では、コマンドプロンプトウィンドウ (``DOS ボックス'') を開いて、そこで行います; Mac OS の場合、作業はもう少しだけ複雑です (下記参照) 
setup コマンドは常に配布物ルートディレクトリ、すなわちモジュールのソース配布物を展開した際のトップレベルのサブディレクトリ内で実行しなければなりません。 
例えば、あるモジュールのソース配布物foo-1.0.tar.gz を Unix システム上にダウンロードしたなら、通常は以下の操作を行います: 
Windows では、おそらく foo-1.0.zip をダウンロードしているでしょう。 
アーカイブファイルを C:Temp にダウンロードしたのなら、(WinZip のような) グラフィカルユーザインタフェースつきのアーカイブ操作ソフトや、 (unzip やpkunzip のような) コマンドラインツールを使ってアーカイブを展開します。 
次に、コマンドプロンプトウィンドウ(``DOS ボックス'') を開いて、以下を実行します: 
setup.py install を実行すると、一度の実行で全てのモジュールをビルドしてインストールします。 
段階的に作業をしたい場合 -- ビルドプロセスをカスタマイズしたり、作業がうまくいかない場合に特に便利です -- には、setup スクリプトに一度に一つづつ作業を行わせるようにできます。 
この機能は、ビルドとインストールを異なるユーザで行う場合にも便利です -- 例えば、モジュール配布物をビルドしておいてシステム管理者に渡して (または、自分でスーパユーザになって) 、インストールしたくなるかもしれません.最初のステップでは全てをビルドしておき、次のステップで全てをインストールするには、 setup スクリプトを二度起動します: 
この作業を行ってみれば、install コマンドを実行するとまず build コマンドを実行し、さらに -- この場合には -- build ディレクトリの中が全て最新の状態になっているので、build は何も行わなくてよいと判断していることがわかるでしょう。 インターネットからダウンロードしたモジュールをインストールしたいだけなら、上のように作業を分割する機能は必要ないかもしれませんが、この機能はより進んだ使い方をする際にはとても便利です。 
自作の Python モジュールや拡張モジュールを配布することになれば、個々の Distutils コマンドを自分で何度も実行することになるでしょう。 
上で示唆したように、 build コマンドは、インストールすべきファイルを ビルドディレクトリ (build directory) に置く働きがあります。 
デフォルトでは、ビルドディレクトリは配布物ルート下の build になります; システムの処理速度に強いこだわりがあったり、ソースツリーに指一本触れたくないのなら、--build-base オプションを使ってビルドディレクトリを変更できます。 例えば: 
(あるいは、システム全体向け、あるいは個人用の Distutils 設定ファイルにディレクティブを書いて、永続的に設定を変えられます;5節を参照してください。 
) 通常は必要ない作業です。 ビルドツリーのデフォルトのレイアウトは以下のようになっています: 
--- build/ --- lib/または--- build/ --- lib.plat/temp.plat/ 
plat は、現在の OS/ハードウェアプラットフォームとPython のバージョンを記述する短い文字列に展開されます。 
第一の lib ディレクトリだけの形式は、 ``pure モジュール配布物''-- すなわち、pure Python モジュールだけの入ったモジュール配布物 --の場合に使われます。 
モジュール配布物に何らかの拡張モジュール(C/C++ で書かれたモジュール) が入っている場合、第二の plat付きディレクトリが二つある形式が使われます。 
この場合、 temp.plat 
ディレクトリには、コンパイル/リンク過程で生成され、実際にはインストールされない一時ファイルが収められます。 
どちらの場合にも、lib (または lib.plat 
) ディレクトリには、最終的にインストールされることになる全ての Python モジュール (pure Python モジュールおよび拡張モジュール) が入ります。 今後、 Python スクリプト、ドキュメント、バイナリ実行可能形式、その他 Python モジュールやアプリケーションのインストール作業に必要なディレクトリが追加されるかもしれません。 
build コマンドを実行した後 (明示的に実行した場合も、install コマンドが代わりに実行してくれた場合も) は、install コマンドの仕事は比較的単純なもの: build/lib(または build/lib.plat ) の下にあるもの全ての指定したインストールディレクトリへのコピー、になります。 
インストールディレクトリを選ばなかった場合 -- すなわち、setup.py install を実行しただけの場合 -- には、installコマンドはサードパーティ製 Python モジュールを置くための標準の場所にインストールを行います。 
この場所は、プラットフォームや、Python 自体をどのようにビルド/インストールしたかで変わります。 
Unix や Mac OSでは、インストールしようとするモジュール配布物が pure Python なのか、拡張モジュールを含む (``非 pure'') のかによっても異なります: 
プラットフォーム 
標準のインストール場所 
デフォルト値 
Unix (非 pure) 
Mac OS (非 pure) 
ほとんどの Linux ディストリビューションには、システムの標準インストール物として Python が入っているので、 Linux では普通、prefix や exec-prefix はどちらも /usr になります。 
Linux (または Unixライクなシステム) 上で自分で Python をビルドした場合、デフォルトの prefix およびexec-prefix は /usr/local になります。 
Windows での Python のデフォルトインストールディレクトリは、Python 1.6a1、 1.5.2、およびそれ以前のバージョンではC:Program FilesPythonです。 
prefix および exec-prefix は、 Python がインストールされているディレクトリと、実行時にライブラリを探しにいく場所を表します。 
これらのディレクトリは、Windows と Mac OS では常に同じで、 Unixでもほぼ常に同じです。 
自分の Python がどんな prefix やexec-prefix を使っているかは、Python を対話モードで起動して、単純なコマンドをいくつか入力すればわかります。 
Windows では、スタート (すべての) プログラム Python 2.4 Python (command line) を選びます。 Mac OS 9 では、 PythonInterpreter を起動します。 
インタプリタを起動すると、プロンプトに Python コードを入力できます。 
例えば、作者の使っている Linux システムで、三つのPython 文を以下のように入力すると、出力から作者のシステムのprefix と exec-prefix を得られます: 
モジュールを標準の場所にインストールしたくない場合や、標準の場所にインストールするためのファイル権限を持っていない場合、3節にある、別の場所へのインストール方法の説明を読んでください。 
インストール先のディレクトリを大幅にカスタマイズしければ、4 節のカスタムインストールに関する説明を読んでください。 
4.2 文字列例外の廃止 
"PyExc_"の後ろにPythonの例外名が続く名前をもつグローバル変数として、すべての標準Python例外が利用可能です。 
これらは型PyObject*を持ち、すべてクラスオブジェクトです。 
完璧を期するために、すべての変数を以下に列挙します: 
C名 
Python名 
これは別の標準例外のためのベースクラスです。 
これはweakref.ReferenceErrorと同じです。 
Windowsでのみ定義されています。 プリプロセッサマクロMS_WINDOWSが定義されているかテストすることで、これを使うコードを保護してください。 
StreamReader クラスは Codec のサブクラスで、以下のメソッドを定義しています。 
全てのストリームリーダは、Python の codec レジストリとの互換性を保つために、これらのメソッドを定義する必要があります。 クラスStreamReader 
StreamReader インスタンスのコンストラクタです。 
全てのストリームリーダはコンストラクタとしてこのインタフェースを提供せねばなりません。 
キーワード引数を追加しても構いませんが、Python の codec レジストリはここで定義されている引数だけを使います。 
stream は、(バイナリで) 読み出し可能なファイル類似のオブジェクトでなくてはなりません。 StreamReader は、errors キーワード引数を受けて、異なったエラー処理の仕組みを実装しても構いません。 
定義済みのパラメタを以下に示します。 
'ignore' 文字を無視して、次の文字から続けます。 
'replace' 適切な置換文字で置換します。 
errors 引数は、同名の属性に代入されます。 
この属性を変更すると、StreamReader オブジェクトが生きている間に、異なるエラー処理に変更できます。 errors 引数が取りえる値の種類はregister_error() で拡張できます。 
ストリームからのデータをデコードし、デコード済のオブジェクトを返します。 
chars はストリームから読み込む文字数です。 read() はchars以上の文字を返しませんが、それより少ない文字しか取得できない場合にはchars以下の文字を返します。 
size は、デコードするためにストリームから読み込む、およその最大バイト数を意味します。 
デコーダはこの値を適切な値に変更できます。 
バージョン 2.4 で 変更 された仕様:引数chars が追加されました。 
入力ストリームから1行読み込み、デコード済みのデータを返します。 
size が与えられた場合、ストリームにおける readline() の size 引数に渡されます。 keepends が偽の場合には行末の改行が削除された行が返ります。 
バージョン 2.4 で 変更 された仕様:引数keependsが追加されました。 
入力ストリームから全ての行を読み込み、行のリストとして返します。 keependsが真なら、改行は、codec デコーダ のメソッド実装され、リスト要素の中に含まれます。 
sizehint が与えられた場合、 ストリームの read() メソッドに size 引数として渡されます。 
状態保持に使われた codec のバッファをリセットします。 ストリームの読み位置を再設定してはならないので注意してください。 
このメソッドはデコードの際にエラーから復帰できるようにするためのものです。 
ここまでで挙げたメソッドの他にも、StreamReader では背後にあるストリームの他の全てのメソッドや属性を継承せねばなりません。 次に挙げる2つの基底クラスは、利便性のために含まれています。 
codec レジストリは、これらを必要としませんが、実際のところ、あると有用なものでしょう。 
StreamReaderWriter を使って、読み書き両方に使えるストリームをラップできます。 lookup() 関数が返すファクトリ関数を使って、インスタンスを生成するという設計です。 
クラスStreamReaderWriter 
StreamReaderWriter インスタンスを生成します。 
StreamReaderWriter インスタンスは、StreamReader クラスと StreamWriterクラスを合わせたインタフェースを継承します。 
元になるストリームからは、他のメソッドや属性を継承します。 
クラスStreamRecoder 
双方向変換を実装する StreamRecoder インスタンスを生成します。 encode と decode はフロントエンド (read() への入力とwrite()からの出力) を処理し、Reader と Writer はバックエンド (ストリームに対する読み書き) を処理します。 
これらのオブジェクトを使って、たとえば、Latin-1 から UTF-8、あるいは逆向きの変換を、透過に記録できます。 
stream はファイル的オブジェクトでなくてはなりません。 
encode と decode は Codec のインタフェースに忠実でなくてはなりません。 Reader と Writer は、それぞれ StreamReader と StreamWriter のインタフェースを提供するオブジェクトのファクトリ関数かクラスでなくてはなりません。 
encode と decode はフロントエンドの変換に必要で、Reader と Writer はバックエンドの変換に必要です。 
StreamRecoder インスタンスは、StreamReader と StreamWriter クラスを合わせたインタフェースを定義します。 
また、元のストリームのメソッドと属性も継承します。 
StreamWriter クラスは Codec のサブクラスで、以下のメソッドを定義しています。 
全てのストリームライタは、Python の codec レジストリとの互換性を保つために、これらのメソッドを定義する必要があります。 クラスStreamWriter 
StreamWriter インスタンスのコンストラクタです。 
全てのストリームライタはコンストラクタとしてこのインタフェースを提供せねばなりません。 
stream は、(バイナリで) 書き込み可能なファイル類似のオブジェクトでなくてはなりません。 StreamWriter は、errors キーワード引数を受けて、異なったエラー処理の仕組みを実装しても構いません。 
定義済みのパラメタを以下に示します。 
'strict' ValueError (または、そのサブクラス)送出します。 
デフォルトの動作です。 
'replace' 適切な置換文字で置換します。 
'xmlcharrefreplace' 適切な XML 文字参照で置換します。 
'backslashreplace' バックスラッシュ付きのエスケープシーケンスで置換します。 
この属性を変更すると、StreamWriter オブジェクトが生きている間に、異なるエラー処理に変更できます。 errors 引数が取りえる値の種類はregister_error() で拡張できます。 
object の内容をエンコードしてストリームに書き出します。 
文字列からなるリストを連結して、(必要に応じて write() を何度も使って) ストリームに書き出します。 
状態保持に使われていた codec のバッファを強制的に出力してリセットします。 このメソッドが呼び出された場合、出力先データをきれいな状態にし、わざわざストリーム全体を再スキャンして状態を元に戻さなくても新しくデータを追加できるようにせねばなりません。 
ここまでで挙げたメソッドの他にも、StreamWriter では背後にあるストリームの他の全てのメソッドや属性を継承せねばなりません。 
複数の文字列リテラルは、互いに異なる引用符を使っていても (空白文字で区切って) 隣接させることができ、その意味は各々の文字列を結合したものと同じになります。 
したがって、"hello" 'world' は"helloworld" と同じになります。 
この機能を使うと、長い文字列を分離して、複数行にまたがらせる際に便利です。 また、部分文字列ごとにコメントを追加することもできます。 
例えば: re.compile("[A-Za-z_]" # letter or underscore"[A-Za-z0-9_]*" # letter, digit or underscore) 
この機能は文法レベルで定義されていますが、スクリプトをコンパイルする際の処理として実現されることに注意してください。 
実行時に文字列表現を結合したければ、 `+' 演算子を使わなければなりません。 
また、リテラルの結合においては、結合する各要素に異なる引用符形式を使える (raw 文字列と三重引用符を混ぜることさえできます) ので注意してください。 
文字列変換は、逆クオート (reverse quite, 別名バッククオート: backward quote) で囲われた式のリストです: string_conversion 
組み込み関数 repr() は、括弧内の引数に対して、逆クオート表記で囲われた中身と全く同じ変換を実行します。 
組み込み関数 str() は似たような動作をしますが、もっとユーザフレンドリな変換になります。 
以下は 8 ビット文字列および Unicode オブジェクトでサポートされるメソッドです: 
最初の文字を大文字にした文字列のコピーを返します。 8ビット文字列では、メソッドはロケール依存になります。 
width の長さをもつ中央寄せされた文字列を返します。 
パディングにはfillchar で指定された値（デフォルトではスペース）が使われます。 バージョン 2.4 で 変更 された仕様:引数 fillchar に対応 
文字列 S[start:end] 中に部分文字列 sub が出現する回数を返します。 
オプション引数 start および endはスライス表記と同じように解釈されます。 
標準のエラー処理は 'strict' で、エンコードに関するエラーは UnicodeError を送出します。 
他に利用できる値は 'ignore' 、 'replace' および関数 codecs.register_error によって登録された名前です。 
バージョン 2.2 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:その他のエラーハンドリングスキーマがサポートされました 
文字列のエンコードされたバージョンを返します。 
標準のエンコーディングは現在のデフォルト文字列エンコーディングです。 標準とは異なるエラー処理を行うために errors を与えることができます。 
標準のエラー処理は 'strict' で、エンコードに関するエラーは UnicodeError を送出します。 
他に利用できる値は 'ignore' 、 'replace' 、'xmlcharrefreplace'、 'backslashreplace' および関数 codecs.register_error によって登録された名前です。 
利用可能なエンコーディングの一覧は、セクション4.9.2を参照してください。 バージョン 2.0 で 新たに追加 された仕様です。 
バージョン 2.3 で 変更 された仕様:'xmlcharrefreplace' 、 'backslashreplace' およびその他のエラーハンドリングスキーマがサポートされました 
文字列の一部が suffix で終わるときに True を返します。 そうでない場合 False を返します。 
オプション引数 start がある場合、文字列の start から比較を始めます。 
end がある場合、文字列の end で比較を終えます。 
全てのタブ文字が空白で展開された文字列のコピーを返します。 
tabsize が与えられていない場合、タブ幅は 8 文字分と仮定します。 
文字列中の領域 [start, end) に sub が含まれる場合、その最小のインデクスを返します。 
オプション引数 start および end はスライス表記と同様に解釈されます。 
sub が見つからなかった場合 -1 を返します。 
find() と同様ですが、sub が見つからなかった場合ValueError を送出します。 
文字列中の全ての文字が英数文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列中の全ての文字が英文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合はを返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列中の大小文字の区別のある文字全てが小文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。 
そうでない場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列中の大小文字の区別のある文字全てが大文字で、かつ 1 文字以上ある場合には真を返し、そうでない場合は偽を返します。 8ビット文字列では、メソッドはロケール依存になります。 
シーケンス seq 中の文字列を結合した文字列を返します。 
文字列を結合するときの区切り文字は、このメソッドを適用する対象の文字列になります。 
width の長さをもつ左寄せした文字列を返します。 パディングには fillchar で指定された文字(デフォルトではスペース）が使われます。 
width が len(s)よりも小さい場合、元の文字列が返されます。 バージョン 2.4 で 変更 された仕様:引数 fillchar が追加されました 
文字列をコピーし、小文字に変換して返します。 8ビット文字列では、メソッドはロケール依存になります。 
文字列をコピーし、文字列の先頭部分を除去して返します。 
chars が省略されるか None の場合、空白文字が除去されます。 
chars が与えられていてかつ Noneでない場合、chars は文字列でなければなりません;このメソッドを適用した対象の文字列の先頭部分から chars 中の文字が除去されます。 バージョン 2.2.2 で 変更 された仕様:引数 chars をサポートしました 
文字列をコピーし、部分文字列 old のある部分全てを newに置換して返します。 
オプション引数 count が与えられている場合、先頭から count 個の old だけを置換します。 
文字列中の領域 [start, end) に sub が含まれる場合、その最大のインデクスを返します。 
オプション引数 start および end はスライス表記と同様に解釈されます。 
sub が見つからなかった場合 -1 を返します。 
find() と同様ですが、sub が見つからなかった場合ValueError を送出します。 
width の長さをもつ右寄せした文字列を返します。 
sep を区切り文字とした、文字列中の単語のリストを返します。 
maxsplit が与えられた場合、最大で maxsplit 個になるように分割が行なわれます、最も右側 （の単語）は1つになります。 
sep が指定されていない、あるいは Noneのとき、全ての空白文字が区切り文字となります。 バージョン 2.4 で 新たに追加 された仕様です。 
文字列をコピーし、文字列の末尾部分を除去して返します。 
chars が与えられていてかつ Noneでない場合、chars は文字列でなければなりません;このメソッドを適用した対象の文字列の末端部分から chars 中の文字が除去されます。 バージョン 2.2.2 で 変更 された仕様:引数 chars をサポートしました 
sep を単語の境界として文字列を単語に分割し、分割された単語からなるリストを返します。 
(したがって返されるリストは 
maxsplit+1 の要素を持ちます）maxsplit が与えられていないかゼロの場合、無制限に分割が行なわれます（全ての可能な分割が行なわれる）。 
連続した区切り文字はグループ化されず、空の文字列を区切っていると判断されます（例えば "'1,,2'.split(',')" は"['1', '', '2']"を返します）。 
区切り文字を指定して空の文字列を分割すると、空のリストを返します。 sep が指定されていないか None が指定されている場合、異なる分割アルゴリズムが適用されます。 
空の文字列への分割は "['']" を返します。 
文字列を改行部分で分解し、各行からなるリストを返します。 
keepends が与えられていて、かつその値が真でない限り、返されるリストには改行文字は含まれません。 8ビット文字列では、メソッドはロケール依存になります。 
文字列の一部が prefix で始まるときに True を返します。 そうでない場合 False を返します。 
オプション引数 start がある場合、文字列の start から比較を始めます。 
end がある場合、文字列の end で比較を終えます。 
文字列をコピーし、文字列の先頭および末尾部分を除去して返します。 
chars が省略されるか None の場合、空白文字が除去されます。 
chars が与えられていてかつ Noneでない場合、chars は文字列でなければなりません;このメソッドを適用した対象の文字列の両端から chars 中の文字が除去されます。 バージョン 2.2.2 で 変更 された仕様:引数 chars をサポートしました 
文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。 
文字列をタイトルケースにして返します: 大文字から始まり、残りの文字のうち大小文字の区別があるものは全て小文字にします。 
文字列をコピーし、オプション引数の文字列 deletechars の中に含まれる文字を全て除去します。 
None に対応付けられた文字は削除されます。 
ちなみに、より柔軟性のあるアプローチは、自作の文字対応付けを行う codecを 
モジュールを使って作成することです (例えば encodings.cp1251 を参照してください。 
文字列をコピーし、大文字に変換して返します。 8ビット文字列では、メソッドはロケール依存になります。 
数値文字列の左側をゼロ詰めし、幅 width にして返します。 
width が len(s) よりも短い場合もとの文字列自体が返されます。 バージョン 2.2.2 で 新たに追加 された仕様です。 
以下の関数では、文字列が渡されるはずのパラメタに非文字列が渡された場合に TypeError を送出します。 
この PyObject のサブタイプは Python の文字列オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python の文字列型を表現します; このオブジェクトは Python レイヤにおけるtypes.TypeType と同じです。 
o が文字列型か文字列型のサブタイプであるときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
o が文字列型で、かつ文字列型のサブタイプでないときに真を返します。 
v を値に持つ文字列オブジェクトを返します。 失敗すると NULLを返します。 
パラメタ v は NULL であってはなりません;NULLかどうかはチェックしません。 
値が v で長さが len の新たな文字列オブジェクトを返します。 失敗すると NULL を返します。 
v がNULL の場合、文字列の中身は未初期化の状態になります。 
C 関数 printf() 形式の format 文字列と可変個の引数をとり、書式化済みの文字列長を計算した上で、書式化を行った結果を値とする Python 文字列にして返します。 
可変個の引数部は C のデータ型でなくてはならず、かつ format 文字列内の書式指定文字(format character) に一致する型でなくてはなりません。 
利用できる書式化文字は以下の通りです: 
書式指定文字 
型 
コメント 
文字 % のリテラル。 
C の整数型で表現される単一の文字。 
C のprintf("%d") と全く同じ。 
C のprintf("%ld") と全く同じ。 
C のprintf("%i") と全く同じ。 
C のprintf("%x") と全く同じ。 
null で終端された C の文字列。 
C ポインタの 16 進表記。 printf("%p")とほとんど同じだが、プラットフォームにおける printf の定義に関わりなく先頭にリテラル 0x が付きます。 
PyString_FromFormat() と同じです。 ただし、こちらの関数は二つしか引数をとりません。 
文字列オブジェクト string 内の文字列値の長さを返します。 
PyString_Size() をマクロで実装したもので、エラーチェックを行いません。 
string の中身を NUL 文字終端された表現で返します。 
ポインタはstring オブジェクトの内部バッファを指し、バッファのコピーを指すわけではありません。 
PyString_FromStringAndSize(NULL, size) を使って生成した文字列でない限り、バッファ内のデータはいかなる変更もしてはなりません。 この文字列をデアロケートしてはなりません。 
string が Unicode オブジェクトの場合、この関数はstring のデフォルトエンコーディング版を計算し、デフォルトエンコーディング版に対して操作を行います。 
string が文字列オブジェクトですらない場合、PyString_AsString() は NULL を返してTypeError を送出します。 
PyString_AsString() をマクロで実装したもので、エラーチェックを行いません。 
文字列オブジェクトだけをサポートします; Unicode オブジェクトを渡してはなりません。 
obj の中身を NUL 文字終端された表現にして、出力用の変数buffer と length を使って返します。 この関数は文字列オブジェクトと Unicode オブジェクトのどちらも入力として受理します。 
Unicode オブジェクトの場合、オブジェクトをデフォルトエンコーディングでエンコードしたバージョン(default encoded version) を返します。 
length が NULL の場合、値を返させるバッファには NUL 文字を入れてはなりません;NUL 文字が入っている場合、関数は -1 を返し、TypeError を送出します。 buffer は obj の内部文字列バッファを参照し、バッファのコピーを参照するわけではありません。 
PyString_FromStringAndSize(NULL, size) を使って生成した文字列でない限り、バッファ内のデータはいかなる変更もしてはなりません。 
この文字列をデアロケートしてはなりません。 
string が Unicode オブジェクトの場合、この関数はstring のデフォルトエンコーディング版を計算し、デフォルトエンコーディング版に対して操作を行います。 
string が文字列オブジェクトですらない場合、PyString_AsStringAnsSize() は NULL を返してTypeError を送出します。 
新しい文字列オブジェクトを *string に作成し、 newpartの内容を string に追加します; 呼び出し側は新たな参照を所有することになります。 
string の以前の値に対する参照は盗み取られます。 
新たな文字列を生成できなければ、string に対する古い参照は無視され、 *string の値は NULL に設定されます; その際、適切な例外情報が設定されます。 
新しい文字列オブジェクトを *string に作成し、 newpartの内容を string に追加します。 
こちらのバージョンの関数はnewpart への参照をデクリメントします。 
``変更不能'' である文字列オブジェクトをサイズ変更する手段です。 新たな文字列オブジェクトを作成するときにのみ使用してください;文字列がすでにコードの他の部分で使われているかもしれない場合には、この関数を使ってはなりません。 
入力する文字列オブジェクトの参照カウントが 1 でない場合、この関数を呼び出すとエラーになります。 左側値には、既存の文字列オブジェクトのアドレスを渡し (このアドレスには書き込み操作が起きるかもしれません)、新たなサイズを指定します。 
成功した場合、 *string はサイズ変更された文字列オブジェクトを保持し、0 が返されます; *string の値は、入力したときの値と異なっているかもしれません。 
文字列の再アロケーションに失敗した場合、*string に入っていた元の文字列オブジェクトを解放し、*string を NULL にセットし、メモリ例外をセットし、-1 を返します。 
新たな文字列オブジェクトを format と args から生成します。 
と似た働きです。 
引数 argsはタプルでなければなりません。 
引数 *string をインプレースで隔離 (intern) します。 
引数は Python 文字列オブジェクトを指すポインタへのアドレスでなくてはなりません。 
*string と等しい、すでに隔離済みの文字列が存在する場合、そのオブジェクトを *string に設定します (かつ、元の文字列オブジェクトの参照カウントをデクリメントし、すでに隔離済みの文字列オブジェクトの参照カウントをインクリメントします)。 
(補足: 参照カウントについては沢山説明して来ましtが、この関数は参照カウント中立 (reference-count-neutral) と考えてください;この関数では、関数の呼び出し後にオブジェクトに対して参照の所有権を持てるのは、関数を呼び出す前にすでに所有権を持っていた場合に限ります。 
PyString_FromString() と PyString_InternInPlace() を組み合わせたもので、隔離済みの新たな文字列オブジェクトを返すか、同じ値を持つすでに隔離済みの文字列オブジェクトに対する新たな (``所有権を得た'') 参照を返します。 
size からなるエンコード済みのバッファ s をencoding の名前で登録されている codec に渡してデコードし、オブジェクトを生成します。 encoding および errors は組み込み関数 unicode() に与える同名のパラメタと同じ意味を持ちます。 
codec が例外を送出した場合にはNULL を返します。 
文字列オブジェクトをencoding の名前で登録されている codec に渡してデコードし、Python オブジェクトを返します。 
LaTeX マークアップに対する小規模な変更のほとんどは、マークアップから表現方法を切り離すためとメンテナンス性の向上の両方を狙ってなされてきたものです。 
1998 年からこのかた、まさにこの目的のもとに数多くの変更が行われました; それ以前は、変更はありましたがあまり体系的なやりかたではなく、既存の内容を更新する必要はないと考えられていました。 
その結果、高度に構造化され、意味論的にはLaTeX の上に読み出されることになるような、LaTeX で実装されたマークアップ言語になってしまいました。 
とはいえ、基本的なTeX やLaTeX によるマークアップが使われていなければ、実際のドキュメントソースでLaTeX が使われている証拠となるのはマークアップの構文法くらいです。 この副作用のせいで、例えばLaTeX やLaTeX2HTML のような、ドキュメントを操作するための標準の ``エンジン'' を使えるにも関わらず、実際の変換のほとんどは Python に特化して作られてしまいました。 
LaTeX ドキュメントクラスとLaTeX2HTML サポートは、いずれもこのドキュメントのために設計された特殊なマークアップを完全に実装しています。 高度にカスタマイズされたマークアップが、ドキュメントを処理するための深遠なる機構と組み合さってしまうと、こんな疑問が出てきます:もっと簡単にできないの? あるいは、もっとましにならないの?コミュニティとのたくさんの議論を重ねた結果、我々は近代的な構造化ドキュメント生成システムの追求にも時間を費やす価値があるという結論に達しました。 
この議論の場には、二つの現実的な競合案: 標準化汎用マークアップ言語(Standard General Markup Language, SGML) と拡張可能なマークアップ言語 (Extensible Markup Language, XML) が挙がっています。 これらの標準には、いずれも長所と短所があり、多くの長所を共有しています。 
SGML はほとんどのドキュメント作者、とりわけ普通のテキストエディタを利用している人たちをそそらせるような長所を持っています。 
また、コンテンツのモデルを定義できるという別の機能もあります。 
完成度が実証されている多くの高品質なツールを利用できますが、そのほとんどはフリーではありません; またこれらのツールでは、可搬性がいまだに問題になっています。 XML には、多数の発展中のツールを使えるという利点があります。 
残念ながら、XML の標準自体の多くがまだ発展中なので、ツールも当分はそれに追従しなければならないでしょう。 
つまり、基本 XML 1.0 勧告を超えた仕様を利用するような安定したツールセットを短い期間で開発するのは不可能です。 
最も重要な関連標準仕様をのいくつかをサポートするような広範な種類の高品質ツールが利用できると自信を持っていえるのははまだ先の話です。 
将来はドキュメントを XML に移行することになっていて、ドキュメントを現在の形式から変換して、最終的なバージョンに近いものにするツールを開発しているところです。 
3 スタイルガイド Python ドキュメントは、可能な限り 
に準拠することになっています。 内容の合理性と、オンラインで容易に取得できることから、このスタイルガイドが選ばれました。 
Apple のスタイルガイドがカバーしていないトピックについては、このドキュメントで必要に応じて議論していきます。 Python ドキュメントの中では、オペレーティングシステムやプログラミング言語、標準機関、その他の名前を含む沢山の特殊な名前を使っています。 
こうした名前の多くはかなり古い時期にLaTeX マクロに割り当てられ、その便利さから長い間利用されつづけてきました。 
``central processing unit'' (中央処理装置) のことです。 多くのスタイルガイドが、この語を最初に利用するときには略さずに書かねばならないとしています (ですから、どうしてもこの語を使う必要があるなら、必ずそうしてください!)。 
Python ドキュメントでは、読者が最初にどこを読むのか合理的に予測する方法がないので、略語の使用を避けねばなりません。 
代わりに ``processor (プロセッサ)'' を使う方がよいでしょう。 
ある一連の標準仕様につけられた名前です。 
常に大文字だけからなります。 
この名前を表現するにはマクロ POSIX を使用してください。 
私たちの好きなプログラミング言語の名前は常に大文字で始めます。 
ある文字セットと、それに対応する符号化方式の名前です。 
常に大文字で始めます。 
1970年代初頭に ATT ベル研究所で開発されたオペレーティングシステムの名前です。 
この名前を使うにはマクロの UNIX を使用してください。 
4. 文字列処理 
この章で解説されているモジュールは文字列を操作するさまざまな処理を提供します。 
一般的な文字列操作 
Perl 風のシンタクスを用いた正規表現検索とマッチ操作。 
文字列データをパックされたバイナリデータとして解釈します。 
オブジェクト同士の違いを計算する 
浮動小数点をフォーマットする汎用関数。 
ファイルのように文字列を読み書きする。 
StringIOを高速にしたものだが、サブクラス化はできない。 
テキストの折り返しと詰め込み 
データやストリームのエンコード・デコード。 
国際化ドメイン名実装 
RFC 3453 による文字列調製 
stringオブジェクトのメソッドについては、2.3.6節の ``文字列型のメソッド''もごらんください。 
更なる組み込みオブジェクト型へのサポートを追加するためや、すでにサポートされている型の扱いを変更するために、Repr.repr1()による動的なディスパッチを使ってReprをサブクラス化することができます。 この例はファイルオブジェクトのための特別なサポートを追加する方法を示しています: 
添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書)オブジェクトから、要素を一つ選択します: 
(式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。 )一次語がシーケンスの場合、式 (リスト) の値評価結果は (通常の) 整数でなければなりません。 
値が負の場合、シーケンスの長さが加算されます(x[-1] がx の最後の要素を指すことになります)。 
加算結果はシーケンス内の要素数よりも小さな非負の整数とならなければなりません。 添字表記は、添字と同じシーケンス中の (ゼロから数えた) インデクスを持つ要素を選択します。 
文字列型の要素は文字 (character) です。 文字は個別の型ではなく、1 文字だけからなる文字列です。 
以下の表は、Python における演算子を、優先順位 
の最も低い (結合度が最も低い)ものから最も高い (結合度が最も高い) ものの順に並べたものです。 同じボックス内に示された演算子は同じ優先順位を持ちます。 
演算子の文法が示されていないかぎり、演算子は全て二項演算子です。 
演算子 
ラムダ式 
ブール演算 OR 
ブール演算 AND 
ブール演算 NOT 
メンバシップテスト 
アイデンティティテスト 
比較 
ビット単位 OR 
ビット単位 XOR 
ビット単位 AND 
シフト演算 
加算および減算 
乗算、除算、剰余 
正符号、負符号 
ビット単位 NOT 
属性参照 
添字指定 
スライス操作 
関数呼び出し 
式結合またはタプル表現 
リスト表現 
辞書表現 
文字列への型変換 
この章では、SunOSオペレーティングシステム バージョン5(Solarisバージョン2)に固有の機能を解説します。 
Python が循環参照を含むガベージの検出とコレクションをサポートするには、他のオブジェクトに対する ``コンテナ'' (他のオブジェクトには他のコンテナも含みます) となるオブジェクト型によるサポートが必要です。 
他のオブジェクトに対する参照を記憶しないオブジェクトや、(数値や文字列のような) アトム型 (atomic type) への参照だけを記憶するような型では、ガベージコレクションに際して特別これといったサポートを提供する必要はありません。 ここで説明しているインタフェースの使い方を示した例は、 
Python の拡張と埋め込み 
の ``循環参照の収集をサポートする'' にあります。 コンテナ型を作るには、型オブジェクトの tp_flags フィールドにPy_TPFLAGS_HAVE_GC フラグがなくてはならず、tp_traverse ハンドラの実装を提供しなければなりません。 
実装する型のインスタンスを変更可能なオブジェクトにするなら、tp_clear の実装も提供しなければなりません。 
このフラグをセットした型のオブジェクトは、この節に述べた規則に適合しなければなりません。 
簡単のため、このフラグをセットした型のオブジェクトをコンテナオブジェクトと呼びます。 
コンテナ型のコンストラクタは以下の二つの規則に適合しなければなりません: 
オブジェクトのメモリは PyObject_GC_New() またはPyObject_GC_VarNew() で確保しなければなりません。 
一度他のコンテナへの参照が入るかもしれないフィールドが全て初期化されたら、PyObject_GC_Track() を呼び出さねばなりません。 
PyObject_New() に似ていますが、Py_TPFLAGS_HAVE_GC のセットされたコンテナオブジェクト用です。 
PyObject_NewVar() に似ていますが、Py_TPFLAGS_HAVE_GC のセットされたコンテナオブジェクト用です。 
PyObject_NewVar() が確保したオブジェクトのメモリをリサイズします。 
リサイズされたオブジェクトを返します。 失敗すると NULL を返します。 
ガベージコレクタが追跡しているコンテナオブジェクトの集合にオブジェクト op を追加します。 
ガベージコレクタの動作する回数は予測不能なので、追加対象にするオブジェクトは追跡されている間ずっと有効なオブジェクトでなければなりません。 
この関数は、通常コンストラクタの最後付近で、tp_traverseハンドラ以降の全てのフィールドが有効な値になった時点で呼び出さねばなりません。 
PyObject_GC_Track() のマクロ版です。 
拡張モジュールに使ってはなりません。 
同様に、オブジェクトのメモリ解放関数も以下の二つの規則に適合しなければなりません: 
他のコンテナを参照しているフィールドを無効化する前に、PyObject_GC_UnTrack() を呼び出さねばなりません。 
オブジェクトのメモリは PyObject_GC_Del()で解放しなければなりません。 
PyObject_GC_New() や PyObject_GC_NewVar()を使って確保されたメモリを解放します。 
ガベージコレクタが追跡しているコンテナオブジェクトの集合からオブジェクト op を除去します。 
PyObject_GC_Track()を呼び出して、除去したオブジェクトを再度追跡対象セットに追加できるので注意してください。 
メモリ解放関数 (deallocator, tp_dealloc ハンドラ) は、tp_traverse ハンドラが使用しているフィールドのいずれかが無効化されるよりも以前にオブジェクトに対して呼び出されていなければなりません。 
PyObject_GC_UnTrack() のマクロ版です。 
tp_traverse ハンドラは以下の型を持つ関数を引数の一つとしてとります: 
tp_traverse ハンドラに渡すビジタ関数 (visitor function) の型です。 
この関数は追跡すべきオブジェクトを object に、tp_traverse ハンドラの第三引数を arg にして呼び出されます。 
Python のコア部分では、ガベージコレクションの実装に複数のビジタ関数を使っています。 ユーザが独自にビジタ関数を書く必要があるとは想定されていません。 
tp_traverse ハンドラは以下の型でなければなりません: 
コンテナオブジェクトのためのトラバーサル関数 (traversal function) です。 
実装では、self に直接入っている各オブジェクトに対してvisit 関数を呼び出さねばなりません。 このとき、visit へのパラメタはコンテナに入っている各オブジェクトと、このハンドラに渡されたarg の値です。 
visit 関数は NULL オブジェクトを引数に渡して呼び出してはなりません。 
visit が非ゼロの値を返す場合、エラーが発生し、戻り値をそのまま返すようににしなければなりません。 
tp_traverse ハンドラの作成を単純化するため、Py_VISIT()マクロが提供されています。 
このマクロを使うには、tp_traverse の実装で、引数を visit および arg という名前にしておかねばなりません: 
引数 o および arg を使ってvisit コールバックを呼び出します。 visit が非ゼロの値を返した場合、その値をそのまま返します。 
このマクロを使えば、tp_traverse ハンドラは以下のようになります: 
tp_clear ハンドラは inquiry 型にするか、オブジェクトが変更不能の場合には NULL にしなければなりません。 NULL if the object is immutable. 
循環参照を形成しているとおぼしき参照群を放棄します。 
変更不可能なオブジェクトは循環参照を直接形成することが決してないので、この関数を定義する必要はありません。 
このメソッドを呼び出した後でもオブジェクトは有効なままでなければならないので注意してください (参照に対して Py_DECREF()を呼ぶだけにしないでください)。 
ガベージコレクタは、オブジェクトが循環参照を形成していることを検出した際にこのメソッドを呼び出します。 
6.9 表のマークアップ 表環境には汎用の三つの形式があり、できる限りこの環境を使うようにしてください。 
こうした環境は標準の LaTeX 表環境を置き換えるためのものではなく、Python ドキュメントを作成するための処理ツールで処理する際に便利なように作られています。 
とりわけ、この表環境で生成した HTML は見栄えがよくなります! また、いつかドキュメントをXML 形式に変換する時にも (9 節、 ``将来の方向性'' を参照してください)、利点があるでしょう。 
各環境は tablecols という形式の名前がついています。 
cols には、表のカラム数を小文字のローマ数字で指定します。 
各々の環境について、追加のマクロlinecols 
が定義されています。 この場合cols は表環境のcolsに対応します。 
サポートされているcols にはii、iii、iv、v があります。 
どの環境も全てtabular 環境の上に構築されています。 
longtable 環境に基づく変化形も提供されています。 標準 Python ドキュメント内の全ての表がカラム間に垂直線を使っており、各表のマークアップでこの垂直線を指定しなければならないので注意してください。 
LaTeX のカラム情報指定子 (column specifier) colspec を使って、2 カラムの表を作成します。 
カラム情報指定子には表によって適切なカラム分割垂直線が入るように指定を行わねばなりませんが、表の外側の垂直線は指定してはなりません (この部分の指定はスタイルシートの問題と考えられているからです)。 
con1font パラメタは、テーブルの最初のカラムの表示スタイルをどうするかを指定します: その結果として、最初のカラムは col1font{column1} のようになります。 
最初のカラムを特別扱いしないために、col1font を"textrm" にしてもかまいません。 
カラムのヘッダは heading1 および heading2からとります。 
tableii に似ていますが、ページ境界を割って配置できるような表を生成します。 
パラメタはtableii と同じです。 
tableii やlongtableii 環境内の単一の行を生成します。 第一カラムのテキストはtableii 環境を始めたときに指定したcol1font を適用して生成します。 
tableii 環境に似ていますが、第三カラムがあります。 第三カラムのヘッダは heading3 に指定します。 
tableiii に似ていますが、ページ境界を割って配置できるような表を生成します。 
パラメタはtableiii と同じです。 
lineii マクロに似ていますが、第三カラムがあります。 
第三カラムのテキストは column3 に指定します。 
tableiii 環境に似ていますが、第四カラムがあります。 第四カラムのヘッダは heading4 に指定します。 
tableiv に似ていますが、ページ境界を割って配置できるような表を生成します。 
パラメタはtableiv と同じです。 
lineiv マクロに似ていますが、第四カラムがあります。 
第四カラムのテキストは column4 に指定します。 
tableiii 環境に似ていますが、第五カラムがあります。 第五カラムのヘッダは heading5 に指定します。 
tablev に似ていますが、ページ境界を割って配置できるような表を生成します。 
パラメタはtablev と同じです。 
lineiv マクロに似ていますが、第五カラムがあります。 
第五カラムのテキストは column5 に指定します。 
表に似たもう一つ環境として synopsistable があります。 
この環境が生成する表は二つのカラムからなり、各行は別のマクロ定義modulesynopsis 中に定義されています。 
通常ドキュメントの作者がこの環境を使うことはありませんが、localmoduletable マクロを使うとこの表を作成します。 ここでwarning モジュールのドキュメントにある小さな表の例を示します; 表のマークアップ自体がかなり識別しやすく作られているので、表セル内のマークアップは最小限にしています。 
これは以下のような表になります。 
クラス 
全ての警告カテゴリの基底クラスです。 
Exception のサブクラスです。 
warn() の標準のカテゴリです。 
機能の撤廃を警告するカテゴリの基底クラスです。 
文法機能のあいまいさを警告するカテゴリの基底クラスです。 
実行時システム機能のあいまいさを警告するカテゴリの基底クラスです。 
最初のカラムを別のマークアップにした表を作成するには、textrm を col1font の値に指定して、各エントリを個別にマークしてください。 表を垂直方向に分割するために水平線を追加するには、標準のマクロhline を分割したい行の間に入れます: 
\begin{tableii}{l|l}{constant}{言語}{対象読者}\lineii{APL}{マゾヒスト}\lineii{BASIC}{PC ハードウェア使いのプログラム初心者}\lineii{C}{\UNIX{} \\ Linux カーネル開発者}\hline\lineii{Python}{誰でも!}\end{tableii} 
全ての出力形式でこの場所に水平線を引けるとは限らないので注意してください。 
今読者が読んでいるドキュメントの出力形式では、上の表は以下のようになります: 
誰でも! 
非圧縮 tar アーカイブをファイル名のリストから作成する方法： 
gzip 圧縮 tar アーカイブを作成してメンバー情報のいくつかを表示する方法： 
見せかけの情報を持つ tar アーカイブを作成する方法： 
非圧縮 tar ストリームをsys.stdinから抽出する唯一の方法： 
TarFile オブジェクトは、tar アーカイブへのインターフェースを提供します。 
tar アーカイブは一連のブロックです。 
アーカイブメンバー(保存されたファイル)は、ヘッダーブロックとそれに続くデータブロックから構成されています。 
ある tar アーカイブにファイルを何回も保存することができます。 
各アーカイブメンバーは、TarInfo オブジェクトによって表わされます、詳細についてはTarInfo オブジェクト (セクション 7.19.2)を見て下さい。 
クラスTarFile 
(非圧縮の) tar アーカイブ nameをオープンします。 
fileobj は、TarFileをクローズする時は、クローズされません。 
代替コンストラクタです。 
モジュールレベルでの open() 関数は、実際はこのクラスメソッドへのショートカットです。 
詳細についてはセクション 7.19 を見て下さい。 
メンバー name に対する TarInfo オブジェクトを返します。 
もし nameがアーカイブに見つからなければ、KeyErrorが発生します。 
注意:もしメンバーがアーカイブに1つ以上あれば、その最後に出現するものが、最新のバージョンであるとみなされます。 
TarInfo オブジェクトのリストとしてアーカイブのメンバーを返します。 
このリストはアーカイブ内のメンバーと同じ順番です。 
メンバーをその名前のリストとして返します。 
これはgetmembers()で返されるリストと同じ順番です。 
コンテンツの表を sys.stdout に印刷します。 
もし verbose がFalse であれば、メンバー名のみ印刷します。 
もしそれがTrue であれば、"ls -l" に似た出力を生成します． 
TarFileが読み込み用にオープンされている時、 アーカイブの次のメンバーをTarInfoオブジェクトとして返します。 
もしそれ以上利用可能なものがなければ、None を返します。 
メンバーをアーカイブから現在の作業ディレクトリに、そのフル名を使って、抽出します。 
注意:ファイル風のオブジェクトは読み出し専用で以下のメソッドを提供します：read(), readline(), readlines(),seek(), tell(). 
ファイル nameをアーカイブに追加します。 
name は、任意のファイルタイプ(ディレクトリ、fifo、シンボリックリンク等)です。 
もしarcname が与えられていれば、それはアーカイブ内のファイルの代替名を指定します。 デフォールトではディレクトリは再帰的に追加されます。 
これは、recursive を False に設定することで避けることができます。 デフォルトは True です． 
TarInfoオブジェクトtarinfoをアーカイブに追加します。 もし fileobj が与えられていれば、 
tarinfo.size バイトがそれから読まれ、アーカイブに追加されます。 
gettarinfo()を使ってTarInfo オブジェクトを作成することができます。 
注意:Windows プラットフォームでは、fileobjは、ファイルサイズに関する問題を避けるために、常に、モード 'rb' でオープンされるべきです。 
TarInfoオブジェクトをファイル name あるいは(そのファイル記述子に os.fstat()を使って) ファイルオブジェクトfileobjのどちらか用に作成します。 
TarInfoの属性のいくつかは、addfile()を使って追加する前に修正することができます。 
arcnameがもし与えられていれば、アーカイブ内のファイルの代替名を指定します。 
TarFileをクローズします。 
書き出しモードでは、完了ゼロブロックが2つ、アーカイブに追加されます。 
この値が真なら、POSIX 1003.1-1990 準拠のアーカイブを作成します。 
この値が偽の場合，シンボリックリンクとハードリンクをアーカイブに追加します。 
真の場合，ターゲットファイルの内容をアーカイブに追加します。 
この値はリンクをサポートしないシステムには影響しません。 
この値が偽の場合，空のブロックをアーカイブの終わりとして処理します。 
真の場合，空(で無効な)ブロックを飛ばして、できるだけ多くのメンバを取得しようとします。 
これはアーカイブを連結している場合やアーカイブが損傷している場合に役に立ちます。 
0(デバッグメッセージなし)から 3(すべてのデバッグメッセージあり)までの値に設定します． 
メッセージはsys.stdout に出力されます． 
この値が0 (デフォルトの値です) の場合，extract() 実行時の全てのエラーを無視します． 
ただし，デバッグが有効になっている場合には，デバッグ出力にエラーメッセージとして出力します． 
値を1 にした場合，すべての致命的な エラーに対してOSErrorまたはIOError 例外を送出します． 
値を2 にした場合、致命的でないエラーもまた，全てTarError 例外として送出します． 
TarInfo オブジェクトは TarFile の一つのメンバーを表します。 
ファイルに必要な(ファイルタイプ、ファイルサイズ、時刻、許可、所有者等のような)すべての属性を保存する他に、そのタイプを決定するのに役に立ついくつかのメソッドを提供します。 
これにはファイルのデータそのものは含まれません。 
TarInfoオブジェクトは TarFileのメソッド getmember()、getmembers() および gettarinfo()によって返されます。 
クラスTarInfo 
TarInfo オブジェクトを作成します。 
TarInfo オブジェクトを文字列バッファから作成して返します。 
TarInfo オブジェクトから文字列バッファを作成します。 
TarInfoオブジェクトには以下の public なデータ属性があります： 
アーカイブメンバーの名前。 
バイト単位でのサイズ。 
最終更新時刻。 
許可ビット。 
ファイルタイプです．type は普通、以下の定数:REGTYPE, AREGTYPE, LNKTYPE,SYMTYPE, DIRTYPE, FIFOTYPE,CONTTYPE, CHRTYPE, BLKTYPE,GNUTYPE_SPARSE のいずれかです．TarInfo オブジェクトのタイプをもっと便利に決定するには、下記の is_*() メソッドを使って下さい。 
ターゲットファイル名の名前で、これは タイプLNKTYPE と SYMTYPE のTarInfoオブジェクトにだけ存在します。 
ファイルメンバを保存した元のユーザのユーザ ID です． 
ファイルメンバを保存した元のユーザのグループ ID です． 
ファイルメンバを保存した元のユーザのユーザ名です． 
ファイルメンバを保存した元のユーザのグループ名です． 
TarInfoオブジェクトは便利な照会用のメソッドもいくつか提供しています: 
Tarinfo オブジェクトが普通のファイルの場合に、True を返します。 
isfile()と同じです。 
ディレクトリの場合にTrueを返します。 
シンボリックリンクの場合にTrueを返します。 
ハードリンクの場合にTrueを返します。 
キャラクタデバイスの場合にTrueを返します。 
ブロックデバイスの場合にTrueを返します。 
FIFO の場合にTrueを返します。 
キャラクタデバイス、ブロックデバイスあるいは FIFOのいずれかの場合に Trueを返します。 
典型的な使い方を表す単純な例を示します: 
Telnet インスタンスは以下のメソッドを持っています: 
expectedで指定された文字列を読み込むか、timeoutで指定された秒数が経過するまで読み込みます。 与えられた文字列に一致する部分が見つからなかった場合、読み込むことができたもの全てを返します。 
これは空の文字列になる可能性があります。 接続が閉じられ、転送処理済みのデータが得られない場合には EOFError が送出されます。 
EOFに到達するまでの全てのデータを読み込みます; 接続が閉じられるまでブロックします。 
EOF に到達しない限り、少なくとも 1 バイトの転送処理済みデータを読み込みます。 EOF に到達した場合は '' を返します。 
すぐに読み出せるデータが存在しない場合にはブロックします。 
I/O によるブロックを起こさずに読み出せる全てのデータを読み込みます (eager モード)。 接続が閉じられており、転送処理済みのデータとして読み出せるものがない場合には EOFError が送出されます。 
それ以外の場合で、単に読み出せるデータがない場合には '' を返します。 IAC シーケンス操作中でないかぎりブロックしません。 
現在すぐに読み出せるデータを読み出します。 
接続が閉じられており、転送処理済みのデータとして読み出せるものがない場合には EOFError が送出されます。 
IAC シーケンス操作中でないかぎりブロックしません。 
このメソッドは決してブロックしません。 
SB/SE ペア (サブオプション開始／終了) の間に収集されたデータを返します。 SE コマンドによって起動されたコールバック関数はこれらのデータにアクセスしなければなりません。 
このメソッドはけっしてブロックしません。 
サーバホストに接続します。 
デバッグレベルが 0 のとき、デバッグ用のメッセージを出力します。 
追加の引数が存在する場合、標準の文字列書式化演算子 % を使って msg 中の書式指定子に代入されます。 
デバッグレベルを設定します。 
debuglevel が大きくなるほど、(sys.stdout に) デバッグメッセージがたくさん出力されます。 
接続を閉じます。 
内部的に使われているソケットオブジェクトです。 
内部的に使われているソケットオブジェクトのファイル記述子です。 
接続が閉じられた場合、socket.error が送出されるかもしれません。 
非常に低機能の telnet クライアントをエミュレートする対話関数です。 
interact() のマルチスレッド版です。 
コンパイルされたもの (re.RegexObject のインスタンス) でも、コンパイルされていないもの (文字列) でもかまいません。 
telnet オプションが入力フローから読み込まれるたびに、callback が (設定されていれば) 以下の引数形式:callback(telnet socket, command (DO/DONT/WILL/WONT), option)で呼び出されます。 
その後 telnet オプションに対しては telnetlib は何も行いません。 
テンプレートオブジェクトは以下のメソッドを持っています: 
パイプラインテンプレートを初期状態に戻します。 
元のパイプラインテンプレートと等価の新しいオブジェクトを返します。 
flag が真の場合、デバッグをオンにします。 
そうでない場合、デバッグをオフにします。 
デバッグがオンの時には、実行されるコマンドが印字され、より多くのメッセージを出力するようにするために、シェルにset -x 命令を与えます。 
新たなアクションをパイプラインの末尾に追加します。 
cmd 変数は有効な bourne shell 命令でなければなりません。 
パイプラインの先頭に新しいアクションを追加します。 
引数の説明についてはappend() を参照してください。 
ファイル類似のオブジェクトを返します。 このオブジェクトは fileを開いていますが、パイプラインを通して読み書きするようになっています。 
mode には 'r' または 'w' のいずれか一つしか与えることができないので注意してください。 
パイプを通して infile を outfile にコピーします。 
TestCaseクラスのインスタンスは個別のテストをあらわすオブジェクトですが、TestCaseの具象サブクラスには複数のテストを定義する事ができます -- 具象サブクラスは、特定のfixture(テスト設備)を示している、と考えてください。 
fixtureは、それぞれのテストケースごとに作成・解放されます。 
TestCaseインスタンスには、次の3種類のメソッドがあります:テストを実行するためのメソッド・条件のチェックやテスト失敗のレポートのためのメソッド・テストの情報収集に使用する問い合わせメソッド。 テストを実行するためのメソッドを以下に示します: 
テストを実行する直前に、fixtureを作成する為に呼び出されます。 
このメソッドを実行中に例外が発生した場合、テストの失敗ではなくエラーとされます。 デフォルトの実装では何も行いません。 
テストを実行し、結果を記録した直後に呼び出されます。 
テスト実行中に例外が発生しても呼び出されますので、内部状態に注意して処理を行ってください。 
メソッドを実行中に例外が発生した場合、テストの失敗ではなくエラーとみなされます。 このメソッドは、setUp()が正常終了した場合にはテストメソッドの実行結果に関わり無く呼び出されます。 
デフォルトの実装では何も行いません。 
テストを実行し、テスト結果をresultに指定されたテスト結果オブジェクトに収集します。 
resultがNoneか省略された場合、一時的な結果オブジェクトを生成して使用しますが呼び出し元には渡されません。 
このメソッドは、TestCaseインスタンスの呼び出しと等価です。 
テスト結果を収集せずにテストを実行します。 
例外が呼び出し元に通知されるため、テストをデバッガで実行することができます。 
テスト結果のチェックとレポートには、以下のメソッドを使用してください。 
exprが偽の場合、テスト失敗を通知します。 msgにはエラーの説明を指定するか、またはNoneを指定してください。 
firstとsecond 
exprが等しくない場合、テスト失敗を通知します。 エラー内容はmsgに指定された値か、またはNoneとなります。 
failUnlessEqual()ではmsgのデフォルト値はfirstとsecondを含んだ文字列となりますので、failUnless()の第一引数に比較の結果を指定するよりも便利です。 
firstとsecond 
exprが等しい場合、テスト失敗を通知します。 エラー内容はmsgに指定された値か、またはNoneとなります。 
failUnlessEqual()ではmsgのデフォルト値はfirstとsecondを含んだ文字列となりますので、failUnless()の第一引数に比較の結果を指定するよりも便利です。 
first と second をplaces で与えた小数位で値を丸めて差分を計算し、ゼロと比較することで、近似的に等価であるかどうかをテストします。 
指定小数位の比較というものは指定有効桁数の比較ではないので注意してください。 値の比較結果が等しくなかった場合、テストは失敗し、msg で指定した説明か、None を返します。 
first と second をplaces で与えた小数位で値を丸めて差分を計算し、ゼロと比較することで、近似的に等価でないかどうかをテストします。 
指定小数位の比較というものは指定有効桁数の比較ではないので注意してください。 値の比較結果が等しかった場合、テストは失敗し、msg で与えた説明か、None を返します。 
callableを呼び出し、発生した例外をテストします。 assertRaises()には、任意の位置パラメータとキーワードパラメータを指定する事ができます。 
exceptionで指定した例外が発生した場合はテスト成功とし、それ以外の例外が発生するか例外が発生しない場合にテスト失敗となります。 
複数の例外を指定する場合には、例外クラスのタプルをexceptionに指定します。 
failIf()はfailUnless()の逆で、exprが真の場合、テスト失敗を通知します。 
エラー内容はmsgに指定された値か、またはNoneとなります。 
無条件にテスト失敗を通知します。 エラー内容はmsgに指定された値か、またはNoneとなります。 
test()メソッドが送出する例外を指定するクラス属性。 
テストフレームワークで追加情報を持つ等の特殊な例外を使用する場合、この例外のサブクラスとして作成します。 
この属性の初期値はAssertionErrorです。 
テストフレームワークは、テスト情報を収集するために以下のメソッドを使用します: 
テストオブジェクトに含まれるテストの数を返します。 
TestCaseインスタンスは常に1を返します。 TestSuiteクラスでは1以上を返します。 
オブジェクトが実行するテストの、デフォルトのテスト結果オブジェクトの型を返します。 
テストケースを特定する文字列を返します。 
通常、idはモジュール名・クラス名を含む、テストメソッドのフルネームを指定します。 
テストの説明を一行分、または説明がない場合にはNoneを返します。 
デフォルトでは、テストメソッドのdocstringの先頭の一行、またはNoneを返します。 
TestLoaderクラスは、クラスやモジュールからテストスイートを作成するために使用します。 
通常はこのクラスのインスタンスを作成する必要はなく、 
モジュールのモジュール属性defaultTestLoaderを共用インスタンスとして使用することができます。 
TestLoader オブジェクトには以下のメソッドがあります: 
TestCaseの派生クラスtestCaseClassに含まれる全テストケースのスイートを返します。 
指定したモジュールに含まれる全テストケースのスイートを返します。 このメソッドはmodule内のTestCase派生クラスを検索し、見つかったクラスのテストメソッドごとにクラスのインスタンスを作成します。 
警告: Testcaseクラスを基底クラスとしてクラス階層を構築するとfixtureや補助的な関数をうまく共用することができますが、基底クラスに直接インスタンス化できないテストメソッドがあると、このloadTestsFromModuleを使うことができません。 
この場合でも、fixtureが全て別々で定義がサブクラスにある場合は使用することができます。 
文字列で指定される全テストケースを含むスイートを返します。 
nameには``ドット修飾名''でモジュールかテストケースクラス、またはTestCaseかTestSuiteのインスタンスを返す呼び出し可能オブジェクトを指定します。 
例えばSampleTestsモジュールにTestCaseから派生したSampleTestCaseクラスがあり、SampleTestCaseにはテストメソッドtest_one()・test_two()・test_three()があるとします。 
この場合、nameに'SampleTests.SampleTestCase'と指定すると、SampleTestCaseの三つのテストメソッドを実行するテストスイートが作成されます。 
loadTestsFromName()と同じですが、名前を一つだけ指定するのではなく、複数の名前のシーケンスを指定する事ができます。 
戻り値はnames中の名前で指定されるテスト全てを含むテストスイートです。 
testCaseClass中の全てのメソッド名を含むソート済みシーケンスを返します。 
以下の属性は、サブクラス化またはインスタンスの属性値を変更してTestLoaderをカスタマイズする場合に使用します。 
テストメソッドの名前と判断されるメソッド名の接頭語を示す文字列。 
デフォルト値は'test'です。 
getTestCaseNames()でメソッド名をソートする際に使用する比較関数。 
デフォルト値は組み込み関数cmp()です。 Noneを指定するとソートを行いません。 
テストのリストからテストスイートを構築する呼び出し可能オブジェクト。 メソッドを持つ必要はありません。 
デフォルト値はTestSuiteです。 
TestResultは、複数のテスト結果を記録します。 
TestCaseクラスとTestSuiteクラスのテスト結果を正しく記録しますので、テスト開発者が独自にテスト結果を管理する処理を開発する必要はありません。 
を利用したテストフレームワークでは、TestRunner.run()が返すTestResultインスタンスを参照し、テスト結果をレポートします。 TestResultインスタンスは、テストの実行件数と、テスト中に発生した失敗・エラーの情報を(testcase, traceback)のタプルで保持します。 
tracebackは例外のトレースバック情報をフォーマットした文字列です。 
以下の属性は、テストの実行結果を検査する際に使用することができます: 
開始したテストの数。 
これまでに実行したテストが全て成功していればTrueを、それ以外ならFalseを返す。 
以下のメソッドは内部データ管理用のメソッドですが、対話的にテスト結果をレポートするテストツールを開発する場合などにはサブクラスで拡張することができます。 
testを実行する直前に呼び出されます。 
testの実行直後に、テスト結果に関わらず呼び出されます。 
テスト実行中に、テストの失敗以外の例外が発生した場合に呼び出されます。 errはsys.exc_info()が返すタプル(type,value, traceback)です。 
テストが失敗した場合に呼び出されます。 errはsys.exc_info()が返すタプル(type, value,traceback)です。 
テストが失敗しなかった場合に呼び出されます。 testには、テストケースオブジェクトが指定されます。 
TestResultオブジェクトには、さらにもう一つのメソッドがあります: 
テスト中断のシグナルを送ります。 
このメソッドが呼び出されると、テストランナーは以降のテスト実行を中止し、呼び出し元に復帰します。 
TextTestRunnerではキーボードからの割り込みでテストを中断するためにこのメソッドを使用しており、独自のランナーを実装する場合にも同じように使用することができます。 
TestSuiteオブジェクトはTestCaseとよく似た動作をしますが、実際のテストは実装せず、一まとめにに実行するテストのグループをまとめるために使用します。 
TestSuiteには以下のメソッドが追加されています: 
TestCase又はTestSuiteのインスタンスをスイートに追加します。 
シーケンスtestsに含まれる全てのTestCase又はTestSuiteのインスタンスをスイートに追加します。 
run()メソッドはTestCaseのrun()メソッドと若干異なります: 
スイート内のテストを実行し、結果をresultで指定した結果オブジェクトに収集します。 
TestCase.run()と異なり、TestSuite.run()では必ず結果オブジェクトを指定する必要があります。 
通常、TestSuiteのrun()メソッドはTestRunnerが起動するため、ユーザが直接実行する必要はありません。 
数少ない状況において、一見無害に見える借用参照の利用が問題をひきおこすことがあります。 
この問題はすべて、インタプリタが非明示的に呼び出され、インタプリタが参照の所有者に参照を放棄させてしまう状況と関係しています。 知っておくべきケースのうち最初の、そして最も重要なものは、リスト要素に対する参照を借りている際に起きる、関係ないオブジェクトに対するPy_DECREF() の使用です。 
例えば: 
上の関数はまず、list[0] への参照を借用し、次にlist[1] を値 0 で置き換え、最後にさきほど借用した参照を出力しています。 
何も問題ないように見えますね? でもそうではないのです! 
PyList_SetItem() の処理の流れを追跡してみましょう。 
リストは全ての要素に対して参照を所有しているので、要素 1 を置き換えると、以前の要素 1 を放棄します。 
ここで、以前の要素 1 がユーザ定義クラスのインスタンスであり、さらにこのクラスが__del__() メソッドを定義していると仮定しましょう。 
このクラスインスタンスの参照カウントが 1 だった場合、リストが参照を放棄すると、インスタンスの __del__()メソッドが呼び出されます。 クラスは Python で書かれているので、__del__()は任意の Python コードを実行できます。 
この __del__()が bug() における item に何か不正なことをしているのでしょうか? その通り! buf() に渡したリストが__del__() メソッドから操作できるとすると、"del list[0]"の効果を持つような文を実行できてしまいます。 
正しく動作するバージョンは以下のようになります: 
これは実際にあった話です。 
以前のバージョンの Python には、このバグの一種が潜んでいて、__del__() メソッドがどうしてうまく動かないのかを調べるために C デバッガで相当時間を費やした人がいました...二つ目は、借用参照がスレッドに関係しているケースです。 
通常は、 Python インタプリタにおける複数のスレッドは、グローバルインタプリタロックがオブジェクト空間全体を保護しているため、互いに邪魔し合うことはありません。 
とはいえ、ロックはPy_BEGIN_ALLOW_THREADS マクロで一時的に解除したり、Py_END_ALLOW_THREADS で再獲得したりできます。 
これらのマクロはブロックの起こる I/O 呼び出しの周囲によく置かれ、I/O が完了するまでの間に他のスレッドがプロセッサを利用できるようにします。 
明らかに、以下の関数は上の例と似た問題をはらんでいます: 
voidbug(PyObject *list){PyObject *item = PyList_GetItem(list, 0);Py_BEGIN_ALLOW_THREADS...ブロックが起こる何らかの I/O 呼び出し...Py_END_ALLOW_THREADSPyObject_Print(item, stdout, 0); /* BUG! */} 
このクラスは個別のスレッド中で実行される活動 (activity) を表現します。 
活動を決める方法はは 2 つあり、一つは呼出し可能オブジェクトをコンストラクタへ渡す方法、もう一つはサブクラスでrun() メソッドをオーバライドする方法です。 
(コンストラクタを除く) その他のメソッドは一切サブクラスでオーバライドしてはなりません。 
言い換えるならば、このクラスの__init__()とrun()メソッドだけをオーバライドしてくださいということです。 ひとたびスレッドオブジェクトを生成すると、スレッドのstart()メソッドを呼び出して活動を開始せねばなりません。 
start()メソッドはそれぞれのスレッドの run() メソッドを起動します。 スレッドの活動が始まると、スレッドは '生存中 (alive)' で、'活動中 (active)' とみなされます (これら二つの概念はほとんど同じですが、全く同じというわけではありません; これら二つは意図的に曖昧に定義されているのです)。 
スレッドの活動は、通常終了、あるいは処理されない例外が送出されたことでrun() メソッドが終了すると生存中でなくなり、かつ活動中でなくなります。 
isAlive() メソッドはスレッドが生存中であるかどうか調べます。 他のスレッドはスレッドの join() メソッドを呼び出せます。 
このメソッドは、join() を呼び出されたスレッドが終了するまで、メソッドの呼び出し手となるスレッドをブロックします。 
このフラグには、残っているスレッドがデーモンスレッドだけになった時にPython プログラム全体を終了させるという意味があります。 
フラグの初期値はスレッドを生成する側のスレッドから継承します。 
``ダミースレッド (dumm thread)'' オブジェクトを作成できる場合があります。 
ダミースレッドは、 ``外来スレッド (alien thread)'' に相当するスレッドオブジェクトです。 
ダミースレッドオブジェクトには限られた機能しかなく、常に生存中、活動中かつデーモンスレッドであるとみなされ、join()できません。 
また、外来スレッドの終了を検出するのは不可能なので、ダミースレッドは削除できません。 
クラスThread 
コンストラクタは常にキーワード引数を使って呼び出さねばなりません。 
各引数は以下の通りです: 
group はNone にせねばなりません。 将来ThreadGroup クラスが実装されたときの拡張用に予約されている引数です。 
target はrun() メソッドによって起動される呼出し可能オブジェクトです。 
デフォルトでは何も呼び出さないことを示すNone になっています。 
nameはスレッドの名前です。 
デフォルトでは、 N を小さな10 進数として、``Thread-N'' という形式の一意な名前を生成します。 
args はtarget を呼び出すときの引数タプルです。 
デフォルトは()です。 
kwargs はtarget を呼び出すときのキーワード引数の辞書です。 
デフォルトは{}です。 サブクラスでコンストラクタをオーバライドした場合、必ずスレッドが何かを始める前に基底クラスのコンストラクタ(Thread.__init__()) を呼び出しておかなくてはなりません。 
スレッドの活動を開始します。 このメソッドは、スレッドオブジェクトあたり一度しか呼び出してはなりません。 
start() は、オブジェクトの run()メソッドが個別の処理スレッド中で呼び出されるように調整します。 
スレッドの活動をもたらすメソッドです。 このメソッドはサブクラスでオーバライドできます。 
標準のrun() メソッドでは、オブジェクトのコンストラクタのtarget 引数に呼び出し可能オブジェクトを指定した場合、args およびkwargsの引数列およびキーワード引数とともに呼び出します。 
このメソッドは、join() を呼び出されたスレッドが、正常終了あるいは処理されない例外によって終了するか、オプションのタイムアウトが発生するまで、メソッドの呼び出し手となるスレッドをブロックします。 
スレッドの名前を返します。 
複数のスレッドに同じ名前をつけてもかまいません。 
名前の初期値はコンストラクタで設定されます。 
スレッドが生存中かどうかを返します。 
大雑把な言い方をすると、スレッドは start() メソッドを呼び出した瞬間から run() メソッドが終了するまでの間生存しています。 
スレッドのデーモンフラグを返します。 
Python インタプリタは完全にスレッド安全 (thread safe) ではありません。 
とはいえ、グローバル変数はまだ一つだけ残っています: それは現在のPyThreadState 
構造体を指すポインタです。 
ほとんどのスレッドパッケージが ``スレッドごとのグローバルデータ''を保存する手段を持っている一方で、Python の内部的なプラットフォーム非依存のスレッド抽象層はこれをサポートしていません。 
従って、現在のスレッド状態を明示的に操作するようにしなければなりません。 ほとんどのケースで、このような操作は十分簡単にできます。 
グローバルインタプリタロックを操作数ほとんどのコードは、以下のような単純な構造を持ちます: 
ローカル変数からスレッド状態を回復する。 このやりかたは非常に一般的なので、作業を単純にするために二つのマクロが用意されています: 
Py_BEGIN_ALLOW_THREADS...ブロックが起きるような何らかの I/O 操作...Py_END_ALLOW_THREADS 
マクロは新たなブロック文を開始し、隠しローカル変数を宣言します;Py_END_ALLOW_THREADS 
はブロック文を終了します。 
これらの二つのマクロを使うもうひとつの利点は、Python をスレッドサポートなしでコンパイルしたとき、マクロの内容、すなわちスレッド状態の退避とロック操作が空になるという点です。 スレッドサポートが有効になっている場合、上記のブロックは以下のようなコードに展開されます: 
PyThreadState *_save;_save = PyEval_SaveThread();...ブロックが起きるような何らかの I/O 操作...PyEval_RestoreThread(_save); 
より低水準のプリミティブを使うと、以下のようにしてほぼ同じ効果を得られます: 
PyThreadState *_save;_save = PyThreadState_Swap(NULL);PyEval_ReleaseLock();...ブロックが起きるような何らかの I/O 操作...PyEval_AcquireLock();PyThreadState_Swap(_save); 
上の二つには微妙な違いがあります; とりわけ、PyEval_RestoreThread() 
はグローバル変数 errno の値を保存しておいて元に戻す点が異なります。 
というのは、ロック操作が errno に何もしないという保証がないからです。 
また、スレッドサポートが無効化されている場合、PyEval_SaveThread() 
およびPyEval_RestoreThread() はロックを操作しません;この場合、PyEval_ReleaseLock() 
およびPyEval_AcquireLock() は利用できません。 
この仕様は、スレッドサポートを無効化してコンパイルされているインタプリタが、スレッドサポートが有効化された状態でコンパイルされている動的ロード拡張モジュールをロードできるようにするためのものです。 
グローバルインタプリタロックは、現在のスレッド状態を指すポインタを保護するために使われます。 
ロックを解放してスレッド状態を退避する際、ロックを解放する前に現在のスレッド状態ポインタを取得しておかなければなりません (他のスレッドがすぐさまロックを獲得して、自らのスレッド状態をグローバル変数に保存してしまうかもしれないからです)。 逆に、ロックを獲得してスレッド状態を復帰する際には、グローバル変数にスレッド状態ポインタを保存する前にロックを獲得しておかなければなりません。 
なぜここまで詳しく説明しようとするかおわかりでしょうか? それは、C でスレッドを生成した場合、そのスレッドにはグローバルインタプリタロックがなく、スレッド状態データ構造体もないからです。 
このようなスレッドが Python/C API を利用するには、まずスレッド状態データ構造体を生成し、次にロックを獲得し、そしてスレッド状態ポインタを保存するといったように、自分自身をブートストラップして生成しなければなりません。 
スレッドが作業を終えたら、スレッド状態ポインタをリセットして、ロックを解放し、最後にスレッド状態データ構造体をメモリ解放しなければなりません。 スレッドデータ構造体を生成する際には、インタプリタ状態データ構造体を指定する必要があります。 
インタプリタ状態データ構造体は、インタプリタ内の全てのスレッド間で共有されているグローバルなデータ、例えばモジュール管理データ (codesys.modules) を保持しています。 
必要に応じて、新たなインタプリタ状態データ構造体を作成するなり、Python メインスレッドが使っているインタプリタ状態データ構造体を共有するなりできます (後者のデータにアクセスするためには、スレッド状態データ構造体を獲得して、その interp メンバにアクセスしなければなりません; この処理は、Python が作成したスレッドから行うか、Python を初期化した後で主スレッドから行わねばなりません)。 
インタプリタオブジェクトにアクセスできるという仮定の下では、C のスレッドから Python を呼び出す際の典型的な常套句は以下のようになります。 
このデータ構造体は、協調動作する多数のスレッド間で共有されている状態 (state) を表現します。 
グローバルインタプリタロックもまた、スレッドがどのインタプリタに属しているかに関わらずすべてのスレッドで共有されています。 
単一のスレッドの状態を表現する表現するデータ構造体です。 
データメンバ PyInterpreterState * 
interpだけが公開されていて、スレッドのインタプリタ状態を指すポインタになっています。 
グローバルインタプリタロックを初期化し、獲得します。 
この関数は、主スレッドが第二のスレッドを生成する以前や、PyEval_ReleaseLock() 
やPyEval_ReleaseThread(tstate) 
といった他のスレッド操作に入るよりも前に呼び出されるようにしておかなければなりません。 
二度目に呼び出すと何も行いません。 
この関数をPy_Initialize() の前に呼び出しても安全です。 
ロックを使わない状況は、すでにロックを獲得している状況と同じです: 単一のスレッドしかなければ、オブジェクトへのアクセスは全て安全です。 
従って、この関数がロックを初期化すると、同時にロックを獲得するようになっています。 
Python の thread モジュールは、新たなスレッドを作成する前に、ロックが存在するか、あるいはまだ作成されていないかを調べ、PyEval_InitThreads() を呼び出します。 
この関数から処理が戻った場合、ロックが作成作成され、呼び出し元スレッドがそのロックを獲得している事が保証されています。 
どのスレッドが現在グローバルインタプリタロックを (存在する場合) 持っているか分からない時にこの関数を使うのは安全ではありません 。 この関数はコンパイル時にスレッドサポートを無効化すると利用できません。 
PyEval_InitThreads()をすでに呼び出している場合は真 (非ゼロ)を返します。 
この関数は、ロックを獲得せずに呼び出すことができますので、シングルスレッドで実行している場合にはロック関連のAPI呼び出しを避けるために使うことができます。 
この関数はコンパイル時にスレッドサポートを無効化すると利用できません。 
グローバルインタプリタロックを獲得します。 
ロックは前もって作成されていなければなりません。 
この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。 
この関数はコンパイル時にスレッドサポートを無効化すると利用できません。 
グローバルインタプリタロックを解放します。 
グローバルインタプリタロックを獲得し、現在のスレッド状態をtstate に設定します。 tstate は NULLであってはなりません。 
ロックはあらかじめ作成されていなければなりません。 
この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。 
現在のスレッド状態をリセットして NULL にし、グローバルインタプリタロックを解放します。 
ロックはあらかじめ作成されていなければならず、かつ現在のスレッドが保持していなければなりません。 
tstate はNULLであってはなりませんが、その値が現在のスレッド状態を表現しているかどうかを調べるためにだけ使われます -- もしそうでなければ、致命的エラーが報告されます。 この関数はコンパイル時にスレッドサポートを無効化すると利用できません。 
(インタプリタロックが生成されていて、スレッドサポートが有効の場合) インタプリタロックを解放して、スレッド状態を NULLにし、以前のスレッド状態 (NULLにはなりません) を返します。 
ロックがすでに生成されている場合、現在のスレッドがロックを獲得していなければなりません。 
(インタプリタロックが生成されていて、スレッドサポートが有効の場合) インタプリタロックを獲得して、現在のスレッド状態をtstate に設定します。 tstate は NULLであってはなりません。 
この関数を呼び出したスレッドがすでにロックを獲得している場合、デッドロックに陥ります。 
(この関数はコンパイル時にスレッドサポートを無効化すると利用できません。 
) 以下のマクロは、通常末尾にセミコロンを付けずに使います;Python ソース配布物内の使用例を見てください。 
このマクロを展開すると"{ PyThreadState *_save; _save = PyEval_SaveThread();"になります。 マクロに開き波括弧が入っていることに注意してください; この波括弧は後で Py_END_ALLOW_THREADS マクロと対応させなければなりません。 
マクロについての詳しい議論は上記を参照してください。 
コンパイル時にスレッドサポートが無効化されていると何も行いません。 
Py_END_ALLOW_THREADS このマクロを展開すると"PyEval_RestoreThread(_save); }"になります。 
マクロに開き波括弧が入っていることに注意してください; この波括弧は事前の Py_BEGIN_ALLOW_THREADS マクロと対応していなければなりません。 
このマクロを展開すると"PyEval_RestoreThread(_save);"になります: 閉じ波括弧のないPy_END_ALLOW_THREADSと同じです。 
コンパイル時にスレッドサポートが無効化されていると何も行いません。 
このマクロを展開すると"_save = PyEval_SaveThread();"になります: 閉じ波括弧のないPy_BEGIN_ALLOW_THREADSと同じです。 
コンパイル時にスレッドサポートが無効化されていると何も行いません。 
以下の全ての関数はコンパイル時にスレッドサポートが有効になっている時だけ利用でき、呼び出すのはインタプリタロックがすでに作成されている場合だけにしなくてはなりません。 
新しいインタプリタ状態オブジェクトを生成します。 
インタプリタロックを保持しておく必要はありませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよいでしょう。 
インタプリタ状態オブジェクト内の全ての情報をリセットします。 
インタプリタロックを保持していなければなりません。 
インタプリタ状態オブジェクトを破壊します。 
インタプリタロックを保持しておく必要はありません。 
インタプリタ状態はPyInterpreterState_Clear() であらかじめリセットしておかなければなりません。 
指定したインタプリタオブジェクトに属する新たなスレッド状態オブジェクトを生成します。 
インタプリタロックを保持しておく必要はありませんが、この関数を次々に呼び出す必要がある場合には保持しておいたほうがよいでしょう。 
スレッド状態オブジェクト内の全ての情報をリセットします。 
インタプリタロックを保持していなければなりません。 
スレッド状態オブジェクトを破壊します。 
インタプリタロックを保持していなければなりません。 
スレッド状態はPyThreadState_Clear() であらかじめリセットしておかなければなりません。 
現在のスレッド状態を返します。 
インタプリタロックを保持していなければなりません。 
拡張モジュールがスレッド固有の状態情報を保存できるような辞書を返します。 
各々の拡張モジュールが辞書に状態情報を保存するためには唯一のキーを使わねばなりません。 
スレッド内で非同期的に例外を送出します。 
グローバルインタプリタロックを保持した状態で呼び出さなければなりません。 
変更を受けたスレッド状態の数を返します; 1 よりも大きな数を返した場合、何らかのトラブルに巻き込まれていることになり、exc をNULL にして再度呼び出すことで効果を打ち消さねばなりません。 
Pythonの状態やスレッドロックに関わらず、実行中スレッドでPython C APIの呼び出しが可能となるようにします。 
この関数はスレッド内で何度でも呼び出すことができますが、必ず全ての呼び出しに対応してPyGILState_Release()を呼び出す必要があります。 
獲得したすべてのリソースを開放します。 
このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動を表現します。 
Timer はThread のサブクラスであり、自作のスレッドを構築した一例でもあります。 タイマは start() メソッドを呼び出すとスレッドとして作動し始めします。 
(活動を開始する前に) cancel() メソッドを呼び出すと、タイマを停止できます。 
タイマが活動を実行するまでの待ち時間は、ユーザが指定した待ち時間と必ずしも厳密には一致しません。 例: 
interval 秒後にfunction を引数 args、キーワード引数 kwargs つきで実行するようなタイマを生成します。 
タイマをストップして、その動作の実行をキャンセルします。 
このメソッドはタイマがまだ活動待ち状態にある場合にのみ動作します。 
16.1.3 Tcl/Tk を (本当に少しだけ) 
16.1.5 Tk と Tkinter 
Tkのクラスコマンドは、Tkinterのクラスコンストラクタに対応しています。 
オブジェクトの親 (master) は、オブジェクトの作成時に指定した新たな名前から非明示的に決定されます。 
Tkinter では親を明示的に指定します。 
Tk の設定オプションは、ハイフンをつけたタグと値の組からなるリストで指定します。 
Tkinter では、オプションはキーワード引数にしてインスタンスのコンストラクタに指定したり、config にキーワード引数を指定して呼び出したり、インデクス指定を使ってインスタンスに代入したりして設定します。 
オプションの設定については16.1.6 節を参照してください。 
　 button .fred -fg red ===== fred = Button(panel, fg = "red").fred configure -fg red ===== fred["fg"] = redOR == fred.config(fg = "red") 
Tk でウィジェットにアクションを実行させるには、ウィジェット名をコマンドにして、その後にアクション名を続け、必要に応じて引数(オプション) を続けます。 
Tkinter では、クラスインスタンスのメソッドを呼び出して、ウィジェットのアクションを呼び出します。 
あるウィジェットがどんなアクション (メソッド) を実行できるかは、Tkinter.py モジュール内にリストされています。 
Tk でウィジェットを packer (ジオメトリマネジャ) に渡すには、pack コマンドをオプション引数付きで呼び出します。 
Tkinter では Pack クラスがこの機能すべてを握っていて、 様々なpack の形式がメソッドとして実装されています。 
のウィジェットは全て Packer からサブクラス化されているため、pack 操作にまつわる全てのメソッドを継承しています。 
Form ジオメトリマネジャに関する詳しい情報については 
モジュールのドキュメントを参照してください。 
オプションは、色やウィジェットの境界線幅などを制御します。 オプションの設定には三通りの方法があります: 
オブジェクトを作成する時にキーワード引数を使う 
オブジェクトを作成した後、オプション名を辞書インデックスのように扱う 
オブジェクトを生成した後、config()メソッドを使って複数の属性を更新する 
オプションとその振る舞いに関する詳細な説明は、該当するウィジェットのTk の man マニュアルを参照してください。 man マニュアルには、各ウィジェットの "STANDARD OPTIONS(標準オプション)" と "WIDGET SPECIFIC OPTIONS(ウィジェット固有のオプション)" がリストされていることに注意しましょう。 
前者は多くのウィジェットに共通のオプションのリストで、後者は特定のウィジェットに特有のオプションです。 
標準オプションの説明は man マニュアルの 
options(3) にあります。 このドキュメントでは、標準オプションとウィジェット固有のオプションを区別していません。 
この辞書は、オプションの名前がキー (例えば 'relief') になっていて、値が5 要素のタプルになっています。 bg のように、いくつかのオプションはより長い名前を持つ共通のオプションに対する同義語になっています (bgは "background" を短縮したものです)。 
短縮形のオプション名を config() に渡すと、5 要素ではなく 2 要素のタプルを返します。 
このタプルには、同義語の名前と 「本当の」オプション名が入っています (例えば('bg', 'background'))。 
例 
データベース検索用のオプション名 
データベース検索用のオプションクラス 
現在の値 
もちろん、実際に出力される辞書には利用可能なオプションが全て表示されます。 
上の表示例は単なる例にすぎません。 
Tk/Tcl は長きにわたり Python の不可欠な一部でありつづけています。 
Tk/Tcl は頑健でプラットホームに依存しないウィンドウ構築ツールキットであり、 Python プログラマは 
モジュールやその拡張の 
モジュールを使って利用できます。 
モジュールは、 Tcl/Tk 上に作られた軽量なオブジェクト指向のレイヤです。 
を使うためにTcl コードを書く必要はありませんが、 Tk のドキュメントや、場合によっては Tcl のドキュメントを調べる必要があるでしょう。 
は Tk のウィジェットを Python のクラスとして実装しているラッパをまとめたものです。 
加えて、内部モジュール_tkinter では、 Python と Tcl がやり取りできるようなスレッド安全なメカニズムを提供しています。 Tk は Python にとって唯一の GUI というわけではありませんが、もっともよく使われています。 
Python 用の他の GUI ツールキットに関する詳しい情報は、16.6章、「他のユーザインタフェースモジュールとパッケージ」を参照してください。 
グラフィカルユーザインタフェースを実現する Tcl/Tk へのインタフェース 
Tkinter用のTk拡張ウィジェット 
垂直スクロールバーを持つテキストウィジェット。 
タートルグラフィックスのための環境。 
各種のMacOSツールボックスへのインターフェースを与えるモジュール群があります。 
対応するモジュールがあるなら、そのモジュールではツールボックスで宣言された各種の構造体のPythonオブジェクトが定義され、操作は定義されたオブジェクトのメソッドとして実装されています。 
その他の操作はモジュールの関数として実装されています。 
Cで可能な操作がすべてPythonで可能なわけではありませんし(コールバックはよく問題になります)、パラメータがPythonだと違ってしまうことはよくあります(特に入力バッファや出力バッファ)。 
全てのメソッドと関数は __doc__ 文字列があるので、引数と返り値の説明を得る事ができます。 他の情報源としては、 
などを参照してください。 これらのモジュールは全て Carbon パッケージに含まれています。 
注意！これらのモジュールはまだ文書化されていません。 
これらのモジュールのどれでもよいですが文書化に協力したいという方は、 docs@python.org まで連絡をください。 
Apple Eventツールボックスへのインタフェース 
Apple ヘルプマネージャへのインタフェース 
アピアランスマネージャへのインタフェース 
Core Foundationへのインタフェース 
Component Managerへのインタフェース 
Carbon Event Managerへのインタフェース 
Control Managerへのインタフェース 
Dialog Managerへのインタフェース 
Event Managerへのインタフェース 
Font Managerへのインタフェース 
Folder Managerへのインタフェース 
Carbon Help Managerへのインタフェース 
List Managerへのインタフェース 
Menu Managerへのインタフェース 
MultiLingual Text Editorへのインタフェース 
QuickDrawツールボックスへのインタフェース 
QuickDrawオフスクリーン APIへのインタフェース 
QuickTime ツールボックスへのインタフェース 
Resource Managerとハンドルへのインタフェース 
Carbon Scrap Managerへのインタフェース 
Sound Managerへのインタフェース 
TextEditへのインタフェース 
Window Managerへのインタフェース 
標準色選択ダイアログへのインターフェース 
7.1 外部ツール Python ドキュメントがサポートしている全ての出力形式を処理できるようにするには、数多くのツールが必要です。 
この節では、処理に使われている各ツールについて列挙し、各々がいつ必要になるのか説明しています。 
これらのツールのいずれかが特定のバージョンを要求しているかどうかは、Doc/README ファイルを調べてみてください。 
このプログラムはよく TeX インストールの一部になっています。 
dvips は ``デバイス非依存 (device independent)'' の.dvi ファイルから PostScript を生成するために使われます。 
PostScript への変換を行う際に必要です。 
Emacs はごちゃまぜ (kitchen sink) の、さらに言うとクソ素晴らしいごちゃまぜのプログラマ向けエディタです。 
info 形式に変換したい場合に、Texinfo ドキュメントの適切なメニュー階層の構築をサポートする上で必要な処理に関係しています。 
FSF の emacs の代わりに xemacsを使うと、変換がうまくいかないことがありますが、これは誰も Emacs のTexinfo コードをメンテナンスして可搬性のあるものにしないからだと思われます。 
LaTeX は、Laslie Lamport による拡張可能な大規模マクロパッケージで、Donald Knuth が作成した世界規模で使われているタイプセッタTeXに基づいています。 
PostScript 形式への変換に必要で、 HTML への変換にも必要です (LaTeX2HTML はLaTeX が生成する中間ファイルの一つを必要とするためです)。 
これまでにメンテナンスされたことのある Perl スクリプトの中でおそらく最長のスクリプトでしょう。 
このツールは LaTeX ドキュメントをHTML ドキュメントに変換し、そこそこ立派な仕事をします。 
HTML や GNU info 形式への変換に必要です。 
HTML から平文テキストへの変換機能を持つテキストモードの Web ブラウザです。 
howto ドキュメントをテキスト形式に変換する際に使います。 
どのバージョンの make も標準ドキュメントの処理に使えるはずですが、 実験段階にあるDoc/tools/sgmlconv/ の処理には、少なくとも実験段階にある間は GNU make が必要です。 
mkhowto スクリプトを走らせる場合には必要ありません。 
LaTeX の索引データをフォーマット済みの索引に変換するための標準プログラムです;全てのLaTeX インストール物に入っているはずです。 
PDF 形式と PostScript形式への変換に必要です。 
Texinfo から GNU info ファイルへの変換には GNU makeinfo を使います。 
Texinfo は info への変換における中間形式の処理に使われるので、info への変換にもこのプログラムが必要です。 
pdfTeX は比較的新しく登場した TeXの変種で、マニュアルの PDF 版を生成するために使います。 
通常、ほとんどの大規模な TeX 配布物の一部としてインストールされています。 
pdflatex は LaTeX 形式を扱う pdfTeX です。 
LaTeX2HTML やLaTeX2HTML 出力に対する仕上げ作業、HTMLからTexinfo への変換には Perl が必要です。 
HTML 形式や GNU info 形式への変換に必要です。 
Python は Doc/tools/ ディレクトリ内の多くのスクリプトで使われています; 全ての形式への変換で必要です。 
Python のドキュメントを書こうと思っているのなら、何も問題はないはずですよね! 
7.2 内部用ツール この節では、ドキュメント処理の様々な段階を実装したり、ビルド手順全体を演出する様々なスクリプトについて説明します。 
これらのツールのほとんどは標準ドキュメントを構築するというコンテキストでのみ有用ですが、汎用的なものもあります。 
サードパーティ製のドキュメントをフォーマットする際に最初に使うスクリプトです。 
mkhowto は howto と manual クラスのどちらのドキュメントにも使えます。 
このツールは、古い Python のソースリリースに入っているバージョンではなく、常に最新のバージョンを使うようにするのがよいでしょう。 
これらのツールは、 DVI、HTML、PDF、PostScript、およびプレインテキスト形式のドキュメント生成に利用できます。 
将来のバージョンでは、このスクリプトで GNU info および iSilo 形式も扱えるようにする予定です。 コマンドラインで--help オプションを使ってこれらのスクリプトを実行すれば、利用できるオプションをまとめたものを表示します。 
7.1 外部ツール 
Python インタプリタは、標準入力や、プログラムの引数として与えられたスクリプト、対話的にタイプ入力された命令、モジュールのソースファイルなど、様々な入力源から入力を得ることができます。 
この章では、それぞれの場合に用いられる構文法について説明しています。 
この簡単な例では基本的なread-eval-printループを実装います。 それは標準的なPythonの対話インタープリタループに似ていますが、Pythonのものより便利ではありません。 
インタープリタループのより完全な実装については、 
モジュールを参照してください。 
1.1 もっとも簡単な場合: ありふれたインストール作業 
Python の広範な標準ライブラリは、プログラミングにおける多くの要求をカバーしていますが、時には何らかの新たな機能をサードパーティ製モジュールの形で追加する必要に迫られます。 
自分がプログラムを書くときのサポートとして必要な場合もあるし、自分が使いたいアプリケーションがたまたま Python で書かれていて、そのサポートとして必要な場合もあるでしょう。 
このドキュメントを読むために、 Python について知っておく必要はありません; インストールしたモジュールを調べるために Python の対話モードにちょっとだけ手を出す必要がありますが、それだけです。 
自作の Python モジュールを他人が使えるようにするために配布する方法を探しているのなら、 
最も楽なのは、インストールしたいモジュール配布物の特殊なバージョンをインストールしたいプラットフォーム向けに誰かがすでに用意してくれていて、他のアプリケーションと同じようにインストールするだけであるような場合です。 
例えば Windows ユーザ向けには実行可能形式のインストーラ、RPM ベースの Linux システム (Red Hat, SuSE, Mandrake その他多数) 向けには RPM パッケージ、 Debian ベースの Linux システム向けには Debian パッケージといった具合に、モジュール開発者はビルド済み配布物を作成しているかもしれません。 このような場合、自分のプラットフォームに合ったインストーラをダウンロードして、実行可能形式なら実行し、RPM なら rpm -install するといった、分かりきった作業をするだけです。 
Python を起動したり、 setup スクリプトを実行する必要はなく、何もコンパイルする必要はありません -- 説明書きを読む必要すら全くないかもしれません (とはいえ、説明書きを読むのはよいことですが)。 もちろん、いつもこう簡単とは限りません。 
自分のプラットフォーム向けのお手軽なインストーラがないモジュール配布物に興味を持つこともあるでしょう。 
そんな場合には、モジュールの作者やメンテナがリリースしているソース配布物から作業をはじめねばなりません。 
ソース配布物からのインストールは、モジュールが標準的な方法でパッケージ化されている限りさほど大変ではありません。 
このドキュメントの大部分は、標準的なソース配布物からのビルドとインストールに関するものです。 
モジュールのソースコード配布物をダウンロードしたら、配布物が標準のやり方、すなわち Distutils のやり方に従ってパッケージされて配布されているかどうかすぐに分かります。 
Distutils の場合、まず配布物の名前とバージョン番号が、例えば foo-1.0.tar.gz やwidget-0.9.7.zip のように、ダウンロードされたアーカイブファイルの名前にはっきりと反映されます。 
次に、アーカイブは同様の名前のディレクトリ、例えば foo-1.0 や widget-0.9.7 に展開されます。 
さらに、配布物には setup スクリプト setup.py が入っています。 また、README.txt 場合によっては README という名前のファイルも入っていて、そこには、モジュール配布物の構築とインストールは簡単で、 
別の言葉で言えば、上のコマンドこそが、このマニュアルから習得すべき全てということになります。 
2.3.1 真値テスト どのオブジェクトも if または while 条件文の中や、以下のブール演算における被演算子として真値テストを行うことができます。 
以下の値は偽であると見なされます: 
数値型におけるゼロ。 例えば 0 、 0L 、0.0 、 0j 。 
空のシーケンス型。 例えば '' 、 () 、 [] 。 
空のマッピング型。 例えば {} 。 
__nonzero__() または __len__() メソッドが定義されているようなユーザ定義クラスのインスタンスで、それらのメソッドが整数値ゼロまたは bool 値の False を返すとき。 
それ以外の値は全て真であると見なされます -- 従って、ほとんどの型のオブジェクトは常に真です。 
ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値として 0 またはFalse を返し、真値として 1 または True を返します (重要な例外: ブール演算"or" 
および "and" 
は常に被演算子の中の一つを返します)。 
これらの特殊なメソッドに関する追加情報は 
に記載されています。 
try 文は、ひとまとめの文に対して、例外処理かつ/またはクリーンアップコードを指定します: 
try 文には二つの形式:try...except およびtry...finally があります。 
これら二つの形式を混合することはできません (互いにネストすることはできます)。 try...except 形式では、一つまたはそれ以上の例外ハンドラ (except 節) を指定します。 
try 節内で全く例外が起きなければ、どの例外ハンドラも実行されません。 
try スイート内で例外が発生すると、例外ハンドラの検索が開始されます。 
この検索では、except 節を逐次調べて、発生した例外に合致するまで続けます。 
式を伴わない except 節を使う場合、最後に書かなければなりません; この except 節は全ての例外に合致します。 
式を伴う except 節に対しては、式が値評価され、返されたオブジェクトが例外と ``互換である (compatible)'' 場合にその節が合致します。 
ある例外に対してオブジェクトが互換であるのは、オブジェクトがその例外のアイデンティティを持つオブジェクトであるか、(クラスの例外の場合) 例外の基底クラスであるか、例外と互換性のある要素が入ったタプルである場合です。 
同じ値を持つオブジェクトであるだけでなく、アイデンティティが合致しなければならないので注意してください。 
except 節は全て実行可能なブロックを持っていなければなりません。 
ブロックの末尾に到達すると、通常は try 文全体の直後に実行を継続します。 
モジュール内の三つの変数に代入されます: sys.exc_type は、例外を示すオブジェクトを受け取ります; sys.exc_value は例外のパラメタを受け取ります;sys.exc_traceback は、プログラム上の例外が発生した位置を識別するトレースバックオブジェクト 
ただしこの関数に対応する変数の使用は、スレッドを使ったプログラムで安全に使えないため撤廃されています。 
Python 1.5 からは、例外を処理した関数から戻るときに、以前の値(関数呼び出し前の値) に戻されます。 
オプションの else 節は、実行の制御が try 節の末尾に到達した場合に実行されます。 
else 節内で起きた例外は、else 節に先行するexcept 節で処理されることはありません。 
try...finally 形式では、`クリーンアップ' ハンドラを指定します。 
まず try 節が実行されます。 
例外が全く発生しなければ、finally 節が実行されます。 
例外がtry 節内で発生した場合、例外は一時的に保存され、finally が実行された後、保存されていた例外が再送出されます。 
finally 節で別の例外が送出されたり、return やbreak 節が実行された場合、保存されていた例外は失われます。 
finally 節での continue 文の使用は不正となります(理由は現在の実装上の問題にあります -- この制限は将来解消されるかもしれません)。 
finally 節の実行中は、例外情報を取得することはできません。 
try...finally 文の try スイート内でreturn、 break、または continue 文が実行された場合、finally 節も `抜け出る途中に (on the way out)'実行されます。 
例外に関するその他の情報は4.2 節にあります。 
また、raise 文の使用による例外の生成に関する情報は、6.9 節にあります。 
...の末尾に到達した場合に実行されます。 
現在、制御が ``末尾に到達する'' のは、例外が発生したり、return、continue、または break 文が実行される場合を除きます。 
この PyObject のサブタイプは Python のタプルオブジェクトを表現します。 
この PyTypeObject のインスタンスは Python のタプル型を表現します; Python レイヤにおける types.TupleType 
と同じオブジェクトです。 
p がタプルオブジェクトか、タプル型のサブタイプのインスタンスである場合に真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
p がタプルオブジェクトで、かつタプル型のサブタイプのインスタンスでない場合に真を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
サイズが len 新たなタプルオブジェクトを返します。 失敗すると NULL を返します。 
"PyTuple_Pack(2, a, b)"は "Py_BuildValue("(OO)", a, b)" と同じです。 バージョン 2.4 で 新たに追加 された仕様です。 
タプルオブジェクトへのポインタを引数にとり、そのタプルのサイズを返します。 
タプル p のサイズを返しますが、p は非 NULL でなくてはならず、タプルオブジェクトを指していなければなりません;エラーチェックを行いません。 
p の指すタプルオブジェクト内の、位置 pos にあるオブジェクトを返します。 
PyTuple_GetItem() に似ていますが、引数に対するエラーチェックを行いません。 
p の指すタプルオブジェクト内の、位置 low からhigh までのスライスを取り出して、タプルオブジェクトとして返します。 
p の指すタプルオブジェクト内の位置 pos に、オブジェクト o への参照を挿入します。 
成功した場合には0 を返します。 
注意:この関数は o への参照を ``盗み取り'' ます。 
PyTuple_SetItem() に似ていますが、エラーチェックを行わず、新たなタプルに値を入れるとき 以外には使ってはなりません。 
注意:この関数は o への参照を ``盗み取り'' ます。 
タプルをリサイズする際に使えます。 newsize はタプルの新たな長さです。 
タプルは変更不能なオブジェクト ということになっているので、この関数は対象のオブジェクトに対してただ一つしか参照がない時以外には使ってはなりません。 
タプルがコード中の他の部分ですでに参照されている場合には、この関数を 使ってはなりません。 
タプルは常に指定サイズの末尾まで伸縮します。 
の値が呼び出し前と同じになると気体してはなりません。 
*p が置き換えられた場合、オリジナルの *p 
は破壊されます。 
失敗すると -1 を返し、 *p をNULL に設定して、 MemoryError またはSystemError を送出します。 
バージョン 2.2 で 変更 された仕様:使われていなかった三つ目のパラメタ、last_is_sticky を削除しました 
12. さあ何を？ 
7 日本語訳について 
Distutils は、可能なときにはいつでも、 setup.py スクリプトを実行する Python インタプリタが提供する設定情報を使おうとします。 
例えば、拡張モジュールをコンパイルする際には、コンパイラやリンカのフラグには Python をコンパイルした際と同じものが使われます。 
通常、この設定はうまくいきますが、状況が複雑になると不適切な設定になることもあります。 
この節では、通常の Distutils の動作をオーバライドする方法について議論します。 
C や C++ で書かれた Python 拡張をコンパイルする際、しばしば特定のライブラリを使ったり、特定の種類のオブジェクトコードを生成したりする上で、コンパイラやリンカに与えるフラグをカスタマイズする必要があります。 ある拡張モジュールが自分のプラットフォームではテストされていなかったり、クロスコンパイルを行わねばならない場合にはこれが当てはまります。 
Setup ファイルの各行には単一のモジュールを書きます。 
各行は以下のような構造をとります: 
次に、各フィールドについて見てみましょう。 
module はビルドする拡張モジュールの名前で、Python の識別子名として有効でなければなりません。 
モジュールの名前変更は、このフィールドを変えるだけではできない (ソースコードの編集も必要です) ので、このフィールドに手を加えるべきではありません。 
sourcefile は、少なくともファイル名から何の言語で書かれているかがわかるようになっているソースコードファイル名です。 
.c で終わるファイルは C で書かれているとみなされ、.C、.cc、および .c++ で終わるファイルはC++ で書かれているとみなされます。 .m や .mm で終わるファイルは Objective C で書かれているとみなされます。 
cpparg は C プリプロセッサへの引数で、-I、 -D、-U または -Cのいずれかから始まる文字列です。 
library は .a で終わるか、-l または -L のいずれかから始まる文字列です。 
特定のプラットフォームにおいて、プラットフォーム上の特殊なライブラリが必要な場合、 Setup ファイルを編集してpython setup.py build を実行すればライブラリを追加できます。 
例えば、以下の行 
で定義されたモジュールを、自分のプラットフォーム上の数学ライブラリlibm.a とリンクしなければならない場合、Setup 内の行に -lm を追加するだけです: 
コンパイラやリンカ向けの任意のスイッチオプションは、-Xcompiler arg や-Xlinker arg オプションで与えます: 
-Xcompiler および -Xlinker の後にくるオプションは、それぞれ適切なコマンドラインに追加されます。 従って、上の例では、コンパイラには -o32 オプションが渡され、リンカには -shared が渡されます。 
コンパイラオプションに引数が必要な場合、複数の -Xcompiler オプションを与えます; 例えば、 -x c++ を渡すには、Setup ファイルには -Xcompiler -x -Xcompiler c++を渡さねばなりません。 コンパイラフラグは、環境変数 CFLAGS の設定でも与えられます。 
CFLAGS が設定されていれば、Setup ファイル内で指定されているコンパイラフラグに CFLAGS の内容が追加されます。 
この小節では、 Borland C++ コンパイラのバージョン 5.5 でDistutils を使うために必要な手順について述べています。 まず、 Borland のオブジェクトファイル形式 (OMF)は、Python 公式サイトや ActiveState の Web サイトからダウンロードできるバージョンの Python が使っている形式とは違うことを知っておかねばなりません (Python は通常、 Microsoft Visual C++ でビルドされています。 
Microsoft Visual C++ は COFF をオブジェクトファイル形式に使います。 )このため、以下のようにして、 Python のライブラリ python24.lib を Borland の形式に変換する必要があります: 
coff2omf プログラムは、 Borland コンパイラに付属しています。 
python24.lib は Python インストールディレクトリの Libs ディレクトリ内にあります。 
拡張モジュールで他のライブラリ (zlib, ...)を使っている場合、それらのライブラリも変換しなければなりません。 変換されたファイルは、通常のライブラリと同じディレクトリに置かねばなりません。 
さて、 Distutils は異なる名前を持つこれらのライブラリをどのように扱うのでしょうか? 拡張モジュールで (例えば foo という名の)ライブラリが必要な場合、 Distutils はまず _bcpp が後ろに付いたライブラリ (例えば foo_bcpp.lib) が見つかるかどうか調べ、あればそのライブラリを使います。 
該当するライブラリがなければ、デフォルトの名前 (foo.lib) を使います 
。 Borland C++ を使って Distutils に拡張モジュールをコンパイルさせるには、以下のように入力します: 
Borland C++ コンパイラをデフォルトにしたいなら、自分用、またはシステム全体向けに、 Distutils の設定ファイルを書くことを検討した方がよいでしょう (5 節を参照してください)。 
Borland によるフリーの C++ コンパイラに関する情報で、コンパイラのダウンロードページへのリンクもあります。 
Borland 製のフリーのコマンドライン C++ を使って Python をビルドする方法について述べたドキュメントです。 
この節では、 Cygwin や MinGW 
これで、上で得られた情報をもとに、 gcc 用の import ライブラリを作成できます。 
python setup.py build --compiler=cygwin のように入力します。 
また、非 cygwin モードの Cygwin 
や MinGW では、 
のように入力します。 上記のオプションやコンパイラをデフォルトにしたいなら、自分用、またはシステム全体向けに、 Distutils の設定ファイルを書くことを検討した方がよいでしょう (5 節を参照してください)。 
MinGW 環境で必要なライブラリのビルドに関する情報があります。 
Cygwin/MinGW および Borland 形式に変換済みの import ライブラリと、Distutils がビルド済みの Python の場所を特定するために必要なレジストリエントリを作成するためのスクリプトがあります。 
... を使います 
つまり、全ての既存の COFF ライブラリを同名の OMF ライブラリに置き換えてもかまわないということです 
詳しくはhttp://sources.redhat.com/cygwin/ やhttp://www.mingw.org/ を参照してください 
このモードでは POSIX エミュレーションを利用できませんが、cygwin1.dll も必要なくなります。 
7 日本語訳について 
新形式の型を定義する構造体: PyTypeObject 構造体は、おそらくPython オブジェクトシステムの中で最も重要な構造体の一つでしょう。 
この節では、型オブジェクトの各フィールドについて詳細を説明します。 
参照の手間を省くために、ここでは定義を繰り返します: 
型オブジェクト構造体はPyVarObject 構造体を拡張したものです。 ob_size フィールドは、(通常 class 文が呼び出すtype_new() で生成される) 動的な型に使います。 
これらのフィールドはマクロ Py_TRACE_REFS が定義されている場合のみ存在します。 
PyObject_HEAD_INIT マクロを使うと、フィールドを NULL に初期化します。 
静的にメモリ確保されているオブジェクトでは、これらのフィールドは常に NULLのままです。 
動的にメモリ確保されるオブジェクトの場合、これら二つのフィールドは、ヒープ上の全ての 存続中のオブジェクトからなる二重リンクリストでオブジェクトをリンクする際に使われます。 
このことは様々なデバッグ目的に利用できます; 現状では、環境変数PYTHONDUMPREFS が設定されているときに、プログラムの実行終了時点で存続しているオブジェクトを出力するのが唯一の用例です。 サブタイプはこのフィールドを継承しません。 
ob_refcnt かたオブジェクトの参照カウントで、PyObject_HEAD_INIT はこの値を 1 に初期化します。 
静的にメモリ確保された型オブジェクトでは、型のインスタンス (ob_type が該当する型を指しているオブジェクト) は参照をカウントする対象にはなりません。 
動的にメモリ確保される型オブジェクトの場合、インスタンスは参照カウントの対象になります。 
サブタイプはこのフィールドを継承しません。 
型自体の型、別の言い方をするとメタタイプです。 PyObject_HEAD_INIT マクロで初期化され、通常はPyType_Type になります。 
しかし、(少なくとも) Windows で利用できる動的ロード可能な拡張モジュールでは、コンパイラは有効な初期化ではないと文句をつけます。 
そこで、ならわしとして、PyObject_HEAD_INIT には NULL を渡して初期化しておき、他の操作を行う前にモジュールの初期化関数で明示的にこのフィールドを初期化することになっています。 
この操作は以下のように行います: Foo_Type.ob_type = PyType_Type; 
上の操作は、該当する型のいかなるインスタンス生成よりも前にしておかねばなりません。 
PyType_Ready() はob_type が NULLかどうか調べ、NULLの場合には初期化します: Python 2.2 では、PyType_Type にセットします; in Python 2.2.1 およびそれ以降では基底クラスのob_type フィールドに初期化します。 
ob_type が非ゼロの場合、PyType_Ready() はこのフィールドを変更しません。 Python 2.2 では、サブタイプはこのフィールドを継承しません。 
2.2.1 と 2.3 以降では、サブタイプはこのフィールドを継承します。 
静的にメモリ確保されている型オブジェクトの場合、このフィールドはゼロに初期化されます。 
動的にメモリ確保されている型オブジェクトの場合、このフィールドは内部使用される特殊な意味を持ちます。 サブタイプはこのフィールドを継承しません。 
型の名前が入っている NUL 終端された文字列へのポインタです。 
モジュールのグローバル変数としてアクセスできる型の場合、この文字列は完全なモジュール名、ドット、そして型の名前と続く文字列になります; 組み込み型の場合、ただの型の名前です。 
モジュールがあるパッケージのサブモジュールの場合、完全なパッケージ名が完全なモジュール名の一部になっています。 
ドットが入っていない場合、tp_name フィールドの内容全てが__name__ 属性になり、 __module__ 属性は(前述のように型の辞書内で明示的にセットしないかぎり) 未定義になります。 このため、こうした型オブジェクトは pickle 化できないことになります。 
サブタイプはこのフィールドを継承しません。 
これらのフィールドは、型インスタンスのバイトサイズを計算できるようにします。 
N の値は通常、インスタンスの ob_size フィールドに記憶されます。 
ただし例外がいくつかあります:例えば、長整数では負の値を ob_size に使って、インスタンスの表す値が負であることを示し、 N 自体は abs(ob_size)になります。 
従って、tp_basicsize の正しい初期化パラメタを得るには、インスタンスデータのレイアウトを宣言するのに使う構造体に対してsizeof 演算子を使うしかありません。 
基本サイズには、GC ヘッダサイズは入っていません (これはPython 2.2 からの新しい仕様です; 2.1 や 2.0 では、GC ヘッダサイズはtp_basicsize に入っていました)。 
バイト整列 (alignment) に関する注釈: 変数の各要素を配置する際に特定のバイト整列が必要となる場合、tp_basicsize の値に気をつけなければなりません。 
インスタンスのデストラクタ関数へのポインタです。 
この関数は(単量子None やEllipsis の場合のように、インスタンスが決してメモリ解放されない型でない限り) 必ず定義しなければなりません。 デストラクタ関数は、Py_DECREF() や Py_XDECREF() マクロで、操作後の参照カウントがゼロになった際に呼び出されます。 
呼び出された時点では、インスタンスはまだ存在しますが、インスタンスに対する参照は全ない状態です。 
デストラクタ関数はインスタンスが保持している全ての参照を解放し、インスタンスが確保している全てのメモリバッファを(バッファの確保時に使った関数に対応するメモリ解放関数を使って)解放し、最後に (かならず最後に行う操作として) その型の tp_free関数を呼び出します。 
ある型がサブタイプを作成できない (Py_TPFLAGS_BASETYPE フラグがセットされていない) 場合、tp_free の代わりにオブジェクトのメモリ解放関数 (deallocator) を直接呼び出してもかまいません。 
オブジェクトのメモリ解放関数は、インスタンスのメモリ確保を行う際に使った関数と同じファミリでなければなりません; インスタンスを PyObject_New() やPyOject_VarNew() でメモリ確保した場合には、通常PyObject_Del() を使い、PyObject_GC_New() やPyObject_GC_VarNew() で確保した場合にはPyObject_GC_Del() を使います。 サブタイプはこのフィールドを継承します。 
出力関数は、インスタンスが 実体のある (real) ファイルに出力される場合にのみ呼び出されます; (StringIO インスタンスのような)擬似ファイルに出力される場合には、インスタンスの tp_repr やtp_str が指す関数が呼び出され、文字列への変換を行います。 
また、tp_print が NULLの場合にもこれらの関数が呼び出されます。 
tp_repr や tp_str と異なる出力を生成するようなtp_print は、決して型に実装してはなりません。 出力関数はPyObject_Print() と同じシグネチャ:int tp_print(PyObject *self, FILE *file, int flags)で呼び出されます。 
self 引数は出力するインスタンスを指します。 
tp_getattr オプションのフィールドです。 
ポインタで、get-attribute-string を行う関数を指します。 このフィールドは撤廃されています。 
このフィールドを定義する場合、tp_getattro 関数と同じように動作し、属性名は Python 文字列オブジェクトではなく C 文字列で指定するような関数を指すようにしなければなりません。 
シグネチャは PyObject_GetAttrString()と同じです。 このフィールドはtp_getattro と共にサブタイプに継承されます: すなわち、サブタイプのtp_getattr およびtp_getattro が共に NULLの場合、サブタイプは基底タイプからtp_getattr と tp_getattro を一緒に継承します。 
tp_setattr オプションのフィールドです。 
ポインタで、set-attribute-string を行う関数を指します。 このフィールドは撤廃されています。 
このフィールドを定義する場合、tp_setattro 関数と同じように動作し、属性名は Python 文字列オブジェクトではなく C 文字列で指定するような関数を指すようにしなければなりません。 
シグネチャは PyObject_SetAttrString()と同じです。 このフィールドはtp_setattro と共にサブタイプに継承されます: すなわち、サブタイプのtp_setattr およびtp_setattro が共に NULLの場合、サブタイプは基底タイプからtp_setattr と tp_setattro を一緒に継承します。 
この関数は self が other よりも大きければ 1、self と other の値が等しければ 0、self が other より小さければ -1 を返します。 
この関数は、比較操作中にエラーが生じた場合、例外状態をセットして-1 を返さねばなりません。 このフィールドはtp_richcompare およびtp_hashと共にサブタイプに継承されます: すなわち、サブタイプのtp_compare 、tp_richcompare およびtp_hash が共に NULLの場合、サブタイプは基底タイプからtp_compare、tp_richcompare、tp_hash の三つを一緒に継承します。 
tp_repr オプションのフィールドです。 
ポインタで、組み込み関数repr() 
理想的には、この関数が返す文字列は、適切な環境でeval() に渡した場合、同じ値を持つオブジェクトになるような文字列でなければなりません。 
tp_hash オプションのフィールドです。 
ポインタで、組み込み関数hash() 
tp_call オプションのフィールドです。 
ポインタで、オブジェクトの呼び出しを実装している関数を指します。 
オブジェクトが呼び出し可能でない場合には NULL にしなければなりません。 
シグネチャは PyObject_Call() と同じです。 サブタイプはこのフィールドを継承します。 
tp_str オプションのフィールドです。 
ポインタで、組み込みの演算 str() を実装している関数を指します。 
(str が型の一つになったため、str() は str のコンストラクタを呼び出すことに注意してください。 
このフィールドが設定されていない場合、文字列表現を返すためにはPyObject_Repr() が呼び出されます。 サブタイプはこのフィールドを継承します。 
tp_getattro オプションのフィールドです。 
ポインタで、get-attribute を実装している関数を指します。 シグネチャはPyObject_GetAttr() と同じです。 
対する通常の属性検索を実装しているPyObject_GenericGetAttr() をこのフィールドに設定しておくと往々にして便利です。 このフィールドはtp_getattr と共にサブタイプに継承されます: すなわち、サブタイプのtp_getattr およびtp_getattro が共に NULLの場合、サブタイプは基底タイプからtp_getattr と tp_getattro を一緒に継承します。 
tp_setattro オプションのフィールドです。 
ポインタで、set-attribute を行う関数を指します。 シグネチャはPyObject_SetAttr() と同じです。 
対する通常の属性設定を実装しているPyObject_GenericSetAttr() をこのフィールドに設定しておくと往々にして便利です。 このフィールドはtp_setattr と共にサブタイプに継承されます: すなわち、サブタイプのtp_setattr およびtp_setattro が共に NULLの場合、サブタイプは基底タイプからtp_setattr と tp_setattro を一緒に継承します。 
バッファインタフェースを実装しているオブジェクトにのみ関連する、一連のフィールド群が入った別の構造体を指すポインタです。 
構造体内の各フィールドは ``バッファオブジェクト構造体'' (10.7 節) で説明します。 tp_as_buffer フィールド自体は継承されませんが、フィールド内に入っているフィールドは個別に継承されます。 
このフィールドは様々なフラグからなるビットマスクです。 
いくつかのフラグは、特定の状況において変則的なセマンティクスが適用されることを示します; その他のフラグは、型オブジェクト(あるいはtp_as_number、tp_as_sequence、tp_as_mapping、およびtp_as_buffer が参照している拡張機能構造体: extention structure ) の特定のフィールドのうち、過去から現在までずっと存在しているわけではないもの が有効になっていることを示すために使われます;フラグビットがクリアであれば、フラグが保護しているフィールドにはアクセスしない代わりに、その値はゼロかNULL になっているとみなさなければなりません。 このフィールドの継承は複雑です。 
ほとんどのフラグビットは個別に継承されます。 つまり、基底タイプであるフラグビットがセットされている場合、サブタイプはそのフラグビットを継承します。 
機能拡張のための構造体に関するフラグビットは、その機能拡張構造体が継承されるときに限定して継承されます。 すなわち、基底タイプのフラグビットの値は、機能拡張構造体へのポインタと一緒にサブタイプにコピーされます。 
PyType_HasFeature() マクロは型とフラグ値、tp および f をとり、 
が非ゼロかどうか調べます。 
このビットがセットされていれば、tp_as_buffer が参照するPyBufferProcs 構造体には bf_getcharbuffer フィールドがあります。 
このビットがセットされていれば、tp_as_sequence が参照するPySequenceMethods 構造体には sq_contains フィールドがあります。 
このビットは旧式のものです。 
このシンボルが指し示していたビットはもはや使われていません。 
シンボルの現在の定義はゼロになっています。 
このビットがセットされていれば、tp_as_sequence が参照するPySequenceMethods 構造体、およびtp_as_number が参照するPyNumberMethods 構造体には in-place 演算に関するフィールドが入っています。 
具体的に言うと、 PyNumberMethods構造体はフィールド nb_inplace_add、nb_inplace_subtract、 nb_inplace_multiply、nb_inplace_divide、 nb_inplace_remainder、nb_inplace_power、 nb_inplace_lshift、nb_inplace_rshift、 nb_inplace_and、nb_inplace_xor、および nb_inplace_orを持つことになります; また、PySequenceMethods 構造体はフィールドsq_inplace_concat および sq_inplace_repeatを持つことになります。 Py_TPFLAGS_CHECKTYPES 
このビットがセットされていれば、tp_as_number が参照するPyNumberMethods 構造体内で定義されている二項演算子および三項演算子は任意のオブジェクト型を非演算子にとるようになり、必要に応じて引数の型変換を行います。 
このビットがクリアなら、演算子は全ての引数が現在のオブジェクト型と同じであるよう要求し、演算の呼び出し側は演算に先立って型変換を行うものと想定します。 
対象となる演算子は nb_add、nb_subtract、 nb_multiply、 nb_divide、nb_remainder、 nb_divmod、 nb_power、nb_lshift、 nb_rshift、 nb_and、nb_xor、および nb_or です。 
このビットがセットされていれば、型オブジェクトにはtp_richcompare フィールド、そして tp_traverseおよび tp_clear フィールドがあります。 
このビットがセットされていれば、構造体にはtp_weaklistoffset フィールドが定義されています。 
tp_weaklistoffset フィールドの値がゼロより大きければ、この型のインスタンスは弱参照で参照できます。 
このビットがセットされていれば、型オブジェクトにはtp_iter および tp_iternext フィールドがあります。 
このビットがセットされていれば、型オブジェクトは Python 2.2 以降で定義されている新たなフィールド: tp_methods、 tp_members、tp_getset、 tp_base、 tp_dict、tp_descr_get、 tp_descr_set、tp_dictoffset、 tp_init、 tp_alloc、tp_new、 tp_free、 tp_is_gc、tp_bases、 tp_mro、 tp_cache、tp_subclasses、 および tp_weaklist があります。 
型オブジェクト自体がヒープにメモリ確保される場合にセットされるビットです。 
型オブジェクト自体がヒープにメモリ確保される場合、インスタンスの ob_type フィールドは型オブジェクトへの参照とみなされます。 
この場合、新たなインスタンスを生成する度に型オブジェクトを INCREF し、インスタンスを解放するたびにDECREF します (サブタイプのインスタンスには適当されません; インスタンスが ob_type で参照している型だけがINCREF および DECREF されます)。 Py_TPFLAGS_BASETYPE 
型を別の型の基底タイプとして使える場合にセットされるビットです。 
このビットがクリアならば、この型のサブタイプは生成できません(Java における "final" クラスに似たクラスになります)。 
型オブジェクトが PyType_Ready() で完全に初期化されるとセットされるビットです。 
PyType_Ready() による型オブジェクトの初期化処理中にセットされるビットです。 
オブジェクトがガベージコレクション (GC) をサポートする場合にセットされるビットです。 
このビットがセットされている場合、インスタンスはPyObject_GC_New() を使って生成し、PyObject_GC_Del() を使って破壊しなければなりません。 
詳しい情報は XXX 節のガベージコレクションに関する説明中にあります。 
このビットはまた、GC に関連するフィールドtp_traverse およびtp_clear が型オブジェクト内に存在することを示します;しかし、これらのフィールドは Py_TPFLAGS_HAVE_GC がクリアでもPy_TPFLAGS_HAVE_RICHCOMPARE がセットされている場合には存在します。 
型オブジェクトおよび拡張機能構造体の特定のフィールドの存在の有無に関連する全てのビットからなるビットマスクです。 
オプションのフィールドです。 
ポインタで、この型オブジェクトのdocstring を与える NUL 終端された C の文字列を指します。 
この値は型オブジェクトと型のインスタンスにおける__doc__ 属性として公開されます。 サブタイプはこのフィールドを継承しません。 
以下の三つのフィールドは、Py_TPFLAGS_HAVE_RICHCOMPARE フラグビットがセットされている場合にのみ存在します。 
tp_traverse オプションのフィールドです。 
ポインタで、ガベージコレクタのためのトラバーサル関数 (traversal function)を指します。 
Py_TPFLAGS_HAVE_GC がセットされている場合にのみ使われます。 
ガベージコレクションに関する詳細は10.9 にあります。 このフィールドは tp_clear および Py_TPFLAGS_HAVE_GCフラグビットと一緒に継承されます: フラグビット、tp_traverse、および tp_clear の値がサブタイプで全てゼロになっており、かつ サブタイプで Py_TPFLAGS_HAVE_RICHCOMPARE フラグビットがセットされている場合に、基底タイプから値を継承します。 
tp_clear オプションのフィールドです。 
ポインタで、ガベージコレクタにおける消去関数 (clear function) を指します。 
この関数は、要求された比較演算が真を返す場合に 1 を、偽を返す場合に 0 を返さなければなりません。 
比較 
次のフィールドは、Py_TPFLAGS_HAVE_WEAKREFSフラグビットがセットされている場合にのみ存在します。 
型のインスタンスが弱参照可能な場合、このフィールドはゼロよりも大きな数になり、インスタンス構造体における弱参照リストの先頭を示すオフセットが入ります (GC ヘッダがある場合には無視します);このオフセット値は PyObject_ClearWeakRefs() およびPyWeakref_*() 関数が利用します。 
次の二つのフィールドは、Py_TPFLAGS_HAVE_CLASSフラグビットがセットされている場合にのみ存在します。 
An optional pointer to a function that returns an iterator for theobject. Its presence normally signals that the instances of thistype are iterable (although sequences may be iterable without thisfunction, and classic instances always have this function, even ifthey don't define an __iter__() method).This function has the same signature asPyObject_GetIter().サブタイプはこのフィールドを継承します。 
tp_iternext オプションのフィールドです。 
ポインタで、イテレータにおいて次の要素を返すか、イテレータの要素がなくなるとStopIteration を送出する関数を指します。 
次の tp_weaklist までのフィールドは、Py_TPFLAGS_HAVE_CLASSフラグビットがセットされている場合にのみ存在します。 
tp_methods オプションのフィールドです。 
tp_members オプションのフィールドです。 
typedef PyObject *(*getter)(PyObject *, void *);typedef int (*setter)(PyObject *, PyObject *, void *);typedef struct PyGetSetDef {char *name; /* 属性名 */getter get; /* 属性の get を行う C 関数 */setter set; /* 属性の set を行う C 関数 */char *doc; /* オプションの docstring */void *closure; /* オプションの get/set 関数用追加データ */} PyGetSetDef; 
オプションのフィールドです。 
ポインタで、型に関するプロパティを継承する基底タイプへのポインタです。 
このフィールドのレベルでは、単継承 (single inheritance) だけがサポートされています;多重継承はメタタイプの呼び出しによる動的な型オブジェクトの生成を必要とします。 
型の辞書はPyType_Ready() によってこのフィールドに収められます。 
このフィールドは通常、PyType_Ready() を呼び出す前に NULLに初期化しておかねばなりません; あるいは、型の初期属性の入った辞書で初期化しておいてもかまいません。 
PyType_Ready() が型をひとたび初期化すると、型の新たな属性をこの辞書に追加できるのは、属性が (__add__() のような) オーバロード用演算でないときだけです。 サブタイプはこのフィールドを継承しません (が、この辞書内で定義されている属性は異なるメカニズムで継承されます)。 
tp_descr_get オプションのフィールドです。 
ポインタで、"デスクリプタ get" 関数を指します。 
XXX blah, blah.サブタイプはこのフィールドを継承します。 
tp_descr_set オプションのフィールドです。 
ポインタで、"デスクリプタ set" 関数を指します。 
tp_dictoffset 型のインスタンスにインスタンス変数の入った辞書がある場合、このフィールドは非ゼロの値になり、型のインスタンスデータ構造体におけるインスタンス変数辞書へのオフセットが入ります;このオフセット値は PyObject_GenericGetAttr() が使います。 
このフィールドを tp_dict と混同しないでください;tp_dict は型オブジェクト自体の属性のための辞書です。 このフィールドの値がゼロより大きければ、値はインスタンス構造体の先頭からのオフセットを表します。 
値がゼロより小さければ、インスタンス構造体の 末尾 からのオフセットを表します。 
負のオフセットを使うコストは比較的高くつくので、インスタンス構造体に可変長の部分があるときのみ使うべきです。 
例えば、str や tuple のサブタイプにインスタンス辞書を追加する場合には、負のオフセットを使います。 この場合、たとえ辞書が基本のオブジェクトレイアウトに含まれていなくても、tp_basicsize フィールドは追加された辞書を考慮にいれなければならないので注意してください。 
ポインタサイズが 4 バイトのシステムでは、構造体の最後尾に辞書が宣言されていることを示す場合、tp_dictoffset を-4 にしなければなりません。 tp_dictoffset が負の場合、インスタンスにおける実際の辞書のオフセットは以下のようにして計算されます: 
ここで、tp_basicsize、 tp_itemsize およびtp_dictoffset は型オブジェクトから取り出され、ob_size はインスタンスから取り出されます。 
長整数は符号を記憶するのに ob_size の符号を使うため、ob_size は絶対値を使います。 (この計算を自分で行う必要はまったくありません; _PyObject_GetDictPtr() がやってくれます。 
)サブタイプはこのフィールドを継承しますが、以下の規則があるので読んでください。 サブタイプはこのオフセット値をオーバライドできます; 従って、サブタイプでは辞書のオフセットが基底タイプとは異なる場合があります。 
辞書へのオフセット常にtp_dictoffset で分かるはずなので、このことは問題にはならないはずです。 class 文で定義された型に __slots__ 宣言が全くなく、かつ基底タイプの全てにインスタンス変数辞書がない場合、辞書のスロットをインスタンスデータレイアウト構造体に追加し、スロットのオフセットをtp_dictoffset に設定します。 
tp_init オプションのフィールドです。 
ポインタで、インスタンス初期化関数を指します。 
tp_new が元の型のサブタイプでない別の型を返す場合、tp_init は全く呼び出されません; tp_new が元の型のサブタイプのインスタンスを返す場合、サブタイプのtp_init が呼び出されます。 
(VERSION NOTE: ここに書かれている内容は、Python 2.2.1 以降での実装に関するものです。 
Python 2.2 では、tp_init は NULLでない限りtp_new が返す全てのオブジェクトに対して常に呼び出されます。 )not NULL.)サブタイプはこのフィールドを継承します。 
関数のシグネチャは 
PyObject *tp_alloc(PyTypeObject *self, int nitems) です。 
この関数の目的は、メモリ確保をメモリ初期化から分離することにあります。 
この関数は、インスタンス用の的確なサイズを持ち、適切にバイト整列され、ゼロで初期化され、ただしob_refcnt を 1 にセットされ、 ob_type が型引数 (type argument) にセットされているようなメモリブロックを返さねばなりません。 
静的に定義する型の場合でも、PyType_GenericAlloc()を推奨します。 
このフィールドが NULL を指している型では、型を呼び出して新たなインスタンスを生成できません; こうした型では、おそらくファクトリ関数のように、インスタンスを生成する他の方法があるはずです。 関数のシグネチャは 
PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds) です。 
引数 subtype は生成するオブジェクトの型です; args およびkwds 引数は、型を呼び出すときの固定引数およびキーワード引数です。 
サブタイプは tp_new 関数を呼び出すときに使う型と等価というわけではないので注意してください;tp_new 関数を呼び出すときに使う型 (と無関係ではない) サブタイプのこともあります。 tp_new 関数は 
subtype-tp_alloc(subtype, nitems) を呼び出してオブジェクトのメモリ領域を確保し、初期化で本当に必要とされる処理だけを行います。 
省略したり繰り返したりしても問題のない初期化処理はtp_init ハンドラ内に配置しなければなりません。 
後者が例外になっているのは、旧式の拡張型が Python 2.2でリンクされたときに呼び出し可能オブジェクトにならないようにするための予防措置です。 
tp_free オプションのフィールドです。 
ポインタで、インスタンスのメモリ解放関数を指します。 この関数のシグネチャは少し変更されています; Python 2.2 および 2.2.1では、シグネチャはdestructor : 
でしたが、 Python 2.3 以降では、シグネチャは freefunc: 
tp_is_gc オプションのフィールドです。 
ポインタで、ガベージコレクタから呼び出される関数を指します。 ガベージコレクタは、オブジェクトがガベージとして収集可能かどうかを知る必要があります。 
これを知るには、通常はオブジェクトの型のtp_flags フィールドを見て、 Py_TPFLAGS_HAVE_GC フラグビットを調べるだけで十分です。 
しかし、静的なメモリ確保と動的なメモリ確保が混じっているインスタンスを持つような型や、静的にメモリ確保されたインスタンスは収集できません。 
こうした型では、このフィールドに関数を定義しなければなりません; 関数はインスタンスが収集可能の場合には 1 を、収集不能の場合には 0 を返さねばなりません。 シグネチャは 
int tp_is_gc(PyObject *self) です。 
(上記のような型の例は、型オブジェクト自体です。 
メタタイプPyType_Type は、型のメモリ確保が静的か動的かを区別するためにこの関数を定義しています。 )サブタイプはこのフィールドを継承します。 
(VERSION NOTE: Python 2.2 では、このフィールドは継承されませんでした。 
2.2.1 以降のバージョンから継承されるようになりました。 
基底型からなるタプルです。 class 文で生成されたクラスの場合このフィールドがセットされます。 
静的に定義されている型の場合には、このフィールドはNULL になります。 このフィールドは継承されません。 
基底クラス群を展開した集合が入っているタプルです。 集合は該当する型自体からはじまり、object で終わります。 
使用されていません。 
継承されません。 
内部で使用するためだけのものです。 
サブクラスへの弱参照からなるリストです。 
サブタイプはこれらのフィールドを継承しません。 
メモリ確保の回数です。 
メモリ解放の回数です。 
同時にメモリ確保できる最大オブジェクト数です。 
tp_allocs フィールドが非ゼロの、(リンクリストの) 次の型オブジェクトを指すポインタです。 
また、 Python のガベージコレクションでは、tp_deallocを呼び出すのはオブジェクトを生成したスレッドだけではなく、任意の Python スレッドかもしれないという点にも注意して下さい。 (オブジェクトが循環参照の一部の場合、任意のスレッドのガベージコレクションによって解放されてしまうかもしれません)。 
Python API 側からみれば、tp_dealloc を呼び出すスレッドは グローバルインタプリタロック (GIL:Global Interpreter Lock) を獲得するので、これは問題ではありません。 しかしながら、削除されようとしているオブジェクトが何らかの C や C++ライブラリ由来のオブジェクトを削除する場合、 tp_dealloc を呼び出すスレッドのオブジェクトを削除することで、ライブラリの仮定している何らかの規約に違反しないように気を付ける必要があります。 
組み込み型を記述する際に用いられる、オブジェクトを表す C 構造体です。 
型オブジェクト自身の型オブジェクトです; Python レイヤにおけるtypes.TypeType と同じオブジェクトです。 
オブジェクト o が型オブジェクトの場合に真を返します。 標準型オブジェクトから導出されたサブタイプ (subtype) のインスタンスも含みます。 
その他の場合には偽を返します。 
オブジェクト o が型オブジェクトの場合に真を返します。 
型オブジェクト o に、型機能 feature が設定されている場合に真を返します。 
型機能は各々単一ビットのフラグで表されます。 
型オブジェクトが o が循環参照検出をサポートしている場合に真を返します; この関数は型機能フラグ Py_TPFLAGS_HAVE_GCの設定状態をチェックします。 バージョン 2.0 で 新たに追加 された仕様です。 
a が b のサブタイプの場合に真を返します。 
型オブジェクトの後始末処理 (finalize) を行います。 
この関数は全てのオブジェクトで初期化を完了するために呼び出されなくてはなりません。 
この関数は、基底クラス型から継承したスロットを型オブジェクトに追加する役割があります。 
成功した場合には 0 を返し、エラーの場合には -1 を返して例外情報を設定します。 バージョン 2.2 で 新たに追加 された仕様です。 
2.3.4.1 整数型におけるビット文字列演算 
Python はコンテナの内容にわたって反復処理を行う概念をサポートしています。 
この概念は 2 つの別々のメソッドを使って実装されています;これらのメソッドはユーザ定義のクラスで反復を行えるようにするために使われます。 後に詳しく述べるシーケンス型はすべて反復処理メソッドをサポートしています。 
以下はコンテナオブジェクトに反復処理をサポートさせるために定義しなければならないメソッドです: 
イテレータオブジェクトは以下で述べるイテレータプロトコルをサポートする必要があります。 
あるコンテナが異なる形式の反復処理をサポートする場合、それらの反復処理形式のイテレータを特定的に要求するようなメソッドを追加することができます(複数の形式での反復処理をサポートするようなオブジェクトとして木構造の例があります。 
木構造は幅優先走査と深さ優先走査の両方をサポートします)。 
このメソッドは Python/C API において Python オブジェクトを表す型構造体の tp_iter スロットに対応します。 
イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要があります。 これらのメソッドは 2 つ合わせて イテレータプロトコルを成します: 
イテレータオブジェクト自体を返します。 
このメソッドはコンテナとイテレータの両方をfor および in 文で使えるようにするために必要です。 
このメソッドは Python/C API において Python オブジェクトを表す型構造体の tp_iter スロットに対応します。 
コンテナ内の次の要素を返します。 
もう要素が残っていない場合、例外 StopIteration を送出します。 
このメソッドはPython/C API において Python オブジェクトを表す型構造体の tp_iternext スロットに対応します。 
Python では、いくつかのイテレータオブジェクトを定義しています。 これらは一般的および特殊化されたシーケンス型、辞書型、そして他のさらに特殊化された形式をサポートします。 
特殊型であることはイテレータプロトコルの実装が特殊になること以外は重要なことではありません。 このプロトコルの趣旨は、一度イテレータの next() メソッドが StopIteration例外を送出した場合、以降の呼び出しでもずっと例外を送出しつづけるところにあります。 
この特性に従わないような実装は変則であるとみなされます (この制限は Python 2.3 で追加されました; Python2.2 では、この規則に従うと多くのイテレータが変則となります)。 
Python におけるジェネレータ (generator) は、イテレータプロトコルを実装する簡便な方法を提供します。 
コンテナオブジェクトの__iter__() メソッドがジェネレータとして実装されていれば、メソッドは __iter__() および next() メソッドを提供するイテレータオブジェクト (技術的にはジェネレータオブジェクト) を自動的に返します。 
2.3.7 set（集合） 型 
他のコレクションと同様、 setsは 
、len(set)および for x in set 
順序を持たないコレクションとして、setsは要素の位置と（要素の）挿入位置を保持しません。 
したがって、setsはインデックス、スライス、その他の数列的な振る舞いをサポートしません。 
set および frozensetという、2つの組み込みset型があります。 set は変更可能な -- add() や remove()のようなメソッドを使って内容を変更できます。 
変更可能なため、ハッシュ値を持たず、また辞書のキーや他のsetの要素として用いることができません。 
set s の基数 
s のメンバに x があるか調べる 
s のメンバに x がないか調べる 
t に s の全ての要素が含まれるか調べる 
s に t の全ての要素が含まれるか調べる 
s と tに含まれるすべての要素を持った新しいsetを作成 
s と t共通に含まれる要素を持った新しいsetを作成 
s には含まれるが tには含まれない要素を持った新しいsetを作成 
s と tのうち、両者には含まれない要素を持った新しいsetを作成 
sの浅いコピーを持った新しいsetを作成 
注意すべき点として、演算子ではないバージョンのメソッド union()、 intersection()、+difference()、symmetric_difference()、issubset()および issuperset()はどの種類のiterableでも引数として受け入れます。 
対照的に、（それぞれのメソッドに）対応する演算子は引数にsets型を要求します。 
set のインスタンスはfrozenset のインスタンスと、そのメンバを基に比較されます。 
例えば "set('abc') == frozenset('abc')" は Trueを返します。 
サブセットと同一性の比較は完全な順序付け関数によって一般化されません。 
例えば、どのような連結されていない2つのsetsが、等しくもなく、もう一方のサブセットでもなければ、以下のコードの 全て にFalseを返します。 
以下の表はsetで可能なリスト操作です。 これらの操作は変更不能なfrozenset のインスタンスには適用されません。 
t の要素を追加したset s を返します。 
t にも含まれる要素を保持したset s を返します。 
t に含まれる要素を削除したset s を返します。 
s と t に含まれているが、共通して含まれていない要素を持ったset s を返します。 
set s に要素 x を追加します 
s.remove(x) set s から要素 x を削除します。 
要素が存在しない場合は KeyError を投げます 
set s に要素 x が存在していれば削除します 
s から、任意の要素を返してその要素を削除します。 空の場合はKeyError を投げます 
set s から全ての要素を削除します 
注意すべき点として、演算子ではないバージョンのメソッド update()、intersection_update()、 difference_update() およびsymmetric_difference_update() は、どんなiterableでも引数として受け入れます。 
Python/C API において重要な役割を持つデータ型は、PyObject型の他にもいくつかあります; ほとんどは int, long, double, および char* といった、単なる C のデータ型です。 
また、モジュールで公開している関数を列挙する際に用いられる静的なテーブルや、新しいオブジェクト型におけるデータ属性を記述したり、複素数の値を記述したりするために構造体をいくつか使っています。 
これらの型については、その型を使う関数とともに説明してゆきます。 
2.3.10.2 クラスおよびクラスインスタンス 
関数オブジェクトは関数定義によって生成されます。 
関数オブジェクトに対する唯一の操作は、それを呼び出すことです: 
func(argument-list).関数オブジェクトには実際には 2 つの種: 組み込み関数とユーザ定義関数があります。 
両方とも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、オブジェクトの型も異なります。 より詳しい情報は 
を参照してください。 
この情報については 
を読んで下さい。 
このオブジェクトではスタックフレーム、トレースバック、スライスオブジェクトを記述しています。 
マップ型 (mapping) オブジェクトは変更不可能な値を任意のオブジェクトに対応付けます。 
対応付け自体は変更可能なオブジェクトです。 
現在のところは標準のマップ型、dictionary だけです。 
辞書のキーにはほとんど任意の値をつかうことができます。 
a 内の要素の数です 
キー k を持つa の要素です 
a[k] を v に設定します 
a から 
a[k] を削除します 
a から全ての要素を削除します 
a の(浅い)コピーです 
a にキー k があれば True 、そうでなければ False です 
a.has_key(k) と同じです 
not a.has_key(k) と同じです 
a における (key, value) ペアのリストのコピーです 
a におけるキーのリストのコピーです 
b によって key/value ペアを更新（上書き） 
seq からキーを作り、値が value であるような、新しい辞書を作成します 
a における値のリストのコピーです 
もし 
なら 
a[k]、そうでなければ xを返します 
a[k]、そうでなければ x (が与えられていた場合)を返します 
a[k] 、そうでなければ x を返して kを除去します 
任意の (key, value) ペアを除去して返します 
(key, value) ペアにわたるイテレータを返します 
マップのキー列にわたるイテレータを返します 
マップの値列にわたるイテレータを返します 
k がマップ内にない場合、例外 KeyError を送出します。 
これにより、(value, key) のペアを zip() を使って: "pairs = zip(a.values(), a.keys())" のように生成することができます。 
iterkeys() およびitervalues() メソッドの間でも同じ関係が成り立ちます:"pairs = zip(a.itervalues(), a.iterkeys())" は pairs と同じ値になります。 同じリストを生成するもう一つの方法は"pairs = [(v, k) for (k, v) in a.iteritems()]"です。 
k がマップ中になくても例外を送出せず、代わりにx を返します。 x はオプションです; x が与えられておらず、かつ k がマップ中になければ、 None が返されます。 
setdefault() は get() に似ていますが、k が見つからなかった場合、x が返されると同時に辞書のk に対する値として挿入されます。 デフォルトで x は Noneです。 
popitem() は、集合アルゴリズムでよく行われるような、辞書を取り崩しながらの反復を行うのに便利です。 
fromkeys() は、新しい辞書を返すクラスメソッドです。 value のデフォルト値は None です。 
pop() は、デフォルト値が渡されず、かつ、キーが見つからない場合に、 KeyError を送出します。 
update() はその他のマッピングオブジェクトや反復可能なキー/値のペア（タプルやその他2つの要素を持つ反復可能な要素）を受け入れます。 
メソッドは属性表記を使って呼び出される関数です。 メソッドには二つの種類があります: (リストへのappend()のような) 組み込みメソッドと、クラスインスタンスのメソッドです。 
組み込みメソッドはそれをサポートする型と一緒に記述されています。 実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性を追加しています: 
m.im_self はメソッドが操作するオブジェクトで、 
m.im_func はメソッドを実装している関数です。 
m(arg-1, arg-2, ..., arg-n)の呼び出しは、 
m.im_func(m.im_self, arg-1,arg-2, ..., arg-n) の呼び出しと完全に等価です。 
クラスインスタンスメソッドには、 メソッドがインスタンスからアクセスされるかクラスからアクセスされるかによって、それぞれバインド または 非バインド　があります。 
メソッドが非バインドメソッドの場合、im_self 属性は None になるため、呼び出す際には self オブジェクトを明示的に第一引数として指定しなければなりません。 
この場合、self は非バインドメソッドのクラス(サブクラス) のインスタンスでなければならず、そうでなければTypeError が送出されます。 関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得できます。 
しかし、メソッド属性は実際には背後の関数オブジェクト(meth.im_func) に記憶されているので、バインド、ヒバインドメソッドへのメソッド属性の設定は許されていません。 
メソッド属性の設定を試みると TypeError が送出されます。 
メソッド属性を設定するためには、その背後の関数オブジェクトで明示的に: 
のように設定しなければなりません。 詳しくは 
モジュールに対する唯一の特殊な演算は属性へのアクセス: 
m.name です。 
ここで m はモジュールで、name は m のシンボルテーブル上に定義された名前にアクセスします。 
モジュール属性も代入することができます。 
(import 文は、厳密にいえば、モジュールオブジェクトに対する演算です; import foo 
m.__dict__['a'] = 1 と書いて 
m.a を 1に定義することはできますが、 m.__dict__ = {} と書くことはできません) 。 
__dict__ を直接編集するのは推奨されません。 
インタプリタ内に組み込まれたモジュールは、module 'sys' (built-in) のように書かれます。 
ファイルから読み出された場合、 module 'os' from'/usr/local/lib/python2.4/os.pyc' と書かれます。 
長整数型には精度の制限がありません。 
浮動小数点型は C ではdouble を使って実装されています。 しかし使っている計算機が何であるか分からないなら、これらの数値型の精度に関して断言はできません。 
複素数型は実数部と虚数部を持ち、それぞれの C では double を使って実装されています。 
複素数 z から実数および虚数部を取り出すには、 
z.real および z.imag を使います。 
数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。 
修飾のない整数リテラル (16 進表現や 8 進表現の値も含みます) は、通常の整数値を表します。 
値が通常の整数で表すには大きすぎる場合、"L" または "l" が末尾につく整数リテラルは長整数型を表します ("L" が望ましいです。 
というのは"1l" は 11 と非常に紛らわしいからです！) 小数点または指数表記のある数値リテラルは浮動小数点数を表します。 
数値リテラルに "j" または "J" をつけると実数部がゼロの複素数を表します。 
複素数の数値リテラルは実数部と虚数部を足したものです。 
Python は型混合の演算を完全にサポートします: ある 2 項演算子が互いに異なる数値型の被演算子を持つ場合、より ``制限された'' 型の被演算子は他方の型に合わせて広げられます。 
コンストラクタ int() 、long() 、float()、および complex() を使って、特定の型の数を生成することができます。 
全ての数値型（complex は例外）は以下の演算をサポートします。 これらの演算は優先度の低いものから順に並べられています (同じボックスにある演算は同じ優先度を持っています; 全ての数値演算は比較演算よりも高い優先度を持っています): 
x と y の加算 
x と y の減算 
x と y の乗算 
x と y の除算 
の剰余 
x の符号反転 
x の符号不変 
x の絶対値または大きさ 
x の通常整数への変換 
x の長整数への変換 
x の浮動小数点数への変換 
実数部 re 、虚数部 im の複素数。 im のデフォルト値はゼロ。 
複素数 c の共役複素数 
(x / y, x % y) からなるペア 
x の y 乗 
(通常および長) 整数の割り算では、結果は整数になります。 この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は 0、(-1)/2 は -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。 
被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返されるので注意してください。 
浮動小数点数から (通常または長) 整数への変換では、C におけるのと同様の値の丸めまたは切り詰めが行われるかもしれません; きちんと定義された変換については、 
モジュールのfloor() および ceil() を参照してください。 
完全な記述については、2.1、``組み込み関数'' を参照してください。 
複素数の切り詰め除算演算子、モジュロ演算子、および divmod()。 
リリース 2.3 で撤廃されました。 適切であれば、abs() を使って浮動小数点に変換してください。 
...型混合の数値間での比較も同じ規則に従います。 
この結果として、リスト [1, 2] は [1.0, 2.0]と等しいと見なされます。 
タプルの場合も同様です 
インタプリタはその他の種類のオブジェクトをいくつかサポートします。 
これらのほとんどは 1 または 2 つの演算だけをサポートします。 
s の要素 s を x と入れ替えます 
s の i から j 番目までの要素を t と入れ替えます 
s[i:j] = [] と同じです 
s[i:j:k] の要素を t と入れ替えます 
リストから 
s[i:j:k] の要素を削除します 
s[len(s):len(s)] = [x] と同じです 
s[len(s):len(s)] = x と同じです 
となる i の個数を返します 
かつ 
となる最小の k を返します。 
i = 0 の場合の 
s[i:i] = [x] と同じです 
と同じです 
del s[s.index(x)] と同じです 
s の値の並びを反転します 
s の要素を並べ替えます 
t は入れ替えるスライスと同じ長さでなければいけません。 
かつての Python の C 実装では、複数パラメタを受理し、非明示的にそれらをタプルに結合していました。 
この間違った機能はPython 1.4 で廃用され、Python 2.0 の導入とともにエラーにするようになりました。 
x がリストオブジェクトでない場合、例外を送出します。 extend() は実験的なメソッドであり、リスト以外の変更可能なシーケンス型ではサポートされていません。 
x が s 中に見つからなかった場合ValueError を送出します。 
　負のインデクスが二番目または三番目のパラメタとして index()メソッドに渡されると、これらの値にはスライスのインデクスと同様にリストの長さが加算されます。 
加算後もまだ負の場合、その値はスライスのインデクスと同様にゼロに切り詰められます。 
バージョン 2.3 で 変更 された仕様:以前は、index() は開始位置や終了位置を指定するのに負の数を使うことができませんでした 
insert() の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。 
それでも負の値を取る場合、スライスのインデクスと同じく、0 に丸められます。 
バージョン 2.3 で 変更 された仕様:以前は、すべての負値は 0 に丸められていました。 
pop() メソッドはリストおよびアレイ型のみでサポートされています。 
オプションの引数 i は標準で -1 なので、標準では最後の要素をリストから除去して返します。 
sort() および reverse() メソッドは大きなリストを並べ替えたり反転したりする際、容量の節約のためにリストを直接変更します。 
副作用があることをユーザに思い出させるために、これらの操作は並べ替えまたは反転されたリストを返しません。 
sort() メソッドは、比較を制御するためにオプションの引数をとります。 
cmp は2つの引数(list items)からなるカスタムの比較関数を指定します。 これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼロ、正数を返します。 
key は1つの引数からなる関数を指定します。 これは個々のリストの要素から比較のキーを取り出すのに使われます。 
reverse は真偽値です。 
True がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。 一般的に、 key および reverse の変換プロセスは同等の cmp 関数を指定するより早く動作します。 
これは key および reverse がそれぞれの要素に一度だけ触れる間に、cmp はリストのそれぞれの要素に対して複数回呼ばれることによるものです。 
バージョン 2.3 で 変更 された仕様:None を渡すのと、cmp を省略した場合とで、同等に扱うサポートを追加 
バージョン 2.4 で 変更 された仕様:key および reverse のサポートを追加 
Python2.3 以降、sort() メソッドは安定していることが保証されています。 
ソートは等しいとされた要素の相対オーダーが変更されないことが保証されれば、安定しています -- これは複合的なパス（例えば部署ごとにソートして、それを給与の等級）でソートを行なうのに役立ちます。 
リストが並べ替えられている間は、リストの変更はもとより、その値の閲覧すらその結果は未定義です。 
Python 2.3以降 の C 実装では、この間リストは空に見えるようになり、並べ替え中にリストが変更されたことが検出されると ValueErrorが送出されます。 
文字列および Unicode オブジェクトには固有の操作: % 演算子 (モジュロ) があります。 
この演算子は文字列 フォーマット化 または 補間 演算としても知られています。 
(format は文字列またはUnicode オブジェクト)とすると、format 中の % 変換指定は values 中のゼロ個またはそれ以上の要素で置換されます。 
この動作は C 言語における sprintf() に似ています。 
format が Unicode オブジェクトであるか、または %s 変換を使って Unicode オブジェクトが変換される場合、その結果もUnicode オブジェクトになります。 format が単一の引数しか要求しない場合、values はタプルでない単一のオブジェクトでもかまいません。 
2.9 それ以外の場合、values はフォーマット文字列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければなりません。 
一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりますが、示した順に出現しなければなりません: 
変換指定子が開始することを示す文字 "%"。 
一部の変換型の結果に影響します。 
最小のフィールド幅 (オプション). "*" (アスタリスク) を指定した場合、実際の文字列幅が values タプルの次の要素から読み出されます。 
タプルには最小フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにします。 精度 (オプション)。 
"." (ドット) とその後に続く精度で与えられます。 
"*" (アスタリスク) を指定した場合、精度の桁数はタプルの次の要素から読み出されます。 タプルには精度指定の後に変換したい値がくるようにします。 
精度長変換子 (オプション)。 
変換型。 
% 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合)、文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字"%" の直後にくるようにしたものが含まれていなければなりません 。 
マップキーはフォーマット化したい値をマップから選び出します。 
この場合、 * 指定子をフォーマットに含めてはいけません(* 指定子は順番付けされたパラメタのリストが必要だからです。 )変換フラグ文字を以下に示します: 
フラグ 
値の変換に (下で定義されている) ``別の形式'' を使います。 
数値型に対してゼロによるパディングを行います。 
変換された値を左寄せにします ("0" と同時に与えた場合、"0" を上書きします) 。 
(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでない場合は空文字になります)。 
変換の先頭に符号文字 ("+" または "-") を付けます("スペース" フラグを上書きします) 。 
精度長変換子として、h 、 l 、および L を使うことができますが、Python では必要ないため無視されます。 変換型を以下に示します: 
変換 
符号付き 10 進整数。 
符号なし 8 進数。 
符号なし 10 進数。 
符号なし 16 進数 (小文字)。 
符号なし 16 進数 (大文字)。 
指数表記の浮動小数点数 (小文字). 
指数表記の浮動小数点数 (大文字). 
10 進浮動小数点数。 
指数部が -4 以上または精度以下の場合には "e" 、それ以外の場合には "f" と同じ。 
指数部が -4 以上または精度以下の場合には "E" 、それ以外の場合には "F" と同じ。 
文字一文字 (整数または一文字からなる文字列を受理します)。 
文字列 (python オブジェクトを repr() で変換します)。 
文字列 (python オブジェクトを str() で変換します)。 
引数を変換せず、返される文字列中では文字 "%" になります。 
別形式の出力にした場合、変換結果の先頭の数字がゼロ ("0") でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。 
別形式にした場合、変換結果の先頭の数字がゼロでないときには、数字の先頭と左側のパディングとの間に '0x' または '0X' (フォーマット文字が "x" か "X" かに依存します)が挿入されます。 
%r 変換は Python 2.0 で追加されました。 
オブジェクトや与えられた書式が unicode 文字列の場合、変換後の文字列も unicode になります。 
Python 文字列には明示的な長さ情報があるので、%s 変換において'0' を文字列の末端と仮定したりはしません。 安全上の理由から、浮動小数点数の精度は 50 桁でクリップされます; 絶対値が 1e25 を超える値の %f による変換は %g変換で置換されます 
2.10 その他のエラーは例外を送出します。 
その他の文字列操作は標準モジュール 
で定義されています。 
...タプルでない単一のオブジェクトでもかまいません。 
従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを values に与えなくてはなりません。 
...変換で置換されます 
この範囲に関する値はかなり適当なものです。 
この仕様は、正しい使い方では障害とならず、かつ特定のマシンにおける浮動小数点数の正確な精度を知らなくても、際限なく長くて意味のない数字からなる文字列を印字しないですむようにするためのものです。 
型は値の変更不能なシーケンスで、広範なループ処理に使われています。 
xrange 型の利点は、 xrange オブジェクトは表現する値域の大きさにかかわらず常に同じ量のメモリしか占めないということです。 
はっきりしたパフォーマンス上の利点はありません。 
XRange オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、 len() 関数のみをサポートしています。 
組み込み型には 6 つのシーケンス型があります: 文字列、ユニコード文字列、リスト、タプル、バッファ、そして xrange オブジェクトです。 文字列リテラルは 'xyzzy'、"frobozz" といったように、単引用符または二重引用符の中に書かれます。 
文字列リテラルについての詳細はは、 
の第 2 章を読んで下さい。 
Unicode 文字列はほとんど文字列と同じですが、u'abc' 、u"def" といったように先頭に文字 "u" を付けて指定します。 
リストは [a, b, c] のように要素をコンマで区切り角括弧で囲って生成します。 
タプルは a, b, c のようにコンマ演算子で区切って生成します (角括弧の中には入れません)。 丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは () のように丸括弧で囲わなければなりません。 
要素が一つのタプルでは、例えば (d,) のように、要素の後ろにコンマをつけなければなりません。 
バッファオブジェクトは Python の構文上では直接サポートされていませんが、組み込み関数 buffer() で生成することができます。 
バッファオブジェクトは結合や反復をサポートしていません。 
xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない点でバッファに似ていて、関数 xrange() で生成します。 
xrange オブジェクトはスライス、結合、反復をサポートせず、in 、 not in 、min() または max() は効率的ではありません。 
ほとんどのシーケンス型は以下の演算操作をサポートします。 
"in" および "not in" は比較演算とおなじ優先度を持っています。 
"+" および "*" は対応する数値演算とおなじ優先度です。 
以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです(同じボックス内の演算は同じ優先度です)。 
テーブル内のs および t は同じ型のシーケンスです; n、iおよび j は整数です: 
s のある要素 x と等しい場合 True 、そうでない場合 False 
s のある要素が x と等しい場合 False 、そうでない場合 True 
s および t の結合 
s の浅いコピー n 個からなる結合 
s の 0 から数えて i 番目の要素 
s の i 番目から j 番目までのスライス 
s の i 番目から j 番目まで、k 毎のスライス 
s の長さ 
s の最小の要素 
s の最大の要素 
s が文字列または Unicode 文字列の場合、 演算操作 in および not in は部分文字列の一致テストと同じように動作します。 
バージョン 2.3 以前の Python では、x は長さ 1 の文字列でした。 Python 2.3 以降では、x はどの長さでもかまいません。 
n が 0 以下の値の場合、0 として扱われます (これは s と同じ型の空のシーケンスを表します)。 
コピーは浅いコピーなので注意してください; 入れ子になったデータ構造はコピーされません。 
これは Python に慣れていないプログラマをよく悩ませます。 例えば以下のコードを考えます: 
以下のようにすると、異なるリストを要素とするリストを生成できます:上のコードで、[[]] は空のリストを要素として含んでいるリストですから、 [[]] * 3 の3つの要素の全てが、空のリスト（への参照）になります。 
lists のいずれかの要素を修正することでこの単一のリストが変更されます。 
以下のようにすると、異なる個別のリストを生成できます: 
i または j が負の数の場合、インデクスは文字列の末端からの相対インデクスになります: len(s) + i 
または len(s) + j 
が代入されます。 
しかし -0 は 0 のままなので注意してください。 
i が省略された場合、0 を使います。 
j が省略された場合、len(s) を使います。 
i が j 以上の場合、スライスは空のシーケンスになります。 
i または j が len(s) より大きい場合、len(s) を使います。 
i または j を省略した場合、``最後''(k の符号に依存)を示す値を使います。 
k はゼロにできないので注意してください。 
s と t の両者が文字列であるとき、CPythonのような実装では、 
という書式で代入をするのにin-place optimizationが働きます。 
このような時、最適化は二乗の実行時間の低減をもたらします。 
この最適化はバージョンや実装に依存します。 
... は対応する数値演算とおなじ優先度です。 
パーザが被演算子の型を識別できるようにするために、このような優先度でなければならないのです。 
2.3.6.1 文字列メソッド 
全ての単項算術演算 (およびビット単位演算子) は、同じ優先順位を持っています: 
単項演算子 - (マイナス) は、引数となる数値の符号を反転(invert) します。 
単項演算子 + (プラス) は、数値引数を変更しません。 
単項演算子 ~ (逆転) は、整数または長整数の引数をビット単位反転 (bit-wise invert) します。 
x のビット単位反転は、 -(x+1) として定義されています。 
この演算子は整数にのみ適用されます。 
上記の三つはいずれも、引数が正しい型でない場合には TypeError例外が送出されます。 
現在ドキュメント化されていないが、ドキュメント化すべきモジュールを以下にざっと列挙します。 
どうぞこれらのドキュメントを寄稿してください！(電子メールで docs@python.org に送ってください)。 
この章のアイデアと元の文章内容は Fredrik Lundh のポストによるものです; この章の特定の内容は実際には改訂されてきています。 
5. 文書化されていないモジュール 
この章のモジュールは、ほとんど (あるいはまったく) ドキュメント化されていません。 
これらのモジュールのいずれかについてドキュメントを寄与したいと考えているなら、 
までご連絡ください。 
AppleSingle フォーマットファイル用の基本的なデコーダ 
BuildAppletとその仲間のヘルパーモジュール 
コンパイル済みアプリケーションに 'PYC~' リソースを作成にするヘルパーモジュール 
コードフラグメントリソースを扱うモジュール 
open()と Internet Config の置き換え 
多くの MacOS エラーコード定数定義 
スクリプトのリソースを見つける 
Navigation Services へのインターフェース 
CodeWarrior プロジェクトの作成 
Netscape OSAモジュールのラッパー 
PixMapオブジェクトのラッパー 
デフォルト設定へのサポートを持つアプリケーション初期設定管理プログラム 
Python インタプリタに特化した初期設定管理プログラム 
バッファを用いての不可視の標準出力 
フレームの継続処理のためのQuickTime ムービーのフレーム読み込み 
上に作られた Mac 用ウイジェット 
``WorldScript-Aware Styled Text Engine''へのインターフェース 
7.3.2.1 組み込み codec (built-in 
以下の API は Unicode オブジェクトおよび文字列を入力に取り(説明では、どちらも文字列と表記しています)、場合に応じて Unicode オブジェクトか整数を返す機能を持っています。 
これらの関数は全て、例外が発生した場合には NULL または -1を返します。 PyObject* 
二つの文字列を結合して、新たな Unicode 文字列を生成します。 
Unicode 文字列のリストを分割して、 Unicode 文字列からなるリストを返します。 
sep が NULL の場合、全ての空白文字を使って分割を行います。 
それ以外の場合、指定された文字を使って分割を行います。 
最大で maxsplit 個までの分割を行います。 
maxsplit が負ならば分割数に制限を設けません。 
分割結果のリスト内には分割文字は含みません。 
Unicode 文字列を改行文字で区切り、Unicode 文字列からなるリストを返します。 
CRLF は一個の改行文字とみなします。 
keependが 0 の場合、分割結果のリスト内に改行文字を含めません。 
errors は codecs で通常使われるのと同じ意味を持ちます。 
errors は NULL にしてもよく、デフォルトエラー処理の使用を意味します。 
指定した separator で文字列からなるシーケンスを連結 (join) し、連結結果を Unicode 文字列で返します。 
substr が指定された末尾条件 (direction == -1 は前方一致、 direction ==1 は後方一致) で str[start:end] とマッチする場合に 1 を返し、それ以外の場合には 0 を返します。 
str[start:end] 中にsubstr が最初に出現する場所を返します。 このとき指定された検索方向 direction (direction == 1 は順方向検索、 direction == -1 は逆方向検索) で検索します。 
戻り値は最初にマッチが見つかった場所のインデクスです; 戻り値 -1 はマッチが見つからなかったことを表し、-2 はエラーが発生して例外情報が設定されていることを表します。 
str[start:end] にsubstr が重複することなく出現する回数を返します。 
エラーが発生した場合には -1 を返します。 
str 中に出現する substr を最大で maxcount 個replstr に置換し、置換結果を Unicode オブジェクトにして返します。 maxcount == -1 にすると、全ての substr を置換します。 
二つの文字列を比較して、左引数が右引数より小さい場合、左右引数が等価の場合、左引数が右引数より大きい場合、について、それぞれ -1, 0, 1 を返します。 
新たな文字列オブジェクトを format および args から生成して返します; このメソッドは 
のようなものです。 
引数 args はタプルでなくてはなりません。 
element が container 内にあるか調べ、その結果に応じて真または偽を返します。 
element は単要素の Unicode 文字に型強制できなければなりません。 
エラーが生じた場合には -1 を返します。 
以下は Python の Unicode 実装に用いられている基本 Unicode オブジェクト型です: 
この型は 16 ビットの符号なしストレージ型を表し、Unicode 序数(Unicode ordinal) を保持するための基礎単位として Python が内部的に使います。 
wchar_t が利用でき、かつ 16 ビットである場合、Py_UNICODE は wchar_t を typedef でエイリアスされ、ネイティブプラットフォームに対する互換性を高めます。 
その他のプラットフォームでは全て、Py_UNICODE はunsigned short の typedef によるエイリアスになります。 
この PyObject のサブタイプは Unicode オブジェクトを表現します。 
この PyTypeObject のインスタンスは Python の Unicode 型を表現します。 
以下の API は実際には C マクロで、Unicode オブジェクト内部の読み出し専用データに対するチェックやアクセスを高速に行います: 
o が Unicode 文字列型か Unicode 文字列型のサブタイプであるときに真を返します。 バージョン 2.2 で 変更 された仕様:サブタイプを引数にとれるようになりました 
o が Unicode 文字列型で、かつ Unicode 文字列型のサブタイプでないときに真を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
オブジェクトのサイズを返します。 o はPyUnicodeObject でなければなりません (チェックはしません)。 
オブジェクトの内部バッファのサイズをバイト数で返します。 
o はPyUnicodeObject でなければなりません (チェックはしません)。 Py_UNICODE* 
オブジェクト内部のPy_UNICODE バッファへのポインタを返します。 o は PyUnicodeObject でなければなりません (チェックはしません)。 
オブジェクト内部バッファへのポインタを返します。 o は PyUnicodeObject でなければなりません (チェックはしません)。 
Unicode は数多くの異なる文字プロパティ (character property)を提供しています。 
よく使われる文字プロパティは、以下のマクロで利用できます。 これらのマクロは Python の設定に応じて、各々 C の関数に対応付けられています。 
ch が空白文字かどうかに応じて 1 または 0 を返します。 
ch が小文字かどうかに応じて 1 または 0 を返します。 
ch が大文字かどうかに応じて 1 または 0 を返します。 
ch がタイトルケース文字 (titlecase character) かどうかに応じて 1 または 0 を返します。 
ch が改行文字かどうかに応じて 1 または 0 を返します。 
ch が 10 進の数字文字かどうかに応じて 1 または 0 を返します。 
ch が 2 進の数字文字かどうかに応じて 1 または 0 を返します。 
ch が数字文字かどうかに応じて 1 または 0 を返します。 
ch がアルファベット文字かどうかに応じて 1 または 0 を返します。 
ch が英数文字かどうかに応じて 1 または 0 を返します。 
以下の API は、高速に直接文字変換を行うために使われます: 
ch を小文字に変換したものを返します。 
ch を大文字に変換したものを返します。 
ch をタイトルケース文字に変換したものを返します。 
ch を 10 進の正の整数に変換したものを返します。 
不可能ならば -1 を返します。 
例外を送出しません。 
ch を一桁の 2 進整数に変換したものを返します。 
不可能ならば -1 を返します。 例外を送出しません。 
ch を (正の) double に変換したものを返します。 
不可能ならば -1.0 を返します。 例外を送出しません。 
Unicode オブジェクトを生成したり、Unicode のシーケンスとしての基本的なプロパティにアクセスしたりするには、以下の API を使ってください: 
size で指定された長さを持つ Py_UNICODE 型バッファ u から Unicode オブジェクトを生成します。 
u を NULL にしてもよく、その場合オブジェクトの内容は未定義です。 
バッファに必要な情報を埋めるのはユーザの責任です。 
バッファの内容は新たなオブジェクトにコピーされます。 
バッファが NULL でない場合、戻り値は共有されたオブジェクトになることがあります。 
従って、この関数が返す Unicodeオブジェクトを変更してよいのは u が NULL のときだけです。 
Unicode オブジェクトの内部バッファ Py_UNICODE に対する読み出し専用のポインタを返します。 unicode が Unicode オブジェクトでなければ NULL を返します。 
Unicode オブジェクトの長さを返します。 
あるエンコード方式でエンコードされたオブジェクト obj をUnicode オブジェクトに型強制して、参照カウントをインクリメントして返します。 型強制は以下のようにして行われます: 
obj が Unicode オブジェクトの場合、オブジェクトそのままを、参照カウントをインクリメントして返します。 
注意:Unicode オブジェクトはデコードできません; encoding に NULL でない値を渡すと、TypeError になります。 
文字列やその他の char バッファ互換オブジェクトの場合、オブジェクトは encoding に従ってデコードされます。 このとき error で定義されたエラー処理を用います。 
これら二つの引数は NULL にでき、その場合デフォルト値が使われます (詳細は次の節を参照してください) 
その他のオブジェクトは例外を引き起こします。 
この API は、エラーが生じたときには NULL を返します。 
呼び出し側は返されたオブジェクトを decref する責任があります。 
PyUnicode_FromEncodedObject(obj, NULL, "strict")を行うショートカットで、インタプリタは Unicode への型強制が必要な際に常にこの関数を使います。 
プラットフォームで wchar_t がサポートされていて、かつwchar.h が提供されている場合、Python は以下の関数を使って wchar_t に対するインタフェースを確立することがあります。 
このサポートは、Python 自体の Py_UNICODE 型がシステムのwchar_t と同一の場合に最適化をもたらします。 
size の wchar_t バッファ w から Unicode オブジェクトを生成します。 
Unicode オブジェクトの内容を wchar_t バッファ wにコピーします。 
最大で size 個の wchar_t 文字を(末尾の 0-終端文字を除いて) コピーします。 
コピーしたwchar_t 文字の個数を返します。 
エラーの時には -1 を返します。 wchar_t 文字列は 0-終端されている場合も、されていない場合もあります。 
関数の呼び出し手の責任で、アプリケーションの必要に応じてwchar_t 文字列を 0-終端してください。 
7.3.2.1 組み込み codec (built-in codec) 
クラスTestCase 
TestCaseクラスのインスタンスは、テストの最小実行単位を示します。 
このクラスをベースクラスとして使用し、必要なテストを具象サブクラスに実装します。 
TestCaseクラスでは、テストランナーがテストを実行するためのインターフェースと、各種のチェックやテスト失敗をレポートするためのメソッドを実装しています。 
クラスFunctionTestCase 
このクラスではTestCaseインターフェースの内、テストランナーがテストを実行するためのインターフェースだけを実装しており、テスト結果のチェックやレポートに関するメソッドは実装していません。 既存のテストコードを 
によるテストフレームワークに組み込むために使用します。 
クラスTestSuite 
このクラスは、個々のテストケースやテストスイートの集約を示します。 
通常のテストケースと同じようにテストランナーで実行すると、テストスイート内の全てのテストケースとテストスイートを実行します。 
テストケース・テストスイートを追加するためのメソッドを用意しています。 
testsには、スイートに追加するテストのシーケンスを指定する事ができます。 
クラスTestLoader 
モジュールまたはTestCaseクラスから、指定した条件に従ってテストをロードし、TestSuiteにラップして返します。 
モジュールからテストをロードする場合、全てのTestCase派生クラスを抽出し、名前が"test"で始まる全てのメソッドのインスタンスを作成します。 
TestLoaderのインスタンスで、共用する事ができます。 
TestLoaderをカスタマイズする必要がなければ、新しいTestLoaderオブジェクトを作らずにこのインスタンスを使用します。 
クラスTextTestRunner 
実行結果を標準結果に出力する、単純なテストランナー。 
いくつかの設定項目がありますが、非常に単純です。 
グラフィカルなテスト実行アプリケーションでは、独自のテストランナーを作成してください。 
テストを実行するためのコマンドラインプログラム。 
この関数を使えば、次のように簡単に実行可能なテストモジュールを作成する事ができます。 
場合によっては、 
モジュールを使って書かれた既存のテストがあります。 
その場合、モジュールは既存のテストコードから unittest.TestSuite インスタンスを自動的に構築できる DocTestSuite クラスを提供します。 バージョン 2.3 で 新たに追加 された仕様です。 
8. Unix独特のサービス 
本章に記述されたモジュールは、Unixオペレーティングシステム、あるいはそれから変形した多くのものに特有する機能のためのインターフェイスを提供します。 
その概要を以下に述べます。 
最も一般的な POSIX システムコール群 (通常は 
モジュールを介して利用されます)。 
パスワードデータベースへのアクセスを提供する(getpwnam() など)。 
グループデータベースへのアクセス (getgrnam() およびその仲間)。 
Unix パスワードをチェックするための関数crypt()。 
共有オブジェクトのC関数の呼び出し 
ndbmを基にした基本的なデータベースインタフェースです。 
GNU による dbm の再実装。 
POSIX スタイルの端末制御。 
一般的な端末制御操作のためのユーティリティ関数群。 
SGIとLinux用の擬似端末を制御する 
fcntl() および ioctl() システムコール。 
Python による Unix シェルパイプラインへのインタフェース。 
ロック機構をサポートするファイル類似オブジェクト。 
現プロセスのリソース使用状態を提供するためのインタフェース。 
Sun の NIS (Yellow Pages) ライブラリへのインタフェース。 
Unix syslog ライブラリルーチン群へのインタフェース。 
外部コマンドを実行するためのユーティリティです。 
例外 URLError を送出します。 
以下の例では、 python.org のメインページを取得して、その最初の100 バイト分を表示します: 
今度は CGI の標準入力にデータストリームを送信し、CGI が返すデータを読み出します: 
上の例で使われているサンプルの CGI は以下のようになっています: 
以下はベーシック HTTP 認証の例です: 
import urllib2# ベーシック HTTP 認証をサポートする OpenerDirector を作成する...auth_handler = urllib2.HTTPBasicAuthHandler()auth_handler.add_password('realm', 'host', 'username', 'password')opener = urllib2.build_opener(auth_handler)# ...urlopen から利用できるよう、グローバルにインストールするurllib2.install_opener(opener)urllib2.urlopen('http://www.example.com/login.html') 
build_opener() はデフォルトで沢山のハンドラを提供しており、その中にProxyHandler があります。 
デフォルトでは、ProxyHandler はscheme_proxy という環境変数を使います。 ここでscheme は URL スキームです。 
例えば、 HTTP プロキシのURL を得るには、環境変数http_proxy を読み出します。 この例では、デフォルトの ProxyHandler を置き換えてプログラム的に作成したプロキシ URL を使うようにし、ProxyBasicAuthHandler でプロキシ認証サポートを追加します。 
proxy_handler = urllib2.ProxyHandler({'http': 'http://www.example.com:3128/'})proxy_auth_handler = urllib2.HTTPBasicAuthHandler()proxy_auth_handler.add_password('realm', 'host', 'username', 'password')opener = build_opener(proxy_handler, proxy_auth_handler)# 今回は OpenerDirector をインストールするのではなく直接使います:opener.open('http://www.example.com/login.html') 以下は HTTP ヘッダを追加する例です: 
headers 引数を使ってRequest コンストラクタを呼び出す方法の他に、以下のようにできます: 
OpenerDirector は全ての Request にUser-Agent: ヘッダを自動的に追加します。 
これを変更するには: 
import urllib2opener = urllib2.build_opener()opener.addheaders = [('User-agent', 'Mozilla/5.0')]opener.open('http://www.example.com/') のようにします。 
また、Request がurlopen() (やOpenerDirector.open()) に渡される際には、いくつかの標準ヘッダ(Content-Length:, Content-Type: およびHost:) も追加されることを忘れないでください。 
URLopener および FancyURLopener クラスのオブジェクトは以下の属性を持っています。 
適切なプロトコルを使って fullurl を開きます。 
このメソッドはキャッシュとプロキシ情報を設定し、その後適切な open メソッドを入力引数つきで呼び出します。 
認識できないスキームが与えられた場合、open_unknown() が呼び出されます。 
data 引数はurlopen() の引数 data と同じ意味を持っています。 
オーバライド可能な、未知のタイプの URL を開くためのインタフェースです。 
url のコンテンツを取得し、filename に書き込みます。 
返り値はタプルで、ローカルシステムにおけるファイル名と、応答ヘッダ (URL がリモートを指している場合) または None (URL がローカルを指している場合) からなります。 
呼び出し側の処理はその後 filename を開いて内容を読み出さなくてはなりません。 
filename が与えられており、かつ URL がローカルシステム上のファイルを示しているばあい、入力ファイル名が返されます。 
URL がローカルのファイルを示しておらず、かつ filename が与えられていない場合、ファイル名は入力 URL の最後のパス構成要素につけられた拡張子と同じ拡張子を tempfile.mktemp() につけたものになります。 
reporthook を与える場合、この変数は 3 つの数値パラメタを受け取る関数でなくてはなりません。 
引数 data は標準の application/x-www-form-urlencoded 形式でなくてはなりません; 上の urlencode() を参照して下さい。 
URL をオープンするオブジェクトのユーザエージェントを指定する変数です。 
を特定のユーザエージェントであるとサーバに通知するには、サブクラスの中でこの値をクラス変数として値を設定するか、コンストラクタの中でベースクラスを呼び出す前に値を設定してください。 
FancyURLopener クラスはオーバライド可能な追加のメソッドを提供しており、適切な振る舞いをさせることができます: 
指定されたセキュリティ領域 (security realm) 下にある与えられたホストにおいて、ユーザ認証に必要な情報を返すための関数です。 
多くの拡張モジュールは単に Python から使える新たな関数や型を提供するだけですが、時に拡張モジュール内のコードが他の拡張モジュールでも便利なことがあります。 
例えば、あるモジュールでは順序概念のないリストのように動作する ``コレクション (collection)'' クラスを実装しているかもしれません。 
ちょうどリストを生成したり操作したりできる C API を備えた標準のPython リスト型のように、この新たなコレクション型も他の拡張モジュールから直接操作できるようにするには一連の C 関数を持っていなければなりません。 一見するとこれは簡単なこと: 単に関数を (もちろんstatic などとは宣言せずに) 書いて、適切なヘッダファイルを提供し、C APIを書けばよいだけ、に思えます。 
そして実際のところ、全ての拡張モジュールが Python インタプリタに常に静的にリンクされている場合にはうまく動作します。 
そして、たとえシンボルがグローバル変数として可視であっても、呼び出したい関数の入ったモジュールがまだロードされていないことだってあります!従って、可搬性の点からシンボルの可視性には何ら仮定をしてはならないことになります。 
つまり拡張モジュール中の全てのシンボルはstatic と宣言せねばなりません。 例外はモジュールの初期化関数で、これは (1.4 で述べたように) 他の拡張モジュールとの間で名前が衝突するのを避けるためです。 
CObject は C API を介してのみ生成したりアクセスしたりできますが、他の Python オブジェクトと同じように受け渡しできます。 
エクスポートされているそれぞれの名前を使うと、CObject自体や、CObject が公表しているアドレスで示される配列内に収められた全ての C API ポインタを得られます。 
そして、ポインタに対する保存や取得といった様々な作業は、コードを提供しているモジュールとクライアントモジュールとの間では異なる方法で分散できます。 以下の例では、名前を公開するモジュールの作者にほとんどの負荷が掛かりますが、よく使われるライブラリを作る際に適切なアプローチを実演します。 
このアプローチでは、全ての C API ポインタ (例中では一つだけですが!) を、CObject の値となるvoid ポインタの配列に保存します。 
拡張モジュールに対応するヘッダファイルは、モジュールの import と C API ポインタを取得するよう手配するマクロを提供します;クライアントモジュールは、C API にアクセスする前にこのマクロを呼ぶだけです。 名前を公開する側のモジュールは、1.1 節のspam モジュールを修正したものです。 
関数spam.system() はC ライブラリ関数system() を直接呼び出さず、PySpam_System() を呼び出します。 この関数はもちろん、実際には (全てのコマンドに ``spam'' を付けるといったような) より込み入った処理を行います。 
この関数 PySpam_System() はまた、他の拡張モジュールにも公開されます。 関数PySpam_System() は、他の全ての関数と同様にstatic で宣言された通常の C 関数です。 
spam_system() には取るに足らない変更が施されています: 
モジュールの先頭にある以下の行 
の直後に、以下の二行: 
を必ず追加してください。 
#define は、ファイルspammodule.h をインクルードしているのが名前を公開する側のモジュールであって、クライアントモジュールではないことをヘッダファイルに教えるために使われます。 
最後に、モジュールの初期化関数は C API のポインタ配列を初期化するよう手配しなければなりません: 
PyMODINIT_FUNCinitspam(void){PyObject *m;static void *PySpam_API[PySpam_API_pointers];PyObject *c_api_object;m = Py_InitModule("spam", SpamMethods);/* C API ポインタ配列を初期化する */PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;/* API ポインタ配列のアドレスが入った CObject を生成する */c_api_object = PyCObject_FromVoidPtr((void *)PySpam_API, NULL);if (c_api_object != NULL)PyModule_AddObject(m, "_C_API", c_api_object);} 
PySpam_API がstatic と宣言されていることに注意してください; そうしなければ、initspam() が終了したときにポインタアレイは消滅してしまいます!からくりの大部分はヘッダファイル spammodule.h 内にあり、以下のようになっています: 
#ifndef Py_SPAMMODULE_H#define Py_SPAMMODULE_H#ifdef __cplusplusextern "C" {#endif/* spammodule のヘッダファイル *//* C API 関数 */#define PySpam_System_NUM 0#define PySpam_System_RETURN int#define PySpam_System_PROTO (char *command)/* C API ポインタの総数 */#define PySpam_API_pointers 1#ifdef SPAM_MODULE/* この部分は spammodule.c をコンパイルする際に使われる */static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;#else/* この部分は spammodule の API を使うモジュール側で使われる */static void **PySpam_API;#define PySpam_System \(*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])/* エラーによる例外の場合には -1 を、成功すると 0 を返す */static intimport_spam(void){PyObject *module = PyImport_ImportModule("spam");if (module != NULL) {PyObject *c_api_object = PyObject_GetAttrString(module, "_C_API");if (c_api_object == NULL)return -1;if (PyCObject_Check(c_api_object))PySpam_API = (void **)PyCObject_AsVoidPtr(c_api_object);Py_DECREF(c_api_object);}return 0;}#endif#ifdef __cplusplus}#endif#endif /* !defined(Py_SPAMMODULE_H) */ 
PySpam_System() へのアクセス手段を得るためにクライアントモジュール側がしなければならないことは、初期化関数内でのimport_spam() 関数 (またはマクロ) の呼び出しです: 
PyMODINIT_FUNCinitclient(void){PyObject *m;Py_InitModule("client", ClientMethods);if (import_spam() 0)return;/* さらなる初期化処理はここに置ける */} 
このアプローチの主要な欠点は、spammodule.h がやや難解になるということです。 
とはいえ、各関数の基本的な構成は公開されるものと同じなので、書き方を一度だけ学べばすみます。 最後に、CObject は、自身に保存されているポインタをメモリ確保したり解放したりする際に特に便利な、もう一つの機能を提供しているということに触れておかねばなりません。 
詳細は 
の ``CObjects '' の節、およびCObjects の実装部分 (Python ソースコード配布物中のファイル Include/cobject.h およびObjects/cobject.c に述べられています。 
1.1 MacPython-OSXの取得とインストール 
1. Mac OS 9でPythonを利用する Macintosh 上での Python の使い方は、特にMac OS 9上においては Unixライクなシステムや Windows システム上で使うのと全く異なっています(MacPython-OSXには完全な Unix Python が入っているので、 Unixライクなシステムとほぼ同じ知識を利用できます) 。 
ほとんどの Python 文書や、「公式の」文書、刊行されている書籍では、Unixライクなシステムや Windows システム上でどう Python を使うかについて述べているにすぎず、 MacPython-OS9 を初めて利用する人を混乱させる原因になっています。 
この章では、簡単な入門編として Macintosh 上で Python を具体的にどう使うのかを解説していきます。 
IDEについての章 (1.3 節) は MacPython-OSX にも関係しています。 
1.2.2.1 ドラッグ＆ドロップする 
この章の関数は、 C で書かれたコードをプラットフォーム間で可搬性のあるものにする上で役立つものから、C から Python モジュールを使うもの、そして関数の引数を解釈したり、 C の値から Python の値を構築するものまで、様々なユーティリティ的タスクを行います。 
この章の関数を使うとファイルまたはバッファにあるPythonソースコードを実行できますが、より詳細なやり取りをインタプリタとすることはできないでしょう。 これらの関数のいくつかは引数として文法の開始記号を受け取ります。 
使用できる開始記号はPy_eval_inputとPy_file_input、Py_single_inputです。 開始期号の説明はこれらを引数として取る関数の後にあります。 
これらの関数のいくつかがFILE*引数をとることにも注意してください。 
注意深く扱う必要がある特別な問題には、異なるCライブラリのFILE構造体は異なっていて互換性がない可能性があるということが関係しています。 
実際に(少なくとも)Windowsでは、動的リンクされる拡張が異なるライブラリを使うことが可能であり、したがって、FILE*引数がPythonランタイムが使っているライブラリと同じライブラリによって作成されたことが確かならば、単にこれらの関数へ渡すだけということに注意すべきです。 
標準インタプリタのためのメインプログラム。 
Pythonを組み込むプログラムのためにこれを利用できるようにしています。 
argcとargv引数をCプログラムのmain()関数へ渡されるものとまったく同じに作成すべきです。 
下記の PyRun_AnyFileExFlags() のcloseit を0に、flags を NULLにして単純化したインタフェースです。 
下記の PyRun_AnyFileExFlags() のcloseit を0にして単純化したインタフェースです。 
下記の PyRun_AnyFileExFlags() のflags を NULLにして単純化したインタフェースです。 
fpが対話的デバイス(コンソールや端末入力あるいはUnix仮想端末)と関連づけられたファイルを参照しているならば、PyRun_InteractiveLoop()の値を返します。 それ以外の場合は、PyRun_SimpleFile()の結果を返します。 
filenameがNULLならば、この関数はファイル名として"???"を使います。 
下記の PyRun_SimpleStringFlags() のPyCompilerFlags* を NULLにして単純化したインタフェースです。 
__main__モジュールの中でflags に従ってcommandに含まれる Python ソースコードを実行します。 
__main__がまだ存在しない場合は作成されます。 正常終了の場合は0を返し、また例外が発生した場合は-1を返します。 
エラーがあっても、例外情報を得る方法はありません。 
下記の PyRun_SimpleStringFileExFlags() のcloseit を 0 に、flags を NULLにして単純化したインタフェースです。 
下記の PyRun_SimpleStringFileExFlags() のcloseit を 0 にして単純化したインタフェースです。 
下記の PyRun_SimpleStringFileExFlags() のflags を NULLにして単純化したインタフェースです。 
Similar to PyRun_SimpleStringFlags(), but the Python sourcePyRun_SimpleString()と似ていますが、Pythonソースコードをメモリ内の文字列ではなくfpから読み込みます。 
filenameはそのファイルの名前でなければなりません。 
closeit が真ならば、PyRun_SimpleFileExFlags は処理を戻す前にファイルを閉じます。 
下記の PyRun_InteractiveOneFlags() のflags を NULLにして単純化したインタフェースです。 
対話的デバイスに関連付けられたファイルから文を一つ読み込み、flags に従って実行します。 
filenameがNULLならば、"???"が代わりに使われます。 
sys.ps1とsys.ps2を使って、ユーザにプロンプトを提示します。 
入力が正常に実行されたときは0を返します。 
例外が発生した場合は-1を返します。 
パースエラーの場合はPythonの一部として配布されているerrcode.hインクルードファイルにあるエラーコードを返します。 (Python.hはerrcode.hをインクルードしません。 
したがって、必要ならば特別にインクルードしなければならないことに注意してください。 ) 
下記の PyRun_InteractiveLoopFlags() のflags を0 にして単純化したインタフェースです。 
対話的デバイスに関連付けられたファイルからEOF に達するまで複数の文を読み込み実行します。 
filenameがNULLならば、"???"が代わりに使われます。 
EOFに達すると0を返します。 
下記の PyRun_SimpleParseStringFlagsFilename() のfilename を NULL に、flags を 0 にして単純化したインタフェースです。 
下記の PyRun_SimpleParseStringFlagsFilename() のfilename を NULL にして単純化したインタフェースです。 
開始トークンstartを使ってstrに含まれる Python ソースコードをflags 引数に従ってパースします。 
効率的に評価可能なコードオブジェクトを作成するためにその結果を使うことができます。 コード断片を何度も評価しなければならない場合に役に立ちます。 
下記の PyRun_SimpleParseFileFlags() のflags を0 にして単純化したインタフェースです。 
PyParser_SimpleParseStringFlagsFilename()に似ていますが、Pythonソースコードをメモリ内の文字列ではなくfpから読み込みます。 
filenameはそのファイルの名前でなけれななりません。 PyObject* 
下記の PyRun_StringFlags() のflags をNULLにして単純化したインタフェースです。 
辞書globalsとlocalsで指定されるコンテキストにおいて、strに含まれるPythonソースコードをコンパイラフラグ flags のもとで実行します。 
下記の PyRun_FileExFlags() のcloseit を0 にし、flags をNULLにして単純化したインタフェースです。 
下記の PyRun_FileExFlags() のflags をNULLにして単純化したインタフェースです。 
下記の PyRun_FileExFlags() のcloseit を0 にして単純化したインタフェースです。 
PyRun_String()と似ていますが、Pythonソースコードをメモリ内の文字列ではなくfpから読み込みます。 
closeit を真にすると、PyRun_FileExFlags() から処理を戻す前にファイルを閉じます。 filenameはそのファイルの名前でなければなりません。 
下記のPy_CompileStringFlags() の flags を NULL にして単純化したインタフェースです。 
str内のPythonソースコードをパースしてコンパイルし、作られたコードオブジェクトを返します。 
開始トークンはstartによって与えられます。 これはコンパイル可能なコードを制限するために使うことができ、Py_eval_input、Py_file_inputもしくはPy_single_inputであるべきです。 
filenameで指定されるファイル名はコードオブジェクトを構築するために使われ、トレースバックあるいはSyntaxError例外メッセージに出てくる可能性があります。 
コードがパースできなかったりコンパイルできなかったりした場合に、これはNULL を返します。 
これは任意の長さのPythonソースコードをコンパイルするときに使う記号です。 
単一の文に対するPython文法の開始記号で、Py_CompileString() 
と一緒に使います。 これは対話式のインタプリタループのための記号です。 
コンパイラフラグを収めておくための構造体です。 
コードをコンパイルするだけの場合、この構造体が int flags として渡されます。 コードを実行する場合にはPyCompilerFlags *flags として渡されます。 
この場合、from __future__ import は flags の内容を変更できます。 PyCompilerFlags *flags がNULLの場合、 cf_flagsは 0 として扱われ、from __future__ import による変更は無視されます。 
このビットを flags にセットすると、除算演算子 / はPEP 238 による 「真の除算 (true division)」 として扱われます。 
警告カテゴリを表現する組み込み例外は数多くあります。 
このカテゴリ化は警告をグループごとフィルタする上で便利です。 
現在以下の警告カテゴリクラスが定義されています: 
全ての警告カテゴリクラスの基底クラスです。 
Exception のサブクラスです。 
その機能が廃用化されていることを示す警告カテゴリの基底クラスです。 
その文法機能があいまいであることを示す警告カテゴリの基底クラスです。 
その実行時システム機能があいまいであることを示す警告カテゴリの基底クラスです。 
その構文の意味付けが将来変更される予定であることを示す警告カテゴリの基底クラスです。 
これらは技術的には組み込み例外ですが、概念的には警告メカニズムに属しているのでここで記述されています。 標準の警告カテゴリをユーザの作成したコード上でサブクラス化することで、さらに別の警告カテゴリを定義することができます。 
警告カテゴリは常に Warning クラスのサブクラスでなければなりません。 
警告フィルタは、ある警告を無視すべきか、表示すべきか、あるいは(例外を送出する) エラーにするべきかを制御します。 概念的には、警告フィルタは複数のフィルタ仕様からなる順番付けられたリストを維持しています; 何らかの特定の警告が生じると、フィルタ仕様の一致するものが見つかるまで、リスト中の各フィルタとの照合が行われます;一致したフィルタ仕様がその警告の処理方法を決定します。 
フィルタの各エントリは(action, message, category, module,lineno) からなるタプルです。 ここで: 
action は以下の文字列のうちの一つです: 
処理方法 
一致した警告を例外に変えます 
一致した警告を決して出力しません 
一致した警告を常に出力します 
一致した警告のうち、警告の原因になったソースコード上の場所ごとに、最初の警告のみ出力します。 
一致した警告のうち、警告の原因になったモジュールごとに、最初の警告のみ出力します。 
一致した警告のうち、警告の原因になった場所にかかわらず最初の警告のみ出力します。 
message は正規表現を含む文字列で、メッセージはこのパタンに一致しなければなりません (照合時には常に大小文字の区別をしないようにコンパイルされます)。 category はクラス (Warning のサブクラス) です。 
警告クラスはこのクラスのサブクラスに一致しなければなりません。 
module は正規表現を含む文字列で、モジュール名はこのパタンに一致しなければなりません (照合時には常に大小文字の区別をしないようにコンパイルされます)。 
lineno 整数で、警告が発生した場所の行番号に一致しなければなりません、すべての行に一致する場合には 0 になります。 
Warning クラスは組み込みの Exception クラスから導出されているので、警告をエラーに変えるには単にcategory(message) を raise します。 警告フィルタは Python インタプリタのコマンドラインに渡される-W オプションで初期化されます。 
インタプリタは-W オプションに渡される全ての引数をsys.warnoptions; に変換せずに保存します; warningsモジュールは最初に import された際にこれらの引数を解釈します(無効なオプションはsys.stderr にメッセージを出力した後無視されます)。 
警告を発するか、無視するか、あるいは例外を送出します。 
category 引数が与えられた場合、警告カテゴリクラスでなければなりません (上を参照してください); 標準の値は UserWarningです。 
message を Warning インスタンスで代用することもできますが、この場合 category は無視され、message.__class__ が使われ、メッセージ文は str(message)になります。 
発された例外が前述した警告フィルタによってエラーに変更された場合、この関数は例外を送出します。 
引数 stacklevelは Python でラッパ関数を書く際に利用することができます。 
こうすることで、警告が参照するソースコード部分を、deprecation() 自身ではなく deprecation() を呼び出した側にできます (というのも、前者の場合は警告メッセージの目的を台無しにしてしまうからです)。 
warn() の機能に対する低レベルのインタフェースで、メッセージ、警告カテゴリ、ファイル名および行番号、そしてオプションのモジュール名およびレジストリ情報 (モジュールの __warningregistry__ 辞書) を明示的に渡します。 
モジュール名は標準で .py が取り去られたファイル名になります;レジストリが渡されなかった場合、警告が抑制されることはありません。 
message は文字列のとき、category は Warningのサブクラスでなければなりません。 また message はWarning のインスタンスであってもよく、この場合category は無視されます。 
警告をファイルに書き込みます。 
標準の実装では、formatwarning(message, category, filename,lineno) を呼び出し、返された文字列を file に書き込みます。 file は標準では sys.stderr です。 
この関数は warnings.showwarning に別の実装を代入して置き換えることができます。 
警告を通常の方法で書式化します。 
返される文字列内には改行が埋め込まれている可能性があり、かつ文字列は改行で終端されています。 
警告フィルタのリストにエントリを一つ挿入します。 
標準ではエントリは先頭に挿入されます; append が真ならば、末尾に挿入されます。 この関数は引数の型をチェックし、message および moduleの正規表現をコンパイルしてから、これらをタプルにして警告フィルタの先頭に挿入します。 
従って、以前に挿入されたエントリと後で挿入されたエントリの両方が特定の警告に合致した場合、後者が前者のエントリを上書きします。 
引数が省略されると、標準では全てにマッチする値に設定されます。 
警告フィルタをリセットします。 
これにより、-W コマンドラインオプションによるものを含め、filterwarnings の呼び出しによる影響はすべて無効化されます。 
この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すためにオブジェクトIDを利用する方法を示します。 
オブジェクトに生きたままであることを強制することなく、オブジェクトのIDは他のデータ構造の中で使えます。 
しかし、そうする場合は、オブジェクトはまだIDによって取り出せます。 import weakref_id2obj_dict = weakref.WeakValueDictionary()def remember(obj):oid = id(obj)_id2obj_dict[oid] = objreturn oiddef id2obj(oid):return _id2obj_dict[oid] 
対応する型オブジェクトのtp_weaklistoffsetフィールドをフィールドのオフセットに設定することもしなければなりません。 また、Py_TPFLAGS_HAVE_WEAKREFSをtp_flagsスロットへ追加する必要もあります。 
例えば、インスタンス型は次のような構造に定義されます: 
typedef struct {PyObject_HEADPyClassObject *in_class; /* クラスオブジェクト */PyObject *in_dict; /* 辞書 */PyObject *in_weakreflist; /* 弱参照のリスト */} PyInstanceObject; 
インスタンスに対して静的に宣言される型オブジェクトはこのように定義されます: 
PyTypeObject PyInstance_Type = {PyObject_HEAD_INIT(PyType_Type)0,"module.instance",/* 簡単のためにたくさんのものを省略... */Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS /* tp_flags */0, /* tp_doc */0, /* tp_traverse */0, /* tp_clear */0, /* tp_richcompare */offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */}; 
型コンストラクタは弱参照リストをNULLに初期化する責任があります: 
static PyObject *instance_new() {/* 簡単のために他の初期化を省略 */self-in_weakreflist = NULL;return (PyObject *) self;} 
さらに一つだけ追加すると、どんな弱参照でも取り除くためには、デストラクタは弱参照マネージャを呼び出す必要があります。 
オブジェクトの破壊のどんな他の部分が起きる前にこれを行うべきですが、弱参照リストが非NULLである場合はこれが要求されるだけです: 
static voidinstance_dealloc(PyInstanceObject *inst){/* 必要なら一時オブジェクトを割り当ててください。 しかし、まだ破壊しないでください。 
*/if (inst-in_weakreflist != NULL)PyObject_ClearWeakRefs((PyObject *) inst);/* 普通にオブジェクトの破壊を進めてください。 */} 
Python は 弱参照 を第一級オブジェクト (first-class object)としてサポートします。 
弱参照を直接実装する二種類の固有のオブジェクト型があります。 
第一は単純な参照オブジェクトで、第二はオリジナルのオブジェクトに対して可能な限りプロキシとして振舞うオブジェクトです。 
ob が参照オブジェクトかプロキシオブジェクトの場合に真を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
ob が参照オブジェクトの場合に真を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
ob がプロキシオブジェクトの場合に真を返します。 
ob に対する弱参照オブジェクトを返します。 
この関数は常に新たな参照を返しますが、必ずしも新たなオブジェクトを作る保証はありません; 既存の参照オブジェクトが返されることもあります。 
第二のパラメタ callback は呼び出し可能オブジェクトで、ob がガーベジコレクションされた際に通知を受け取ります;callback は弱参照オブジェクト自体を単一のパラメタとして受け取ります。 
callback は None や NULL にしてもかまいません。 
ob が弱参照できないオブジェクトの場合や、callback が呼び出し可能オブジェクト、None、NULLのいずれでもない場合は、NULL を返してTypeErrorを送出します。 
ob に対する弱参照プロキシオブジェクトを返します。 
この関数は常に新たな参照を返しますが、必ずしも新たなオブジェクトを作る保証はありません; 既存の参照オブジェクトが返されることもあります。 
ob が弱参照できないオブジェクトの場合や、callback が呼び出し可能オブジェクト、None、NULLのいずれでもない場合は、NULL を返してTypeErrorを送出します。 
弱参照 ref が参照しているオブジェクトを返します。 
被参照オブジェクトがすでに存続していない場合、 None を返します。 バージョン 2.2 で 新たに追加 された仕様です。 
PyWeakref_GetObject() に似ていますが、マクロで実装されていて、エラーチェックを行いません。 バージョン 2.2 で 新たに追加 された仕様です。 
while 文は、式の値が真である間、実行を繰り返すために使われます: 
while 文は式を繰り返し真偽評価し、真であれば最初のスイートを実行します。 式が偽であれば (最初から偽になっていることもありえます)、else 節がある場合にはそれを実行し、ループを終了します。 
continue 文が最初のスイート内で実行されると、スイート内にある残りの文の実行をスキップして、式の真偽評価に戻ります。 
論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、タブ、およびフォームフィードは、トークンを分割するために自由に利用することができます。 
二つのトークンを並べて書くと別のトークンとしてみなされてしまうような場合には、トークンの間に空白が必要となります (例えば、ab は一つのトークンですが、 a b は二つのトークンとなります)。 
4.2 Unix と Windows 
Windows での拡張モジュールのビルドには、Unix と同じように、 
パッケージを使ったビルド作業の制御と手動の二通りのアプローチがあります。 
distutils によるアプローチはほとんどの拡張モジュールでうまくいきます; 
を使った拡張モジュールのビルドとパッケージ化については、 
ここで述べる例題のファイルは、Python ソースコードと共に配布されており、PCexample_nt ディレクトリにあります。 
例題ファイルをコピーする 
example_nt ディレクトリは PC ディレクトリのサブディレクトリになっています。 これは PC 関連の全てのファイルをソースコード配布物内の同じディレクトリに置くための措置です。 
とはいえ実際には、example_nt ディレクトリはPC の下では利用できません。 
そこで、まずこのディレクトリを一階層上にコピーして、example_nt が PC および Include と同じ階層のディレクトリになるようにします。 
以降の作業は、移動先の新しいディレクトリ内で行ってください。 
プロジェクトを開く 
VC++から、 ファイル ワークスペースを開くダイアログメニューを選択します (ファイル 開くではありません!)。 
ディレクトリ階層を辿って、example_nt 
をコピーしたディレクトリ 内のexample.dsw を選択し、「開く」をクリックします。 
例題の DLL をビルドする 
設定が全て正しく行われているか調べるために、ビルドしてみます: 
ビルド構成を選びます。 
このステップは省略できます。 
ビルド アクティブな構成の選択 を選び、example - Win32 リリース または example - Win32 デバッグ を選びます。 
このステップを飛ばすと、VC++ はデフォルトでデバッグ構成を使います。 
DLL をビルドします。 
デバッグモードなら、ビルド example_d.dll のビルド を、リリースモードならビルド example.dll を選びます。 この操作で。 
全ての中間ファイルおよび最終ファイルが、上のビルド構成で選んだ構成に従ってDebug または Release という名前のディレクトリに生成されます。 
デバッグモードの DLL をテストする 
デバッグビルドが成功したら、コマンドプロンプトを起動し、example_ntDebug ディレクトリに移動してください。 
以下のセッション通りにコマンドを実行できるはずです(C は DOS コマンドのプロンプト、 はPython のプロンプトです; ビルド情報や様々なデバッグ出力は、ここに示したスクリーン出力と一致しないこともあるので注意して下さい): 
おめでとうございます! とうとう初めての Python 拡張モジュールのビルドに成功しましたね。 
自分用にプロジェクトを作成する 
プロジェクト用のディレクトリを適当な名前で作成してください。 
自作の C ソースコードをディレクトリ内にコピーします。 
モジュールのソースコードファイル名は必ずしもモジュール名と一致している必要はありませんが、初期化関数の名前はモジュール名と一致していなければなりません -- 初期化関数の名前がinitspam() なら、モジュールはspam という名前でしか import できません。 
initspam() は第一引数を "spam" にして、Py_InitModule() を呼び出します (このディレクトリにある、最小限の内容が書かれているexample.c を手がかりにするとよいでしょう)。 ならわしとして、ファイルはspam.c または spammodule.c という名前にしておきます。 
出力ファイル名はリリースモードでは smap.dll や spam.pyd、デバッグモードではsmap_d.dll や spam_d.pyd、になるはずです (後者は、システムライブラリ spam.dll と、Pythonインタフェースとなる自作のモジュールとの混同を避けるために推奨されています) 。 さて、やり方は二通りあります: 
example.dsw と example.dsp をコピーし、spam.* に名前を変えて、手作業で編集する 
新しくプロジェクトを作成する; 説明は下にあります。 
どちらの場合も、example_ntexample.def をspamspam.def にコピーして、新たにできたspam.def を編集し、二行目に `initspam' が入るようにします。 
自分で新たなプロジェクトを作成したのなら、ここで spam.def をプロジェクトに追加しておいてください (このファイルはたった二行しかない目障りなファイルです。 
.def ファイルを全く無視するという方法もあり、それには /exprt:initspam を「プロジェクトのオプション」ダイアログにあるリンク設定のどこかに手動で追加します)。 
新しくプロジェクトを作成する 
ファイル 新規作成 プロジェクト ダイアログを使って、新たなプロジェクト用ワークスペースを作成します。 
Win32 ダイナミックリンクライブラリ を選択し、名前("spam")を入れ、「場所」が先ほど作成した spam ディレクトリ下に(Python ビルドツリーの直下のサブディレクトリで、Include および PC と同じディレクトリになるはずです) あることを確かめます。 
「作成」をクリックします。 
プロジェクト 設定 ダイアログを開きます。 
ほんのいくつかですが、設定の変更が必要です。 
「構成」ドロップダウンリストに「すべての構成」が設定されているか確かめてください。 
C/C++ タブを選び、ポップアップメニューから「プリプロセッサ」カテゴリを選びます。 
以下のテキスト: 
を、追加のインクルードディレクトリ とラベルされたエントリボックスに入力します次に、「リンカ」タブの「入力」カテゴリを選び、 
を 追加のライブラリディレクトリ と書かれたテキストボックスに入力します。 さて、構成ごとに特有の設定をいくつか行う必要があります:「構成」 ドロップダウンリストから、Win32 リリース を選んでください。 
「リンク」タブをクリックし、「入力」カテゴリを選んで、「追加の依存ファイル」ボックス内のリストにpythonXY.lib を追加します。 「構成」 ドロップダウンリストから、Win32 デバッグ に切り替え、「追加の依存ファイル」ボックス内のリストにpythonXY_d.lib を追加します。 
次に C/C++ タブをクリックして、 コード生成 をカテゴリから選び、 ラインタイムライブラリ に対して マルチスレッド デバッグ DLL を選びます。 「構成」ドロップダウンリストから Win32 リリース に切り替えなおします。 
ラインタイムライブラリ に対してマルチスレッド DLL を選びます。 前の節で述べたspam.def をここで作成しておかねばなりません。 
その後、追加 ファイルをプロジェクトに追加 ダイアログを選びます。 
「ファイルの種類」を *.* にして、spam.c と spam.def を選び、 OK をクリックします(一つ一つファイルを追加してもかまいません)。 
作っているモジュールが新たな型を作成するのなら、以下の行: 
に変更してください。 
また、以下の行をモジュール初期化関数に加えます: 
この操作を行う詳しい理由は、 
の第 3 節を参照してください。 
Windows 版の Python は Microsoft Visual C++でビルドされています; 他のコンパイラを使うと、うまく動作したり、しなかったりします(Borland も一見うまく動作しません)。 
この節の残りの部分は MSVC++向けの説明です。 Windows で DLL を作成する際は、pythonXY.lib をリンカに渡さねばなりません。 
例えば二つの DLL 、spam と ni (spam の中にはC 関数が入っているとします) をビルドするには、以下のコマンドを実行します: 
最初のコマンドで、三つのファイル: spam.obj、spam.dll および spam.lib ができます。 
他のモジュール (Python 自体を含みます) から、自作の識別子が見えるようにするには、"void _declspec(dllexport) initspam(void)" や"PyObject _declspec(dllexport) *NiGetSpamData(void)"のように、"_declspec(dllexport)" で宣言せねばなりません。 
Developer Studio は必要もなく大量のインポートライブラリを DLL に突っ込んで、実行形式のサイズを 100K も大きくしてしまいます。 
不用なライブラリを追い出したければ、「プロジェクトのプロパティ」ダイアログを選び、「リンカ」タブに移動して、インポートライブラリの無視 を指定します。 
その後、適切なmsvcrtxx.lib をライブラリのリストに追加してください。 
2.9.3 コントロールウィンドウオブジェクト 
2.9.2 ウィンドウオブジェクト ウィンドウオブジェクトは特に次のメソッドを持ちます。 
ウィンドウを開く時はこのメソッドをオーバーライドします。 
MacOS ウィンドウ ID を self.wid に入れて do_postopen() メソッドを呼ぶと、親アプリケーションにウィンドウを登録します。 
ウィンドウを閉じるときに特別な処理をする場合はこのメソッドをオーバーライドします。 
親アプリケーションからウィンドウの登録を削除するには、 do_postclose() を呼びます。 
ウィンドウがリサイズされた後に呼ばれます。 
InvalRect を呼び出す以外にもすることがある場合はこれをオーバーライドします。 
ウィンドウのコンテント部分をユーザーがクリックすると呼ばれます。 
引数は位置座標(ウィンドウを基準)、キーモディファイア、生のイベントです。 
ウィンドウのアップデートイベントが受信された時に呼ばれます。 
ウィンドウを再描画します。 
ウィンドウがアクティブ化( 
activate == 1)、非アクティブ化( 
activate == 0)する際に呼ばれます。 
フォーカスのハイライトなどを処理します。 
このモジュールでは、3 種類の writer オブジェクトインタフェース実装を提供しています。 
ほとんどのアプリケーションでは、NullWriter から新しい writer クラスを導出する必要があるでしょう。 
クラスNullWriter 
インタフェース定義だけを提供する writer クラスです; どのメソッドも何ら処理を行いません。 
このクラスは、メソッド実装をまったく継承する必要のない writer 全ての基底クラスになります。 
クラスAbstractWriter 
この writer は formatter をデバッグするのに利用できますが、それ以外に利用できるほどのものではありません。 
各メソッドを呼び出すと、メソッド名と引数を標準出力に印字して呼び出されたことを示します。 
クラスDumbWriter 
単純な writer クラスで file に渡されたファイルオブジェクトかfile が省略された場合には標準出力に出力を書き込みます。 
出力は maxcol で指定されたカラム数で単純な行端折り返しが行われます。 
このクラスは連続した段落を再割り付けするのに適しています。 
12.1.3 writer インタフェース writer を作成するためのインタフェースは、インスタンス化しようとする個々の writer クラスに依存します。 
以下で解説するのは、インスタンス化された全ての writer がサポートしなければならないインタフェースです。 
ほとんどのアプリケーションでは AbstractFormatter クラスをformatter として使うことができますが、通常 writer はアプリケーション側で与えなければならないので注意してください。 
バッファに蓄積されている出力データやデバイス制御イベントをフラッシュします。 
字揃えのスタイルを設定します。 
align の値は任意のオブジェクトを取りえますが、慣習的な値は文字列または None で、None は writer の ``好む'' 字揃えを使うことを表します。 
慣習的な align の値は 'left'、 'center'、'right'、および 'justify' です。 new_font 
フォントスタイルを設定します。 
font は、デバイスの標準のフォントが使われることを示す None か、( 
)の形式をとるタプルになります。 
size はフォントサイズを示す文字列になります; 特定の文字列やその解釈はアプリケーション側で定義します。 
italic、bold、および teletype といった値はブール値で、それらの属性を使うかどうかを指定します。 
マージンレベルを整数値 level に設定し、論理タグ (logical tag)を margin に設定します。 
論理タグの解釈は writer の判断に任されます; 論理タグの値に対する唯一の制限は level が非ゼロの値の際に偽であってはならないということです。 
割り付けスタイル (spacing style) を spacing に設定します。 
追加のスタイルを設定します。 
styles の値は任意の値からなるタプルです; AS_IS 値は無視されます。 
少なくとも blankline 空行分の間隔か、空行そのもので段落を分割します。 
blankline の値は整数になります。 
writer の実装では、改行を行う必要がある場合、このメソッドの呼び出しに先立って send_line_break() の呼び出しを受ける必要あります;このメソッドには段落の最後の行を閉じる機能は含まれておらず、段落間に垂直スペースを空ける役割しかありません。 
水平罫線を出力デバイスに表示します。 
このメソッドへの引数は全てアプリケーションおよび writer 特有のものなので、注意して解釈する必要があります。 
このメソッドの実装では、すでに改行がsend_line_break() によってなされているものと仮定しています。 
行端が折り返され、必要に応じて再割り付け解析を行った (re-flowed) 文字データを出力します。 
このメソッドを連続して呼び出す上では、writer は複数の空白文字は単一のスペース文字に縮約されていると仮定することがあります。 
すでに表示用に書式化された文字データを出力します。 
これは通常、改行文字で表された改行を保存し、新たに改行を持ち込まないことを意味します。 
send_formatted_data() インタフェースと違って、データには改行やタブ文字が埋め込まれていてもかまいません。 
可能ならば、data を現在の左マージンの左側に設定します。 
data の値には制限がありません; 文字列でない値の扱い方はアプリケーションや writer に完全に依存します。 このメソッドは行の先頭でのみ呼び出されます。 
test パッケージ用のテストを書く場合、 
回帰テストの目的はコードの分解です。 そのためには以下のいくつかのガイドラインに従ってください: 
テストスイートはすべてのクラス、関数および定数を用いるべきです。 これは外部に公開される外部APIだけでなく"非公開"コードも含んでいます。 
ホワイトボックス・テスト (テストを書くときに対象のコードをすぐテストする) を推奨します。 ブラックボックス・テスト (最終的に公開されたユーザーインターフェイスだけをテストする) は、すべての境界条件と極端条件を確実にテストするには完全ではありません。 
分岐が生じるテストし、入力を調整して、コードの全体に渡って取りえる限りの個々の処理経路を確実にたどらせるようにしてください。 
テスト対象のコードにどんなバグが発見された場合でも、明示的なテスト追加するようにしてください。 そうすることで、将来コードを変更した際にエラーが再発しないようにできます。 
(一時ファイルをすべて閉じたり削除したりするといった) テストの後始末を必ず行ってください。 import するモジュールをできるかぎり少なくし、可能な限り早期に import を行ってください。 
そうすることで、てテストの外部依存性を最小限にし、モジュールの import による副作用から生じる変則的な動作を最小限にできます。 
コードの再利用を最大限に行うようにしてください。 時として、テストの多様性はどんな型の入力を受け取るかの違いまで小さくなります。 
例えば以下のように、入力が指定されたサブクラスで基底テストクラスをサブクラス化して、コードの複製を最小化します: 
コードより前にテストを書く方法論に関する Kent Beck の著書 
このモジュールでの例外はクラスインスタンスとしてコードされています: 
ベースとなる例外クラスです。 
Error public なデータメンバとして msg を持ち、エラーの詳細が収められています。 
Error から導出されたクラスです。 
インスタンス変数は塚されていません。 
これらの例外を補足する方法を以下の例に示します: 
Packer インスタンスには以下のメソッドがあります: 
現在のパック処理用バッファを文字列で返します。 
パック処理用バッファをリセットして、空文字にします。 
一般的には、適切な pack_type() メソッドを使えば、一般に用いられているほとんどの XDR データをパックすることができます。 
各々のメソッドは一つの引数をとり、パックしたい値を与えます。 
単純なデータ型をパックするメソッドとして、以下のメソッド:pack_uint() 、pack_int() 、 pack_enum() 、pack_bool() 、pack_uhyper() そしてpack_hyper() がサポートされています。 
単精度 (single-precision) の浮動小数点数 value をパックします。 
倍精度 (double-precision) の浮動小数点数 value をパックします。 
以下のメソッドは文字列、バイト列、不透明データ (opaque data) のパック処理をサポートします: 
固定長の文字列、s をパックします。 
n は文字列の長さですが、この値自体はデータバッファにはパック されません 。 
4 バイトのアラインメントを保証するために、文字列は必要に応じて null バイト列でパディングされます。 
pack_fstring() と同じく、固定長の不透明データストリームをパックします。 
可変長の文字列 s をパックします。 
文字列の長さが最初に符号なし整数でパックされ、続いて pack_fstring() を使って文字列データがパックされます。 
pack_string() と同じく、可変長の不透明データ文字列をパックします。 
pack_string() と同じく、可変長のバイトストリームをパックします。 
以下のメソッドはアレイやリストのパック処理をサポートします: 
一様な項目からなる list をパックします。 
このメソッドはサイズ不定、すなわち、全てのリスト内容を網羅するまでサイズが分からないリストに対して有用です。 
リストのすべての項目に対し、最初に符号無し整数 1 がパックされ、続いてリスト中のデータがパックされます。 pack_item は個々の項目をパックするために呼び出される関数です。 
リストの末端に到達すると、符号無し整数 0 がパックされます。 
例えば、整数のリストをパックするには、コードは以下のようになるはずです: import xdrlibp = xdrlib.Packer()p.pack_list([1, 2, 3], p.pack_int) 
一様な項目からなる固定長のリスト (array) をパックします。 
n はリストの長さです。 この値はデータバッファにパックされません が、len(array) が n と等しくない場合、例外 ValueError が送出されます。 
上と同様に、pack_item は個々の要素をパック処理するための関数です。 
一様の項目からなる可変長の list をパックします。 
まず、リストの長さが符号無し整数でパックされ、つづいて各要素が上の pack_farray() と同じやり方でパックされます。 
Unpacker クラスは以下のメソッドを提供します: 
文字列バッファを data でリセットします。 
データバッファ中の現在のアンパック処理位置を返します。 
データバッファ中のアンパック処理位置を position に設定します。 
get_position() および set_position() は注意して使わなければなりません。 
現在のアンパック処理用データバッファを文字列で返します。 
アンパック処理を終了させます。 
全てのデータがまだアンパックされていなければ、例外 Error が送出されます。 
上のメソッドに加えて、Packer でパック処理できるデータ型はいずれもUnpacker でアンパック処理できます。 
アンパック処理メソッドはunpack_type() の形式をとり、引数をとりません。 
これらのメソッドはアンパックされたデータオブジェクトを返します。 
単精度の浮動小数点数をアンパックします。 
unpack_float() と同様に、倍精度の浮動小数点数をアンパックします。 
上のメソッドに加えて、文字列、バイト列、不透明データをアンパックする以下のメソッドが提供されています: 
固定長の文字列をアンパックして返します。 
n は予想される文字列の長さです。 
4 バイトのアラインメントを保証するために null バイトによるパディングが行われているものと仮定して処理を行います。 
unpack_fstring() と同様に、固定長の不透明データストリームをアンパックして返します。 
可変長の文字列をアンパックして返します。 
最初に文字列の長さが符号無し整数としてアンパックされ、次に unpack_fstring() を使って文字列データがアンパックされます。 
unpack_string() と同様に、可変長の不透明データ文字列をアンパックして返します。 
unpack_string() と同様に、可変長のバイトストリームをアンパックして返します。 
以下メソッドはアレイおよびリストのアンパック処理をサポートします。 
一様な項目からなるリストをアンパック処理してかえします。 
リストは一度に 1 要素づつアンパック処理されます、まず符号無し整数によるフラグがアンパックされます。 
もしフラグが 1 なら、要素はアンパックされ、返り値のリストに追加されます。 
フラグが 0 であれば、リストの終端を示します。 unpack_item は個々の項目をアンパック処理するために呼び出される関数です。 
一様な項目からなる固定長のアレイをアンパックして（リストとして）返します。 
n はバッファ内に存在すると期待されるリストの要素数です。 上と同様に、 unpack_item は各要素をアンパックするために使われる関数です。 
一様な項目からなる可変長の list をアンパックして返します。 まず、リストの長さが符号無し整数としてアンパックされ、続いて各要素が上の unpack_farray() のようにしてアンパック処理されます。 
このモジュールは XML 名前空間勧告に定義された名前空間をサポートします。 
XML 名前空間に定義されたタグ名と属性名は、名前空間(名前空間を定義したURL)の後ににスペース置き、それに続くタグ名または属性名として扱われます。 
たとえば、タグが html xmlns='http://www.w3.org/TR/REC-html40' の場合、タグ名は 'http://www.w3.org/TR/REC-html40 html' として処理され、この要素の中にタグ html:a href='http://frob.com' が現れた場合、タグ名は 'http://www.w3.org/TR/REC-html40 a' で、属性名は 'http://www.w3.org/TR/REC-html40 href' となります。 古い XML 名前空間勧告ドラフトに基いたものも処理可能ですが、警告が発せられます。 
この W3 コンソーシアム 勧告には、XML 名前空間の正確なシンタクスと処理に必要な内容について述べられています。 
xmlparser オブジェクトは以下のようなメソッドを持ちます。 
(XML) 宣言中のシステム識別子中の相対 URI を解決するための、基底 URI を設定します。 
相対識別子の解決はアプリケーションに任されます: この値は関数 ExternalEntityRefHandler やNotationDeclHandler、UnparsedEntityDeclHandlerに引数 base としてそのまま渡されます。 
以前の SetBase() によって設定された基底 URI を文字列の形で返します。 
SetBase()が呼ばれていないときには None を返します。 
親となるパーザで解析された内容が参照している、外部で解析されるエンティティを解析するために使える ``子の'' パーザを作成します。 
context パラメータは、以下に記すようにExternalEntityRefHandler() ハンドラ関数に渡される文字列でなければなりません。 子のパーザはordered_attributes、returns_unicode、specified_attributes が現在のパーザの値に設定されて生成されます。 
flagの値をデフォルトのtrueにすると、Expatは代わりのDTDをロードするため、すべての引数にNone を設定してExternalEntityRefHandler を呼び出します。 
xmlparser オブジェクトは次のような属性を持ちます: 
buffer_text が真の時に使われるバッファのサイズです。 
この値は変更できません。 バージョン 2.3 で 新たに追加 された仕様です。 
この値を真にすると、xmlparser オブジェクトが Expatから返されたもとの内容をバッファに保持するようになります。 これにより可能なときに何度も CharacterDataHandler() を呼び出してしまうようなことを避けることができます。 
Expatは通常、文字列のデータを行末ごと大量に破棄するため、かなりパフォーマンスを改善できるはずです。 
この属性はデフォルトでは偽で、いつでも変更可能です。 
バージョン 2.3 で 新たに追加 された仕様です。 buffer_used 
buffer_text が利用可能なとき、バッファに保持されたバイト数です。 
これらのバイトはUTF-8でエンコードされたテキストを表します。 
この属性はbuffer_text が偽の時には意味がありません。 
バージョン 2.3 で 新たに追加 された仕様です。 ordered_attributes 
この属性をゼロ以外の整数にすると、報告される(XMLノードの) 属性を辞書型ではなくリスト型にします。 
属性は文書のテキスト中の出現順で示されます。 
それぞれの属性は、2つのリストのエントリ: 属性名とその値、が与えられます。 
(このモジュールの古いバージョンでも、同じフォーマットが使われています。 
)デフォルトでは、この属性はデフォルトでは偽となりますが、いつでも変更可能です。 
バージョン 2.1 で 新たに追加 された仕様です。 returns_unicode 
この属性をゼロ以外の整数にすると、ハンドラ関数に Unicode 文字列が渡されます。 
returns_unicode が 0 の時には、UTF-8でエンコードされたデータを含む 8 ビット文字列がハンドラに渡されます。 
バージョン 1.6 で 変更 された仕様:戻り値の型がいつでも変更できるように変更されたはずです specified_attributes 
ゼロ以外の整数にすると、パーザは文書のインスタンスで特定される属性だけを報告し、属性宣言から導出された属性は報告しないようになります。 
この属性が指定されたアプリケーションでは、XMLプロセッサの振る舞いに関する標準に従うために必要とされる (文書型) 宣言によって、どのような付加情報が利用できるのかということについて特に注意を払わなければなりません。 
デフォルトで、この属性は偽となりますが、いつでも変更可能です。 
バージョン 2.1 で 新たに追加 された仕様です。 以下の属性には、 xmlparser オブジェクトで最も最近に起きたエラーに関する値が入っており、また Parse() または ParseFile()メソッドが xml.parsers.expat.ExpatError 例外を送出した際にのみ正しい値となります。 
エラーが発生したバイトのインデクスです。 
エラーを特定する数値によるコードです。 
この値はErrorString() に渡したり、 errors オブジェクトで定義された内容と比較できます。 
エラーの発生したカラム番号です。 
エラーの発生した行番号です。 
以下の属性は xmlparser オブジェクトがその時パースしている位置に関する値を保持しています。 
コールバックがパースイベントを報告している間、これらの値はイベントの生成した文字列の先頭の位置を指し示します。 
コールバックの外から参照された時には、（対応するコールバックであるかにかかわらず）直前のパースイベントの位置を示します。 バージョン 2.4 で 新たに追加 された仕様です。 
パーサへの入力の、現在のバイトインデックス。 
パーサへの入力の、現在のカラム番号。 
パーサへの入力の、現在の行番号。 
以下に指定可能なハンドラのリストを示します。 
xmlparser オブジェクト o にハンドラを指定するには、 
を使用します。 handlername は、以下のリストに挙げた値をとらねばならず、また func は正しい数の引数を受理する呼び出し可能なオブジェクトでなければなりません。 
引数は特に明記しない限り、すべて文字列となります。 
XML 宣言が解析された時に呼ばれます。 
Expatが文書型宣言!DOCTYPE ...)を解析し始めたときに呼び出されます。 
doctypeName は、与えられた値がそのままExpat に提供されます。 
Expatが文書型宣言の解析を終えたときに呼び出されます。 このハンドラには、Expat version 1.2以上が必要です。 
それぞれの要素型宣言ごとに呼び出されます。 nameは要素型の名前であり、model は内容モデル (content model) の表現です。 
ひとつの要素型で宣言される属性ごとに呼び出されます。 
属性リストの宣言が3つの属性を宣言したとすると、このハンドラはひとつの属性に1度づつ、3度呼び出されます。 elname は要素名であり、これに対して宣言が適用され、attnameが宣言された属性名となります。 
文書のインスタンスによって属性値が与えられる必要のあるときにはrequiredがtrueになります。 このメソッドはExpat version 1.95.0 以上が必要です。 
要素の開始を処理するごとに呼び出されます。 name は要素名を格納した文字列で、attributes はその値に属性名を対応付ける辞書型です。 
要素の終端を処理するごとに呼び出されます。 
Called for every processing instruction.処理命令を処理するごとに呼び出されます。 
文字データを処理するときに呼びだされます。 
このハンドラは通常の文字データ、CDATAセクション、無視できる空白文字列のために呼び出されます。 
これらを識別しなければならないアプリケーションは、要求された情報を収集するために StartCdataSectionHandler, EndCdataSectionHandler,and ElementDeclHandlerコールバックメソッドを使用できます。 
解析されていない (NDATA) エンティティ宣言を処理するために呼び出されます。 
このハンドラは Expat ライブラリのバージョン1.2のためだけに存在します;より最近のバージョンでは、代わりにEntityDeclHandlerを使用してください (根底にあるExpat ライブラリ内の関数は、撤廃されたものであると宣言されています)。 
エンティティ宣言ごとに呼び出されます。 
パラメタと内部エンティティについて、value はエンティティ宣言の宣言済みの内容を与える文字列となります; 外部エンティティの時にはNone となります。 
記法の宣言 (notation declaration) で呼び出されます。 notationName, base, systemId, および publicId を与える場合、文字列にします。 
public な識別子が省略された場合、publicId は None になります。 
要素が名前空間宣言を含んでいる場合に呼び出されます。 
名前空間宣言は、宣言が配置されている要素に対して StartElementHandler が呼び出される前に処理されます。 
名前空間宣言を含んでいたエレメントの終了タグに到達したときに呼び出されます。 
このハンドラは、要素に関する名前空間宣言ごとに、StartNamespaceDeclHandler とは逆の順番で一度だけ呼び出され、各名前空間宣言のスコープが開始されたことを示します。 
このハンドラは、要素が終了する際、対応するEndElementHandler が呼ばれた後に呼び出されます。 
コメントで呼び出されます。 data はコメントのテキストで、先頭の `!- 
-' と末尾の `- 
-'を除きます。 
CDATA セクションの開始時に呼び出されます。 
CDATA セクションの構文的な開始と終了位置を識別できるようにするには、このハンドラとStartCdataSectionHandler が必要です。 
CDATA セクションの終了時に呼び出されます。 
XML 文書中で、適用可能なハンドラが指定されていない文字すべてに対して呼び出されます。 
この文字とは、検出されたことが報告されるが、ハンドラは指定されていないようなコンストラクト (construct) の一部である文字を意味します。 
DefaultHandler と同じですが、内部エンティティの展開を禁止しません。 エンティティ参照はデフォルトハンドラに渡されません。 
XML 文書がスタンドアロンの文書として宣言されていない場合に呼び出されます。 外部サブセットやパラメタエンティティへの参照が存在するが、XML 宣言がXML 宣言中で standalone 変数を yes に設定していない場合に起きます。 
このハンドラが 0 を返すと、パーザは XML_ERROR_NOT_STANDALONE を送出します。 
このハンドラが設定されていなければ、パーザは前述の事態で例外を送出しません。 
外部エンティティの参照時に呼び出されます。 base は現在の基底(base) で、以前の SetBase() で設定された値になっています。 
public、および system の識別子である、systemId とpublicIdが指定されている場合、値は文字列です; public 識別子が指定されていない場合、 publicId は None になります。 
XMLReader は次のメソッドをサポートします。 : 
入力ソースを処理し、SAX イベントを発生させます。 
source オブジェクトにはシステム識別子(入力ソースを特定する文字列 - 一般にファイル名やURL)、ファイル風オブジェクト、または InputSource オブジェクトを指定できます。 
parse() から return された段階で、入力データの処理は完了、パーサ・オブジェクトは破棄ないしリセットされます。 
なお、現在の実装はバイト・ストリームのみをサポートしており、文字ストリームの処理は将来の課題になっています。 
現在の ContentHandler を返します。 
現在の ContentHandler をセットします。 
ContentHandler がセットされていない場合、コンテント・イベントは破棄されます。 
現在の DTDHandler を返します。 
現在の DTDHandler をセットします。 
DTDHandler がセットされていない場合、DTD イベントは破棄されます。 
現在の EntityResolver を返します。 
現在の EntityResolver をセットします。 
EntityResolver がセットされていない場合、外部エンティティとして解決されるべきものが、システム識別子として解釈されてしまうため、該当するものがなければ結果的にエラーとなります。 
現在の ErrorHandler を返します。 
現在のエラー・ハンドラをセットします。 
ErrorHandler がセットされていない場合、エラーは例外を発生し、警告が表示されます。 
アプリケーションにエラーや警告のロカール設定を許可します。 
SAX パーサにとって、エラーや警告の地域化は必須ではありません。 しかし、パーサは要求されたロカールをサポートしていない場合、SAX 例外を発生させなければなりません。 
アプリケーションはパースの途中でロカールを変更することもできます。 
機能 featurename の現在の設定を返します。 
その機能が認識できないときは、SAXNotRecognizedException を発生させます。 
広く使われている機能名の一覧はモジュール xml.sax.handler に書かれています。 
機能名 featurename に値 value をセットします。 
その機能が認識できないときは、SAXNotRecognizedException を発生させます。 
また、パーサが指定された機能や設定をサポートしていないときは、SAXNotSupportedException を発生させます。 
属性名 propertyname の現在の値を返します。 
その属性が認識できないときは、 SAXNotRecognizedException を発生させます。 
広く使われている属性名の一覧はモジュール xml.sax.handler に書かれています。 
属性名 propertyname に値 value をセットします。 
その機能が認識できないときは、SAXNotRecognizedException を発生させます。 
また、パーサが指定された機能や設定をサポートしていないときは、SAXNotSupportedException is raised を発生させます。 
ジェネレータ関数の本体は、ジェネレータのnext() が例外を発行するまで繰り返し呼び出して実行します。 yield 文が実行されると、現在のジェネレータの状態は凍結 (freeze) され、expression_list の値が next() の呼び出し側に返されます。 
ここでの ``凍結'' は、ローカルな変数への束縛、命令ポインタ (instruction pointer)、および内部実行スタック(internal evaluation stack) を含む、全てのローカルな状態が保存されることを意味します: すなわち、必要な情報を保存しておき、次にnext() が呼び出された際に、関数が yield 文をあたかももう一つの外部呼出しであるかのように処理できるようにします。 yield 文は、try ... finally 構造のtry 節中で使うことはできません。 
ジェネレータが常に実行再開されるとは限らないので、finally ブロックが常に実行される保証がないという問題があるためです。 
注意:Python 2.2 では、generators 機能が有効になっている場合にのみyield 文を使えます。 
Python 2.3 では、常に有効になっています。 
__future__ import 文を使うと、この機能を有効にできます: 
PEP 0255, 単純なジェネレータ 
Python へのジェネレータと yield 文の導入提案 
クラスZipFile 
ZIP ファイルを開きます。 file はファイルへのパス名 (文字列)またはファイルのように振舞うオブジェクトのどちらでもかまいません。 
mode パラメタは、既存のファイルを読むためには'r'、既存のファイルを切り詰めたり新しいファイルに書き込むためには 'w'、追記を行うためには 'a' でなくてはなりません。 
mode が 'a' で file が既存の ZIP ファイルを参照している場合、追加するファイルは既存のファイル中の ZIP アーカイブに追加されます。 
file が ZIP を参照していない場合、新しい ZIPアーカイブが生成され、既存のファイルの末尾に追加されます。 
このことは、ある ZIP ファイルを他のファイル、例えばpython.exe に 
また、ZIP_DEFLATED 定数が指定されているのに 
を利用することができない場合、RuntimeError が送出されます。 
デフォルト値はZIP_STORED です。 
アーカイブファイルを閉じます。 
close() はプログラムを終了する前に必ず呼び出さなければなりません。 さもないとアーカイブ上の重要なレコードが書き込まれません。 
アーカイブメンバ name に関する情報を持つ ZipInfo オブジェクトを返します。 
アーカイブに含まれる各メンバの ZipInfo オブジェクトからなるリストを返します。 
既存のアーカイブファイルを開いている場合、リストの順番は実際の ZIP ファイル中のメンバの順番と同じになります。 
アーカイブメンバの名前のリストを返します。 
アーカイブの目次を sys.stdout に出力します。 
アーカイブ中のファイルの内容をバイト列にして返します。 
アーカイブは読み込みまたは追記モードで開かれていなくてはなりません。 
アーカイブ中の全てのファイルを読み、CRCチェックサムが正常か調べます。 
アーカイブ中で不正なチェックサムをもつ最初のファイルの名前を返します。 
不正なファイルがなければ None を返します。 
filename に指定したファイル名を持つファイルを、アーカイブ名をarcname (デフォルトでは filename と同じ) にしてアーカイブに収録します。 
compress_type を指定した場合、コンストラクタを使って新たなアーカイブエントリを生成した際に使ったcompression パラメタを上書きします。 
アーカイブのモードは 'w' または 'a' でなくてはなりません。 
文字列 bytesをアーカイブに書き込みます。 
zinfo_or_arcnameはアーカイブ中で指定するファイル名か、またはZipInfo インスタンスを指定します。 
zinfo_or_arcnameにZipInfo インスタンスを指定する場合、zinfoインスタンスには少なくともファイル名、日付および時刻を指定しなければなりません。 
ファイル名を指定した場合、日付と時刻には現在の日付と時間が設定されます。 
アーカイブはモード 'w' または 'a'で開かれていなければなりません。 
以下のデータ属性も利用することができます。 
使用するデバッグ出力レベル。 
この属性は 0(デフォルト、何も出力しない) から 3 (最も多くデバッグ情報を出力する) までの値に設定することができます。 
デバッグ情報は sys.stdout に出力されます。 
ZipFile オブジェクトの getinfo() およびinfolist() メソッドは ZipInfo クラスのインスタンスを返します。 
それぞれのインスタンスオブジェクトは ZIP アーカイブの一個のメンバについての情報を保持しています。 インスタンスは以下の属性を持ちます: 
アーカイブ中のファイルの名前。 
アーカイブメンバの最終更新日時。 
この属性は6つの値からなるタプルです。 : 
西暦年 
月 (1 から始まる) 
日 (1 から始まる) 
時 (0 から始まる) 
分 (0 から始まる) 
秒 (0 から始まる) 
アーカイブメンバの圧縮形式。 
各アーカイブメンバに対するコメント。 
拡張フィールドデータ。 
この文字列データに含まれているデータの内部構成については、 
でコメントされています。 
create_system ZIP アーカイブを作成したシステムを記述する文字列。 
このアーカイブを作成した PKZIP のバージョン。 
このアーカイブを展開する際に必要な PKZIP のバージョン。 reserved 
予約領域。 
ゼロでなくてはなりません。 
ZIP フラグビット列。 
ファイルヘッダのボリュームナンバ。 
内部属性。 
外部ファイル属性。 
header_offset 　ファイルヘッダへのバイト数で表したオフセット。 
ファイルデータの開始点へのバイト数で表したオフセット。 
圧縮前のファイルの CRC-32 チェックサム。 
compress_size 圧縮後のデータのサイズ。 
圧縮前のファイルのサイズ。 
